<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oscilloscope Trait & Rarity Generator</title>
    <style>
        :root {
            --bg-color: #121212;
            --primary-text: #e0e0e0;
            --secondary-text: #b3b3b3;
            --header-bg: #1e1e1e;
            --border-color: #333;
            --accent-color: #03dac6;
            --button-bg: #bb86fc;
            --button-text: #000;
            --input-bg: #2c2c2c;
            --rank-gold: #ffd700;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--primary-text);
            margin: 0;
            padding: 2rem;
            line-height: 1.6;
        }

        .container {
            max-width: 95%;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        h1 {
            color: var(--accent-color);
            text-align: center;
            margin-bottom: 0.5rem;
        }

        .explanation {
            text-align: center;
            color: var(--secondary-text);
            max-width: 800px;
            margin: 0 auto 1.5rem auto;
            font-size: 0.95rem;
        }

        textarea {
            width: 100%;
            height: 200px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--primary-text);
            padding: 1rem;
            font-size: 1rem;
            box-sizing: border-box;
            resize: vertical;
        }

        button {
            padding: 0.8rem 1.5rem;
            font-size: 1.1rem;
            font-weight: bold;
            background-color: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            align-self: center;
        }

        button:hover {
            background-color: #a764fa;
        }

        #status {
            text-align: center;
            min-height: 24px;
            font-style: italic;
            color: var(--accent-color);
        }

        .table-container {
            overflow-x: auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            white-space: nowrap;
        }

        th, td {
            padding: 0.6rem 0.8rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        td { border-left: 1px solid var(--border-color); }
        th { border-left: 1px solid var(--border-color); }
        td:first-child, th:first-child { border-left: none; }


        th {
            background-color: var(--header-bg);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        tbody tr:nth-child(even) {
            background-color: #1a1a1a;
        }
        
        .rank-col, .score-col { font-weight: bold; }
        .rank-1 { color: var(--rank-gold); }
        .rank-2 { color: #c0c0c0; }
        .rank-3 { color: #cd7f32; }
        
        .rarity-score {
            font-size: 0.8em;
            color: #888;
            margin-left: 4px;
        }

        .long-text {
            min-width: 300px;
            white-space: normal;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Oscilloscope Trait & Rarity Generator</h1>
        <div class="explanation">
            <p>Paste your seed list, and the tool will generate all visual/audio traits for each seed.</p>
            <p>It then calculates a <strong>Statistical Rarity Score</strong> for each trait and an overall score for each seed. The table is automatically sorted with the rarest items at the top.</p>
        </div>
        
        <textarea id="seed-input" placeholder="Paste seeds here (one seed per line)..."></textarea>
        
        <button id="generate-button">Generate Traits & Rarity</button>

        <div id="status"></div>
        
        <div class="table-container" id="output-container">
            <!-- Generated table will be inserted here -->
        </div>
    </div>

    <script>
        // --- CONSTANTS AND DEFAULTS ---
        const CONSTANTS = {
            SHAPES: ["circle", "square", "butterfly", "Bowditch", "spiro", "harmonograph", "rose", "hypocycloid", "epicycloid", "spiral", "star", "flower", "wave", "mandala", "infinity", "dna", "tornado"],
            SOUNDS: ["hum", "circle", "square", "butterfly", "Bowditch", "spiro", "harmonograph", "rose", "hypocycloid", "epicycloid", "spiral", "star", "flower", "wave", "mandala", "infinity", "dna", "tornado"],
            PROB: { "mono-prob": 0.02, "half-dominant-prob": 0.05, "group-strobe-prob": 0.01, "dark-palette-prob": 0.01, "neutral-palette-prob": 0.05 },
            EFFECT_WEIGHTS: { none: 60, glow: 25, strobe: 10, neon: 5 },
            COLOR_WEIGHTS: { bitcoin_orange: 3, stacks_purple: 2, deep_purple: 2, light_magenta: 3, shocking_pink: 4, royal_blue: 10, dark_green: 3, bright_pink: 6, bright_red: 12, dark_red: 6, bright_yellow: 1, gold: 1, white: 3, dark_gray: 2, cycler: 3 },
            DARK_COLOR_WEIGHTS: { extra_dark_purple: 2, very_dark_blue: 2, very_dark_green: 3, dark_red: 5, extra_dark_gray: 3, charcoal: 2, near_black: 1, gold: 1 },
            NEUTRAL_COLOR_WEIGHTS: { near_black: 4, extra_dark_gray: 5, charcoal: 5, dark_gray: 5, slate_gray: 4, dim_gray: 4, silver: 3, gainsboro: 3, off_white: 4, white: 3 },
            HALF_DOMINANT_RATIO: 0.5,
        };
        const NEUTRAL_COLOR_KEYS = Object.keys(CONSTANTS.NEUTRAL_COLOR_WEIGHTS);

        // --- CORE GENERATIVE ALGORITHMS (MATCHING USER-PROVIDED CODE) ---
        const createRng = s => {
             // THIS RNG EXACTLY MATCHES THE 'deterministicPreset' SNIPPET PROVIDED
            let a = 0x6d2b79f5 ^ s.length;
            for (let i = 0; i < s.length; i++) {
                a = Math.imul(a ^ s.charCodeAt(i), 2654435761);
            }
            return () => {
                a = Math.imul(a ^ (a >>> 15), 1 | a);
                return ((a >>> 16) & 0xffff) / 0x10000;
            };
        };

        const createRngEnsurePlan = s => {
            // THIS RNG IS FROM THE WIDER APPLICATION CODE (used for visual traits)
            let t = 0;
            for (let i = 0; i < s.length; i++) t = (t << 5) - t + s.charCodeAt(i);
            t = 0 | t;
            return () => {
                t = t + 1831565813 | 0;
                let e = Math.imul(t ^ t >>> 15, 1 | t);
                e = e + Math.imul(e ^ e >>> 7, 61 | e) ^ e;
                return ((e ^ e >>> 14) >>> 0) / 4294967296
            };
        };

        const pickWeightedKey = (rng, weights) => {
            const keys = Object.keys(weights);
            if (!keys.length) return null;
            const totalWeight = keys.reduce((sum, key) => sum + (weights[key] || 0), 0);
            if (totalWeight <= 0) return keys[0];
            let r = rng() * totalWeight;
            for (const key of keys) {
                r -= (weights[key] || 0);
                if (r <= 0) return key;
            }
            return keys[keys.length - 1];
        };
        
        const chooseSubset = (rng, arr, count) => {
            const shuffled = [...arr];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled.slice(0, count);
        };
        
        const onlyKeys = (obj, keys) => Object.fromEntries(keys.filter(key => key in obj).map(key => [key, obj[key]]));
        
        // --- VISUAL TRAIT GENERATION ---
        function generateVisualTraits(seed) {
            const sounds = CONSTANTS.SOUNDS;
            const isMono = createRngEnsurePlan(`${seed}::mode::mono`)() < CONSTANTS.PROB["mono-prob"];
            const isNeutralPalette = !isMono && createRngEnsurePlan(`${seed}::mode::neutral`)() < CONSTANTS.PROB["neutral-palette-prob"];
            const isDarkPalette = !isMono && !isNeutralPalette && createRngEnsurePlan(`${seed}::mode::dark`)() < CONSTANTS.PROB["dark-palette-prob"];
            const isHalf = !isMono && createRngEnsurePlan(`${seed}::mode::half`)() < CONSTANTS.PROB["half-dominant-prob"];
            const isGroupStrobe = createRngEnsurePlan(`${seed}::mode::gStrobe`)() < CONSTANTS.PROB["group-strobe-prob"];
            const groupStrobeAll = isGroupStrobe && (createRngEnsurePlan(`${seed}::mode::gStrobeType`)() < 0.5);

            let activeColorWeights = isNeutralPalette ? onlyKeys(CONSTANTS.NEUTRAL_COLOR_WEIGHTS, NEUTRAL_COLOR_KEYS)
                : isDarkPalette ? CONSTANTS.DARK_COLOR_WEIGHTS
                : { ...CONSTANTS.COLOR_WEIGHTS };
            
            let halfDominantKey = null;
            if (isHalf) {
                halfDominantKey = pickWeightedKey(createRngEnsurePlan(`${seed}::halfColorPick`), activeColorWeights);
            }

            const perShapeColorKey = {};
            const perShapeEffectKey = {};
            
             for (const key of sounds) {
                const rngColor = createRngEnsurePlan(`${seed}::color::${key}`);
                const isDominant = isHalf && chooseSubset(createRngEnsurePlan(`${seed}::halfSubset`), sounds, Math.round(sounds.length * 0.5)).includes(key);

                perShapeColorKey[key] = isMono ? pickWeightedKey(createRngEnsurePlan(`${seed}::monoColorPick`), activeColorWeights)
                    : isDominant ? halfDominantKey
                    : pickWeightedKey(rngColor, activeColorWeights);

                perShapeEffectKey[key] = pickWeightedKey(createRngEnsurePlan(`${seed}::effect::${key}`), CONSTANTS.EFFECT_WEIGHTS) ?? 'none';
            }

            if (isGroupStrobe) {
                let strobeSet = groupStrobeAll ? new Set(sounds) : new Set(chooseSubset(createRngEnsurePlan(`${seed}::gStrobe::subset`), sounds, Math.round(sounds.length * (0.5 + 0.5 * createRngEnsurePlan(`${seed}::gStrobe::size`)()))));
                for (const key of strobeSet) perShapeEffectKey[key] = 'strobe';
            }

            const colors = Object.values(perShapeColorKey);
            const effects = Object.values(perShapeEffectKey);

            let paletteType = isMono ? 'Mono' : isNeutralPalette ? 'Neutral' : isDarkPalette ? 'Dark' : 'Standard';

            return {
                paletteType,
                paletteTrait: isHalf ? 'Half-Dominant' : 'None',
                groupEffect: isGroupStrobe ? (groupStrobeAll ? 'Strobe (All)' : 'Strobe (Subset)') : 'None',
                numColors: new Set(colors).size,
                neonShapes: effects.filter(e => e === 'neon').length,
                strobeShapes: effects.filter(e => e === 'strobe').length,
                glowShapes: effects.filter(e => e === 'glow').length,
                cyclerShapes: colors.filter(c => c === 'cycler').length,
                dominantColor: halfDominantKey || 'N/A'
            };
        }
        
        // --- AUDIO TRAIT GENERATION ---
        const deterministicPreset = (seed, shape) => {
            const r = createRng(`${seed}_${shape}`);
            const types = ['sine', 'triangle', 'square', 'sawtooth'];
            const notes = ['C1', 'C2', 'E2', 'G2', 'A2', 'C3', 'E3', 'G3', 'B3', 'D4', 'F#4', 'A4', 'C5'];
            const m = r();
            const mode = m < .18 ? 0 : m < .56 ? 1 : m < .85 ? 2 : 3;
            const cnt = mode === 3 ? 2 + (r() > .7 ? 1 : 0) : 1 + (r() > .6 ? 1 : 0);
            const pick = arr => arr[Math.floor(r() * arr.length)];
            const oscs = Array.from({ length: cnt }, () => [pick(types), pick(notes)]);
            let lfoRate;
            if (mode === 0) { lfoRate = .07 + r() * .3; }
            else if (mode === 1) { lfoRate = .25 + r() * 8; }
            else if (mode === 2) { lfoRate = 6 + r() * 20; }
            else { lfoRate = 24 + r() * 36; }
            return { mode, osc1: oscs[0], osc2: oscs[1] || null, lfoRate };
        };

        const getUniqueAlgorithmMapping = (seed) => {
            const r = createRngEnsurePlan(`${seed}_unique_algo_mapping`);
            const keys = CONSTANTS.SOUNDS;
            const n = keys.length;
            const base = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
            const pool = [];
            while (pool.length < n) pool.push(...base);
            pool.length = n;
            for (let i = pool.length - 1; i > 0; i--) {
                const j = (r() * (i + 1)) | 0;
                [pool[i], pool[j]] = [pool[j], pool[i]];
            }
            return pool;
        };

        function generateAudioTraits(seed) {
            const presets = CONSTANTS.SHAPES.map(shape => deterministicPreset(seed, shape));
            const modeCounts = { 0: 0, 1: 0, 2: 0, 3: 0 };
            const waveformCounts = { sine: 0, triangle: 0, square: 0, sawtooth: 0 };
            let totalLfo = 0;
            
            presets.forEach(p => {
                modeCounts[p.mode]++;
                waveformCounts[p.osc1[0]]++;
                if (p.osc2) waveformCounts[p.osc2[0]]++;
                totalLfo += p.lfoRate;
            });
            
            const dominantSoundMode = `Mode ${Object.keys(modeCounts).reduce((a, b) => modeCounts[a] > modeCounts[b] ? a : b)}`;
            const numSoundModes = Object.values(modeCounts).filter(c => c > 0).length;
            const dualOscillatorShapes = presets.filter(p => p.osc2).length;
            const dominantWaveform = Object.keys(waveformCounts).reduce((a, b) => waveformCounts[a] > waveformCounts[b] ? a : b);
            
            const avgLfo = totalLfo / presets.length;
            let avgLfoCategory = avgLfo > 20 ? 'Fast' : avgLfo > 5 ? 'Medium' : avgLfo > 1 ? 'Slow' : 'Subtle';

            return {
                dominantSoundMode, numSoundModes, dualOscillatorShapes,
                dominantWaveform, avgLfoCategory,
                signatureMapping: getUniqueAlgorithmMapping(seed).join(', ')
            };
        }
        
        // --- RARITY CALCULATION ---
        function calculateRarity(allTraits) {
            const totalCount = allTraits.length;
            if (totalCount === 0) return [];
            
            const traitKeys = Object.keys(allTraits[0]).filter(k => k !== 'seed');
            const occurrences = {};
            traitKeys.forEach(key => occurrences[key] = {});

            // 1. Count occurrences of each trait value
            for (const trait of allTraits) {
                for (const key of traitKeys) {
                    const value = trait[key];
                    occurrences[key][value] = (occurrences[key][value] || 0) + 1;
                }
            }
            
            // 2. Calculate scores for each trait and an overall score for each seed
            allTraits.forEach(trait => {
                trait.scores = {};
                trait.overallRarityScore = 0;
                for (const key of traitKeys) {
                    const value = trait[key];
                    const count = occurrences[key][value];
                    const score = totalCount / count;
                    trait.scores[key] = score;
                    trait.overallRarityScore += score;
                }
            });
            
            // 3. Sort by overall score (descending)
            allTraits.sort((a, b) => b.overallRarityScore - a.overallRarityScore);

            // 4. Add rank
            allTraits.forEach((trait, index) => {
                trait.rank = index + 1;
            });

            return allTraits;
        }

        // --- UI AND TABLE GENERATION ---
        function generateTable() {
            const seedInput = document.getElementById('seed-input');
            const outputContainer = document.getElementById('output-container');
            const statusDiv = document.getElementById('status');
            
            const seeds = seedInput.value.split('\n').map(s => s.trim()).filter(s => s);
            if (seeds.length === 0) {
                statusDiv.textContent = 'Please enter at least one seed.';
                outputContainer.innerHTML = '';
                return;
            }

            statusDiv.textContent = `Generating traits for ${seeds.length} seed(s)...`;
            outputContainer.innerHTML = '';

            setTimeout(() => {
                let allTraits = seeds.map(seed => {
                    const visual = generateVisualTraits(seed);
                    const audio = generateAudioTraits(seed);
                    return { seed, ...visual, ...audio };
                });

                statusDiv.textContent = 'Calculating rarity scores...';
                
                setTimeout(() => {
                    allTraits = calculateRarity(allTraits);

                    const headers = [
                        'Rank', 'Seed', 'Overall Rarity', 'Palette Type', 'Palette Trait', 'Group Effect',
                        '# Colors', 'Neon', 'Strobe', 'Glow', 'Cyclers', 'Dom Color', 'Dom Sound Mode', '# Sound Modes', 
                        'Dual-Osc', 'Dom Waveform', 'Avg LFO', 'Audio Sig Map'
                    ];

                    const keys = [
                        'rank', 'seed', 'overallRarityScore', 'paletteType', 'paletteTrait', 'groupEffect', 
                        'numColors', 'neonShapes', 'strobeShapes', 'glowShapes', 'cyclerShapes', 'dominantColor', 
                        'dominantSoundMode', 'numSoundModes', 'dualOscillatorShapes', 'dominantWaveform', 
                        'avgLfoCategory', 'signatureMapping'
                    ];

                    let tableHTML = '<table><thead><tr>';
                    headers.forEach(h => tableHTML += `<th>${h}</th>`);
                    tableHTML += '</tr></thead><tbody>';

                    allTraits.forEach(trait => {
                        tableHTML += '<tr>';
                        tableHTML += `<td class="rank-col rank-${trait.rank}">${trait.rank}</td>`;
                        tableHTML += `<td>${trait.seed}</td>`;
                        tableHTML += `<td class="score-col">${trait.overallRarityScore.toFixed(2)}</td>`;
                        
                        // Add trait value and its score
                        keys.slice(3).forEach(key => {
                           const value = trait[key];
                           const score = trait.scores[key].toFixed(2);
                           const isLong = key === 'signatureMapping';
                           tableHTML += `<td ${isLong ? 'class="long-text"' : ''}>${value}<span class="rarity-score">(${score})</span></td>`;
                        });

                        tableHTML += '</tr>';
                    });

                    tableHTML += '</tbody></table>';
                    outputContainer.innerHTML = tableHTML;
                    statusDiv.textContent = `Generated and ranked traits for ${seeds.length} seed(s).`;
                }, 10);
            }, 10);
        }
        
        document.getElementById('generate-button').addEventListener('click', generateTable);

    </script>
</body>
</html>