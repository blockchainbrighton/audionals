(async () => {
  // Tuneful Seed Finder v1.7 — "Character Seed" Finder
  // Modified to find two specific types of seeds:
  // 1. Sparse & Harmonious: Very few unique notes, but highly consonant.
  // 2. High-Pause: Over 50% of shapes are not mapped to the melodic algorithm.

  // ----- Config you can tweak -----
  const TOTAL_SEEDS = 100000;   // try more for finer results
  const BATCH_SIZE  = 100;
  const KEEP_TOP    = 1000;
  const RNG_CHARS   = "0123456789abcdefghijklmnopqrstuvwxyz";

  // We only care about shapes mapped to alg 11 (dense melodic generator)
  const TARGET_ALGORITHMS = new Set([11]);

  // Gate for Sparse/Harmonious search: still require a decent mapping
  const MIN_HITRATE_FOR_SPARSE = 0.25;
  const MIN_PALETTE_FALLBACK = 3; // Allow smaller palettes for the sparse search

  // ----- Music helpers -----
  const NOTE_BASE = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 };
  const toMidi = (note) => {
    if (!note || typeof note !== 'string') return null;
    const m = note.match(/^([A-G])([#b]?)(-?\d+)$/i); if (!m) return null;
    const [, L, acc, octStr] = m;
    let s = NOTE_BASE[L.toUpperCase()];
    if (acc === '#') s += 1; else if (acc === 'b') s -= 1;
    const octave = parseInt(octStr, 10);
    return 12 * (octave + 1) + s;
  };

  const MAJOR=[0,2,4,5,7,9,11], MINOR=[0,2,3,5,7,8,10];
  const rotatePC = (pcs, t) => pcs.map(x => (x + t) % 12);
  const scaleFitScore = (pcs, tmpl) => {
    let best = -Infinity, bestKey = 0;
    for (let t=0; t<12; t++) {
      const set = new Set(rotatePC(tmpl, t));
      let hits = 0, misses = 0;
      for (const p of pcs) set.has(p) ? hits++ : misses++;
      const s = hits - 0.35 * misses;
      if (s > best) { best = s; bestKey = t; }
    }
    return { score: best, key: bestKey, template: tmpl };
  };

  const INTERVAL_SCORE = {0:1.0,1:-0.55,2:-0.25,3:0.75,4:0.85,5:0.60,6:-0.80,7:0.95,8:0.35,9:0.55,10:-0.35,11:-0.55};
  const clamp01 = x => Math.max(0, Math.min(1, x));
  const sum  = a => a.reduce((x,y)=>x+y,0);

  // ----- Shape keys from app (fallbacks if not present) -----
  const safeGetShapeKeys = () => {
    try {
      if (window.app?.state?.presets && Object.keys(window.app.state.presets).length) return Object.keys(window.app.state.presets);
      return ['circle','square','triangle','star','hex','wave','ring','burst','coil','loop','arc','petal'];
    } catch {
      return ['circle','square','triangle','star','hex','wave','ring','burst','coil','loop','arc','petal'];
    }
  };
  const SHAPE_KEYS = safeGetShapeKeys();
  const ALL_KEYS = SHAPE_KEYS.includes('hum') ? SHAPE_KEYS : ['hum', ...SHAPE_KEYS];

  // ----- Engine-matching RNG + preset + mapping -----
  const _rng = s => { let a = 0x6d2b79f5 ^ s.length; for (let i=0;i<s.length;i++) a = Math.imul(a ^ s.charCodeAt(i), 2654435761); return () => (a = Math.imul(a ^ (a >>> 15), 1 | a), ((a >>> 16) & 0xffff) / 0x10000); };
  const deterministicPreset = (seed, shape) => {
    const r = _rng(`${seed}_${shape}`), types = ['sine','triangle','square','sawtooth'], notes = ['C1','C2','E2','G2','A2','C3','E3','G3','B3','D4','F#4','A4','C5'];
    const m = r(), mode = m < .18 ? 0 : m < .56 ? 1 : m < .85 ? 2 : 3;
    const cnt = (mode === 3 ? 2 + (r() > .7 ? 1 : 0) : 1 + (r() > .6 ? 1 : 0));
    const oscs = Array.from({ length: cnt }, () => [types[(r() * types.length) | 0], notes[(r() * notes.length) | 0]]);
    return { osc1: oscs[0], osc2: oscs[1] || null };
  };

  const _getUniqueAlgorithmMapping = (seed) => {
    const r = _rng(`${seed}_unique_algo_mapping`), keys = ALL_KEYS, n = keys.length;
    const base = [1,2,3,4,5,6,7,8,9,10,11], pool = [];
    while (pool.length < n) pool.push(...base);
    pool.length = n;
    for (let i = pool.length - 1; i > 0; i--) { const j = (r() * (i + 1)) | 0; [pool[i], pool[j]] = [pool[j], pool[i]]; }
    const m = {}; keys.forEach((k, i) => m[k] = pool[i]); return m;
  };

  // ----- SCORING FUNCTION 1: Sparse & Harmonious Palettes -----
  function scoreSparseAndHarmonious(seed) {
    const presets = SHAPE_KEYS.map(k => deterministicPreset(seed, k));
    const pcsAll = new Set();
    for (const p of presets) {
      const m1 = toMidi(p.osc1?.[1]); if (m1 != null) pcsAll.add(m1 % 12);
      const m2 = toMidi(p.osc2?.[1]); if (m2 != null) pcsAll.add(m2 % 12);
    }
    if (pcsAll.size < MIN_PALETTE_FALLBACK) return { score: 0, details: null };

    const pcs = Array.from(pcsAll);
    const fitMaj = scaleFitScore(pcs, MAJOR);
    const fitMin = scaleFitScore(pcs, MINOR);
    const best = (fitMaj.score >= fitMin.score) ? fitMaj : fitMin;
    const scaleSet = new Set(rotatePC(best.template, best.key));
    const scaleName = `${best.template===MAJOR?'Major':'Minor'} @ ${['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'][best.key]}`;

    const stepIntervals = [];
    presets.forEach(p => {
      const m1 = toMidi(p.osc1?.[1]), m2 = toMidi(p.osc2?.[1]);
      if (m1 != null && m2 != null && scaleSet.has(m1%12) && scaleSet.has(m2%12)) {
        stepIntervals.push(Math.abs(m2 - m1) % 12);
      }
    });

    // ----- Metrics -----
    // 1. Sparsity Score: Heavily rewards a low number of unique pitch classes (notes).
    const k = pcsAll.size;
    const sparsityScore = Math.exp(-Math.pow((k - 4) / 1.5, 2)); // Bell curve centered at 4 notes

    // 2. Harmony Score: Combination of in-scale fit and internal consonance.
    const scaleFit = clamp01(best.score / Math.max(3, k));
    const consRaw = stepIntervals.length ? sum(stepIntervals.map(ic => INTERVAL_SCORE[ic] ?? 0)) / stepIntervals.length : 0;
    const consonance = clamp01((consRaw + 0.8) / 1.8);
    const harmonyScore = 0.6 * scaleFit + 0.4 * consonance;

    // Final score is a product of sparsity and harmony.
    const final = sparsityScore * harmonyScore;

    return {
      score: final,
      details: {
        scaleName,
        uniquePCs: k,
        sparsity: sparsityScore,
        harmony: harmonyScore,
        scaleFit,
        consonance
      }
    };
  }

  function analyzeSeed(seed) {
    const map = _getUniqueAlgorithmMapping(seed);
    let hits = 0;
    for (const key of SHAPE_KEYS) if (TARGET_ALGORITHMS.has(map[key])) hits++;
    const hitRate = SHAPE_KEYS.length ? (hits / SHAPE_KEYS.length) : 0;

    // --- Score for Sparse & Harmonious ---
    let sparseResult = { seed, score: 0, hitRate: (hitRate*100).toFixed(0)+'%', uniquePCs: 'n/a', scale: 'n/a', details: 'n/a' };
    if (hitRate >= MIN_HITRATE_FOR_SPARSE) {
      const sparse = scoreSparseAndHarmonious(seed);
      if (sparse.details) {
        const d = sparse.details;
        sparseResult = {
          seed,
          score: +(sparse.score).toFixed(4),
          hitRate: (hitRate*100).toFixed(0)+'%',
          uniquePCs: d.uniquePCs,
          scale: d.scaleName,
          details: `sparsity:${(d.sparsity*100|0)}% harmony:${(d.harmony*100|0)}%`
        };
      }
    }

    // --- Score for High Pauses ---
    const pauseRate = 1.0 - hitRate;
    let pauseResult = { seed, score: 0, pauseRate: '0%', details: `${12-hits}/${SHAPE_KEYS.length} pauses` };
    if (pauseRate > 0.5) {
       pauseResult = {
         seed,
         score: +pauseRate.toFixed(4),
         pauseRate: (pauseRate*100).toFixed(0)+'%',
         details: `${12-hits}/${SHAPE_KEYS.length} pauses`
       };
    }

    return { sparseResult, pauseResult };
  }

  function downloadCSV(data, filename) {
    if (!data || data.length === 0) return;
    const replacer = (key, value) => value === null ? '' : value;
    const header = Object.keys(data[0]);
    let csv = data.map(row => header.map(fieldName => JSON.stringify(row[fieldName], replacer)).join(','));
    csv.unshift(header.join(','));
    csv = csv.join('\r\n');

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8,' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  // ----- Run (batched) -----
  const resultsSparse = [];
  const resultsPauses = [];
  const seen = new Set();
  const randSeed = () => Array.from({length:8}, () => RNG_CHARS[(Math.random()*36)|0]).join('');

  const t0 = performance.now();
  console.log(`Searching ${TOTAL_SEEDS} seeds for two categories of character seeds...`);
  
  let lastLoggedPercent = -1;

  for (let i = 0; i < TOTAL_SEEDS; i++) {
    let s; do { s = randSeed(); } while (seen.has(s)); seen.add(s);
    const { sparseResult, pauseResult } = analyzeSeed(s);
    if (sparseResult.score > 0) resultsSparse.push(sparseResult);
    if (pauseResult.score > 0) resultsPauses.push(pauseResult);

    const percentComplete = Math.floor(((i + 1) / TOTAL_SEEDS) * 100);
    if (percentComplete > lastLoggedPercent) {
      console.log(`Searching... ${percentComplete}% complete.`);
      lastLoggedPercent = percentComplete;
    }

    if ((i + 1) % BATCH_SIZE === 0) await new Promise(r => setTimeout(r, 0));
  }
  const t1 = performance.now();

  // --- Process and Display Results ---
  console.log(`%cCharacter Seed Finder — Complete`,'font-weight:bold;');
  console.log(`Tried ${TOTAL_SEEDS} seeds in ${(t1 - t0).toFixed(0)}ms.`);

  // 1. Sparse & Harmonious Results
  resultsSparse.sort((a,b)=>b.score - a.score);
  const topSparse = resultsSparse.slice(0, KEEP_TOP);
  if (topSparse.length > 0) {
    const bankSparse = topSparse.map(r => r.seed).join(' ');
    console.log(`\n%c--- Top ${topSparse.length} Sparse & Harmonious Seeds ---`,'font-weight:bold; color: #8f8;');
    console.log(`(Copy this line):`);
    console.log(bankSparse);
    const tableSparse = topSparse.map((r,i)=>({'#':i+1, ...r}));
    console.table(tableSparse);
    downloadCSV(tableSparse, 'top_1000_sparse_harmonious.csv');
  } else {
    console.log('\n%c--- No qualifying Sparse & Harmonious seeds found. ---','color: #f88;');
  }

  // 2. High-Pause Results
  resultsPauses.sort((a,b)=>b.score - a.score);
  const topPauses = resultsPauses.slice(0, KEEP_TOP);
   if (topPauses.length > 0) {
    const bankPauses = topPauses.map(r => r.seed).join(' ');
    console.log(`\n%c--- Top ${topPauses.length} High-Pause (>50%) Seeds ---`,'font-weight:bold; color: #88f;');
    console.log(`(Copy this line):`);
    console.log(bankPauses);
    const tablePauses = topPauses.map((r,i)=>({'#':i+1, ...r}));
    console.table(tablePauses);
    downloadCSV(tablePauses, 'top_1000_high_pauses.csv');
  } else {
    console.log('\n%c--- No qualifying High-Pause seeds found. ---','color: #f88;');
  }

  return { topSparse, topPauses };
})();