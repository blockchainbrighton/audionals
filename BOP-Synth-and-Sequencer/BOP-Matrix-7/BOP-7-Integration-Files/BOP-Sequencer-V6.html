    }
    function getCurrentSequence() { return projectData.sequences[projectData.currentSequenceIndex]; }
    function addChannelsToCurrentSequence(count) {
      const currentSeq = getCurrentSequence();
      const newChannelCount = currentSeq.channels.length + count;
      if (newChannelCount > MAX_CHANNELS_PER_SEQUENCE) { loaderStatus.textContent = `Max channels per sequence (${MAX_CHANNELS_PER_SEQUENCE}) reached.`; return; }
      for (let i = 0; i < count; i++) currentSeq.channels.push({ selectedSampleIndex: 0, steps: Array(STEPS_PER_BAR * BARS_PER_SEQUENCE).fill(false) });
      renderSequencer();
    }
    function updateSequenceListUI() {
      sequenceListEl.innerHTML = '';
      projectData.sequences.forEach((seq, index) => {
        const btn = document.createElement('button');
        btn.className = 'sequence-btn';
        btn.textContent = `Seq ${index + 1}`;
        if (index === projectData.currentSequenceIndex) btn.classList.add('active');
        btn.onclick = () => switchToSequence(index);
        sequenceListEl.appendChild(btn);
      });
    }
    // --- CORE: Render steps as auto-wrapped grid
    function renderSequencer() {
      sequencerEl.innerHTML = '';
      const currentSeq = getCurrentSequence();
      if (!currentSeq) return;
      const totalSteps = STEPS_PER_BAR * BARS_PER_SEQUENCE;
      sequencerEl.className = "sequencer";
      currentSeq.channels.forEach((channelData, ch) => {
        const channel = document.createElement('div');
        channel.className = 'channel';
        const label = document.createElement('div');
        label.className = 'channel-label';
        label.textContent = sampleNames[channelData.selectedSampleIndex] || `Sample ${channelData.selectedSampleIndex}`;
        channel.appendChild(label);
        const select = document.createElement('select');
        select.className = 'sample-select';
        select.dataset.channel = ch;
        sampleNames.forEach((name, j) => {
          const opt = document.createElement('option');
          opt.value = j;
          opt.textContent = isLoopSample[j] ? `${name} (${sampleBPMs[j]} BPM)` : name;
          select.appendChild(opt);
        });
        select.value = channelData.selectedSampleIndex;
        select.onchange = async () => {
          const chIndex = parseInt(select.dataset.channel, 10);
          const idx = parseInt(select.value, 10);
          getCurrentSequence().channels[chIndex].selectedSampleIndex = idx;
          label.textContent = sampleNames[idx];
          isLoopSample[idx] ? checkBPMCompatibility(idx) : checkAllSelectedLoopsBPM();
          if(!allBuffers[idx]) {
            loaderStatus.textContent = `Loading: ${sampleNames[idx]}...`;
            try { allBuffers[idx] = await SimpleSampleLoader.getSampleByIndex(idx); loaderStatus.textContent = 'Ready!'; } catch {
              loaderStatus.textContent = `Failed to load: ${sampleNames[idx]}`; setTimeout(()=>loaderStatus.textContent='Ready!',2000);
            }
          }
        };
        channel.appendChild(select);
        // --- Step grid (rows/columns) ---
        const stepsContainer = document.createElement('div');
        stepsContainer.className = 'steps';
        for (let row = 0; row < STEP_ROWS; row++) {
          const rowDiv = document.createElement('div');
          rowDiv.className = 'step-row';
          for (let col = 0; col < STEPS_PER_ROW; col++) {
            const step = row * STEPS_PER_ROW + col;
            if (step >= totalSteps) break;
            const stepEl = document.createElement('div');
            stepEl.className = 'step';
            if (channelData.steps[step]) stepEl.classList.add('active');
            if (step === currentStepIndex && projectData.isPlaying &&
              ((projectData.playMode === 'sequence' && ch < currentSeq.channels.length) ||
              (projectData.playMode === 'all' && ch < projectData.sequences[currentPlaybackSequenceIndex]?.channels.length))) {
              stepEl.classList.add('playing');
            }
            stepEl.dataset.channel = ch;
            stepEl.dataset.step = step;
            stepEl.onclick = () => {
              stepEl.classList.toggle('active');
              const currentSeqData = getCurrentSequence();
              currentSeqData.channels[ch].steps[step] = !currentSeqData.channels[ch].steps[step];
            };
            rowDiv.appendChild(stepEl);
          }
          stepsContainer.appendChild(rowDiv);
        }
        channel.appendChild(stepsContainer);
        sequencerEl.appendChild(channel);
      });
    }
    function highlightPlayhead(stepIndex) {
      document.querySelectorAll('.step.playing').forEach(el => el.classList.remove('playing'));
      document.querySelectorAll(`.step[data-step="${stepIndex}"]`).forEach(el => el.classList.add('playing'));
    }
    function scheduleStep(time, stepIndex) {
      highlightPlayhead(stepIndex);
      const seqData = projectData.playMode === 'all'
        ? projectData.sequences[currentPlaybackSequenceIndex]
        : getCurrentSequence();
      seqData.channels.forEach((channel, ch) => {
        if (channel.steps[stepIndex]) {
          const idx = channel.selectedSampleIndex;
          const buffer = allBuffers[idx];
          if (buffer) {
            const player = new Tone.Player(buffer).toDestination();
            player.start(time);
          }
        }
      });
      currentStepIndex = stepIndex;
    }
    function createSequence() {
      const totalSteps = STEPS_PER_BAR * BARS_PER_SEQUENCE;
      const sequenceSteps = Array.from({ length: totalSteps }, (_, i) => i);
      if (sequence) sequence.dispose();
      sequence = new Tone.Sequence((time, stepIndex) => {
        scheduleStep(time, stepIndex);
        if (projectData.playMode === 'all' && stepIndex === totalSteps - 1) {
            Tone.Transport.scheduleOnce(() => {
                const nextSeqIndex = (currentPlaybackSequenceIndex + 1) % projectData.sequences.length;
                currentPlaybackSequenceIndex = nextSeqIndex;
                switchToSequence(nextSeqIndex, { updateUI: true });
                if (sequence) sequence.dispose();
                createSequence();
                sequence.start(Tone.Transport.seconds);
            }, Tone.Transport.seconds + 0.01);
        }
      }, sequenceSteps, "16n");
      sequence.start(0);
    }
    function startSequencerWithTone(mode) {
      projectData.playMode = mode;
      if (mode === 'all') {
        currentPlaybackSequenceIndex = projectData.currentSequenceIndex;
        switchToSequence(currentPlaybackSequenceIndex, { updateUI: true });
      } else {
        switchToSequence(projectData.currentSequenceIndex, { updateUI: true });
      }
      if (!isToneStarted) {
        Tone.start().then(() => {
          isToneStarted = true;
          proceedWithStart();
        }).catch(err => {
          loaderStatus.textContent = "Error starting audio. Please try again.";
          loaderStatus.style.color = "#f00";
        });
      } else { proceedWithStart(); }
      function proceedWithStart() {
        projectData.isPlaying = true;
        playSequenceBtn.disabled = true;
        playAllBtn.disabled = true;
        stopBtn.disabled = false;
        Tone.Transport.bpm.value = projectData.bpm;
        createSequence();
        Tone.Transport.start();
      }
    }
    function stopSequencerWithTone() {
      Tone.Transport.stop();
      if (sequence) sequence.dispose();
      sequence = null;
      document.querySelectorAll('.step.playing').forEach(el => el.classList.remove('playing'));
      currentStepIndex = 0;
      projectData.isPlaying = false;
      projectData.playMode = null;
      currentPlaybackSequenceIndex = projectData.currentSequenceIndex;
      playSequenceBtn.disabled = false;
      playAllBtn.disabled = false;
      stopBtn.disabled = true;
    }
    async function initSequencer() {
      try {
        loaderStatus.textContent = 'Fetching sample list...';
        await loadSampleMetadata();
        projectData.sequences = [createEmptySequence(INITIAL_CHANNELS_PER_SEQUENCE)];
        projectData.currentSequenceIndex = 0;
        projectData.bpm = 120.00;
        updateSequenceListUI();
        updateStepRows();
        renderSequencer();
        loaderStatus.textContent = 'Ready! Click Play to start.';
        loaderStatus.style.color = '#0f0';
        playSequenceBtn.disabled = false;
        playAllBtn.disabled = false;
        stopBtn.disabled = false;
        const initialSamples = getCurrentSequence().channels.map(ch => ch.selectedSampleIndex);
        await Promise.all(initialSamples.map(async idx=>{
          if(!allBuffers[idx]) allBuffers[idx] = await SimpleSampleLoader.getSampleByIndex(idx);
        }));
      } catch (err) {
        loaderStatus.textContent = 'Error: ' + err.message;
        loaderStatus.style.color = '#f00';
        return;
      }
      checkAllSelectedLoopsBPM();
    }
    async function loadSampleMetadata() {
      const urls = SimpleSampleLoader.ogSampleUrls;
      if (!urls.length) throw new Error("No samples found in ogSampleUrls");
      urls.forEach((item,i)=>{