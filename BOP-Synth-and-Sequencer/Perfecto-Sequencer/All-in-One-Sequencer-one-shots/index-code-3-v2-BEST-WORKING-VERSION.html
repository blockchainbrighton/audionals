<!-- 
    USAGE NOTES:
    1. Save this file and open directly in any modern browser
    2. The sequencer has 8 rows:
       - Top 4 rows are sample players (drag/drop audio files)
       - Bottom 4 rows are synthesizers (click steps to set notes)
    3. Controls:
       - Play/Stop button at top
       - Global BPM input (default 120)
       - Per-row Mute/Clear buttons
    4. For sample rows:
       - Drag audio files onto the row header
       - Or click header to open file dialog
    5. For synth rows:
       - Click steps to set notes (C4 by default)
       - Use waveform/ADSR controls to shape sound
       - Piano keys at bottom for auditioning
    6. Sequencer automatically starts playing when first step is activated
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4-Bar Sequencer</title>
    <style>
        :root {
            --step-size: 20px;
            --active-color: #4CAF50;
            --playing-color: #2196F3;
            --muted-color: #9E9E9E;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: Arial, sans-serif; padding: 20px; background: #1e1e1e; color: #eee; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; margin-bottom: 20px; }
        
        .transport-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background: #333;
            border-radius: 8px;
        }
        button { padding: 8px 16px; cursor: pointer; border: none; border-radius: 4px; }
        .play-btn { background: #4CAF50; color: white; }
        .stop-btn { background: #f44336; color: white; }
        .bpm-control { display: flex; align-items: center; gap: 10px; }
        input[type="number"] { padding: 5px; width: 70px; }
        
        .sequencer-grid {
            display: grid;
            grid-template-columns: 120px repeat(64, var(--step-size));
            gap: 2px;
            margin-bottom: 20px;
        }
        
        .row-header {
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 5px;
            background: #444;
            text-align: center;
            font-size: 12px;
        }
        .sample-row .row-header { background: #3a506b; }
        .synth-row .row-header { background: #503a6b; }
        
        .step {
            width: var(--step-size);
            height: var(--step-size);
            background: #555;
            border-radius: 2px;
            cursor: pointer;
        }
        .step.active { background: var(--active-color); }
        .step.playing { background: var(--playing-color); box-shadow: 0 0 5px var(--playing-color); }
        .step.muted { background: var(--muted-color); }
        
        .channel-controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-top: 5px;
        }
        .channel-controls button {
            padding: 3px 6px;
            font-size: 10px;
        }
        
        .synth-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 5px;
        }
        .synth-controls select, .synth-controls input {
            font-size: 10px;
            padding: 2px;
        }
        
        .piano-container {
            margin-top: 20px;
            padding: 15px;
            background: #333;
            border-radius: 8px;
        }
        .piano {
            display: flex;
            height: 60px;
            margin-top: 10px;
        }
        .key {
            flex: 1;
            border: 1px solid #555;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 5px;
            font-size: 10px;
            color: #333;
        }
        .key.black {
            height: 60%;
            width: 70%;
            background: black;
            color: white;
            margin: 0 -35%;
            z-index: 1;
            position: relative;
        }
        .key.active { background: #4CAF50; }
        .key.black.active { background: #2E7D32; }
        
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-size: 24px;
        }
        #loader.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="loader">
        <div id="loader-status">Loading Audio Engine...</div>
    </div>
    
    <div class="container">
        <h1>4-Bar Sequencer</h1>
        
        <div class="transport-controls">
            <button id="play-btn" class="play-btn">Play</button>
            <button id="stop-btn" class="stop-btn">Stop</button>
            <div class="bpm-control">
                <label for="bpm-input">BPM:</label>
                <input type="number" id="bpm-input" min="20" max="300" value="120">
            </div>
        </div>
        
        <div id="sequencer-grid" class="sequencer-grid"></div>
        
        <div class="piano-container">
            <h3>Piano Keys (C4 to B4)</h3>
            <div id="piano" class="piano"></div>
        </div>
    </div>

    <script>
        // Loader status handler
        function setLoaderStatus(message, isError = false) {
            const loader = document.getElementById('loader');
            const status = document.getElementById('loader-status');
            status.textContent = message;
            if (isError) {
                status.style.color = 'red';
            } else if (message === '') {
                // Only hide when explicitly called with empty message
                loader.classList.add('hidden');
            }
        }

        // Runtime state
        const runtimeState = {
            Tone: null
        };

        // Application state management
        const initialState = {
            isPlaying: false,
            bpm: 120,
            currentStep: -1,
            channels: Array(8).fill().map((_, i) => ({
                id: i,
                type: i < 4 ? 'sample' : 'synth',
                name: i < 4 ? `Sample ${i+1}` : `Synth ${i-3}`,
                muted: false,
                steps: Array(64).fill(false),
                // Sample-specific properties
                sampleFile: null,
                player: null,
                // Synth-specific properties
                waveform: 'sine',
                attack: 0.1,
                decay: 0.3,
                sustain: 0.5,
                release: 0.8,
                synth: null,
                notes: Array(64).fill('C4')
            }))
        };

        // State reducer
        function reducer(state, action) {
            switch(action.type) {
                case 'TOGGLE_PLAY':
                    return { ...state, isPlaying: !state.isPlaying };
                case 'SET_BPM':
                    return { ...state, bpm: action.payload };
                case 'SET_CURRENT_STEP':
                    return { ...state, currentStep: action.payload };
                case 'TOGGLE_STEP':
                    return {
                        ...state,
                        channels: state.channels.map((channel, i) => 
                            i === action.channelIndex 
                                ? { 
                                    ...channel, 
                                    steps: channel.steps.map((step, j) => 
                                        j === action.stepIndex ? !step : step
                                    )
                                } 
                                : channel
                        )
                    };
                case 'SET_NOTE':
                    return {
                        ...state,
                        channels: state.channels.map((channel, i) => 
                            i === action.channelIndex 
                                ? { 
                                    ...channel, 
                                    notes: channel.notes.map((note, j) => 
                                        j === action.stepIndex ? action.note : note
                                    )
                                } 
                                : channel
                        )
                    };
                case 'TOGGLE_MUTE':
                    return {
                        ...state,
                        channels: state.channels.map((channel, i) => 
                            i === action.channelIndex 
                                ? { ...channel, muted: !channel.muted } 
                                : channel
                        )
                    };
                case 'CLEAR_CHANNEL':
                    return {
                        ...state,
                        channels: state.channels.map((channel, i) => 
                            i === action.channelIndex 
                                ? { ...channel, steps: Array(64).fill(false) } 
                                : channel
                        )
                    };
                case 'SET_SAMPLE':
                    return {
                        ...state,
                        channels: state.channels.map((channel, i) => 
                            i === action.channelIndex 
                                ? { ...channel, sampleFile: action.file, player: action.player } 
                                : channel
                        )
                    };
                case 'SET_SYNTH_PARAM':
                    return {
                        ...state,
                        channels: state.channels.map((channel, i) => 
                            i === action.channelIndex && channel.type === 'synth'
                                ? { ...channel, [action.param]: action.value } 
                                : channel
                        )
                    };
                default:
                    return state;
            }
        }

        // Action creators
        const togglePlay = () => ({ type: 'TOGGLE_PLAY' });
        const setBpm = (bpm) => ({ type: 'SET_BPM', payload: bpm });
        const setCurrentStep = (step) => ({ type: 'SET_CURRENT_STEP', payload: step });
        const toggleStep = (channelIndex, stepIndex) => ({ 
            type: 'TOGGLE_STEP', 
            channelIndex, 
            stepIndex 
        });
        const setNote = (channelIndex, stepIndex, note) => ({ 
            type: 'SET_NOTE', 
            channelIndex, 
            stepIndex, 
            note 
        });
        const toggleMute = (channelIndex) => ({ type: 'TOGGLE_MUTE', channelIndex });
        const clearChannel = (channelIndex) => ({ type: 'CLEAR_CHANNEL', channelIndex });
        const setSample = (channelIndex, file, player) => ({ 
            type: 'SET_SAMPLE', 
            channelIndex, 
            file, 
            player 
        });
        const setSynthParam = (channelIndex, param, value) => ({ 
            type: 'SET_SYNTH_PARAM', 
            channelIndex, 
            param, 
            value 
        });

        // Sample channel rendering and handling
        function renderSampleChannel(header, channel, channelIndex, dispatch) {
            // Create file input for drag/drop
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'audio/*';
            fileInput.style.display = 'none';
            fileInput.onchange = (e) => handleFileSelect(e.target.files[0]);
            
            // Create drop zone
            const dropZone = document.createElement('div');
            dropZone.textContent = channel.sampleFile ? channel.sampleFile.name : 'Drop audio file';
            dropZone.style.cssText = `
                padding: 5px;
                margin-top: 5px;
                background: #2c3e50;
                border-radius: 4px;
                cursor: pointer;
                font-size: 10px;
                overflow: hidden;
                text-overflow: ellipsis;
            `;
            
            dropZone.onclick = () => fileInput.click();
            
            // Drag and drop handling
            dropZone.ondragover = (e) => {
                e.preventDefault();
                dropZone.style.background = '#34495e';
            };
            
            dropZone.ondragleave = () => {
                dropZone.style.background = '#2c3e50';
            };
            
            dropZone.ondrop = (e) => {
                e.preventDefault();
                dropZone.style.background = '#2c3e50';
                if (e.dataTransfer.files.length) {
                    handleFileSelect(e.dataTransfer.files[0]);
                }
            };
            
            function handleFileSelect(file) {
                if (!file.type.startsWith('audio/')) return;
                
                const player = new runtimeState.Tone.Player(URL.createObjectURL(file)).toDestination();
                dispatch(setSample(channelIndex, file, player));
                dropZone.textContent = file.name;
            }
            
            header.appendChild(fileInput);
            header.appendChild(dropZone);
        }

        // Synth channel rendering and controls
        function renderSynthChannel(header, channel, channelIndex, dispatch) {
            // Waveform selector
            const waveformSelect = document.createElement('select');
            waveformSelect.innerHTML = `
                <option value="sine">Sine</option>
                <option value="square">Square</option>
                <option value="sawtooth">Sawtooth</option>
                <option value="triangle">Triangle</option>
            `;
            waveformSelect.value = channel.waveform;
            waveformSelect.onchange = () => 
                dispatch(setSynthParam(channelIndex, 'waveform', waveformSelect.value));
            
            // ADSR controls
            const adsrControls = document.createElement('div');
            adsrControls.className = 'synth-controls';
            
            ['attack', 'decay', 'sustain', 'release'].forEach(param => {
                const label = document.createElement('label');
                label.textContent = param[0].toUpperCase();
                label.title = param;
                
                const input = document.createElement('input');
                input.type = 'range';
                input.min = param === 'sustain' ? '0' : '0.01';
                input.max = '2';
                input.step = '0.01';
                input.value = channel[param];
                input.oninput = () => 
                    dispatch(setSynthParam(channelIndex, param, parseFloat(input.value)));
                
                adsrControls.appendChild(label);
                adsrControls.appendChild(input);
            });
            
            header.appendChild(waveformSelect);
            header.appendChild(adsrControls);
        }

        // Sequencer grid rendering and interaction
        function renderSequencerGrid(container, state, dispatch) {
            container.innerHTML = '';
            
            state.channels.forEach((channel, channelIndex) => {
                const row = document.createElement('div');
                row.className = channel.type === 'sample' ? 'sample-row' : 'synth-row';
                row.style.cssText = `
                    display: contents;
                `;
                
                // Row header
                const header = document.createElement('div');
                header.className = 'row-header';
                header.textContent = channel.name;
                
                // Channel controls
                const controls = document.createElement('div');
                controls.className = 'channel-controls';
                
                const muteBtn = document.createElement('button');
                muteBtn.textContent = channel.muted ? 'Unmute' : 'Mute';
                muteBtn.onclick = () => dispatch(toggleMute(channelIndex));
                
                const clearBtn = document.createElement('button');
                clearBtn.textContent = 'Clear';
                clearBtn.onclick = () => dispatch(clearChannel(channelIndex));
                
                controls.appendChild(muteBtn);
                controls.appendChild(clearBtn);
                header.appendChild(controls);
                
                row.appendChild(header);
                
                // Steps
                channel.steps.forEach((isActive, stepIndex) => {
                    const step = document.createElement('div');
                    step.className = 'step';
                    step.dataset.channel = channelIndex;
                    step.dataset.step = stepIndex;
                    
                    if (isActive) step.classList.add('active');
                    if (channel.muted) step.classList.add('muted');
                    if (state.currentStep === stepIndex) step.classList.add('playing');
                    
                    step.onclick = () => {
                        if (channel.type === 'sample') {
                            dispatch(toggleStep(channelIndex, stepIndex));
                        } else {
                            // For synth channels, prompt for note selection
                            const note = prompt(`Enter note for step ${stepIndex + 1} (e.g. C4, D#5)`, channel.notes[stepIndex]);
                            if (note) {
                                dispatch(setNote(channelIndex, stepIndex, note.toUpperCase()));
                                dispatch(toggleStep(channelIndex, stepIndex));
                            }
                        }
                    };
                    
                    row.appendChild(step);
                });
                
                container.appendChild(row);
                
                // Render channel-specific controls
                if (channel.type === 'sample') {
                    renderSampleChannel(header, channel, channelIndex, dispatch);
                } else {
                    renderSynthChannel(header, channel, channelIndex, dispatch);
                }
            });
        }

        // Transport controls handling
        function setupTransportControls(state, dispatch) {
            const playBtn = document.getElementById('play-btn');
            const stopBtn = document.getElementById('stop-btn');
            const bpmInput = document.getElementById('bpm-input');
            
            playBtn.onclick = () => {
                dispatch(togglePlay());
                if (state.isPlaying) {
                    runtimeState.Tone.Transport.stop();
                } else {
                    runtimeState.Tone.Transport.start();
                }
            };
            
            stopBtn.onclick = () => {
                runtimeState.Tone.Transport.stop();
                runtimeState.Tone.Transport.seconds = 0;
                dispatch(togglePlay());
            };
            
            bpmInput.value = state.bpm;
            bpmInput.onchange = () => {
                const bpm = parseInt(bpmInput.value);
                if (bpm >= 20 && bpm <= 300) {
                    runtimeState.Tone.Transport.bpm.value = bpm;
                    dispatch(setBpm(bpm));
                }
            };
        }

        // Main application boot function
        function boot() {
            // Create store
            let state = initialState;
            const listeners = [];
            const dispatch = (action) => {
                state = reducer(state, action);
                listeners.forEach(listener => listener());
            };

            const subscribe = (listener) => {
                listeners.push(listener);
                return () => {
                    const index = listeners.indexOf(listener);
                    if (index > -1) listeners.splice(index, 1);
                };
            };

            // DOM elements
            const gridContainer = document.getElementById('sequencer-grid');
            const pianoContainer = document.getElementById('piano');

            // Render initial UI
            function render() {
                renderSequencerGrid(gridContainer, state, dispatch);
            }

            // Initialize transport
            runtimeState.Tone.Transport.bpm.value = state.bpm;
            runtimeState.Tone.Transport.loop = true;
            runtimeState.Tone.Transport.loopStart = 0;
            runtimeState.Tone.Transport.loopEnd = '4m';

            // Create sequencer callback
            const noteSequence = new runtimeState.Tone.Sequence((time, step) => {
                dispatch(setCurrentStep(step));
                
                state.channels.forEach(channel => {
                    if (channel.muted || !channel.steps[step]) return;
                    
                    if (channel.type === 'sample' && channel.player) {
                        channel.player.start(time);
                    } else if (channel.type === 'synth') {
                        // Create synth if it doesn't exist
                        if (!channel.synth) {
                            const envelope = new runtimeState.Tone.AmplitudeEnvelope({
                                attack: channel.attack,
                                decay: channel.decay,
                                sustain: channel.sustain,
                                release: channel.release
                            }).toDestination();
                            
                            const filter = new runtimeState.Tone.Filter(800, "lowpass").connect(envelope);
                            const oscillator = new runtimeState.Tone.Oscillator(channel.waveform).connect(filter);
                            
                            channel.synth = { oscillator, envelope, filter };
                        }
                        
                        // Update synth parameters
                        channel.synth.envelope.attack = channel.attack;
                        channel.synth.envelope.decay = channel.decay;
                        channel.synth.envelope.sustain = channel.sustain;
                        channel.synth.envelope.release = channel.release;
                        channel.synth.oscillator.type = channel.waveform;
                        
                        // Play note
                        channel.synth.oscillator.frequency.value = runtimeState.Tone.Frequency(channel.notes[step]).toFrequency();
                        channel.synth.envelope.triggerAttackRelease("8n", time);
                    }
                });
            }, [...Array(64).keys()], '16n');

            noteSequence.start(0);

            // Setup transport controls
            setupTransportControls(state, dispatch);

            // Subscribe to state changes
            subscribe(render);

            // Create piano keys
            const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const whiteKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];

            notes.forEach(note => {
                const key = document.createElement('div');
                key.className = 'key';
                key.textContent = note;
                key.dataset.note = `${note}4`;
                
                if (!whiteKeys.includes(note)) {
                    key.classList.add('black');
                }
                
                key.onmousedown = () => {
                    const synth = new runtimeState.Tone.Synth().toDestination();
                    synth.triggerAttackRelease(`${note}4`, '8n');
                    key.classList.add('active');
                    setTimeout(() => key.classList.remove('active'), 200);
                };
                
                pianoContainer.appendChild(key);
            });

            // Initial render
            render();
            
            // Hide loader after everything is rendered
            setLoaderStatus('');
        }

        // Load Tone.js from ordinals
        document.addEventListener('DOMContentLoaded', () => {
            const TONE_ORDINALS_URL = 'https://ordinals.com/content/04813d7748d918bd8a3069cb1823ebc9586f0ce16cd6a97a784581ec38d13062i0';
            
            setLoaderStatus('Loading Audio Engine...');
            import(TONE_ORDINALS_URL)
                .then(() => {
                    runtimeState.Tone = window.Tone;
                    console.log('[4-Bar Sequencer] Tone.js loaded:', runtimeState.Tone?.version ?? 'Unknown');
                    setLoaderStatus('Audio Engine Loaded');
                    // Call boot immediately after Tone.js is loaded
                    boot();
                })
                .catch(err => {
                    setLoaderStatus('Failed to load Tone.js. App cannot start.', true);
                    console.error('[4-Bar Sequencer] Critical Tone.js load error:', err);
                });
        });
    </script>
</body>
</html>