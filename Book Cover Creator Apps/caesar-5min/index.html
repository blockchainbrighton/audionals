<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BURGESS Design Studio</title>
<style>
/* Core Reset & Theme */
* { margin:0; padding:0; box-sizing:border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
  min-height: 100vh; color: white;
}

/* Layout */
.container { max-width: 1400px; margin: 0 auto; padding: 20px; }
.header { text-align: center; margin-bottom: 30px; }
.header h1 { font-size: 2.5rem; font-weight: bold; margin-bottom: 10px; text-shadow: 0 2px 10px rgba(0,0,0,0.3); }
.header p { color: #a5b4fc; font-size: 1.1rem; }

/* Mode Switcher */
.mode-switcher {
  display: flex;
  justify-content: center;
  gap: 20px;
  margin-bottom: 30px;
  background: rgba(255,255,255,0.05);
  padding: 10px;
  border-radius: 50px;
  width: fit-content;
  margin-left: auto;
  margin-right: auto;
  border: 1px solid rgba(255,255,255,0.1);
}
.mode-btn {
  padding: 10px 30px;
  border-radius: 40px;
  border: none;
  background: transparent;
  color: #a5b4fc;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 1rem;
}
.mode-btn.active {
  background: #4f46e5;
  color: white;
  box-shadow: 0 4px 15px rgba(79, 70, 229, 0.4);
}

/* Main Grid */
.main-grid { display: grid; grid-template-columns: 1fr 400px; gap: 30px; align-items: start; }

/* Canvas Section */
.canvas-section { background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 16px; padding: 20px; }
.canvas-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px; font-size: 1.1rem; font-weight: 600; color: #e2e8f0; }

/* Canvas Aspect Ratios */
.canvas-wrapper { width: 100%; display: flex; justify-content: center; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 20px; }
.canvas {
  position: relative;
  background-size: cover;
  background-position: center;
  border-radius: 4px;
  overflow: hidden;
  box-shadow: 0 20px 50px rgba(0,0,0,0.5);
  transition: all 0.3s ease;
  border: 1px solid rgba(255,255,255,0.1);
}

/* Aspect Ratio Classes */
.ratio-poster { width: 100%; aspect-ratio: 3/2; max-height: 600px; }
.ratio-book { height: 600px; aspect-ratio: 2/3; width: auto; }

/* Canvas Elements */
.canvas-element {
  position: absolute;
  cursor: grab;
  user-select: none;
  filter: drop-shadow(0 4px 6px rgba(0,0,0,0.8));
  transition: transform 0.1s;
}
.canvas-element:active { cursor: grabbing; transform: scale(1.02); }
.hidden { display: none !important; }

/* Controls */
.controls-section { display: flex; flex-direction: column; gap: 20px; }
.tabs { background: rgba(30, 41, 59, 0.7); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; overflow: hidden; backdrop-filter: blur(10px); }
.tab-buttons { display: flex; overflow-x: auto; background: rgba(0,0,0,0.2); border-bottom: 1px solid rgba(255,255,255,0.05); }
.tab-button {
  flex: 1; padding: 15px; background: transparent; border: none; color: #94a3b8;
  cursor: pointer; font-weight: 600; transition: all 0.2s; white-space: nowrap;
}
.tab-button:hover { color: white; background: rgba(255,255,255,0.05); }
.tab-button.active { color: white; background: rgba(79, 70, 229, 0.2); border-bottom: 2px solid #4f46e5; }

.tab-content { padding: 20px; max-height: 500px; overflow-y: auto; }
.tab-panel { display: none; }
.tab-panel.active { display: block; }

/* Option Grid */
.option-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; }
.option-item {
  position: relative; border-radius: 8px; overflow: hidden; border: 2px solid rgba(255,255,255,0.1);
  cursor: pointer; transition: all 0.2s; background: rgba(0,0,0,0.2); aspect-ratio: 1;
}
.option-item:hover { transform: translateY(-2px); border-color: #818cf8; }
.option-item.selected { border-color: #4f46e5; box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.3); }
.option-item img { width: 100%; height: 100%; object-fit: contain; padding: 5px; }

/* Arrows for Variants */
.variant-btn {
  position: absolute; top: 50%; transform: translateY(-50%);
  width: 24px; height: 24px; border-radius: 50%; border: none;
  background: rgba(0,0,0,0.8); color: white; font-size: 10px;
  cursor: pointer; display: flex; align-items: center; justify-content: center;
  transition: 0.2s; opacity: 0;
}
.option-item:hover .variant-btn { opacity: 1; }
.variant-btn.left { left: 5px; }
.variant-btn.right { right: 5px; }

/* Sliders & Buttons */
.sliders-panel { background: rgba(30, 41, 59, 0.7); padding: 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); }
.control-group { margin-bottom: 15px; }
.control-group label { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.9rem; color: #e2e8f0; }
input[type=range] { width: 100%; accent-color: #4f46e5; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; }

.action-buttons { display: flex; gap: 10px; margin-top: 10px; }
.btn {
  flex: 1; padding: 12px; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;
  display: flex; align-items: center; justify-content: center; gap: 8px; transition: 0.2s;
}
.btn-reset { background: rgba(255,255,255,0.1); color: white; }
.btn-reset:hover { background: rgba(255,255,255,0.2); }
.btn-save { background: linear-gradient(135deg, #4f46e5, #ec4899); color: white; }
.btn-save:hover { filter: brightness(1.1); transform: translateY(-1px); }

@media (max-width: 900px) {
  .main-grid { grid-template-columns: 1fr; }
  .ratio-book { height: auto; width: 100%; max-width: 400px; margin: 0 auto; }
}
</style>
</head>
<body>

<div class="container">
    <header class="header">
        <h1>Design Studio</h1>
        <p>Create Posters & Book Covers in seconds</p>
    </header>

    <!-- Mode Switcher -->
    <div class="mode-switcher">
        <button class="mode-btn active" onclick="setMode('poster')">Poster Mode</button>
        <button class="mode-btn" onclick="setMode('book')">Book Cover Mode</button>
    </div>

    <div class="main-grid">
        <!-- Canvas Area -->
        <div class="canvas-section">
            <div class="canvas-header">
                <span>Live Preview</span>
                <span style="font-size: 0.8rem; opacity: 0.7; font-weight: 400;">Drag elements to move</span>
            </div>
            <div class="canvas-wrapper">
                <div id="canvas" class="canvas ratio-poster">
                    <!-- Poster Elements -->
                    <img id="poster-text" class="canvas-element poster-el" src="" style="width: 60%; top: 20%; left: 50%; transform: translate(-50%, -50%); z-index: 2;">
                    <img id="poster-char" class="canvas-element poster-el" src="" style="width: 30%; top: 60%; left: 50%; transform: translate(-50%, -50%); z-index: 3;">
                    
                    <!-- Book Elements -->
                    <img id="book-title" class="canvas-element book-el hidden" src="" style="width: 80%; top: 15%; left: 50%; transform: translate(-50%, -50%); z-index: 3;">
                    <img id="book-author" class="canvas-element book-el hidden" src="" style="width: 60%; top: 85%; left: 50%; transform: translate(-50%, -50%); z-index: 3;">
                </div>
            </div>
        </div>

        <!-- Controls Area -->
        <div class="controls-section">
            <!-- Tabs -->
            <div class="tabs">
                <div id="tab-buttons" class="tab-buttons">
                    <!-- Injected by JS -->
                </div>
                <div id="tab-content" class="tab-content">
                    <!-- Injected by JS -->
                </div>
            </div>

            <!-- Size Sliders -->
            <div class="sliders-panel">
                <div id="sliders-container">
                    <!-- Injected by JS based on active elements -->
                </div>
                
                <div class="action-buttons">
                    <button class="btn btn-reset" onclick="resetLayout()">
                        <span>↺</span> Reset
                    </button>
                    <button class="btn btn-save" onclick="downloadDesign()">
                        <span>⬇</span> Save Image
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * APP CONFIGURATION
 * Defines folder paths, file bases, and available tabs for each mode.
 */
const CONFIG = {
    poster: {
        ratioClass: 'ratio-poster',
        rootFolder: 'posters/',
        tabs: [
            { id: 'bg', label: 'Backgrounds', folder: 'backgrounds', target: 'bg', bases: ['album_collage', 'dressing_room', 'vinyl_wall'] },
            { id: 'char', label: 'Character', folder: 'characters', target: 'poster-char', bases: ['BURGESS'] },
            { id: 'txt', label: 'Text', folder: 'text', target: 'poster-text', bases: ['BurgessText', 'burgess_retro', 'burgess_neon'] }
        ],
        sliders: [
            { target: 'poster-text', label: 'Text Size', default: 60 },
            { target: 'poster-char', label: 'Character Size', default: 30 }
        ]
    },
    book: {
        ratioClass: 'ratio-book',
        rootFolder: 'books/',
        tabs: [
            { id: 'cover', label: 'Covers', folder: 'covers', target: 'bg', bases: ['cover_base', 'fantasy_bg', 'thriller_bg'] },
            { id: 'title', label: 'Title', folder: 'titles', target: 'book-title', bases: ['book_title', 'fantasy_title', 'modern_title'] },
            { id: 'author', label: 'Author', folder: 'authors', target: 'book-author', bases: ['author_name', 'simple_author'] }
        ],
        sliders: [
            { target: 'book-title', label: 'Title Size', default: 80 },
            { target: 'book-author', label: 'Author Size', default: 60 }
        ]
    }
};

// Global State
let currentState = {
    mode: 'poster',
    selections: {}, // Stores current file index for each base (e.g., BURGESS: 1)
    activeTab: null
};

// --- INITIALIZATION ---
document.addEventListener('DOMContentLoaded', () => {
    setMode('poster');
});

// --- CORE FUNCTIONS ---

function setMode(mode) {
    currentState.mode = mode;
    
    // 1. Update Mode Buttons
    document.querySelectorAll('.mode-btn').forEach(b => {
        b.classList.toggle('active', b.textContent.toLowerCase().includes(mode));
    });

    // 2. Update Canvas Shape & Visible Elements
    const canvas = document.getElementById('canvas');
    canvas.className = `canvas ${CONFIG[mode].ratioClass}`;
    
    // Toggle visibility of elements
    document.querySelectorAll('.poster-el').forEach(el => el.classList.toggle('hidden', mode !== 'poster'));
    document.querySelectorAll('.book-el').forEach(el => el.classList.toggle('hidden', mode !== 'book'));

    // 3. Render Tabs
    renderTabs(mode);

    // 4. Render Sliders
    renderSliders(mode);

    // 5. Reset/Init Selection for this mode
    // (This attempts to load the first image of the first base for each tab)
    CONFIG[mode].tabs.forEach(tab => {
        if (!currentState.selections[tab.id]) {
            currentState.selections[tab.id] = { baseIdx: 0, variantIdx: 1 };
        }
        updateElement(tab, currentState.selections[tab.id]);
    });

    // 6. Reset Layout Positions to defaults
    resetLayout();
}

function renderTabs(mode) {
    const tabContainer = document.getElementById('tab-buttons');
    const contentContainer = document.getElementById('tab-content');
    
    tabContainer.innerHTML = '';
    contentContainer.innerHTML = '';

    CONFIG[mode].tabs.forEach((tab, index) => {
        // Create Button
        const btn = document.createElement('button');
        btn.className = `tab-button ${index === 0 ? 'active' : ''}`;
        btn.textContent = tab.label;
        btn.onclick = () => activateTab(tab.id);
        tabContainer.appendChild(btn);

        // Create Panel
        const panel = document.createElement('div');
        panel.id = `panel-${tab.id}`;
        panel.className = `tab-panel ${index === 0 ? 'active' : ''}`;
        
        // Populate Grid
        const grid = document.createElement('div');
        grid.className = 'option-grid';
        
        // For each base defined in config, create a card
        tab.bases.forEach(baseName => {
            const card = createOptionCard(mode, tab, baseName);
            grid.appendChild(card);
        });
        
        panel.appendChild(grid);
        contentContainer.appendChild(panel);
    });

    currentState.activeTab = CONFIG[mode].tabs.id;
    bindDragEvents(); // Re-bind drag logic based on active tab
}

function createOptionCard(mode, tab, baseName) {
    const wrapper = document.createElement('div');
    wrapper.className = 'option-item';
    
    // Helper to build path
    const getPath = (variant) => `${CONFIG[mode].rootFolder}${tab.folder}/${baseName}_${variant}.png`;

    // Preview Image (Defaults to _1.png)
    const img = document.createElement('img');
    img.src = getPath(1);
    img.onerror = () => { img.src = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBmaWxsPSIjNDQ0Ij48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1zaXplPSIxMiIgZmlsbD0iI2ZmZiIgdGV4dC1hbmNob3I9Im1pZGRsZSI+TWlzc2luZzwvdGV4dD48L3N2Zz4='; }; // Placeholder on error
    img.alt = baseName;

    // Arrow Controls for Variants
    const leftBtn = document.createElement('button');
    leftBtn.className = 'variant-btn left';
    leftBtn.innerHTML = '◀';
    leftBtn.onclick = (e) => { e.stopPropagation(); changeVariant(tab, baseName, -1, img); };

    const rightBtn = document.createElement('button');
    rightBtn.className = 'variant-btn right';
    rightBtn.innerHTML = '▶';
    rightBtn.onclick = (e) => { e.stopPropagation(); changeVariant(tab, baseName, 1, img); };

    wrapper.onclick = () => {
        // Highlight selection
        document.querySelectorAll(`#panel-${tab.id} .option-item`).forEach(el => el.classList.remove('selected'));
        wrapper.classList.add('selected');
        
        // Get current variant index stored on the image element dataset or default to 1
        const currentVar = parseInt(img.dataset.variant || 1);
        updateElement(tab, { base: baseName, variantIdx: currentVar });
    };

    wrapper.append(leftBtn, img, rightBtn);
    return wrapper;
}

// Variant Logic (Cycles _1.png, _2.png, etc)
function changeVariant(tab, baseName, dir, imgEl) {
    let current = parseInt(imgEl.dataset.variant || 1);
    let next = current + dir;
    if (next < 1) next = 5; // Loop back (arbitrary max of 5 assumed, normally would check existence)
    if (next > 5) next = 1;
    
    const mode = currentState.mode;
    const newPath = `${CONFIG[mode].rootFolder}${tab.folder}/${baseName}_${next}.png`;
    
    // Optimistic update
    imgEl.src = newPath;
    imgEl.dataset.variant = next;

    // If this card is currently selected, update the canvas immediately
    if (imgEl.parentElement.classList.contains('selected')) {
        updateElement(tab, { base: baseName, variantIdx: next });
    }
}

function updateElement(tab, selection) {
    const path = `${CONFIG[currentState.mode].rootFolder}${tab.folder}/${selection.base || selection.baseName}_${selection.variantIdx}.png`;
    
    if (tab.target === 'bg') {
        document.getElementById('canvas').style.backgroundImage = `url('${path}')`;
    } else {
        const el = document.getElementById(tab.target);
        if (el) el.src = path;
    }
    currentState.selections[tab.id] = selection;
}

function activateTab(tabId) {
    // UI Updates
    document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
    
    const btn = Array.from(document.querySelectorAll('.tab-button')).find(b => b.textContent === CONFIG[currentState.mode].tabs.find(t => t.id === tabId).label);
    if(btn) btn.classList.add('active');
    
    document.getElementById(`panel-${tabId}`).classList.add('active');
    
    currentState.activeTab = tabId;
    bindDragEvents(); // Update which element is draggable
}

function renderSliders(mode) {
    const container = document.getElementById('sliders-container');
    container.innerHTML = '';
    
    CONFIG[mode].sliders.forEach(slider => {
        const group = document.createElement('div');
        group.className = 'control-group';
        
        const label = document.createElement('label');
        label.innerHTML = `${slider.label} <span id="val-${slider.target}">${slider.default}%</span>`;
        
        const input = document.createElement('input');
        input.type = 'range';
        input.min = '10';
        input.max = '200';
        input.value = slider.default;
        
        input.oninput = (e) => {
            const val = e.target.value;
            document.getElementById(`val-${slider.target}`).textContent = val + '%';
            const el = document.getElementById(slider.target);
            if (el) el.style.width = val + '%';
        };

        group.append(label, input);
        container.append(group);
    });
}

function resetLayout() {
    const mode = currentState.mode;
    // Reset sliders
    renderSliders(mode);
    
    // Reset positions based on mode
    if (mode === 'poster') {
        const txt = document.getElementById('poster-text');
        const char = document.getElementById('poster-char');
        txt.style.top = '20%'; txt.style.left = '50%'; txt.style.width = '60%';
        char.style.top = '60%'; char.style.left = '50%'; char.style.width = '30%';
    } else {
        const title = document.getElementById('book-title');
        const author = document.getElementById('book-author');
        title.style.top = '15%'; title.style.left = '50%'; title.style.width = '80%';
        author.style.top = '85%'; author.style.left = '50%'; author.style.width = '60%';
    }
}

// --- DRAG AND DROP LOGIC ---

function bindDragEvents() {
    // Clear old events
    document.querySelectorAll('.canvas-element').forEach(el => {
        el.onmousedown = null; el.ontouchstart = null;
        el.style.cursor = 'default';
    });

    // Determine drag target based on active tab
    // (If active tab is Background, no drag. If Text tab, Text drag, etc.)
    const modeConfig = CONFIG[currentState.mode];
    const currentTabObj = modeConfig.tabs.find(t => t.id === currentState.activeTab);
    
    if (!currentTabObj || currentTabObj.target === 'bg') return;

    const targetEl = document.getElementById(currentTabObj.target);
    if (!targetEl) return;

    targetEl.style.cursor = 'grab';

    targetEl.onmousedown = targetEl.ontouchstart = function(e) {
        e.preventDefault();
        
        let startX = e.clientX || e.touches.clientX;
        let startY = e.clientY || e.touches.clientY;
        
        const elemRect = targetEl.getBoundingClientRect();
        const canvasRect = document.getElementById('canvas').getBoundingClientRect();
        
        // Calculate offset from the element's center to mouse click
        // This prevents the "jump to center" effect
        const offsetX = startX - (elemRect.left + elemRect.width/2);
        const offsetY = startY - (elemRect.top + elemRect.height/2);

        targetEl.style.cursor = 'grabbing';
        targetEl.style.zIndex = 100; // Bring to front while dragging

        document.onmousemove = document.ontouchmove = function(moveEvent) {
            moveEvent.preventDefault();
            const mouseX = moveEvent.clientX || moveEvent.touches.clientX;
            const mouseY = moveEvent.clientY || moveEvent.touches.clientY;

            // Calculate new position relative to canvas container
            let newLeft = mouseX - canvasRect.left - offsetX;
            let newTop = mouseY - canvasRect.top - offsetY;

            // Convert to percentages
            let percentLeft = (newLeft / canvasRect.width) * 100;
            let percentTop = (newTop / canvasRect.height) * 100;

            targetEl.style.left = `${percentLeft}%`;
            targetEl.style.top = `${percentTop}%`;
        };

        document.onmouseup = document.ontouchend = function() {
            targetEl.style.cursor = 'grab';
            targetEl.style.zIndex = '';
            document.onmousemove = document.ontouchmove = null;
            document.onmouseup = document.ontouchend = null;
        };
    };
}

// --- EXPORT LOGIC ---

function downloadDesign() {
    const canvasEl = document.getElementById('canvas');
    const mode = currentState.mode;
    
    // Create high-res canvas for export
    const exportCanvas = document.createElement('canvas');
    const ctx = exportCanvas.getContext('2d');
    
    // Set dimensions based on mode ratio
    // Poster 3:2 -> 1500x1000, Book 2:3 -> 1000x1500
    const w = mode === 'poster' ? 1500 : 1000;
    const h = mode === 'poster' ? 1000 : 1500;
    exportCanvas.width = w;
    exportCanvas.height = h;

    // Helper: Load Image Promise
    const loadImg = (src) => new Promise((resolve) => {
        if(!src || src === window.location.href) return resolve(null);
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => resolve(img);
        img.onerror = () => resolve(null);
        img.src = src;
    });

    // 1. Draw Background
    const bgUrl = window.getComputedStyle(canvasEl).backgroundImage.slice(5, -2).replace(/['"]/g, '');
    
    loadImg(bgUrl).then(bgImg => {
        if (bgImg) ctx.drawImage(bgImg, 0, 0, w, h);

        // 2. Identify elements to draw
        const elementsToDraw = [];
        if (mode === 'poster') {
            elementsToDraw.push(document.getElementById('poster-char')); // Z-index 2
            elementsToDraw.push(document.getElementById('poster-text')); // Z-index 3 (Text usually on top)
        } else {
            elementsToDraw.push(document.getElementById('book-title'));
            elementsToDraw.push(document.getElementById('book-author'));
        }

        // Load all element images
        const promises = elementsToDraw.map(el => loadImg(el.src).then(img => ({ img, el })));

        return Promise.all(promises);
    }).then(results => {
        results.forEach(({ img, el }) => {
            if (!img) return;
            // Calculate relative position and size
            const rect = el.getBoundingClientRect();
            const containerRect = canvasEl.getBoundingClientRect();

            // The style.left/top are percentages, but getBoundingClientRect gives us visual pixels
            // We need to map visual pixels relative to container -> export canvas pixels
            
            const relX = rect.left - containerRect.left;
            const relY = rect.top - containerRect.top;
            
            const scaleX = w / containerRect.width;
            const scaleY = h / containerRect.height;

            ctx.drawImage(
                img, 
                relX * scaleX, 
                relY * scaleY, 
                rect.width * scaleX, 
                rect.height * scaleY
            );
        });

        // Trigger Download
        const link = document.createElement('a');
        link.download = `burgess-${mode}-design.png`;
        link.href = exportCanvas.toDataURL('image/png');
        link.click();
    });
}
</script>
</body>
</html>
