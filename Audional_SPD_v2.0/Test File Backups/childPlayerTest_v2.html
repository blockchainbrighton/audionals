<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>OB1 #1 - Audional Art</title><style>body{background-color:#000000;display:flex;justify-content:center;align-items:center;height:100vh;margin:0}img {width: auto;height: auto;max-width: 60%;max-height: 80vh;object-fit: contain;aspect-ratio: 1 / 1;}
</style></head>
<div id="ob1Number" style="display: none;">TEST_OB</div> <!--PLACE COLLECTION NUMBER HERE-->
<div id="sampleName" style="display: none;">TEST CLICK</div><!--PLACE SAMPLE NAME HERE-->
<body>
<img id="OB1_Image" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAIAAABLixI0AAAACXBIWXMAAAAnAAAAJwEqCZFPAAAAI0lEQVQ4jWN81s3JQCXARC2DRs0aNWvUrFGzRs0aNWsYmQUAtP4BrHiSyo4AAAAASUVORK5CYII=" alt="Click to play audio">
<!-- Audio: Short click sound -->
<audio id="audionalData" loop data-audionalSampleName="808 Kick Drum">
<source src="data:audio/wav;base64,UklGRhowAABXQVZFZm10IBAAAAABAAEARKwAABCxAgAEABAAZGF0YUwAAAACAAACABgAZGF0YQAAAAEAkZAgIIEyHjAqeykAAAAA//uQZAUABfQU8WkMAAAAAHHVUUU5VZmUId2luZwAAAAAA//uQZAUABfQU8WkMAAAAAHHVUUU5VZmUId2luZwAAAAAA//uQZAMABfQU8WkMAAAAAHHVUUU5VZmUId2luZwAAAAAA" type="audio/wav">
Your browser does not support the audio element.
</audio>
<div id= "BPM">78 BPM</div> 
<style>
    #BPM {
        font-size: 24px; /* Adjust the font size as needed */
        font-weight: bold;
        color: rgb(255, 251, 0);
        position: absolute;
        top: 5%;
        left: 50%;
        transform: translate(-50%, -50%);
        opacity: 0; /* Initially set the opacity to 0 for fade in effect */
        transition: opacity 0.5s ease-in-out; /* Apply transition for smooth fade in/out */
    }

    #BPM.show {
        opacity: 1; /* Set opacity to 1 to make the element visible */
    }
    
   
   
</style>


<script>

// Audio Context and Gain Node Initialization

// Dynamically manage Audio Context initialization
let audioContext = null;
let gainNode = null;

let animationTimeoutId = null;

let multiplierCount = 0;
let isMuted = false;
let previousVolume = 1;

let beatCounter = 0; // Initialize a counter to keep track of the beats

let isFadingOut = false;

function getAudioContext() {
        if (!window.myAudioContext || window.myAudioContext.state === 'closed') {
            window.myAudioContext = new AudioContext();
        }
        return window.myAudioContext;
    }


    // Adjusted state object to not use audioContext at definition
    const state = {
        bpm: 78,
        isLooping: false,
        audioBuffer: null,
        nextNoteTime: 0, // Temporarily set to 0 or some safe initial value
        scheduledNotes: [],
        scheduleMultiplier: 1,
    };


    // Event listener for image click to toggle audio playback
    // Event listener for image click to toggle audio playback
    document.getElementById("OB1_Image").addEventListener("click", async () => {
            const context = getAudioContext(); // Ensure audioContext is available
            if (context.state === 'suspended') await context.resume();
    
            // Reinitialize AudioContext if it's been closed
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioContext.createGain();
                gainNode.connect(audioContext.destination);
                // Fetch and decode the audio again if necessary
                await fetchAndDecodeAudio("audionalData");
            }
            
            const loopingState = state.isLooping ? "STOP" : "START";
            console.log(`[Click Event] Looping state: ${loopingState}`);
            state.isLooping ? stopAudioPlayback() : playAudioBuffer();
        });


// Event Listener for Messages
window.addEventListener('message', (event) => {
    // Check if the message is from the current window and ignore it if so
    if (event.source === window) {
        return; // Ignore messages that the window sent to itself
    }
    const { type, data } = event.data;
        switch (type) {
            case 'updateBPM':
                updateBPM(Math.max(60, Math.min(240, data.bpm)));
                break;
            case 'muteControl':
                applyVolumeFade(data.mute ? 0 : previousVolume, audioContext.currentTime, 0.03);
                break;
            case 'requestSettings':
                sendCurrentSettings();
                break;
            default:
                console.log('Unknown message type:', type);
        }
    });
    



    // Event listener for DOMContentLoaded to fetch and decode audio
    document.addEventListener('DOMContentLoaded', () => fetchAndDecodeAudio("audionalData"));

    
   // Event listener for spacebar press to trigger sample playback
   document.addEventListener('keydown', event => {
            console.log('Spacebar pressed');
            if (event.key === ' ' || event.keyCode === 32) playSampleOnce();
        });

    // Event listeners for custom BPM and scheduling multiplier adjustments
    document.addEventListener('bpmChange', (event) => {
        updateBPM(state.bpm + event.detail.adjustment);
    });

  
    // Function to send current settings back to parent
    function sendCurrentSettings() {
        console.log('Sending current settings back to parent:', {
            volume: gainNode.gain.value,
            scheduleMultiplier: state.scheduleMultiplier
        });
        event.source.postMessage({
            type: 'currentSettings',
            settings: {
                volume: gainNode.gain.value,
                scheduleMultiplier: state.scheduleMultiplier
            }
        }, '*'); // Consider replacing '*' with event.origin for security
    }

     // Function to get the sample name from the HTML element
function getSampleName() {
    const sampleName = document.getElementById('sampleName').innerText;
    console.log(`[Child] Sample Name fetched: ${sampleName}`);
    return sampleName;
}

// Function to get the OB1 number from the HTML element
function getOb1Number() {
    const ob1Number = document.getElementById('ob1Number').innerText;
    console.log(`[Child] OB1 Number fetched: ${ob1Number}`);
    return ob1Number;
}

// Function to broadcast the sample play to the parent window
function broadcastSamplePlay(sampleName, ob1Number) {
    const currentTimeMillis = Date.now(); // Get current time in milliseconds
    console.log(`[Child] Broadcasting play with real-time timestamp: Sample Name - ${sampleName}, OB1 Number - ${ob1Number}, Timestamp - ${currentTimeMillis}`);

    window.parent.postMessage({
        type: 'playingNote',
        details: {
            sampleName: sampleName,
            ob1Number: ob1Number,
        },
        timestamp: currentTimeMillis // Include the current real-time timestamp
    }, '*'); // Reminder to replace '*' with a specific domain for production for security
}



// Function to start audio playback and handle its lifecycle
function startAudioPlayback(callback) {
    const source = createAndConnectBufferSource(state.audioBuffer);
    console.log('[Child] Starting audio playback');
    startAnimation('OB1_Image');
    source.start(audioContext.currentTime);

    source.onended = () => {
        console.log('[Child] Audio playback ended');
        setTimeout(() => {
            stopAnimation('OB1_Image');
        }, 150);
        source.disconnect();
        if (callback) callback();
    };
    state.scheduledNotes.push(source);
    console.log('[Child] Audio source pushed to scheduled notes');
}

// Function to play audio sample and broadcast its details to the parent
function playAudional() {
    const sampleName = getSampleName();
    const ob1Number = getOb1Number();
    console.log(`[Child] Playing Audional Sample: ${sampleName} from OB1 #${ob1Number}`);

    broadcastSamplePlay(sampleName, ob1Number);

    startAudioPlayback(() => {
        console.log('[Child] Additional logic after playAudional playback ends');
    });
}

// Function to play a sample once upon a user action, broadcasting its details
function playSampleOnce() {
    const sampleName = getSampleName();
    const ob1Number = getOb1Number();
    console.log(`[Child] Playing Sample Once: ${sampleName} from OB1 #${ob1Number}`);
    
    broadcastSamplePlay(sampleName, ob1Number);

    startAudioPlayback(() => {
        console.log('[Child] Additional logic after playSampleOnce playback ends');
    });
}


     // Fetch and decode audio data
     async function fetchAndDecodeAudio(elementId) {
        console.log(`[fetchAndDecodeAudio] Fetching audio for element: ${elementId}`);
        const audioElement = document.getElementById(elementId);
        if (!audioElement) return console.error("Audio element not found:", elementId);

        const audioSrc = audioElement.querySelector('source')?.src || audioElement.src;
        if (!audioSrc) return console.error("Audio source not found for element:", elementId);

        try {
            const arrayBuffer = await (await fetch(audioSrc)).arrayBuffer();
            const context = getAudioContext(); // Ensure audioContext is initialized
            context.decodeAudioData(arrayBuffer, buffer => {
                state.audioBuffer = buffer;
                console.log("[fetchAndDecodeAudio] Audio data fetched and decoded successfully.");
            }, error => console.error("Error decoding audio data:", error));
        } catch (error) {
            console.error("Error fetching audio data:", error);
        }
    }

 
      
     // Create buffer source and connect it to gain node
     function createAndConnectBufferSource(buffer) {
         const source = audioContext.createBufferSource();
         source.buffer = buffer;
         source.connect(gainNode);
         return source;
     }
 
     // Play audio buffer for looping playback
     function playAudioBuffer() {
         if (!state.isLooping) {
             state.isLooping = true;
             state.startTime = state.nextNoteTime = audioContext.currentTime;
             scheduleNextNote();
         }
     }
 
    // Stop audio playback and reset counters
    function stopAudioPlayback() {
        if (state.isLooping) {
            state.isLooping = false;
            
            // Reset counters and cancel scheduled notes
            beatCounter = 0;
            cancelScheduledNotes();
            
            // Close and nullify the AudioContext
            if (audioContext) {
                audioContext.close().then(() => {
                    audioContext = null;
                    console.log('[Child] AudioContext closed.');
                });
            }
            
            console.log('[Child] Playback stopped. Counters and timers reset.');
        }
    }


    // Function to cancel all scheduled notes
    function cancelScheduledNotes() {
        // Example implementation, adapt based on how notes are scheduled and managed
        state.scheduledNotes.forEach(source => {
            source.stop();
            source.disconnect();
        });
        state.scheduledNotes = [];
    }


    // Fade out and stop all scheduled sources
    function fadeOutAndStopSources() {
        // Prevent function from running if fade-out is already in progress
        if (isFadingOut) return;
        isFadingOut = true;

        const currentTime = audioContext.currentTime;
        const fadeDuration = 0.1; // Fade out over 100 milliseconds

        // Set the current value and schedule a ramp to 0
        gainNode.gain.setValueAtTime(gainNode.gain.value, currentTime);
        gainNode.gain.linearRampToValueAtTime(0, currentTime + fadeDuration);

        // After the fade duration, stop all sources
        setTimeout(() => {
            state.scheduledNotes.forEach(source => {
                source.stop();
                source.disconnect(); // Ensure clean disconnect
            });
            state.scheduledNotes = [];

            // Reset the gain node for future use
            gainNode.gain.cancelScheduledValues(audioContext.currentTime);
            gainNode.gain.setValueAtTime(1, audioContext.currentTime);

            // Fade-out complete, allow function to run again
            isFadingOut = false;
        }, fadeDuration * 1000);
    }

     // Calculate beat duration
     function calculateBeatDuration(bpm) {
         return 60 / bpm;
     }
 
     // Update BPM and restart playback if looping
     function updateBPM(newBPM) {
        console.log(`Updating BPM to ${newBPM}`);
        state.bpm = newBPM;

        // Assume we have a function to adjust playback scheduling based on BPM
        adjustPlaybackTimingBasedOnBPM();

        // If necessary, update UI or other elements to reflect the new BPM
        displayUpdate('BPM', `${newBPM} BPM`);
    }

    function adjustPlaybackTimingBasedOnBPM() {
        // Example: Adjusting the next note time based on the new BPM
        // This is a simplified example. Your actual implementation may vary.
        const beatDuration = 60 / state.bpm;
        state.nextNoteTime = audioContext.currentTime + beatDuration;

        // If there's ongoing playback that needs to be rescheduled, handle it here
        if (state.isLooping) {
            // Stop current playback loop
            stopAudioPlayback();

            // Restart playback with the new BPM
            playAudioBuffer();
        }
    }

    // Step 1: Define Multiplier Steps
    // Adjusted Multiplier Steps to reflect logical progression
    const multiplierSteps = [
        32, 16, 8, 4, 2, 1, 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625, 0.001953125, 0.0009765625, 0.00048828125
    ];

    // Corrected loop length descriptions
    const loopLengthDescriptions = {
        32: "1/32",
        16: "1/16",
        8: "1/8",
        4: "1/4",
        2: "1/2 beat",
        1: "1 beat",
        0.5: "2 beats",
        0.25: "1 bar", // Corrected here
        0.125: "2 bars",
        0.0625: "4 bars",
        0.03125: "8 bars",
        0.015625: "16 bars",
        0.0078125: "32 bars",
        0.00390625: "64 bars",
        0.001953125: "128 bars",
        0.0009765625: "256 bars",
        0.00048828125: "512 bars",
    };


    // Refactored Event Listener for Multiplier Changes
    // Event listener for handling multiplier changes accurately
document.addEventListener('multiplierChange', (event) => {
    if (event.detail.multiplier === 1) {
        state.scheduleMultiplier = 1; // Reset multiplier
    } else {
        // Find the current index of the scheduleMultiplier
        let currentIndex = multiplierSteps.indexOf(state.scheduleMultiplier);
        // Calculate the new index based on the direction of the change
        let newIndex = event.detail.multiplier === 2 ?
            Math.max(0, currentIndex - 1) : // Doubling the multiplier, move up in the array
            Math.min(multiplierSteps.length - 1, currentIndex + 1); // Halving the multiplier, move down in the array
        // Update the scheduleMultiplier based on the new index
        state.scheduleMultiplier = multiplierSteps[newIndex];
    }
    console.log(`Multiplier adjusted: ${state.scheduleMultiplier}`);
    displayUpdate('BPM', `Multiplier: ${state.scheduleMultiplier}`);
});


    // Schedule next note for looping playback
    function scheduleNextNote() {
        if (!state.isLooping || !state.audioBuffer) return;
        const currentTime = audioContext.currentTime;
        if (currentTime >= state.nextNoteTime) {
            playAudional();
            // Log the scheduled beat time
            console.log(`Beat ${++beatCounter}: Scheduled at ${state.nextNoteTime.toFixed(3)} seconds.`);
            state.nextNoteTime += calculateBeatDuration(state.bpm) / state.scheduleMultiplier;
        }
        const delayUntilNextCheck = Math.max((state.nextNoteTime - currentTime) * 1000, 10);
        setTimeout(scheduleNextNote, delayUntilNextCheck);
    }
 
 
  // Display update with CSS transition and stabilized display timing
    let displayTimeout; // Declare outside to clear previous timeouts

    function displayUpdate(elementId, text, duration = 3000) {
        const element = document.getElementById(elementId);
        element.textContent = text.startsWith("Multiplier:") 
            ? calculateDisplayTextForMultiplier(text.split(": ")[1]) 
            : text;
        element.classList.add('show');

        // Clear any existing timeout to reset the display timer
        clearTimeout(displayTimeout);
        displayTimeout = setTimeout(() => element.classList.remove('show'), duration);
    }

   // Calculate display text for multiplier without changes
function calculateDisplayTextForMultiplier(rawMultiplierText) {
    const multiplier = parseFloat(rawMultiplierText);
    let displayText = "Loop length equals ";

    if (multiplier in loopLengthDescriptions) {
        displayText += loopLengthDescriptions[multiplier];
    } else {
        displayText = "Multiplier out of range";
    }

    return displayText;
}

document.addEventListener('keydown', handleKeyDownEvent);

function handleKeyDownEvent(event) {
    const currentTime = audioContext.currentTime;
    const fadeDuration = 0.03; // Fast fade duration in seconds

    // Adjust scheduling multiplier, BPM Adjustment, and reset scheduling multiplier with '0'
    adjustControls(event);

    // Gain adjustment with smooth fade and Toggle mute/unmute
    adjustVolumeAndToggleMute(event, currentTime, fadeDuration);
}

// Function to dispatch custom events for BPM and multiplier changes
function dispatchEvent(eventName, detail) {
    const event = new CustomEvent(eventName, { detail });
    document.dispatchEvent(event);
}

function adjustControls(event) {
    // Check for BPM adjustments
    if (event.key === '+' && event.shiftKey && !event.ctrlKey) {
        dispatchEvent('bpmChange', { adjustment: 1 });
    } else if (event.key === '_' && event.shiftKey && !event.ctrlKey) {
        dispatchEvent('bpmChange', { adjustment: -1 });
    } else if (event.key === '=' && event.shiftKey && event.ctrlKey) {
        dispatchEvent('bpmChange', { adjustment: 10 });
    } else if (event.key === '_' && event.shiftKey && event.ctrlKey) {
        dispatchEvent('bpmChange', { adjustment: -10 });
    }

    // Check for multiplier adjustments or reset
    if ((event.key === '=' || event.key === '-') && !event.shiftKey && !event.ctrlKey) {
        const multiplier = event.key === '=' ? 2 : 0.5;
        dispatchEvent('multiplierChange', { multiplier });
        console.log(`Dispatching multiplierChange event, multiplier: ${multiplier}`);
    } else if (event.key === '0' && !event.shiftKey && !event.ctrlKey) {
        dispatchEvent('multiplierChange', { multiplier: 1 });
        console.log(`Resetting multiplier to initial value: 1`);
    }
}



    





function adjustVolumeAndToggleMute(event, currentTime, fadeDuration) {
    // Volume adjustment
    if ((event.key === ',' || event.key === '.') && !event.shiftKey && !event.ctrlKey) {
        const direction = event.key === ',' ? -0.1 : 0.1;
        const newGainValue = Math.min(2, Math.max(0, gainNode.gain.value + direction));
        previousVolume = newGainValue;
        applyVolumeFade(newGainValue, currentTime, fadeDuration);
    }
    // Toggle mute/unmute
    else if (event.key === 'm' && !event.shiftKey && !event.ctrlKey) {
        isMuted = !isMuted;
        const targetVolume = isMuted ? 0 : previousVolume;
        applyVolumeFade(targetVolume, currentTime, fadeDuration);
        console.log(isMuted ? "Muted" : "Unmuted");
    }
}

function applyVolumeFade(targetGainValue, currentTime, fadeDuration) {
    gainNode.gain.setValueAtTime(gainNode.gain.value, currentTime);
    gainNode.gain.linearRampToValueAtTime(targetGainValue, currentTime + fadeDuration);
    console.log(`Volume adjusted, target gain: ${targetGainValue}`);
}

</script>

<style>
 /* Shake in All Directions */
    
 @keyframes shake-all-directions {
        0%, 100% { transform: translate(0); }
        10% { transform: translate(-5px, -5px); }
        20% { transform: translate(5px, -5px); }
        30% { transform: translate(-5px, 5px); }
        40% { transform: translate(5px, 5px); }
        50% { transform: translate(-5px, -5px); }
        60% { transform: translate(5px, 5px); }
        70% { transform: translate(-5px, 5px); }
        80% { transform: translate(5px, -5px); }
        90% { transform: translate(-5px, -5px); }
    }

    .shake-all-directions-animation {
        animation: shake-all-directions 0.15s cubic-bezier(.36,.07,.19,.97) both infinite;
    }
</style>

<script>
// ANIMATION SCRIPT AND STYLES AT BOTTOM OF FILE FOR EASY UPDATING

// Function to start animation
function startAnimation(elementId) {
    const element = document.getElementById(elementId);
    if (!element) return;

    element.classList.add('shake-all-directions-animation');



    // Clear any existing timeout to prevent stopping the animation prematurely
    if (animationTimeoutId) {
        clearTimeout(animationTimeoutId);
        animationTimeoutId = null;
    }

    // Set a timeout to remove the animation class if there are no further calls
    animationTimeoutId = setTimeout(() => {
        //
        element.classList.remove('shake-all-directions-animation');
     

        animationTimeoutId = null;
    }, 150); // Adjust timeout duration as needed based on testing
}

// Function to stop animation
function stopAnimation(elementId) {
    const element = document.getElementById(elementId);
    if (!element) return;
  
    element.classList.remove('shake-all-directions-animation');
   
}
</script>
</body>
</html>

