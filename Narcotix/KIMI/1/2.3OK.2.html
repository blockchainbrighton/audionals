<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NarcotiX V3 - Enhanced Tactical Stealth</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0a; color: #fff; font-family: 'Courier New', monospace;
            overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh;
            cursor: crosshair;
        }
        #gameContainer {
            position: relative; width: 95vw; max-width: 1600px; height: 90vh; max-height: 900px;
            border: 2px solid #ff00ff; box-shadow: 0 0 40px rgba(255, 0, 255, 0.5); background: #1a001a;
        }
        #gameCanvas { 
            width: 100%; height: 100%; image-rendering: pixelated; 
            cursor: none; /* Hide default cursor for custom crosshair */
        }
        #uiOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .panel {
            position: absolute; background: rgba(0, 0, 0, 0.95); border: 2px solid #00ffff;
            padding: 12px; font-size: 11px; pointer-events: auto; max-height: 350px; overflow-y: auto;
            backdrop-filter: blur(5px); border-radius: 4px;
        }
        #statsPanel { top: 10px; left: 10px; min-width: 240px; }
        #inventoryPanel { top: 10px; right: 10px; width: 320px; display: none; }
        #questPanel { bottom: 10px; left: 10px; width: 340px; max-height: 200px; }
        #shopPanel { bottom: 10px; right: 10px; width: 340px; display: none; }
        #legendPanel {
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 520px; height: 600px; display: none; font-size: 12px; overflow-y: auto;
        }
        #tipsPanel {
            position: absolute; top: 10px; right: 340px; width: 280px; min-height: 100px;
            background: rgba(0, 0, 0, 0.9); border: 2px solid #ff00ff; padding: 10px;
            font-size: 10px; pointer-events: none; border-radius: 4px;
        }
        .legend-item {
            display: flex; align-items: center; margin: 6px 0; padding: 3px;
            background: rgba(255, 255, 255, 0.05); border-radius: 3px;
        }
        .legend-color {
            width: 20px; height: 20px; margin-right: 12px; border: 1px solid #fff; border-radius: 3px;
        }
        .pill {
            display: inline-block; margin: 3px; padding: 6px; border: 1px solid; border-radius: 50%;
            cursor: pointer; transition: all 0.2s; font-size: 9px; width: 48px; height: 48px;
            text-align: center; line-height: 36px; user-select: none;
        }
        .pill:hover { transform: scale(1.15); box-shadow: 0 0 15px currentColor; }
        .rarity-common { border-color: #888; color: #888; }
        .rarity-uncommon { border-color: #0f0; color: #0f0; }
        .rarity-rare { border-color: #00f; color: #00f; }
        .rarity-epic { border-color: #f0f; color: #f0f; }
        .rarity-legendary { border-color: #ff0; color: #ff0; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        .effect-badge {
            font-size: 9px; background: rgba(255, 0, 255, 0.3); padding: 2px 5px;
            border-radius: 3px; margin: 2px; display: inline-block; border: 1px solid rgba(255, 0, 255, 0.5);
        }
        button {
            background: linear-gradient(to bottom, #ff00ff, #cc00cc); color: #000; border: none; padding: 8px 14px;
            cursor: pointer; font-family: inherit; font-weight: bold; margin: 2px; border-radius: 3px;
            transition: all 0.2s;
        }
        button:hover { background: linear-gradient(to bottom, #00ffff, #009999); box-shadow: 0 0 12px #00ffff; transform: translateY(-1px); }
        #controls {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            text-align: center; font-size: 11px; background: rgba(0, 0, 0, 0.8);
            padding: 6px 12px; border: 1px solid #ff00ff; white-space: nowrap; border-radius: 4px;
        }
        #loadingScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1a001a 0%, #0a0a0a 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100;
        }
        .loading-bar {
            width: 320px; height: 24px; border: 2px solid #ff00ff; margin-top: 20px; border-radius: 12px; overflow: hidden;
        }
        .loading-fill {
            height: 100%; background: linear-gradient(90deg, #ff00ff, #00ffff);
            width: 0%; transition: width 0.3s; box-shadow: 0 0 10px #ff00ff;
        }
        .crosshair {
            position: absolute; width: 20px; height: 20px; pointer-events: none; z-index: 20;
        }
        .building-label {
            position: absolute; background: rgba(0, 0, 0, 0.8); color: #fff; padding: 2px 6px;
            font-size: 9px; border: 1px solid #00ffff; border-radius: 3px; pointer-events: none;
        }
        .damage-number {
            position: absolute; color: #ff0; font-size: 14px; font-weight: bold; pointer-events: none;
            animation: damageFloat 1s ease-out forwards;
        }
        @keyframes damageFloat {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-30px); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiOverlay">
            <div id="loadingScreen">
                <h1 style="color: #ff00ff; text-shadow: 0 0 20px #ff00ff;">NARCOTIX V3</h1>
                <p style="color: #00ffff;">Initializing enhanced tactical world...</p>
                <div class="loading-bar">
                    <div class="loading-fill" id="loadingFill"></div>
                </div>
            </div>
            
            <!-- Custom Crosshair -->
            <div id="crosshair" class="crosshair" style="display: none;">
                <svg viewBox="0 0 20 20" width="20" height="20">
                    <circle cx="10" cy="10" r="9" fill="none" stroke="#ff00ff" stroke-width="1"/>
                    <line x1="10" y1="0" x2="10" y2="6" stroke="#ff00ff" stroke-width="1"/>
                    <line x1="10" y1="14" x2="10" y2="20" stroke="#ff00ff" stroke-width="1"/>
                    <line x1="0" y1="10" x2="6" y2="10" stroke="#ff00ff" stroke-width="1"/>
                    <line x1="14" y1="10" x2="20" y2="10" stroke="#ff00ff" stroke-width="1"/>
                </svg>
            </div>

            <!-- Tips Panel -->
            <div id="tipsPanel">
                <h4 style="color: #ff00ff; margin-bottom: 8px; text-shadow: 0 0 10px #ff00ff;">üìö TACTICAL TIPS</h4>
                <div id="tipContent" style="line-height: 1.4;">Welcome to NarcotiX V3! Use WASD to move strategically...</div>
                <div style="margin-top: 8px; font-size: 9px; color: #888;">
                    Tip <span id="tipCounter">1</span>/<span id="totalTips">30</span>
                </div>
            </div>

            <div id="statsPanel" class="panel">
                <h3 style="color: #ff00ff; text-shadow: 0 0 10px #ff00ff;">üî• PLAYER STATS</h3>
                <div>Score: <span id="score">0</span></div>
                <div>Cash: $<span id="cash">500</span></div>
                <div>Territory: <span id="territory">0</span> tiles</div>
                <div>Income: $<span id="income">0</span>/min</div>
                <div>Health: <span id="health">100</span>/<span id="maxHealth">100</span></div>
                <div>Armor: <span id="armor">0</span>/<span id="maxArmor">100</span></div>
                <div>Speed: <span id="speed">1.0</span>x</div>
                <div>Stealth: <span id="stealth">0</span>%</div>
                <div>Luck: <span id="luck">0</span>%</div>
                <div>Weapon: <span id="currentWeapon">Fists (‚àû)</span></div>
                <div>Active Effects:</div>
                <div id="activeEffects" style="min-height: 20px;"></div>
            </div>
            
            <div id="inventoryPanel" class="panel">
                <h3 style="color: #00ffff; text-shadow: 0 0 10px #00ffff;">üíä INVENTORY (<span id="invCount">0</span>/25)</h3>
                <div id="inventoryGrid" style="display: flex; flex-wrap: wrap; gap: 5px;"></div>
                <div style="margin-top: 12px;">
                    <button id="closeInvBtn">Close [I]</button>
                    <button id="usePillBtn">Use Selected</button>
                    <button id="equipWeaponBtn">Equip Weapon</button>
                </div>
            </div>
            
            <div id="questPanel" class="panel">
                <h3 style="color: #ff0; text-shadow: 0 0 10px #ff0;">üìú QUESTS & STORY</h3>
                <div id="questList"></div>
            </div>
            
            <div id="shopPanel" class="panel">
                <h3 style="color: #00ffff; text-shadow: 0 0 10px #00ffff;">üè™ STASH HOUSE</h3>
                <div id="shopInventory"></div>
                <button id="closeShopBtn">Close</button>
            </div>
            
            <div id="legendPanel" class="panel">
                <h3 style="color: #ff00ff; text-shadow: 0 0 10px #ff00ff;">üé® COLOR KEY & LEGEND</h3>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff0; border-radius: 50%; border: 2px solid #fff;"></div>
                    <span><strong>Yellow Circle:</strong> YOU (the player) - Size: Small tactical unit</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #8B4513; border-radius: 50%;"></div>
                    <span><strong>Brown Circle:</strong> Thug (security, patrols only)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff4500; border-radius: 50%;"></div>
                    <span><strong>Orange Circle:</strong> Rogue (short detect, very fast)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #0000ff; border-radius: 50%;"></div>
                    <span><strong>Blue Circle:</strong> Police (medium detect, patrols routes)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff0000; border-radius: 50%;"></div>
                    <span><strong>Red Circle:</strong> BOSS (rare, long patrol, very dangerous)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00ffff;"></div>
                    <span><strong>Cyan Square:</strong> Stash House (shop - buy/sell items)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #654321; border-radius: 50%;"></div>
                    <span><strong>Brown Square:</strong> Enterable Building (shelter, blocks enemies)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #666;"></div>
                    <span><strong>Dark Gray Square:</strong> Normal Building (blocks movement)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #333;"></div>
                    <span><strong>Dark Gray Tile:</strong> Street (fast movement +2%)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #0a4a0a;"></div>
                    <span><strong>Green Tile:</strong> Grass (normal speed -2%)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff00ff;"></div>
                    <span><strong>Magenta Square:</strong> Drug Lab (rare pills, high risk)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #0066cc;"></div>
                    <span><strong>Blue Water:</strong> Water (slow movement -10%)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(0, 255, 0, 0.2);"></div>
                    <span><strong>Green Overlay:</strong> Your claimed territory</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #0f0; border-radius: 50%;"></div>
                    <span><strong>Green Dot:</strong> Dropped pill pickup</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff0; width: 4px; height: 4px; border-radius: 50%;"></div>
                    <span><strong>Yellow Dot:</strong> Bullet/Projectile</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: radial-gradient(circle, #ff0, #f00, transparent); border-radius: 50%;"></div>
                    <span><strong>Explosion:</strong> Weapon impact area</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(255, 255, 255, 0.1);"></div>
                    <span><strong>White Overlay:</strong> Inside building (shelter)</span>
                </div>
                <button id="closeLegendBtn" style="margin-top: 12px; width: 100%;">Close [K]</button>
            </div>
            
            <div id="controls" style="color: #00ffff;">
                [WASD/Arrows] Move | MOUSE Aim | [LMB] Fire | [R] Reload | [SPACE] Use Pill | [I] Inventory | [E] Interact | [Q] Quests | [K] Legend | [1-3] Switch Weapon
            </div>
        </div>
    </div>

    <script>
        (function() {
            "use strict";
            
            // ============================================================================
            // TACTICAL CONFIGURATION - SLOWED DOWN
            // ============================================================================
            const GAME_CONFIG = Object.freeze({
                TILE_SIZE: 40,
                MAP_WIDTH: 60,
                MAP_HEIGHT: 60,
                TERRAIN_TYPES: Object.freeze({
                    0: Object.freeze({ name: 'street', color: '#333', speed: 1.02, passable: true }),
                    1: Object.freeze({ name: 'grass', color: '#0a4a0a', speed: 0.98, passable: true }),
                    2: Object.freeze({ name: 'building', color: '#666', speed: 0, passable: false }),
                    3: Object.freeze({ name: 'water', color: '#0066cc', speed: 0.9, passable: true }),
                    4: Object.freeze({ name: 'drug-lab', color: '#ff00ff', speed: 1.0, passable: true, special: 'lab' }),
                    5: Object.freeze({ name: 'stash-house', color: '#00ffff', speed: 1.0, passable: true, special: 'shop' }),
                    6: Object.freeze({ name: 'enterable-building', color: '#654321', speed: 1.0, passable: true, special: 'building' })
                }),
                ENEMY_TYPES: Object.freeze({
                    thug: Object.freeze({ hp: 50, damage: 8, speed: 0.04, color: '#8B4513', detectionRange: 0, patrol: true, label: 'Thug' }),
                    rogue: Object.freeze({ hp: 35, damage: 12, speed: 0.06, color: '#ff4500', detectionRange: 20, patrol: false, label: 'Rogue' }),
                    police: Object.freeze({ hp: 90, damage: 18, speed: 0.05, color: '#0000ff', detectionRange: 25, patrol: true, label: 'Police' }),
                    boss: Object.freeze({ hp: 250, damage: 30, speed: 0.03, color: '#ff0000', detectionRange: 35, patrol: false, label: 'BOSS' })
                }),
                PLAYER_BASE_SPEED: 0.06, // Much slower for tactical gameplay
                SPEED_EFFECT_MULTIPLIER: 1.15, // Reduced from 1.2
                PLAYER_VISION_RANGE: 100, // Reduced from 120
                TERRITORY_CLAIM_DELAY: 3000, // 3 seconds between claims
                ENEMY_SPAWN_RATE: 0.00008, // Even rarer spawns
                MIN_SPAWN_DISTANCE: 30,
                DETECTION_TIME_REQUIRED: 4.0, // 4 seconds to detect player
                BUILDING_SHELTER_TIME: 8000, // 8 seconds of shelter
                WEAPON_TYPES: Object.freeze({
                    fists: Object.freeze({ damage: 10, range: 1.5, cooldown: 800, ammo: -1, color: '#fff', name: 'FISTS' }),
                    pistol: Object.freeze({ damage: 25, range: 8, cooldown: 1200, ammo: 12, color: '#ff0', name: 'PISTOL' }),
                    shotgun: Object.freeze({ damage: 60, range: 5, cooldown: 2000, ammo: 6, color: '#f00', name: 'SHOTGUN' }),
                    rifle: Object.freeze({ damage: 40, range: 15, cooldown: 300, ammo: 30, color: '#0f0', name: 'RIFLE' })
                })
            });

            // ============================================================================
            // EXPANDED TIPS SYSTEM
            // ============================================================================
            const TIPS = [
                "Welcome to NarcotiX V3! Use WASD to move and MOUSE to aim.",
                "Buildings with brown squares are enterable - use [E] to enter for shelter!",
                "Enemies cannot follow you into buildings. Use this tactical advantage wisely.",
                "Different enemy types have unique behaviors: Thugs patrol, Rogues hunt, Police investigate.",
                "BOSS enemies are rare but extremely dangerous - avoid direct confrontation unless well-equipped.",
                "Click [LMB] to fire your current weapon. Each weapon has different stats.",
                "Press [R] to reload your weapon. Reloading takes 2 seconds and leaves you vulnerable.",
                "Switch weapons with [1], [2], [3] for Fists/Pistol/Shotgun/Rifle.",
                "Pills provide various effects: SPEED, STRENGTH, STEALTH, VISION, LUCK, ARMOR, HEALTH.",
                "STEALTH makes you harder to detect. LUCK increases loot quality and cash gains.",
                "Claim territory by moving through areas - more territory means more passive income.",
                "Visit stash houses (cyan squares) to buy/sell pills and upgrade equipment.",
                "Drug labs (magenta tiles) contain rare pills but are heavily guarded.",
                "Terrain affects speed: Streets (+2%), Grass (-2%), Water (-10%).",
                "Your vision range is limited - be cautious when exploring unknown areas.",
                "Enemies need 4 seconds to detect you. Stay out of their range!",
                "Dropped pills appear as green dots - collect them to expand your inventory.",
                "Complete quests to unlock story elements and earn substantial rewards.",
                "Pill prices fluctuate based on rarity and demand in the underground market.",
                "Legendary pills provide the most powerful effects but are extremely rare.",
                "Side effects can be beneficial or harmful - experiment to find optimal combos.",
                "Armor reduces incoming damage by up to 50% but degrades over time.",
                "Environmental hazards like water slow movement but may provide tactical cover.",
                "Time your pill consumption carefully - effects have durations and cooldowns.",
                "The most successful players balance aggression with stealth and resource management.",
                "Use mouse wheel or [1-3] to quickly switch weapons in combat.",
                "Buildings provide 8 seconds of guaranteed safety - plan your escape routes!",
                "Explosions deal damage in an area - use them to hit multiple enemies.",
                "Your crosshair turns red when aiming at an enemy within range.",
                "The underground rewards patience and strategic thinking over reckless action."
            ];

            // ============================================================================
            // NFT COLLECTION GENERATOR (Unchanged)
            // ============================================================================
            class NFTCollection {
                constructor() {
                    this.pills = [];
                    this.rarityDistribution = { common: 0.60, uncommon: 0.25, rare: 0.10, epic: 0.04, legendary: 0.01 };
                    this.effectTypes = ['SPEED', 'STRENGTH', 'STEALTH', 'VISION', 'LUCK', 'CHAOS', 'ARMOR', 'HEALTH'];
                    this.sideEffects = ['NONE', 'MILD_HALLUCINATION', 'REVERSED_CONTROLS', 'DOUBLE_VISION', 'PARANOIA', 'EUPHORIA', 'ADDICTION'];
                    this.colors = ['#ff00ff', '#00ffff', '#ff0', '#f0f', '#0f0', '#f00', '#00f', '#fa0', '#f0a', '#a0f'];
                    this.generateCollection();
                }

                generateCollection() {
                    const prefixes = ['Cyber', 'Neuro', 'Quantum', 'Psycho', 'Digital', 'Synth', 'Bio', 'Nano', 'Plasma', 'Crystal', 'Dark', 'Light', 'Void', 'Chaos', 'Order'];
                    const bases = ['Pill', 'Tab', 'Cap', 'Dose', 'X', 'Max', 'Core', 'Drive', 'Wave', 'Rush', 'Boost', 'Surge'];
                    const suffixes = ['+', 'Pro', 'Ultra', 'Xtreme', 'Prime', 'Omega', 'Alpha', 'Neo', 'Max', 'Core', 'Elite', 'Supreme'];

                    let id = 0;
                    for (let rarity in this.rarityDistribution) {
                        const count = Math.floor(3333 * this.rarityDistribution[rarity]);
                        for (let i = 0; i < count && id < 3333; i++) {
                            const rarityMultiplier = rarity === 'legendary' ? 4 : rarity === 'epic' ? 2.5 : rarity === 'rare' ? 1.8 : 1;
                            const pill = {
                                id: id++,
                                name: `${prefixes[id % prefixes.length]}${bases[id % bases.length]}${suffixes[id % suffixes.length]}`,
                                rarity: rarity,
                                effect: this.effectTypes[Math.floor(Math.random() * this.effectTypes.length)],
                                potency: Math.floor(Math.random() * 15 * rarityMultiplier) + 1,
                                duration: Math.floor(Math.random() * 45 * rarityMultiplier) + 15,
                                sideEffect: this.sideEffects[Math.floor(Math.random() * this.sideEffects.length)],
                                color: this.colors[Math.floor(Math.random() * this.colors.length)],
                                marketValue: Math.floor(Math.random() * 800 * rarityMultiplier) + 100,
                                visualTrait: {
                                    shape: ['circle', 'square', 'hexagon', 'diamond'][Math.floor(Math.random() * 4)],
                                    pattern: ['solid', 'striped', 'dotted', 'glow'][Math.floor(Math.random() * 4)],
                                    glowIntensity: rarity === 'legendary' ? 4 : rarity === 'epic' ? 3 : rarity === 'rare' ? 2 : 1
                                }
                            };
                            this.pills.push(pill);
                        }
                    }
                    this.pills.sort(() => Math.random() - 0.5);
                    console.log(`Generated ${this.pills.length} pills`);
                }

                getPillById(id) { return this.pills[id]; }
                getRandomPill() { return this.pills[Math.floor(Math.random() * this.pills.length)]; }
                getPillsByRarity(rarity) { return this.pills.filter(p => p.rarity === rarity); }
            }

            // ============================================================================
            // MAP MODULE WITH BUILDINGS (Unchanged)
            // ============================================================================
            class Map {
                constructor(width, height) {
                    this.width = Number(width) || GAME_CONFIG.MAP_WIDTH;
                    this.height = Number(height) || GAME_CONFIG.MAP_HEIGHT;
                    this.tiles = [];
                    this.stashHouses = [];
                    this.enterableBuildings = [];
                    this.generate();
                }

                generate() {
                    this.tiles = Array(this.height).fill(null).map(() => Array(this.width).fill(1));
                    
                    for (let y = 0; y < this.height; y++) {
                        for (let x = 0; x < this.width; x++) {
                            let tile;
                            if (x % 8 === 0 || y % 8 === 0) {
                                tile = 0;
                            } else if (Math.random() < 0.12) {
                                tile = 2;
                            } else if (Math.random() < 0.08) {
                                tile = 3;
                            } else if (Math.random() < 0.05) {
                                tile = 6;
                            } else {
                                tile = 1;
                            }
                            this.tiles[y][x] = tile;
                        }
                    }
                    this.placeSpecialTiles();
                }

                placeSpecialTiles() {
                    for (let i = 0; i < 6; i++) {
                        const x = Math.floor(Math.random() * this.width);
                        const y = Math.floor(Math.random() * this.height);
                        if (this.tiles[y]?.[x] === 1) {
                            this.tiles[y][x] = 4;
                        }
                    }

                    for (let i = 0; i < 4; i++) {
                        const x = Math.floor(Math.random() * this.width);
                        const y = Math.floor(Math.random() * this.height);
                        if (this.tiles[y]?.[x] !== 2) {
                            this.tiles[y][x] = 5;
                            this.stashHouses.push({ x, y, id: i, inventory: [] });
                        }
                    }

                    for (let i = 0; i < 8; i++) {
                        const x = Math.floor(Math.random() * this.width);
                        const y = Math.floor(Math.random() * this.height);
                        if (this.tiles[y]?.[x] !== 2 && this.tiles[y]?.[x] !== 5) {
                            this.tiles[y][x] = 6;
                            this.enterableBuildings.push({ x, y, id: i, occupied: false, name: `Building ${i + 1}` });
                        }
                    }
                }

                getTile(x, y) {
                    const terrain = GAME_CONFIG.TERRAIN_TYPES;
                    if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
                        return terrain[2];
                    }
                    const tileIndex = this.tiles[y]?.[x] ?? 1;
                    return terrain[tileIndex] || terrain[1];
                }

                isPassable(x, y) {
                    const tile = this.getTile(x, y);
                    return tile?.passable ?? false;
                }

                getSpeedModifier(x, y) {
                    const tile = this.getTile(x, y);
                    return tile?.speed ?? 1.0;
                }

                isBuilding(x, y) {
                    return this.tiles[y]?.[x] === 6;
                }

                getBuildingAt(x, y) {
                    return this.enterableBuildings.find(b => Math.abs(b.x - x) < 1 && Math.abs(b.y - y) < 1);
                }
            }

            // ============================================================================
            // ENHANCED PLAYER MODULE - SMALLER, TACTICAL
            // ============================================================================
            class Player {
                constructor(x, y, nftCollection) {
                    this.x = Number(x) || 30;
                    this.y = Number(y) || 30;
                    this.size = 8; // REDUCED from 12
                    this.health = 100;
                    this.maxHealth = 100;
                    this.armor = 0;
                    this.maxArmor = 100;
                    this.cash = 500;
                    this.score = 0;
                    this.baseSpeed = GAME_CONFIG.PLAYER_BASE_SPEED;
                    this.speed = this.baseSpeed;
                    this.stealth = 0;
                    this.luck = 0;
                    this.inventory = [];
                    this.maxInventory = 25;
                    this.territory = new Set();
                    this.income = 0;
                    this.statusEffects = [];
                    this.selectedPill = null;
                    this.selectedWeapon = null;
                    this.currentWeapon = 'fists';
                    this.weapons = { fists: { ammo: -1, maxAmmo: -1, name: 'FISTS' } };
                    this.ownedNFTs = this.generateStarterNFTs(nftCollection);
                    this.lastTerritoryClaim = 0;
                    this.nftCollection = nftCollection;
                    this.inBuilding = false;
                    this.buildingTimer = 0;
                    this.shelterTime = 0;
                    this.buildingUses = 0;
                    this.enemiesDefeated = 0;
                    this.reloadTimer = 0;
                }

                generateStarterNFTs(nftCollection) {
                    const owned = [];
                    owned.push(...nftCollection.getPillsByRarity('legendary').slice(0, 2));
                    owned.push(...nftCollection.getPillsByRarity('epic').slice(0, 3));
                    owned.push(...nftCollection.getPillsByRarity('rare').slice(0, 5));
                    while (owned.length < 15) {
                        const pill = nftCollection.getRandomPill();
                        if (!owned.find(p => p.id === pill.id)) {
                            owned.push(pill);
                        }
                    }
                    return owned;
                }

                move(dx, dy, map) {
                    if (this.reloadTimer > 0) return; // Can't move while reloading
                    
                    const speedMod = map.getSpeedModifier(this.x + dx, this.y + dy);
                    const effectMultiplier = this.hasEffect('SPEED') ? GAME_CONFIG.SPEED_EFFECT_MULTIPLIER : 1;
                    const finalSpeed = this.speed * speedMod * effectMultiplier;
                    
                    if (map.isPassable(this.x + dx, this.y + dy)) {
                        this.x += dx * finalSpeed;
                        this.y += dy * finalSpeed;
                        this.claimTerritory();
                        this.updateBuildingStatus(map);
                    }
                }

                updateBuildingStatus(map) {
                    if (map.isBuilding(this.x, this.y)) {
                        if (!this.inBuilding) {
                            this.inBuilding = true;
                            this.shelterTime = GAME_CONFIG.BUILDING_SHELTER_TIME;
                        }
                    } else {
                        this.inBuilding = false;
                        this.shelterTime = 0;
                    }
                }

                claimTerritory() {
                    const now = Date.now();
                    if (now - this.lastTerritoryClaim < GAME_CONFIG.TERRITORY_CLAIM_DELAY) return;
                    this.lastTerritoryClaim = now;

                    const tileKey = `${Math.floor(this.x)},${Math.floor(this.y)}`;
                    if (!this.territory.has(tileKey)) {
                        this.territory.add(tileKey);
                        this.updateIncome();
                    }
                }

                updateIncome() {
                    this.income = Math.floor(this.territory.size * 0.4);
                }

                addToInventory(pill) {
                    if (this.inventory.length >= this.maxInventory) return false;
                    this.inventory.push(pill);
                    this.score += pill.marketValue;
                    return true;
                }

                consumePill(pill) {
                    if (!pill) return;
                    
                    const multiplier = pill.rarity === 'legendary' ? 4 : pill.rarity === 'epic' ? 2.5 : 
                                     pill.rarity === 'rare' ? 1.8 : 1;
                    
                    this.statusEffects.push({
                        type: pill.effect,
                        duration: pill.duration * multiplier,
                        maxDuration: pill.duration * multiplier,
                        potency: pill.potency * multiplier,
                        pill: pill
                    });

                    if (pill.sideEffect !== 'NONE') {
                        this.statusEffects.push({
                            type: pill.sideEffect,
                            duration: Math.floor(pill.duration * 0.6),
                            maxDuration: Math.floor(pill.duration * 0.6),
                            potency: 1,
                            pill: pill
                        });
                    }

                    const idx = this.inventory.indexOf(pill);
                    if (idx > -1) this.inventory.splice(idx, 1);
                }

                updateStatusEffects() {
                    this.speed = this.baseSpeed;
                    this.stealth = 0;
                    this.luck = 0;
                    this.maxHealth = 100;
                    this.armor = Math.max(0, this.armor - 0.05);

                    this.statusEffects = this.statusEffects.filter(effect => {
                        effect.duration -= 0.016;
                        if (effect.duration <= 0) return false;

                        switch(effect.type) {
                            case 'SPEED': this.speed += effect.potency * 0.08; break;
                            case 'STRENGTH': this.maxHealth = 100 + effect.potency * 15; break;
                            case 'STEALTH': this.stealth = Math.min(100, effect.potency * 20); break;
                            case 'LUCK': this.luck = effect.potency * 15; break;
                            case 'ARMOR': this.armor = Math.min(this.maxArmor, effect.potency * 10); break;
                            case 'HEALTH': this.health = Math.min(this.maxHealth, this.health + effect.potency * 0.3); break;
                        }
                        return true;
                    });

                    if (this.reloadTimer > 0) {
                        this.reloadTimer -= 16;
                    }

                    if (this.inBuilding && this.shelterTime > 0) {
                        this.shelterTime -= 16;
                    }
                }

                hasEffect(type) {
                    return this.statusEffects.some(e => e.type === type);
                }

                takeDamage(amount) {
                    const armorReduction = Math.min(this.armor, amount * 0.5);
                    this.armor -= armorReduction;
                    const remainingDamage = amount - armorReduction;
                    const stealthReduction = remainingDamage * (this.stealth / 200);
                    const actualDamage = Math.floor(remainingDamage - stealthReduction);
                    
                    this.health -= actualDamage;
                    if (this.health <= 0) this.respawn();
                    return actualDamage;
                }

                respawn() {
                    this.health = this.maxHealth;
                    this.armor = 0;
                    this.x = Math.floor(Math.random() * GAME_CONFIG.MAP_WIDTH);
                    this.y = Math.floor(Math.random() * GAME_CONFIG.MAP_HEIGHT);
                    this.cash = Math.max(0, this.cash - 200);
                    this.territory.clear();
                    this.statusEffects = [];
                    this.inBuilding = false;
                    this.inventory = this.inventory.slice(0, 5);
                }

                sellPill(pill) {
                    const value = Math.floor(pill.marketValue * (1 + this.luck / 100));
                    this.cash += value;
                    const idx = this.inventory.indexOf(pill);
                    if (idx > -1) this.inventory.splice(idx, 1);
                    return value;
                }

                addWeapon(weaponType) {
                    if (!this.weapons[weaponType]) {
                        const weaponData = GAME_CONFIG.WEAPON_TYPES[weaponType];
                        this.weapons[weaponType] = {
                            ammo: weaponData.ammo,
                            maxAmmo: weaponData.ammo,
                            name: weaponData.name
                        };
                    }
                }

                fireWeapon(targetX, targetY) {
                    const weaponData = GAME_CONFIG.WEAPON_TYPES[this.currentWeapon];
                    const weapon = this.weapons[this.currentWeapon];
                    
                    if (weapon.ammo === 0) return null;
                    if (weapon.ammo > 0) weapon.ammo = Math.max(0, weapon.ammo - 1);
                    
                    return {
                        x: this.x,
                        y: this.y,
                        targetX: targetX,
                        targetY: targetY,
                        damage: weaponData.damage,
                        range: weaponData.range,
                        speed: 0.6,
                        color: weaponData.color,
                        type: this.currentWeapon
                    };
                }

                reloadWeapon() {
                    const weapon = this.weapons[this.currentWeapon];
                    if (weapon.ammo !== -1 && weapon.ammo < weapon.maxAmmo && this.reloadTimer <= 0) {
                        this.reloadTimer = 2000; // 2 second reload
                        weapon.ammo = weapon.maxAmmo;
                        return true;
                    }
                    return false;
                }

                switchWeapon(weaponType) {
                    if (this.weapons[weaponType]) {
                        this.currentWeapon = weaponType;
                        return true;
                    }
                    return false;
                }
            }

            // ============================================================================
            // ENHANCED BULLET SYSTEM WITH DAMAGE NUMBERS
            // ============================================================================
            class Bullet {
                constructor(x, y, targetX, targetY, damage, range, color, type) {
                    this.x = x;
                    this.y = y;
                    this.startX = x;
                    this.startY = y;
                    this.targetX = targetX;
                    this.targetY = targetY;
                    this.damage = damage;
                    this.maxRange = range;
                    this.color = color;
                    this.type = type;
                    
                    const dx = targetX - x;
                    const dy = targetY - y;
                    const len = Math.hypot(dx, dy) || 1;
                    this.vx = (dx / len) * 0.6;
                    this.vy = (dy / len) * 0.6;
                    this.traveled = 0;
                    this.trail = [{x, y}, {x, y}]; // For trail effect
                }

                update() {
                    this.trail.push({x: this.x, y: this.y});
                    if (this.trail.length > 5) this.trail.shift();
                    
                    this.x += this.vx;
                    this.y += this.vy;
                    this.traveled = Math.hypot(this.x - this.startX, this.y - this.startY);
                    
                    return this.traveled < this.maxRange;
                }

                checkCollision(enemies) {
                    for (let enemy of enemies) {
                        const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                        if (dist < enemy.size + 1.5) {
                            return enemy;
                        }
                    }
                    return null;
                }
            }

            // ============================================================================
            // DAMAGE NUMBER DISPLAY
            // ============================================================================
            class DamageNumber {
                constructor(x, y, damage, color = '#ff0') {
                    this.x = x;
                    this.y = y;
                    this.damage = damage;
                    this.color = color;
                    this.life = 1.0;
                    this.vy = -0.8;
                }

                update() {
                    this.y += this.vy;
                    this.life -= 0.02;
                    return this.life > 0;
                }
            }

            // ============================================================================
            // ENHANCED ENEMY MODULE - SMALLER, TACTICAL
            // ============================================================================
            class Enemy {
                constructor(x, y, type, nftCollection) {
                    this.x = Number(x) || 0;
                    this.y = Number(y) || 0;
                    this.type = type;
                    this.stats = { ...GAME_CONFIG.ENEMY_TYPES[type] };
                    this.color = this.stats?.color || '#f00';
                    this.state = 'patrol';
                    this.nftCollection = nftCollection;
                    this.lastPillDrop = 0;
                    this.detectionTimer = 0;
                    this.patrolPath = this.generatePatrolPath();
                    this.currentWaypoint = 0;
                    this.lastAttackTime = 0;
                }

                generatePatrolPath() {
                    const path = [];
                    const numPoints = Math.floor(Math.random() * 4) + 3;
                    for (let i = 0; i < numPoints; i++) {
                        path.push({
                            x: this.x + (Math.random() - 0.5) * 20,
                            y: this.y + (Math.random() - 0.5) * 20
                        });
                    }
                    return path;
                }

                update(player, map) {
                    const dist = Math.hypot(player.x - this.x, player.y - this.y);
                    const playerInBuilding = player.inBuilding;
                    
                    let shouldChase = false;
                    if (this.stats.detectionRange > 0 && dist < this.stats.detectionRange && !player.hasEffect('STEALTH') && !playerInBuilding) {
                        this.detectionTimer += 0.016;
                        if (this.detectionTimer >= GAME_CONFIG.DETECTION_TIME_REQUIRED) {
                            shouldChase = true;
                        }
                    } else {
                        this.detectionTimer = Math.max(0, this.detectionTimer - 0.032);
                    }

                    if (shouldChase && !playerInBuilding) {
                        this.state = 'chase';
                    } else if (this.stats.patrol) {
                        this.state = 'patrol';
                    } else {
                        this.state = 'idle';
                    }

                    switch(this.state) {
                        case 'chase':
                            if (!playerInBuilding) {
                                const dx = player.x - this.x;
                                const dy = player.y - this.y;
                                const len = Math.hypot(dx, dy) || 1;
                                this.x += (dx / len) * this.stats.speed;
                                this.y += (dy / len) * this.stats.speed;
                            }
                            break;
                        
                        case 'patrol':
                            if (this.patrolPath.length > 0) {
                                const waypoint = this.patrolPath[this.currentWaypoint];
                                const dx = waypoint.x - this.x;
                                const dy = waypoint.y - this.y;
                                const len = Math.hypot(dx, dy) || 1;
                                
                                if (len < 1.5) {
                                    this.currentWaypoint = (this.currentWaypoint + 1) % this.patrolPath.length;
                                } else {
                                    this.x += (dx / len) * this.stats.speed * 0.7;
                                    this.y += (dy / len) * this.stats.speed * 0.7;
                                }
                            }
                            break;
                        
                        case 'idle':
                            if (Math.random() < 0.003) {
                                this.x += (Math.random() - 0.5) * 0.3;
                                this.y += (Math.random() - 0.5) * 0.3;
                            }
                            break;
                    }

                    if (dist < 2 && !playerInBuilding && Date.now() - this.lastAttackTime > 1500) {
                        player.takeDamage(this.stats.damage);
                        this.lastAttackTime = Date.now();
                    }
                }

                dropLoot() {
                    const now = Date.now();
                    if (now - this.lastPillDrop < 3000) return null;
                    this.lastPillDrop = now;

                    const dropChance = this.type === 'boss' ? 0.9 : this.type === 'police' ? 0.4 : 0.6;
                    return Math.random() < dropChance ? this.nftCollection.getRandomPill() : null;
                }

                get size() {
                    return this.stats?.boss ? 12 : 8; // REDUCED from 20/14
                }
            }

            // ============================================================================
            // ENHANCED SHOP MODULE (Unchanged)
            // ============================================================================
            class Shop {
                constructor(x, y, nftCollection) {
                    this.x = Number(x) || 0;
                    this.y = Number(y) || 0;
                    this.inventory = [];
                    this.weapons = [];
                    this.nftCollection = nftCollection;
                    this.restock();
                    this.lastRestock = Date.now();
                }

                restock() {
                    this.inventory = [];
                    this.weapons = [];
                    
                    for (let i = 0; i < 12; i++) {
                        const pill = this.nftCollection.getRandomPill();
                        const price = Math.floor(pill.marketValue * (0.7 + Math.random() * 0.6));
                        this.inventory.push({ pill, price });
                    }

                    const weaponTypes = ['pistol', 'shotgun', 'rifle'];
                    weaponTypes.forEach(weapon => {
                        const weaponData = GAME_CONFIG.WEAPON_TYPES[weapon];
                        const price = Math.floor(weaponData.damage * 50 + weaponData.range * 20);
                        this.weapons.push({ type: weapon, price, data: weaponData });
                    });
                }

                update() {
                    const now = Date.now();
                    if (now - this.lastRestock > 90000) {
                        this.restock();
                        this.lastRestock = now;
                    }
                }
            }

            // ============================================================================
            // ENHANCED QUEST SYSTEM (Unchanged)
            // ============================================================================
            class QuestSystem {
                constructor() {
                    this.activeQuests = [];
                    this.completedQuests = 0;
                    this.storyProgress = 0;
                    this.generateQuests();
                }

                generateQuests() {
                    this.activeQuests = [
                        {
                            id: 1, title: "Territory Expansion", desc: "Control 75 tiles of territory to establish your presence",
                            target: 75, current: 0, reward: 2000, type: 'territory', story: "The streets are watching. Make your mark."
                        },
                        {
                            id: 2, title: "Pill Collector", desc: "Collect 15 unique pills to expand your inventory",
                            target: 15, current: 0, reward: 1000, type: 'collect', story: "Knowledge is power. Each pill teaches you something new."
                        },
                        {
                            id: 3, title: "Survivalist", desc: "Reach a score of 10000 through strategic gameplay",
                            target: 10000, current: 0, reward: 3000, type: 'score', story: "In this world, only the smart survive."
                        },
                        {
                            id: 4, title: "Building Master", desc: "Use enterable buildings 10 times to escape enemies",
                            target: 10, current: 0, reward: 1500, type: 'shelter', story: "Every building could be your sanctuary... or your tomb."
                        },
                        {
                            id: 5, title: "Weapon Specialist", desc: "Defeat 20 enemies using different weapon types",
                            target: 20, current: 0, reward: 2500, type: 'combat', story: "Firepower speaks louder than words in the underground."
                        }
                    ];
                }

                updateQuests(player) {
                    this.activeQuests.forEach(quest => {
                        switch(quest.type) {
                            case 'territory': quest.current = player.territory.size; break;
                            case 'collect': quest.current = player.inventory.length; break;
                            case 'score': quest.current = player.score; break;
                            case 'shelter': quest.current = player.buildingUses || 0; break;
                            case 'combat': quest.current = player.enemiesDefeated || 0; break;
                        }

                        if (quest.current >= quest.target && !quest.completed) {
                            this.completeQuest(quest, player);
                        }
                    });
                }

                completeQuest(quest, player) {
                    player.cash += quest.reward;
                    player.score += quest.reward * 3;
                    quest.completed = true;
                    this.completedQuests++;
                    this.storyProgress++;
                    this.generateNewQuest();
                }

                generateNewQuest() {
                    const newQuests = [
                        {
                            id: Date.now(), title: "Drug Lord", desc: "Control 200 tiles of territory",
                            target: 200, current: 0, reward: 5000, type: 'territory', story: "You're becoming a legend in the underground."
                        },
                        {
                            id: Date.now() + 1, title: "Master Chemist", desc: "Collect 5 legendary pills",
                            target: 5, current: 0, reward: 4000, type: 'legendary', story: "The most powerful substances are also the most dangerous."
                        }
                    ];
                    
                    if (this.activeQuests.length < 7) {
                        this.activeQuests.push(newQuests[Math.floor(Math.random() * newQuests.length)]);
                    }
                }
            }

            // ============================================================================
            // TIPS SYSTEM (Unchanged)
            // ============================================================================
            class TipsSystem {
                constructor() {
                    this.currentTip = 0;
                    this.tips = TIPS;
                    this.lastTipChange = Date.now();
                    this.tipInterval = 15000;
                }

                update() {
                    const now = Date.now();
                    if (now - this.lastTipChange > this.tipInterval) {
                        this.currentTip = (this.currentTip + 1) % this.tips.length;
                        this.lastTipChange = now;
                        this.displayTip();
                    }
                }

                displayTip() {
                    const tipContent = document.getElementById('tipContent');
                    const tipCounter = document.getElementById('tipCounter');
                    
                    if (tipContent && tipCounter) {
                        tipContent.textContent = this.tips[this.currentTip];
                        tipCounter.textContent = this.currentTip + 1;
                    }
                }

                initialize() {
                    document.getElementById('totalTips').textContent = this.tips.length;
                    this.displayTip();
                }
            }

            // ============================================================================
            // ENHANCED MAIN GAME ENGINE
            // ============================================================================
            class NarcotiXGame {
                constructor() {
                    this.canvas = document.getElementById('gameCanvas');
                    this.ctx = this.canvas.getContext('2d');
                    
                    this.canvas.width = GAME_CONFIG.MAP_WIDTH * GAME_CONFIG.TILE_SIZE;
                    this.canvas.height = GAME_CONFIG.MAP_HEIGHT * GAME_CONFIG.TILE_SIZE;

                    this.nftCollection = new NFTCollection();
                    this.map = new Map(GAME_CONFIG.MAP_WIDTH, GAME_CONFIG.MAP_HEIGHT);
                    this.player = new Player(GAME_CONFIG.MAP_WIDTH / 2, GAME_CONFIG.MAP_HEIGHT / 2, this.nftCollection);
                    
                    this.enemies = [];
                    this.shops = [];
                    this.questSystem = new QuestSystem();
                    this.tipsSystem = new TipsSystem();
                    this.keys = {};
                    this.lastTime = 0;
                    this.camera = { x: 0, y: 0 };
                    this.particles = [];
                    this.droppedPills = [];
                    this.bullets = [];
                    this.explosions = [];
                    this.damageNumbers = [];
                    this.mouseX = 0;
                    this.mouseY = 0;
                    this.mouseWorldX = 0;
                    this.mouseWorldY = 0;
                    this.lastFireTime = 0;
                    this.lastReloadTime = 0;
                    this.crosshair = document.getElementById('crosshair');

                    this.bindButtonEvents();
                    this.initialize();
                }

                bindButtonEvents() {
                    document.getElementById('closeInvBtn').onclick = () => this.toggleInventory();
                    document.getElementById('usePillBtn').onclick = () => this.consumePill();
                    document.getElementById('equipWeaponBtn').onclick = () => this.equipWeapon();
                    document.getElementById('closeShopBtn').onclick = () => this.closeShop();
                    document.getElementById('closeLegendBtn').onclick = () => this.closeLegend();
                }

                initialize() {
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                        this.crosshair.style.display = 'block';
                    }, 2000);

                    for (let i = 0; i < 6; i++) {
                        let x, y, dist;
                        let attempts = 0;
                        do {
                            x = Math.random() * GAME_CONFIG.MAP_WIDTH;
                            y = Math.random() * GAME_CONFIG.MAP_HEIGHT;
                            dist = Math.hypot(x - GAME_CONFIG.MAP_WIDTH/2, y - GAME_CONFIG.MAP_HEIGHT/2);
                            attempts++;
                        } while (dist < GAME_CONFIG.MIN_SPAWN_DISTANCE && attempts < 50);
                        
                        const types = ['thug', 'rogue', 'police'];
                        const type = i < 1 ? 'boss' : types[Math.floor(Math.random() * types.length)];
                        this.enemies.push(new Enemy(x, y, type, this.nftCollection));
                    }

                    this.map.stashHouses.forEach(shopData => {
                        this.shops.push(new Shop(shopData.x, shopData.y, this.nftCollection));
                    });

                    this.player.ownedNFTs.forEach(pill => {
                        this.player.addToInventory(pill);
                    });
                    this.player.addWeapon('pistol');

                    this.setupEventListeners();
                    this.tipsSystem.initialize();
                    this.gameLoop();
                }

                setupEventListeners() {
                    window.addEventListener('keydown', (e) => {
                        this.keys[e.key.toLowerCase()] = true;
                        
                        switch(e.key.toLowerCase()) {
                            case 'i':
                                this.toggleInventory();
                                break;
                            case 'e':
                                this.interact();
                                break;
                            case 'q':
                                this.toggleQuestPanel();
                                break;
                            case ' ':
                                this.consumePill();
                                break;
                            case 'k':
                                this.toggleLegend();
                                break;
                            case 'r':
                                this.reloadWeapon();
                                break;
                            case '1':
                                this.player.switchWeapon('fists');
                                break;
                            case '2':
                                this.player.switchWeapon('pistol');
                                break;
                            case '3':
                                this.player.switchWeapon('rifle');
                                break;
                        }
                    });

                    window.addEventListener('keyup', (e) => {
                        this.keys[e.key.toLowerCase()] = false;
                    });

                    this.canvas.addEventListener('mousemove', (e) => {
                        const rect = this.canvas.getBoundingClientRect();
                        this.mouseX = e.clientX - rect.left;
                        this.mouseY = e.clientY - rect.top;
                        this.mouseWorldX = this.camera.x / GAME_CONFIG.TILE_SIZE + this.mouseX / GAME_CONFIG.TILE_SIZE;
                        this.mouseWorldY = this.camera.y / GAME_CONFIG.TILE_SIZE + this.mouseY / GAME_CONFIG.TILE_SIZE;
                        
                        // Update crosshair position
                        this.crosshair.style.left = (this.mouseX - 10) + 'px';
                        this.crosshair.style.top = (this.mouseY - 10) + 'px';
                    });

                    this.canvas.addEventListener('mousedown', (e) => {
                        if (e.button === 0) {
                            this.fireWeapon();
                        }
                    });

                    this.canvas.addEventListener('click', (e) => {
                        const rect = this.canvas.getBoundingClientRect();
                        const x = this.camera.x / GAME_CONFIG.TILE_SIZE + (e.clientX - rect.left) / GAME_CONFIG.TILE_SIZE;
                        const y = this.camera.y / GAME_CONFIG.TILE_SIZE + (e.clientY - rect.top) / GAME_CONFIG.TILE_SIZE;
                        this.handleCanvasClick(x, y);
                    });
                }

                handleCanvasClick(x, y) {
                    this.droppedPills = this.droppedPills.filter(pill => {
                        const dist = Math.hypot(pill.x - x, pill.y - y);
                        if (dist < 1.5) {
                            if (this.player.addToInventory(pill)) {
                                this.createParticle(worldToScreenX(pill.x), worldToScreenY(pill.y), '+PILL', '#0f0');
                                return false;
                            }
                        }
                        return true;
                    });
                }

                toggleInventory() {
                    const panel = document.getElementById('inventoryPanel');
                    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                    this.updateInventoryUI();
                }

                toggleQuestPanel() {
                    const panel = document.getElementById('questPanel');
                    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                }

                updateInventoryUI() {
                    const grid = document.getElementById('inventoryGrid');
                    const count = document.getElementById('invCount');
                    grid.innerHTML = '';
                    count.textContent = this.player.inventory.length;

                    this.player.inventory.forEach((pill, index) => {
                        const div = document.createElement('div');
                        div.className = `pill rarity-${pill.rarity}`;
                        div.style.borderColor = pill.color;
                        div.style.boxShadow = pill.rarity === 'legendary' ? `0 0 ${8 * pill.visualTrait.glowIntensity}px ${pill.color}` : 'none';
                        div.textContent = pill.name.substring(0, 6);
                        div.title = `${pill.name}\nEffect: ${pill.effect}\nRarity: ${pill.rarity}\nValue: $${pill.marketValue}\nDuration: ${pill.duration}s\nSide Effect: ${pill.sideEffect}`;
                        div.onclick = () => {
                            this.player.selectedPill = pill;
                            document.querySelectorAll('.pill').forEach(p => p.style.borderWidth = '1px');
                            div.style.borderWidth = '3px';
                        };
                        grid.appendChild(div);
                    });
                }

                interact() {
                    this.shops.forEach(shop => {
                        const dist = Math.hypot(this.player.x - shop.x, this.player.y - shop.y);
                        if (dist < 3) {
                            this.openShop(shop);
                        }
                    });

                    const building = this.map.getBuildingAt(this.player.x, this.player.y);
                    if (building) {
                        this.player.buildingUses++;
                        this.player.inBuilding = true;
                        this.player.shelterTime = GAME_CONFIG.BUILDING_SHELTER_TIME;
                        this.createParticle(this.player.x, this.player.y, 'BUILDING SECURED!', '#0f0');
                    }
                }

                openShop(shop) {
                    const panel = document.getElementById('shopPanel');
                    panel.style.display = 'block';
                    
                    const inv = document.getElementById('shopInventory');
                    inv.innerHTML = '<h4 style="color: #f0f;">Sell Your Pills:</h4>';

                    this.player.inventory.forEach(pill => {
                        const price = Math.floor(pill.marketValue * 0.8);
                        const btn = document.createElement('button');
                        btn.textContent = `${pill.name.substring(0, 15)} - $${price}`;
                        btn.onclick = () => {
                            const soldPrice = this.player.sellPill(pill);
                            this.createParticle(this.player.x, this.player.y, `+$${soldPrice}`, '#ff0');
                            this.updateUI();
                            this.openShop(shop);
                        };
                        inv.appendChild(btn);
                    });

                    inv.innerHTML += '<h4 style="color: #0f0;">Buy New Pills:</h4>';
                    shop.inventory.forEach(item => {
                        const btn = document.createElement('button');
                        btn.textContent = `${item.pill.name.substring(0, 15)} - $${item.price}`;
                        btn.onclick = () => {
                            if (this.player.cash >= item.price) {
                                this.player.cash -= item.price;
                                this.player.addToInventory(item.pill);
                                this.updateUI();
                                this.createParticle(this.player.x, this.player.y, `+${item.pill.name.substring(0, 10)}`, '#0f0');
                            }
                        };
                        inv.appendChild(btn);
                    });

                    inv.innerHTML += '<h4 style="color: #f00;">Buy Weapons:</h4>';
                    shop.weapons.forEach(item => {
                        const btn = document.createElement('button');
                        btn.textContent = `${item.data.name} - $${item.price} (DMG: ${item.data.damage})`;
                        btn.onclick = () => {
                            if (this.player.cash >= item.price) {
                                this.player.cash -= item.price;
                                this.player.addWeapon(item.type);
                                this.updateUI();
                                this.createParticle(this.player.x, this.player.y, `+${item.data.name}`, '#f0f');
                            }
                        };
                        inv.appendChild(btn);
                    });
                }

                closeShop() {
                    document.getElementById('shopPanel').style.display = 'none';
                }

                toggleLegend() {
                    const panel = document.getElementById('legendPanel');
                    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                }

                closeLegend() {
                    document.getElementById('legendPanel').style.display = 'none';
                }

                consumePill() {
                    if (this.player.selectedPill) {
                        this.player.consumePill(this.player.selectedPill);
                        this.createParticle(this.player.x, this.player.y, 'CONSUMED!', this.player.selectedPill.color);
                        this.updateInventoryUI();
                        this.updateUI();
                    }
                }

                equipWeapon() {
                    const weapons = Object.keys(this.player.weapons);
                    const currentIndex = weapons.indexOf(this.player.currentWeapon);
                    const nextIndex = (currentIndex + 1) % weapons.length;
                    this.player.currentWeapon = weapons[nextIndex];
                    this.updateUI();
                }

                fireWeapon() {
                    const now = Date.now();
                    const weaponData = GAME_CONFIG.WEAPON_TYPES[this.player.currentWeapon];
                    
                    if (now - this.lastFireTime < weaponData.cooldown || this.player.reloadTimer > 0) return;
                    
                    const bullet = this.player.fireWeapon(this.mouseWorldX, this.mouseWorldY);
                    if (bullet) {
                        this.bullets.push(new Bullet(bullet.x, bullet.y, bullet.targetX, bullet.targetY, 
                                                   bullet.damage, bullet.range, bullet.color, bullet.type));
                        this.lastFireTime = now;
                        this.createParticle(this.player.x, this.player.y, 'FIRE!', bullet.color);
                    }
                }

                reloadWeapon() {
                    const now = Date.now();
                    if (now - this.lastReloadTime < 500) return; // Prevent spam
                    
                    if (this.player.reloadWeapon()) {
                        this.lastReloadTime = now;
                        this.createParticle(this.player.x, this.player.y, 'RELOADING...', '#ff0');
                    }
                }

                createParticle(x, y, text, color) {
                    this.particles.push({ x, y, text, color, life: 1.0, vy: -0.5 });
                }

                createExplosion(x, y) {
                    this.explosions.push({ x, y, life: 0.5 });
                }

                createDamageNumber(x, y, damage, color = '#ff0') {
                    this.damageNumbers.push(new DamageNumber(x, y, damage, color));
                }

                updateParticles() {
                    this.particles = this.particles.filter(p => {
                        p.life -= 0.016;
                        p.y += p.vy;
                        return p.life > 0;
                    });

                    this.explosions = this.explosions.filter(e => {
                        e.life -= 0.016;
                        return e.life > 0;
                    });

                    this.damageNumbers = this.damageNumbers.filter(d => d.update());
                }

                updateBullets() {
                    this.bullets = this.bullets.filter(bullet => {
                        if (!bullet.update()) {
                            return false;
                        }

                        const hitEnemy = bullet.checkCollision(this.enemies);
                        if (hitEnemy) {
                            const damage = hitEnemy.stats.hp - Math.max(0, hitEnemy.stats.hp - bullet.damage);
                            hitEnemy.stats.hp -= bullet.damage;
                            this.createExplosion(bullet.x, bullet.y);
                            this.createDamageNumber(hitEnemy.x, hitEnemy.y, damage, bullet.color);
                            
                            if (hitEnemy.stats.hp <= 0) {
                                const loot = hitEnemy.dropLoot();
                                if (loot) {
                                    loot.x = hitEnemy.x;
                                    loot.y = hitEnemy.y;
                                    this.droppedPills.push(loot);
                                }
                                this.enemies.splice(this.enemies.indexOf(hitEnemy), 1);
                                this.player.enemiesDefeated++;
                                this.createParticle(hitEnemy.x, hitEnemy.y, 'ELIMINATED!', '#f00');
                            }
                            return false;
                        }
                        return true;
                    });
                }

                updateUI() {
                    document.getElementById('score').textContent = this.player.score;
                    document.getElementById('cash').textContent = this.player.cash;
                    document.getElementById('territory').textContent = this.player.territory.size;
                    document.getElementById('income').textContent = this.player.income;
                    document.getElementById('health').textContent = Math.floor(this.player.health);
                    document.getElementById('maxHealth').textContent = this.player.maxHealth;
                    document.getElementById('armor').textContent = Math.floor(this.player.armor);
                    document.getElementById('maxArmor').textContent = this.player.maxArmor;
                    document.getElementById('speed').textContent = this.player.speed.toFixed(1);
                    document.getElementById('stealth').textContent = this.player.stealth;
                    document.getElementById('luck').textContent = this.player.luck;
                    
                    const weapon = this.player.weapons[this.player.currentWeapon];
                    const weaponName = GAME_CONFIG.WEAPON_TYPES[this.player.currentWeapon].name;
                    const ammo = weapon.ammo === -1 ? '‚àû' : weapon.ammo;
                    document.getElementById('currentWeapon').textContent = `${weaponName} (${ammo})`;

                    const effectsDiv = document.getElementById('activeEffects');
                    effectsDiv.innerHTML = '';
                    this.player.statusEffects.forEach(effect => {
                        const badge = document.createElement('div');
                        badge.className = 'effect-badge';
                        badge.textContent = `${effect.type} (${Math.ceil(effect.duration)}s)`;
                        effectsDiv.appendChild(badge);
                    });

                    const questDiv = document.getElementById('questList');
                    questDiv.innerHTML = '';
                    this.questSystem.activeQuests.forEach(quest => {
                        const div = document.createElement('div');
                        div.style.fontSize = '11px';
                        div.style.marginBottom = '8px';
                        div.style.opacity = quest.completed ? '0.5' : '1';
                        div.innerHTML = `<strong>${quest.title}</strong><br>${quest.desc}<br>Progress: ${quest.current}/${quest.target}<br><em style="color: #888;">${quest.story}</em>`;
                        questDiv.appendChild(div);
                    });
                }

                handleInput() {
                    if (this.player.reloadTimer > 0) return; // Can't move while reloading
                    
                    const reversed = this.player.hasEffect('REVERSED_CONTROLS');
                    const dir = reversed ? -1 : 1;
                    let dx = 0, dy = 0;

                    if (this.keys['w'] || this.keys['arrowup']) dy = -1 * dir;
                    if (this.keys['s'] || this.keys['arrowdown']) dy = 1 * dir;
                    if (this.keys['a'] || this.keys['arrowleft']) dx = -1 * dir;
                    if (this.keys['d'] || this.keys['arrowright']) dx = 1 * dir;

                    if (dx !== 0 || dy !== 0) {
                        this.player.move(dx, dy, this.map);
                    }
                }

                updateEnemies() {
                    this.enemies.forEach((enemy, index) => {
                        enemy.update(this.player, this.map);
                    });

                    if (Math.random() < GAME_CONFIG.ENEMY_SPAWN_RATE && this.enemies.length < 12) {
                        let x, y, dist;
                        let attempts = 0;
                        do {
                            x = Math.random() * GAME_CONFIG.MAP_WIDTH;
                            y = Math.random() * GAME_CONFIG.MAP_HEIGHT;
                            dist = Math.hypot(x - this.player.x, y - this.player.y);
                            attempts++;
                        } while (dist < GAME_CONFIG.MIN_SPAWN_DISTANCE / 2 && attempts < 50);

                        const types = ['thug', 'rogue', 'police'];
                        this.enemies.push(new Enemy(x, y, types[Math.floor(Math.random() * types.length)], this.nftCollection));
                    }
                }

                passiveIncome() {
                    const now = Date.now();
                    if (!this.lastIncomeTime) this.lastIncomeTime = now;
                    if (now - this.lastIncomeTime > 60000) {
                        this.player.cash += this.player.income;
                        this.lastIncomeTime = now;
                        this.createParticle(this.player.x, this.player.y, `+$${this.player.income}`, '#0f0');
                    }
                }

                render() {
                    const ctx = this.ctx;
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    const camX = this.player.x * GAME_CONFIG.TILE_SIZE - this.canvas.width / 2;
                    const camY = this.player.y * GAME_CONFIG.TILE_SIZE - this.canvas.height / 2;
                    this.camera = { x: camX, y: camY };

                    ctx.save();
                    ctx.translate(-camX, -camY);

                    // Draw map with shadows
                    const startX = Math.max(0, Math.floor(camX / GAME_CONFIG.TILE_SIZE));
                    const startY = Math.max(0, Math.floor(camY / GAME_CONFIG.TILE_SIZE));
                    const endX = Math.min(this.map.width, startX + Math.ceil(this.canvas.width / GAME_CONFIG.TILE_SIZE) + 2);
                    const endY = Math.min(this.map.height, startY + Math.ceil(this.canvas.height / GAME_CONFIG.TILE_SIZE) + 2);

                    for (let y = startY; y < endY; y++) {
                        for (let x = startX; x < endX; x++) {
                            const tile = this.map.getTile(x, y);
                            ctx.fillStyle = tile.color;
                            ctx.fillRect(x * GAME_CONFIG.TILE_SIZE, y * GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE);
                            
                            // Special rendering for buildings
                            if (tile.special === 'building') {
                                ctx.strokeStyle = '#ccc';
                                ctx.setLineDash([5, 5]);
                                ctx.lineWidth = 2;
                                ctx.strokeRect(x * GAME_CONFIG.TILE_SIZE, y * GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE);
                                ctx.setLineDash([]);
                                ctx.lineWidth = 1;
                            }
                            
                            if (tile.special === 'shop') {
                                ctx.fillStyle = '#00ffff';
                                ctx.font = 'bold 16px monospace';
                                ctx.fillText('$', x * GAME_CONFIG.TILE_SIZE + 12, y * GAME_CONFIG.TILE_SIZE + 24);
                            }
                            
                            ctx.strokeStyle = '#222';
                            ctx.strokeRect(x * GAME_CONFIG.TILE_SIZE, y * GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE);
                        }
                    }

                    // Draw territory overlay
                    this.player.territory.forEach(key => {
                        const [x, y] = key.split(',').map(Number);
                        if (x >= startX && x < endX && y >= startY && y < endY) {
                            ctx.fillStyle = 'rgba(0, 255, 0, 0.08)';
                            ctx.fillRect(x * GAME_CONFIG.TILE_SIZE, y * GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE);
                        }
                    });

                    // Draw dropped pills
                    this.droppedPills.forEach(pill => {
                        ctx.fillStyle = pill.color;
                        ctx.beginPath();
                        ctx.arc(pill.x * GAME_CONFIG.TILE_SIZE, pill.y * GAME_CONFIG.TILE_SIZE, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    });

                    // Draw bullets with trails
                    this.bullets.forEach(bullet => {
                        // Trail
                        ctx.strokeStyle = bullet.color;
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(bullet.trail[0].x * GAME_CONFIG.TILE_SIZE, bullet.trail[0].y * GAME_CONFIG.TILE_SIZE);
                        for (let i = 1; i < bullet.trail.length; i++) {
                            ctx.lineTo(bullet.trail[i].x * GAME_CONFIG.TILE_SIZE, bullet.trail[i].y * GAME_CONFIG.TILE_SIZE);
                        }
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                        
                        // Bullet
                        ctx.fillStyle = bullet.color;
                        ctx.shadowBlur = 6;
                        ctx.shadowColor = bullet.color;
                        ctx.beginPath();
                        ctx.arc(bullet.x * GAME_CONFIG.TILE_SIZE, bullet.y * GAME_CONFIG.TILE_SIZE, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    });

                    // Draw explosions
                    this.explosions.forEach(explosion => {
                        ctx.save();
                        ctx.globalAlpha = explosion.life * 2;
                        const gradient = ctx.createRadialGradient(
                            explosion.x * GAME_CONFIG.TILE_SIZE, explosion.y * GAME_CONFIG.TILE_SIZE, 0,
                            explosion.x * GAME_CONFIG.TILE_SIZE, explosion.y * GAME_CONFIG.TILE_SIZE, 30
                        );
                        gradient.addColorStop(0, '#ff0');
                        gradient.addColorStop(0.5, '#f00');
                        gradient.addColorStop(1, 'transparent');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(explosion.x * GAME_CONFIG.TILE_SIZE, explosion.y * GAME_CONFIG.TILE_SIZE, 30, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    });

                    // Draw enemies with shadows and detection indicators
                    this.enemies.forEach(enemy => {
                        const distToPlayer = Math.hypot(enemy.x - this.player.x, enemy.y - this.player.y);
                        
                        if (distToPlayer < GAME_CONFIG.PLAYER_VISION_RANGE || enemy.state === 'chase') {
                            // Detection indicator
                            if (enemy.detectionTimer > 0 && enemy.detectionTimer < GAME_CONFIG.DETECTION_TIME_REQUIRED) {
                                ctx.fillStyle = `rgba(255, 165, 0, ${0.3 + enemy.detectionTimer * 0.2})`;
                                ctx.beginPath();
                                ctx.arc(enemy.x * GAME_CONFIG.TILE_SIZE, enemy.y * GAME_CONFIG.TILE_SIZE, enemy.size + 10, 0, Math.PI * 2);
                                ctx.fill();
                            } else if (enemy.state === 'chase') {
                                ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                                ctx.beginPath();
                                ctx.arc(enemy.x * GAME_CONFIG.TILE_SIZE, enemy.y * GAME_CONFIG.TILE_SIZE, enemy.stats.detectionRange * GAME_CONFIG.TILE_SIZE, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                            
                            // Shadow
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                            ctx.beginPath();
                            ctx.arc(enemy.x * GAME_CONFIG.TILE_SIZE + 2, enemy.y * GAME_CONFIG.TILE_SIZE + 2, enemy.size, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Enemy body
                            ctx.fillStyle = enemy.color;
                            ctx.beginPath();
                            ctx.arc(enemy.x * GAME_CONFIG.TILE_SIZE, enemy.y * GAME_CONFIG.TILE_SIZE, enemy.size, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Enemy border
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = enemy.state === 'chase' ? 2 : 1;
                            ctx.stroke();
                            ctx.lineWidth = 1;
                            
                            // Enemy label
                            ctx.fillStyle = '#fff';
                            ctx.font = 'bold 9px monospace';
                            ctx.fillText(enemy.stats.label, enemy.x * GAME_CONFIG.TILE_SIZE - 12, enemy.y * GAME_CONFIG.TILE_SIZE - enemy.size - 6);
                            
                            // Health bar
                            if (enemy.stats.hp < GAME_CONFIG.ENEMY_TYPES[enemy.type].hp) {
                                const healthPercent = enemy.stats.hp / GAME_CONFIG.ENEMY_TYPES[enemy.type].hp;
                                const barWidth = 24;
                                ctx.fillStyle = '#f00';
                                ctx.fillRect(enemy.x * GAME_CONFIG.TILE_SIZE - barWidth/2, enemy.y * GAME_CONFIG.TILE_SIZE - enemy.size - 12, barWidth, 3);
                                ctx.fillStyle = '#0f0';
                                ctx.fillRect(enemy.x * GAME_CONFIG.TILE_SIZE - barWidth/2, enemy.y * GAME_CONFIG.TILE_SIZE - enemy.size - 12, barWidth * healthPercent, 3);
                            }
                        }
                    });

                    // Draw damage numbers
                    this.damageNumbers.forEach(dn => {
                        ctx.save();
                        ctx.globalAlpha = dn.life;
                        ctx.fillStyle = dn.color;
                        ctx.font = 'bold 14px monospace';
                        ctx.fillText(`-${dn.damage}`, dn.x * GAME_CONFIG.TILE_SIZE, dn.y * GAME_CONFIG.TILE_SIZE);
                        ctx.restore();
                    });

                    // Draw shops (cyan squares)
                    this.shops.forEach(shop => {
                        ctx.fillStyle = '#00ffff';
                        ctx.fillRect(shop.x * GAME_CONFIG.TILE_SIZE - 10, shop.y * GAME_CONFIG.TILE_SIZE - 10, 20, 20);
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(shop.x * GAME_CONFIG.TILE_SIZE - 10, shop.y * GAME_CONFIG.TILE_SIZE - 10, 20, 20);
                        ctx.lineWidth = 1;
                        
                        // Shop label
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 14px monospace';
                        ctx.fillText('$', shop.x * GAME_CONFIG.TILE_SIZE - 4, shop.y * GAME_CONFIG.TILE_SIZE + 4);
                    });

                    // Draw player with shadow and building indicator
                    if (this.player.inBuilding) {
                        // Building interior overlay
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.fillRect(this.player.x * GAME_CONFIG.TILE_SIZE - 5, this.player.y * GAME_CONFIG.TILE_SIZE - 5, 10, 10);
                        
                        // Building border effect
                        ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(this.player.x * GAME_CONFIG.TILE_SIZE, this.player.y * GAME_CONFIG.TILE_SIZE, this.player.size + 8, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.lineWidth = 1;
                    }
                    
                    // Player shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.beginPath();
                    ctx.arc(this.player.x * GAME_CONFIG.TILE_SIZE + 2, this.player.y * GAME_CONFIG.TILE_SIZE + 2, this.player.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Player body
                    const playerColor = this.player.hasEffect('STEALTH') ? 'rgba(255, 255, 0, 0.7)' : '#ff0';
                    ctx.fillStyle = playerColor;
                    ctx.beginPath();
                    ctx.arc(this.player.x * GAME_CONFIG.TILE_SIZE, this.player.y * GAME_CONFIG.TILE_SIZE, this.player.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Player border
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.lineWidth = 1;

                    // Reload indicator
                    if (this.player.reloadTimer > 0) {
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                        ctx.font = 'bold 12px monospace';
                        ctx.fillText('RELOADING...', this.player.x * GAME_CONFIG.TILE_SIZE - 30, this.player.y * GAME_CONFIG.TILE_SIZE - 20);
                    }

                    // Draw particles
                    this.particles.forEach(p => {
                        ctx.save();
                        ctx.globalAlpha = p.life;
                        ctx.fillStyle = p.color;
                        ctx.font = 'bold 12px monospace';
                        ctx.fillText(p.text, p.x * GAME_CONFIG.TILE_SIZE, p.y * GAME_CONFIG.TILE_SIZE);
                        ctx.restore();
                    });

                    ctx.restore();
                }

                gameLoop(timestamp = 0) {
                    const deltaTime = timestamp - this.lastTime;
                    this.lastTime = timestamp;

                    this.handleInput();
                    this.player.updateStatusEffects();
                    this.updateEnemies();
                    this.updateBullets();
                    this.shops.forEach(shop => shop.update());
                    this.questSystem.updateQuests(this.player);
                    this.tipsSystem.update();
                    this.updateParticles();
                    this.passiveIncome();

                    this.render();
                    this.updateUI();

                    requestAnimationFrame((t) => this.gameLoop(t));
                }
            }

            // ============================================================================
            // WORLD TO SCREEN CONVERSION HELPERS
            // ============================================================================
            function worldToScreenX(worldX) {
                return worldX * GAME_CONFIG.TILE_SIZE;
            }

            function worldToScreenY(worldY) {
                return worldY * GAME_CONFIG.TILE_SIZE;
            }

            // ============================================================================
            // ERROR BOUNDARY
            // ============================================================================
            try {
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => {
                        new NarcotiXGame();
                    });
                } else {
                    new NarcotiXGame();
                }
            } catch (error) {
                console.error("Game initialization failed:", error);
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen) {
                    loadingScreen.innerHTML = `<h1 style="color: #f00;">ERROR</h1><p>${error.message}</p><p>Check console for details.</p>`;
                    loadingScreen.style.display = 'flex';
                }
            }
        })();
    </script>
</body>
</html>