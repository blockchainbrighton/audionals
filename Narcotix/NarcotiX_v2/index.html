<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NarcotiX Systems - Game V2</title>
    <style>
        body { margin: 0; background-color: #1a1a1a; /* Darker bg */ color: #0FF; /* Cyan text default */ font-family: 'Courier New', Courier, monospace; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; }
        canvas { border: 1px solid #0FF; background-color: #080808; } /* Darker canvas, cyan border */
        .ui-container { position: absolute; top: 10px; left: 10px; background-color: rgba(10,20,30,0.85); padding: 10px; border-radius: 5px; font-size: 14px; border: 1px solid #0AA; max-width: 250px; z-index: 50; }
        #inventoryDisplay, #shopInterface, #questLog {
            display: none; 
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 500px;
            background-color: rgba(0,10,20,0.97); /* Dark blueish */
            border: 2px solid #0FF; /* Cyan border */
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,255,255,0.3); /* Cyan glow */
            z-index: 100;
            color: #FFF;
        }
        #inventoryDisplayInner, #shopInterfaceInner, #questLogInner {
             max-height: 400px;
             overflow-y: auto;
             scrollbar-width: thin;
             scrollbar-color: #0FF #051018;
        }
        #shopInterface h3, #inventoryDisplay h3, #questLog h3 { margin-top: 0; border-bottom: 1px solid #0AA; padding-bottom: 5px; color: #0FF;}
        .shopItem, .inventoryItem, .questItem { padding: 8px; border-bottom: 1px solid #055; } /* Darker teal lines */
        .shopItem:last-child, .inventoryItem:last-child, .questItem:last-child { border-bottom: none; }
        .shopItem:hover, .inventoryItem:hover { background-color: #034; } /* Darker blue hover */
        .abilityCooldown { font-size: 12px; color: #999; }
        #tutorialPopup {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 50, 100, 0.95);
            color: #0FF;
            padding: 15px;
            border-radius: 8px;
            font-size: 16px;
            z-index: 1000;
            display: none;
            border: 1px solid #0FF;
            text-align: center;
        }
        .button {
            background-color: #088; border: 1px solid #0FF; color: #FFF; padding: 8px 12px;
            text-align: center; text-decoration: none; display: inline-block; font-size: 14px; margin: 4px 2px; cursor: pointer; border-radius: 4px;
        }
        .button:hover { background-color: #0AA; box-shadow: 0 0 5px #0FF; }
        .button-sell { background-color: #A00; border-color: #F33; }
        .button-sell:hover { background-color: #C00; }
        .button-use { background-color: #00A; border-color: #33F;}
        .button-use:hover { background-color: #00C; }
        .button-close { background-color: #555; border-color: #888; }
        .button-close:hover { background-color: #777; }
        #messageLog {
            position: fixed;
            bottom: 10px;
            right: 260px; /* Adjusted to make space for legend */
            width: 300px;
            height: 120px;
            overflow-y: scroll;
            background-color: rgba(0,5,10,0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            border: 1px solid #0AA;
            z-index: 50;
            color: #0CF;
        }
        #messageLog div { margin-bottom: 3px; }

        #keyLegend {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(10,20,30,0.85);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #0AA;
            font-size: 12px;
            width: 230px;
            max-height: calc(100vh - 40px); /* Max height it can take */
            overflow-y: auto;
            z-index: 50;
            color: #FFF;
            scrollbar-width: thin;
            scrollbar-color: #0FF #051018;
        }
        #keyLegend h4 {
            margin-top: 0;
            margin-bottom: 5px;
            color: #0FF;
            border-bottom: 1px solid #0AA;
            padding-bottom: 3px;
        }
        #keyLegend ul {
            list-style-type: none;
            padding: 0;
            margin: 0 0 10px 0;
        }
        #keyLegend li {
            margin-bottom: 4px;
            display: flex;
            align-items: center;
        }
        #keyLegend .key-symbol {
            display: inline-block;
            width: 20px;
            font-weight: bold;
            text-align: center;
            margin-right: 8px;
            font-family: Arial, sans-serif;
        }
        #keyLegend .key-color-box {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 8px;
            border: 1px solid #077;
        }

    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div class="ui-container" id="hud">
        <div>Vitality: <span id="playerHealth">100</span>/<span id="playerMaxHealth">100</span></div>
        <div>Creds: <span id="playerMoney">0</span>c</div>
        <div>System State: <span id="playerStatus">Nominal</span></div>
        <div id="activeQuestHUD">Active Protocol: <span id="activeQuestTitle">None</span></div>
        <div>FPS: <span id="fpsDisplay">0</span></div>
        <div>Cycle: <span id="gameTimeDisplay">Phase 1 - 00:00</span></div>
        <div id="abilityStatus">
            Subroutines: (1) C-Burst (RDY) | (2) G-Packet (RDY) | (3) Nano-Flush (RDY)
        </div>
    </div>

    <div id="keyLegend">
        <h4>SYSTEM LEGEND</h4>
        <ul>
            <li><span class="key-symbol" style="color: #3F3;">웃</span> Xperient (You! Subvert the system)</li>
        </ul>
        <h4>Hostile Entities</h4>
        <ul>
            <li><span class="key-symbol" style="color: #F66;">E</span> System Enforcer (30HP, 5 Dmg. Standard patrol)</li>
            <li><span class="key-symbol" style="color: #C00;">W</span> Zone Warden (100HP, 15 Dmg. Heavy. Guards key nodes)</li>
            <li><span class="key-symbol" style="color: #88F;">d</span> Meta-Patrol Unit (20HP. Tags Xperients)</li>
        </ul>
        <h4>Data Fragments / Consumables (On Grid)</h4>
        <ul>
            <li><span class="key-symbol" style="color: #FFD700;">c</span> Creds (Digital currency)</li>
            <li><span class="key-symbol" style="color: #FFD700;">+</span> Nanite Repair Kit (Restores 50 Vitality)</li>
            <li><span class="key-symbol" style="color: #FFD700;">⦾</span> NarcotiX Pill (Chaotic effects: Heal/DMG/Glitch)</li>
            <li><span class="key-symbol" style="color: #FFD700;">></span> Adrena-Rush Injector (+50% Clock Speed, 10s)</li>
            <li><span class="key-symbol" style="color: #FFD700;">!</span> Kaos Elixir (+30% Speed, 15s. Draws aggro)</li>
            <li><span class="key-symbol" style="color: #FFD700;">Җ</span> XData Fragment (Corrupted. Quest-related)</li>
            <li><span class="key-symbol" style="color: #0F0;">X</span> Xemist Airdrop (Event: High-value data/pills)</li>
        </ul>
        <h4>Protocol Markers (Above Target)</h4>
        <ul>
            <li><span class="key-symbol" style="color: yellow;">!</span> New Protocol Available</li>
            <li><span class="key-symbol" style="color: lime;">?</span> Protocol Completion Target</li>
            <li><span class="key-symbol" style="color: cyan;">?</span> Active: Deliver Packet Here</li>
            <li><span class="key-symbol" style="color: red;">X</span> Active: Defrag Zone (Eliminate Hostiles)</li>
            <li><span class="key-symbol" style="color: lightblue;">*</span> Active: Locate Data Fragment Here</li>
        </ul>
        <h4>Grid Tiles (Interactive/Notable)</h4>
        <ul>
            <li><span class="key-color-box" style="background-color: #777;"></span> Data Stream (High-speed traversal)</li>
            <li><span class="key-color-box" style="background-color: #353;"></span> Low-Rez Plain (Standard traversal)</li>
            <li><span class="key-color-box" style="background-color: #444;"></span> Firewall (Blocks path)</li>
            <li><span class="key-color-box" style="background-color: #118;"></span> Coolant Reservoir (Blocks path)</li>
            <li><span class="key-color-box" style="background-color: #0FF;"></span> Exchange Node (Aqua. Enter to trade data/pills)</li>
            <li><span class="key-color-box" style="background-color: #F0F;"></span> XLounge Stash Access (Magenta. Secure inventory access)</li>
            <li><span class="key-color-box" style="background-color: #FF0;"></span> Rogue Xemist Contact (Yellow. Access Protocols)</li>
            <li><span class="key-color-box" style="background-color: #411;"></span> Hostile Spawn Vector</li>
        </ul>
    </div>


    <div id="inventoryDisplay">
        <h3>Personal Data-Stash (I or Esc to close)</h3>
        <div id="inventoryDisplayInner">
             <div id="inventoryItems"></div>
        </div>
        <button class="button button-close" onclick="game.toggleInventory()" style="margin-top:15px;">Secure & Close</button>
    </div>

    <div id="shopInterface">
        <h3 id="shopName">Interface Node</h3>
        <div id="shopInterfaceInner">
            <p id="shopWelcomeMessage"></p>
            <h4>Available Data/Pills:</h4>
            <div id="shopItemsForSale"></div>
            <h4>Your Sellable Assets:</h4>
            <div id="playerItemsToSell"></div>
        </div>
        <button class="button button-close" onclick="game.closeShop()" style="margin-top:15px;">Disconnect Interface</button>
    </div>

    <div id="questLog">
        <h3>Active Protocols (J or Esc to close)</h3>
        <div id="questLogInner">
            <div id="activeQuestsDisplay"></div>
        </div>
        <button class="button button-close" onclick="game.toggleQuestLog()" style="margin-top:15px;">Minimize Protocols</button>
    </div>

    <div id="messageLog"></div>
    <div id="tutorialPopup"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const TILE_SIZE = 32;
        const MAP_WIDTH_TILES = 100;
        const MAP_HEIGHT_TILES = 100;
        const VIEWPORT_WIDTH_TILES = 25;
        const VIEWPORT_HEIGHT_TILES = 17;

        canvas.width = VIEWPORT_WIDTH_TILES * TILE_SIZE;
        canvas.height = VIEWPORT_HEIGHT_TILES * TILE_SIZE;

        let gameState = 'PLAYING';
        let gameTime = 0;
        const TICKS_PER_GAME_MINUTE = 1; 
        const GAME_MINUTES_PER_DAY = 24 * 60;
        let currentDay = 1; // Renamed to currentPhase in display
        let isDayTime = true; // Renamed to isHighTraffic in display

        let lastTime = 0;
        let fps = 0;
        let frameCount = 0;
        let fpsUpdateInterval = 1000;
        let lastFpsUpdateTime = 0;

        const keysPressed = {};

        const gameMessages = [];
        const MAX_MESSAGES = 10;
        let tutorialQueue = [];
        let currentTutorial = null;
        let tutorialDisplayTime = 5000;
        let tutorialTimer = 0;

        // --- Utility Functions ---
        function AABBCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        function showTutorial(message, duration = 5000) {
            const popup = document.getElementById('tutorialPopup');
            popup.textContent = message;
            popup.style.display = 'block';
            tutorialDisplayTime = duration;
            tutorialTimer = Date.now();

            setTimeout(() => {
                if (popup.textContent === message) {
                     popup.style.display = 'none';
                }
            }, duration);
        }

        function queueTutorial(message, conditionFunction) {
            tutorialQueue.push({ message, conditionFunction, shown: false });
        }

        function processTutorialQueue() {
            if (currentTutorial && Date.now() - tutorialTimer < tutorialDisplayTime) return;
            if (currentTutorial) {
                document.getElementById('tutorialPopup').style.display = 'none';
                currentTutorial = null;
            }
            for (let i = 0; i < tutorialQueue.length; i++) {
                if (!tutorialQueue[i].shown && tutorialQueue[i].conditionFunction()) {
                    currentTutorial = tutorialQueue[i];
                    showTutorial(currentTutorial.message);
                    tutorialQueue[i].shown = true;
                    break;
                }
            }
        }

        function addMessage(text) {
            gameMessages.unshift(`[SYS] ${text}`); // Add a prefix for messages
            if (gameMessages.length > MAX_MESSAGES) gameMessages.pop();
            renderMessages();
        }

        function renderMessages() {
            const log = document.getElementById('messageLog');
            log.innerHTML = gameMessages.map(msg => `<div>${msg.replace(/</g, "<").replace(/>/g, ">")}</div>`).join(''); // Basic XSS guard
            log.scrollTop = 0;
        }

        const TILE_TYPES = { EMPTY: 0, DATA_STREAM: 1, LOW_REZ_PLAIN: 2, FIREWALL: 3, SECURE_DATA_SILO_WALL: 4, EXCHANGE_NODE_ENTRANCE: 5, EXCHANGE_INTERIOR: 6, XLOUNGE_STASH_ENTRANCE: 7, XLOUNGE_INTERIOR: 8, HOSTILE_SPAWN_VECTOR: 9, DATA_FRAGMENT_SPAWN: 10, XEMIST_CONTACT_POINT: 11, COOLANT_RESERVOIR: 12 };
        const TILE_PROPERTIES = {
            [TILE_TYPES.EMPTY]: { color: '#050505', collision: true, speedModifier: 0 }, // Darker empty
            [TILE_TYPES.DATA_STREAM]: { color: '#666', collision: false, speedModifier: 1.2 }, // Slightly desaturated road
            [TILE_TYPES.LOW_REZ_PLAIN]: { color: '#353', collision: false, speedModifier: 0.8 }, // Desaturated grass
            [TILE_TYPES.FIREWALL]: { color: '#444', collision: true, speedModifier: 0 }, // Darker wall
            [TILE_TYPES.SECURE_DATA_SILO_WALL]: { color: '#503020', collision: true, speedModifier: 0 }, // More techy building wall
            [TILE_TYPES.EXCHANGE_NODE_ENTRANCE]: { color: '#0FF', collision: false, speedModifier: 1, interactive: true, type: 'exchange_node_entrance' },
            [TILE_TYPES.EXCHANGE_INTERIOR]: { color: '#223', collision: false, speedModifier: 1 },
            [TILE_TYPES.XLOUNGE_STASH_ENTRANCE]: { color: '#F0F', collision: false, speedModifier: 1, interactive: true, type: 'xlounge_stash_entrance' },
            [TILE_TYPES.XLOUNGE_INTERIOR]: { color: '#303', collision: false, speedModifier: 1 },
            [TILE_TYPES.HOSTILE_SPAWN_VECTOR]: { color: '#300', collision: false, speedModifier: 1 }, // Darker red
            [TILE_TYPES.DATA_FRAGMENT_SPAWN]: { color: '#003', collision: false, speedModifier: 1 }, // Darker blue
            [TILE_TYPES.XEMIST_CONTACT_POINT]: { color: '#DD0', collision: false, speedModifier: 1, interactive: true, type: 'xemist_contact_point' }, // slightly darker yellow
            [TILE_TYPES.COOLANT_RESERVOIR]: { color: '#118', collision: true, speedModifier: 0 }, // Darker blue water
        };

        let mapData = [];
        const camera = {
            x: 0, y: 0, width: canvas.width, height: canvas.height,
            update: function(targetEntity) {
                let targetX = targetEntity.x - this.width / 2;
                let targetY = targetEntity.y - this.height / 2;
                targetX = Math.max(0, Math.min(targetX, MAP_WIDTH_TILES * TILE_SIZE - this.width));
                targetY = Math.max(0, Math.min(targetY, MAP_HEIGHT_TILES * TILE_SIZE - this.height));
                this.x = targetX;
                this.y = targetY;
            }
        };

        let itemsOnMap = [];
        let enemies = [];
       
        const game = {
            init: function() {
                queueTutorial("Initiate Movement Matrix: WASD or Arrow Keys.", () => true);
                queueTutorial("Access Personal Data-Stash: Press 'I'.", () => game.player.inventory.items.length > 0 || game.player.money > 10);
                queueTutorial("Execute Subroutines (1-3) for tactical advantage.", () => game.player.abilities.length > 0 && game.player.money > 0);
                queueTutorial("Interface with Highlighted Grid Nodes (E): Exchange Nodes (Aqua/Magenta), Xemist Contacts (Yellow).", () => true);
                queueTutorial("Engage Hostiles: Press 'Space' for Melee Disruptor.", () => enemies.some(e => distance(game.player.x, game.player.y, e.x, e.y) < game.player.attackRange * 2));
               
                this.itemManager.defineItems();
                this.mapManager.generateMap();
                this.player.init();
                this.enemyManager.initEnemyTypes();
                this.enemyManager.spawnInitialEnemies();
                this.itemManager.spawnInitialItems();
                this.questManager.initQuests();
                this.zoneManager.initZones();
                this.shopManager.initShops();

                this.hud.update();
                addMessage("NarcotiX Systems Online. Welcome, Xperient.");
            },

            mapManager: {
                generateMap: function() {
                    mapData = [];
                    for (let r = 0; r < MAP_HEIGHT_TILES; r++) {
                        mapData[r] = [];
                        for (let c = 0; c < MAP_WIDTH_TILES; c++) {
                            let tileType = TILE_TYPES.LOW_REZ_PLAIN;
                            if (c > 0 && c < MAP_WIDTH_TILES -1 && r > 0 && r < MAP_HEIGHT_TILES -1) {
                                if ((c % 12 <= 1 || r % 12 <= 1) && (c > 2 && c < MAP_WIDTH_TILES - 3 && r > 2 && r < MAP_HEIGHT_TILES - 3)) tileType = TILE_TYPES.DATA_STREAM;
                                if (Math.random() < 0.04 && tileType === TILE_TYPES.LOW_REZ_PLAIN) tileType = TILE_TYPES.SECURE_DATA_SILO_WALL;
                                if (Math.random() < 0.005 && tileType === TILE_TYPES.LOW_REZ_PLAIN) tileType = TILE_TYPES.COOLANT_RESERVOIR;
                                if (Math.random() < 0.002 && tileType !== TILE_TYPES.DATA_STREAM && tileType !== TILE_TYPES.COOLANT_RESERVOIR && tileType !== TILE_TYPES.SECURE_DATA_SILO_WALL) tileType = TILE_TYPES.HOSTILE_SPAWN_VECTOR;
                            }
                            if (c === 0 || r === 0 || c === MAP_WIDTH_TILES - 1 || r === MAP_HEIGHT_TILES - 1) tileType = TILE_TYPES.FIREWALL;

                            let cellData = { type: tileType };
                           
                            if(c > 0 && c < MAP_WIDTH_TILES -1 && r > 0 && r < MAP_HEIGHT_TILES -1){
                                // Exchange Node (Central Market)
                                if (c >= 9 && c <= 11 && r >= 9 && r <= 11) {cellData.type = TILE_TYPES.SECURE_DATA_SILO_WALL;}
                                if (c === 10 && r === 11) { cellData.type = TILE_TYPES.EXCHANGE_NODE_ENTRANCE; cellData.interactionTargetId = 'central_exchange'; cellData.interactionType = 'exchange_node'; }

                                // Xemist's Back Alley (Shady Dealer)
                                if (c >= 39 && c <= 41 && r >= 4 && r <= 6) { cellData.type = TILE_TYPES.SECURE_DATA_SILO_WALL; }
                                if (c === 40 && r === 6) { cellData.type = TILE_TYPES.EXCHANGE_NODE_ENTRANCE; cellData.interactionTargetId = 'xemist_den'; cellData.interactionType = 'exchange_node'; }

                                // XLounge Stash Access (Player Stash)
                                if (c >= 29 && c <= 31 && r >= 29 && r <= 31) {cellData.type = TILE_TYPES.SECURE_DATA_SILO_WALL; }
                                if (c === 30 && r === 31) { cellData.type = TILE_TYPES.XLOUNGE_STASH_ENTRANCE; cellData.interactionTargetId = 'xlounge_personal'; cellData.interactionType = 'xlounge_stash';} 

                                // Rogue Xemist (Quest Giver)
                                if (c === 5 && r === 15) { cellData.type = TILE_TYPES.XEMIST_CONTACT_POINT; cellData.interactionTargetId = 'glitch_codex'; cellData.interactionType = 'xemist_contact';}
                            }
                            mapData[r][c] = cellData;
                        }
                    }
                },
                render: function() {
                    const { startCol, endCol, startRow, endRow } = game.getVisibleTiles();
                    for (let r = startRow; r < endRow; r++) {
                        for (let c = startCol; c < endCol; c++) {
                            if (r < 0 || r >= MAP_HEIGHT_TILES || c < 0 || c >= MAP_WIDTH_TILES) continue;
                            const tile = mapData[r][c];
                            const tileDef = TILE_PROPERTIES[tile.type] || TILE_PROPERTIES[TILE_TYPES.EMPTY];
                            ctx.fillStyle = tileDef.color;
                            ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            // Optional: Add grid pattern to tiles for more "metaverse" feel
                            // if (tileDef.color === '#666' || tileDef.color === '#353') {
                            //    ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.strokeRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            // }
                        }
                    }
                },
                getTilePropertiesAt: function(worldX, worldY) {
                    const tileX = Math.floor(worldX / TILE_SIZE);
                    const tileY = Math.floor(worldY / TILE_SIZE);
                    if (tileX >= 0 && tileX < MAP_WIDTH_TILES && tileY >= 0 && tileY < MAP_HEIGHT_TILES) {
                        const tile = mapData[tileY][tileX];
                        return TILE_PROPERTIES[tile.type];
                    }
                    return TILE_PROPERTIES[TILE_TYPES.EMPTY];
                },
                isColliding: function(worldX, worldY) {
                    const tileProps = this.getTilePropertiesAt(worldX, worldY);
                    return tileProps ? tileProps.collision : true;
                },
                isValidTile: function(tileX, tileY) {
                    return tileX >= 0 && tileX < MAP_WIDTH_TILES && tileY >= 0 && tileY < MAP_HEIGHT_TILES;
                }
            },
           
            player: {
                x: TILE_SIZE * 5, y: TILE_SIZE * 5, width: TILE_SIZE * 0.7, height: TILE_SIZE * 0.7, color: '#3F3', char: '웃',
                speed: 150, baseSpeed: 150, hp: 100, maxHp: 100, money: 150, // money is "Creds"
                inventory: { items: [], capacity: 10 },
                abilities: [
                    { name: "Clock Cycle Burst", key: '1', cooldown: 30000, duration: 5000, lastUsedTime: 0, effect: () => { game.player.applyStatusEffect("C-Burst", 5000, { speedMultiplier: 2 }); addMessage("Clock Cycle Burst Activated!"); }},
                    { name: "Ghost Packet", key: '2', cooldown: 60000, duration: 10000, lastUsedTime: 0, effect: () => { game.player.applyStatusEffect("Ghosting", 10000); addMessage("Ghost Packet Engaged. Hostiles may lose track."); }},
                    { name: "Emergency Nano-Flush", key: '3', cooldown: 90000, duration: 0, lastUsedTime: 0, effect: () => { game.player.heal(25); addMessage("Nano-Flush Initiated! +25 Vitality"); }}
                ],
                statusEffects: [], attackPower: 10, attackCooldown: 500, lastAttackTime: 0, attackRange: TILE_SIZE * 1.1,
                init: function() {
                    this.x = TILE_SIZE * (MAP_WIDTH_TILES / 2);
                    this.y = TILE_SIZE * (MAP_HEIGHT_TILES / 2);
                    camera.x = this.x - camera.width/2;
                    camera.y = this.y - camera.height/2;
                    this.hp = this.maxHp; this.money = 150; this.inventory.items = []; this.statusEffects = [];
                    this.abilities.forEach(ab => ab.lastUsedTime = -ab.cooldown);
                    const firstAid = game.itemManager.createItemById('nanite_repair'); if (firstAid) this.addItem(firstAid);
                },
                render: function() {
                    ctx.fillStyle = this.isStealthed() ? 'rgba(50, 255, 50, 0.4)' : this.color; // Stealth has visual
                    // Pulsing effect if has Kaos Elixir or C-Burst
                    if (this.hasStatusEffect("Kaos Frenzy") || this.hasStatusEffect("C-Burst")) {
                         const pulse = Math.abs(Math.sin(Date.now() / 200)) * 0.3 + 0.7; // 0.7 to 1.0
                         ctx.globalAlpha = pulse;
                    }
                    ctx.font = `${TILE_SIZE * 0.9}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(this.char, this.x + this.width / 2, this.y + this.height / 2 + TILE_SIZE * 0.05);
                    ctx.globalAlpha = 1.0; // Reset alpha

                    if (this.hp < this.maxHp) {
                        const barY = this.y - 7;
                        ctx.fillStyle = 'red'; ctx.fillRect(this.x, barY, this.width, 5);
                        ctx.fillStyle = '#0F0'; ctx.fillRect(this.x, barY, this.width * (this.hp / this.maxHp), 5);
                    }
                },
                handleInput: function(deltaTime) {
                    if (gameState !== 'PLAYING' && gameState !== 'INVENTORY_OPEN' && gameState !== 'QUESTLOG_OPEN') return;
                    let dx = 0, dy = 0;
                    if (keysPressed['w'] || keysPressed['ArrowUp']) dy -= 1; if (keysPressed['s'] || keysPressed['ArrowDown']) dy += 1;
                    if (keysPressed['a'] || keysPressed['ArrowLeft']) dx -= 1; if (keysPressed['d'] || keysPressed['ArrowRight']) dx += 1;

                    if (this.isConfused()) { let temp = dx; dx = dy; dy = -temp; } 

                    if (dx !== 0 || dy !== 0) {
                        if (dx !== 0 && dy !== 0) { const fact = Math.sqrt(0.5); dx *= fact; dy *= fact; }
                       
                        const currentSpeed = this.speed * (this.statusEffects.find(e => e.name === "C-Burst" || e.name === "Kaos Frenzy")?.data.speedMultiplier || 1);
                        const tileProps = game.mapManager.getTilePropertiesAt(this.x + this.width/2, this.y + this.height/2);
                        const effectiveSpeed = currentSpeed * (tileProps ? tileProps.speedModifier : 1);

                        let nextX = this.x + dx * effectiveSpeed * deltaTime;
                        let nextY = this.y + dy * effectiveSpeed * deltaTime;

                        if (!this.checkCollision({ x: nextX, y: this.y, width: this.width, height: this.height })) this.x = nextX;
                        if (!this.checkCollision({ x: this.x, y: nextY, width: this.width, height: this.height })) this.y = nextY;
                       
                        this.x = Math.max(this.width/2, Math.min(this.x, MAP_WIDTH_TILES * TILE_SIZE - this.width*1.5));
                        this.y = Math.max(this.height/2, Math.min(this.y, MAP_HEIGHT_TILES * TILE_SIZE - this.height*1.5));
                        this.pickupItems();
                    }
                },
                checkCollision: function(rect) {
                    const corners = [ { x: rect.x, y: rect.y }, { x: rect.x + rect.width, y: rect.y }, { x: rect.x, y: rect.y + rect.height }, { x: rect.x + rect.width, y: rect.y + rect.height }];
                    for (const corner of corners) if (game.mapManager.isColliding(corner.x, corner.y)) return true;
                    return false;
                },
                attack: function() {
                    if (Date.now() - this.lastAttackTime < this.attackCooldown) return; this.lastAttackTime = Date.now();
                    addMessage("Melee Disruptor Field Online!"); let attacked = false;
                    enemies.forEach(enemy => {
                        if (distance(this.x + this.width/2, this.y + this.height/2, enemy.x + enemy.width/2, enemy.y + enemy.height/2) < this.attackRange) {
                            enemy.takeDamage(this.attackPower); attacked = true;
                        }
                    });
                    if (!attacked) addMessage("...Disruptor Field hit static.");
                },
                takeDamage: function(amount) { this.hp -= amount; addMessage(`Xperient integrity compromised by ${amount}! Vitality: ${this.hp}/${this.maxHp}`); if (this.hp <= 0) { this.hp = 0; game.gameOver(); } game.hud.update(); },
                heal: function(amount) { this.hp = Math.min(this.hp + amount, this.maxHp); addMessage(`Nanites repaired ${amount} Vitality. Current: ${this.hp}/${this.maxHp}`); game.hud.update(); },
                addItem: function(item) {
                    if (this.inventory.items.length >= this.inventory.capacity && (!item.stackable || !this.inventory.items.find(i => i.id === item.id))) { addMessage("Data-Stash at capacity!"); return false; }
                    const existing = this.inventory.items.find(i => i.id === item.id && item.stackable);
                    if (existing) existing.quantity = (existing.quantity || 1) + (item.quantity || 1); else this.inventory.items.push({...item});
                    addMessage(`Acquired ${item.name} (x${item.quantity || 1}). Stored.`); this.renderInventory(); game.hud.update(); return true;
                },
                removeItem: function(itemId, quantity = 1) {
                    const idx = this.inventory.items.findIndex(i => i.id === itemId);
                    if (idx > -1) { const item = this.inventory.items[idx]; if (item.quantity && item.quantity > quantity) item.quantity -= quantity; else this.inventory.items.splice(idx, 1); this.renderInventory(); game.hud.update(); return true; } return false;
                },
                hasItem: function(itemId, quantity = 1) { const item = this.inventory.items.find(i => i.id === itemId); return item && (item.quantity || 1) >= quantity; },
                useItem: function(itemIndex) {
                    const item = this.inventory.items[itemIndex];
                    if (item) { if (item.effect) item.effect(this); else addMessage(`${item.name} has no direct activation routine.`); if (item.type === 'consumable') this.removeItem(item.id); else addMessage(`Activated ${item.name}.`); this.renderInventory(); game.hud.update(); }
                },
                pickupItems: function() {
                    for (let i = itemsOnMap.length - 1; i >= 0; i--) {
                        const item = itemsOnMap[i];
                        if (AABBCollision(this, item)) { if (this.addItem(game.itemManager.createItemById(item.id, item.quantity))) itemsOnMap.splice(i, 1); else addMessage(`Cannot acquire ${item.name}. Stash full?`);}
                    }
                },
                renderInventory: function() {
                    const invDiv = document.getElementById('inventoryItems'); invDiv.innerHTML = '';
                    if (this.inventory.items.length === 0) { invDiv.innerHTML = '<p>Stash empty. Go acquire some... assets.</p>'; return; }
                    this.inventory.items.forEach((item, index) => {
                        const itemDiv = document.createElement('div'); itemDiv.className = 'inventoryItem';
                        let content = `${item.name} (x${item.quantity || 1}) - <i>${item.description}</i>`;
                        if(item.type === 'consumable' || item.effect) { content += `<button class="button button-use" style="float:right;" onclick="game.player.useItem(${index})">Use</button>`; }
                        itemDiv.innerHTML = content; invDiv.appendChild(itemDiv);
                    });
                },
                useAbility: function(key) {
                    const ability = this.abilities.find(a => a.key === key); if (!ability) return;
                    const now = Date.now();
                    if (now - ability.lastUsedTime >= ability.cooldown) { ability.effect(); ability.lastUsedTime = now; this.updateAbilityStatusDisplay(); }
                    else { addMessage(`${ability.name} subroutine recharging: ${Math.ceil((ability.cooldown - (now - ability.lastUsedTime)) / 1000)}s`); }
                },
                updateAbilityCooldowns: function(dt) { this.updateAbilityStatusDisplay(); },
                updateAbilityStatusDisplay: function() {
                    const div = document.getElementById('abilityStatus');
                    div.innerHTML = 'Subroutines: ' + this.abilities.map(ab => {
                        const cdLeft = Math.max(0, ab.cooldown - (Date.now() - ab.lastUsedTime));
                        return `${ab.name} (${ab.key}) ${cdLeft > 0 ? `(RCHG ${Math.ceil(cdLeft/1000)}s)`: '(RDY)'}`;
                    }).join(' | ');
                },
                applyStatusEffect: function(name, duration, data = {}) {
                    this.statusEffects = this.statusEffects.filter(e => e.name !== name || (e.name === "C-Burst" && e.data.speedMultiplier > data.speedMultiplier)); 
                    const effect = { name, duration, remainingTime: duration, data };
                    
                    if (name === "System Glitch") { addMessage("System Glitch! Input matrix scrambled!"); }
                    else if (name === "Ghosting") { addMessage("Ghosting active. Evading sensors...");}
                    else if (name === "Kaos Frenzy") { addMessage("KAOS FRENZY! Unleash the absurd!"); enemies.forEach(e => { if (distance(this.x, this.y, e.x, e.y) < e.detectionRange * 2.5) e.alertToPosition(this.x, this.y); });}
                    else if (name === "Sys-Marked") { addMessage("System mark acquired! Hostiles prioritizing your signature."); }
                    
                    this.statusEffects.push(effect); this.updatePlayerStatusDisplay();
                },
                updateStatusEffects: function(deltaTime) {
                    for (let i = this.statusEffects.length - 1; i >= 0; i--) {
                        const e = this.statusEffects[i]; e.remainingTime -= deltaTime * 1000;
                        if (e.remainingTime <= 0) { addMessage(`Effect "${e.name}" expired.`); this.statusEffects.splice(i, 1); this.updatePlayerStatusDisplay(); }
                    }
                    const speedBoosts = this.statusEffects.filter(e => e.name === "C-Burst" || e.name === "Kaos Frenzy");
                    let maxMultiplier = 1;
                    if(speedBoosts.length > 0) maxMultiplier = Math.max(...speedBoosts.map(sb => sb.data.speedMultiplier));
                    this.speed = this.baseSpeed * maxMultiplier;

                    this.updatePlayerStatusDisplay();
                },
                hasStatusEffect: (name) => game.player.statusEffects.some(e => e.name === name),
                isStealthed: () => game.player.hasStatusEffect("Ghosting"),
                isConfused: () => game.player.hasStatusEffect("System Glitch"),
                updatePlayerStatusDisplay: function() {
                    const s = document.getElementById('playerStatus');
                    s.textContent = this.statusEffects.length > 0 ? this.statusEffects.map(e => `${e.name}(${Math.ceil(e.remainingTime/1000)}s)`).join(', ') : "Nominal";
                },
                payMoney: function(amount) { if (this.money >= amount) { this.money -= amount; game.hud.update(); return true; } return false; },
                earnMoney: function(amount) { this.money += amount; addMessage(`Creds Acquired: ${amount}c.`); game.hud.update(); }
            },

            itemManager: {
                items: {},
                defineItems: function() { this.items = {
                    'narcotix_pill': { id: 'narcotix_pill', name: "NarcotiX Pill (Generic)", description: "A pill-enabled passport to the bettaverse. Consume for unpredictable effects.", type: 'consumable', buyPrice: 20, sellPrice: 15, stackable: true, effect: (p) => { const r = Math.random(); addMessage("Pill deployed..."); if (r < 0.3) { p.applyStatusEffect("System Glitch", 10000); addMessage("...experiencing input desync!"); } else if (r < 0.6) {p.heal(10); addMessage("...positive feedback loop: +10 Vitality.");} else {p.takeDamage(5); addMessage("...negative resonance cascade: -5 Vitality!");} }},
                    'nanite_repair': { id: 'nanite_repair', name: "Nanite Repair Kit", description: "Restores 50 Vitality. Self-administered.", type: 'consumable', buyPrice: 100, sellPrice: 40, stackable: true, effect: (p) => p.heal(50) },
                    'adrena_rush_injector': { id: 'adrena_rush_injector', name: "Adrena-Rush Injector", description: "Temporary +50% clock speed. Short burst.", type: 'consumable', buyPrice: 75, sellPrice: 30, stackable: true, effect: (p) => p.applyStatusEffect("C-Burst", 10000, { speedMultiplier: 1.5 }) }, // Linked to C-Burst ability for name consistency
                    'kaos_elixir': { id: 'kaos_elixir', name: "Kaos Elixir", description: "Pure, distilled chaos. +30% Speed. ATTRACTS ATTENTION.", type: 'consumable', buyPrice: 150, sellPrice: 60, stackable: false, effect: (p) => { p.applyStatusEffect("Kaos Frenzy", 15000, { speedMultiplier: 1.3 }); }},
                    'xdata_fragment': { id: 'xdata_fragment', name: "Corrupted XData Fragment", description: "Highly sensitive, likely illicit. Needed by a Xemist.", type: 'quest_item', buyPrice: 0, sellPrice: 0, stackable: false }
                };},
                createItemById: function(id, quantity=1) { const def = this.items[id]; if(!def) return null; return {...def, quantity: def.stackable ? quantity : 1}; },
                spawnInitialItems: function() { itemsOnMap = [];
                    for(let i=0; i<20; i++) {
                        let rX = Math.floor(Math.random()*MAP_WIDTH_TILES), rY = Math.floor(Math.random()*MAP_HEIGHT_TILES);
                        let attempts = 0;
                        while((game.mapManager.isColliding(rX*TILE_SIZE,rY*TILE_SIZE) || mapData[rY][rX].type === TILE_TYPES.COOLANT_RESERVOIR) && attempts < 10) {
                            rX = Math.floor(Math.random()*MAP_WIDTH_TILES); rY = Math.floor(Math.random()*MAP_HEIGHT_TILES); attempts++;
                        }
                        if(attempts < 10) {
                             const sItems = Object.keys(this.items).filter(id => this.items[id].type !== 'quest_item');
                            const rId = sItems[Math.floor(Math.random()*sItems.length)]; const iDef = this.items[rId];
                            if (iDef) itemsOnMap.push({ id: rId, x: rX*TILE_SIZE+TILE_SIZE*0.1, y: rY*TILE_SIZE+TILE_SIZE*0.1, width: TILE_SIZE*0.8, height: TILE_SIZE*0.8, name: iDef.name, quantity: iDef.stackable?(Math.floor(Math.random()*3)+1):1});
                        }
                    }
                },
                updateItemsOnMap: function(dt) {},
                renderItemsOnMap: function() { itemsOnMap.forEach(item => {
                    if (item.x + TILE_SIZE > camera.x && item.x < camera.x + camera.width && item.y + TILE_SIZE > camera.y && item.y < camera.y + camera.height) {
                        let char = 'c'; if(item.id === 'nanite_repair') char='+'; else if(item.id.includes('pill')) char='⦾'; else if(item.id.includes('adrena_rush') || item.id.includes('injector')) char='>'; else if(item.id.includes('kaos')) char='!'; else if(item.id.includes('xdata')) char='Җ'; if (item.isEventItem && item.char) char = item.char; // 'X' for Xemist Drop
                        ctx.fillStyle = item.color || '#0FF'; // Changed default to Cyan to match theme
                        ctx.font = `${TILE_SIZE*0.7}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText(char, item.x + item.width/2, item.y + item.height/2 + TILE_SIZE*0.1);
                    }
                });}
            },

            enemyManager: {
                enemyTypes: {},
                initEnemyTypes: function() { this.enemyTypes = {
                    'enforcer': { name: "System Enforcer", char: 'E', color: '#F66', hp: 30, speed: 80, damage: 5, detectionRange: TILE_SIZE * 5, attackRange: TILE_SIZE * 0.9, ai: 'basic_melee', loot: () => { const r=Math.random(); if (r < 0.5) return { money: Math.floor(r*20)+5 }; if (r < 0.7) return { item: game.itemManager.createItemById('narcotix_pill') }; return null;}},
                    'warden': { name: "Zone Warden", char: 'W', color: '#C00', hp: 100, speed: 60, damage: 15, detectionRange: TILE_SIZE * 7, attackRange: TILE_SIZE * 1, ai: 'guard_area', loot: () => ({ money: Math.floor(Math.random()*50)+25, item: (Math.random() < 0.5 ? game.itemManager.createItemById('nanite_repair') : game.itemManager.createItemById('adrena_rush_injector')) }), isBoss: true}, // isBoss used for quest tracking for XData Fragment
                    'drone': { name: "Meta-Patrol Unit", char: 'd', color: '#88F', hp: 20, speed: 120, damage: 0, detectionRange: TILE_SIZE * 8, attackRange: TILE_SIZE * 1.5, ai: 'tagger', attackEffect: (p)=>{ p.applyStatusEffect("Sys-Marked", 30000); addMessage("Meta-Patrol Unit tagged your signature!"); }, loot: () => (Math.random() < 0.2 ? {money: Math.floor(Math.random()*5)+1} : null)}
                };},
                createEnemy: function(typeId, x, y, patrolPath=[]) {
                    const def = this.enemyTypes[typeId]; if(!def) return null;
                    return {
                        id: `e_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`, typeId, x, y, width: TILE_SIZE * 0.8, height: TILE_SIZE * 0.8, ...def, currentHp: def.hp,
                        aiState: 'PATROL', currentPatrolIndex:0, patrolPath, target: null, lastAttackTime: 0, attackCooldown: 1000, alertedPosition: null, isBoss: def.isBoss || false,
                        takeDamage: function(amt) { this.currentHp -= amt; addMessage(`${this.name} integrity failing (-${amt}).`); if (this.currentHp <= 0) this.die(); else if(this.aiState !== 'CHASE' && this.aiState !== 'ATTACK' && !game.player.isStealthed()) { this.aiState='CHASE'; this.target=game.player; addMessage(`${this.name} detected hostile Xperient signature!`); }},
                        die: function() { addMessage(`${this.name} neutralized!`); enemies = enemies.filter(e => e.id !== this.id); const loot = this.loot(); if(loot){if(loot.money)game.player.earnMoney(loot.money); if(loot.item){ itemsOnMap.push({...loot.item, x:this.x, y:this.y, width: TILE_SIZE*0.8, height: TILE_SIZE*0.8}); addMessage(`${this.name} jettisoned: ${loot.item.name}.`);}} game.questManager.notifyEnemyDefeated(this); game.zoneManager.notifyEnemyDefeatedInZone(this);},
                        updateAI: function(dt) {
                            if (game.player.isStealthed() && this.target === game.player && this.aiState !== 'ATTACK') { if (distance(this.x,this.y,game.player.x,game.player.y) > this.detectionRange * 0.85) { this.target = null; this.aiState = 'PATROL'; this.alertedPosition = null; addMessage(`${this.name} lost Xperient signature...`);}}
                           
                            const distToPlayer = distance(this.x,this.y,game.player.x,game.player.y);
                           
                            if(this.alertedPosition){ const dAlert=distance(this.x,this.y,this.alertedPosition.x,this.alertedPosition.y); if(dAlert<TILE_SIZE*0.8){this.alertedPosition=null; if (this.aiState !== 'CHASE' && this.aiState !== 'ATTACK') this.aiState='PATROL';}else{this.moveTo(this.alertedPosition.x,this.alertedPosition.y,dt); return;}}
                           
                            const canSeePlayer = (!game.player.isStealthed() || (this.target === game.player && distToPlayer < this.detectionRange * 0.6));
                            const detectionRadius = (game.player.hasStatusEffect("Sys-Marked")) ? this.detectionRange * 1.5 : this.detectionRange;
                           
                            if(this.aiState === 'ATTACK'){ if(distToPlayer > this.attackRange * 1.2 || (this.target && this.target.hp <= 0)) {this.aiState = 'CHASE';} if(!this.target || this.target.hp <=0) {this.aiState = 'PATROL'; this.target = null;} }
                            else if(this.aiState === 'CHASE'){ if(!this.target || this.target.hp <= 0 || (!canSeePlayer && distToPlayer > detectionRadius * 1.2)){this.aiState = 'PATROL'; this.target = null;} else if(distToPlayer <= this.attackRange) this.aiState = 'ATTACK';}
                            else { /* PATROL or IDLE */ if(canSeePlayer && distToPlayer <= detectionRadius){this.aiState = 'CHASE'; this.target = game.player; addMessage(`${this.name} locked on Xperient signature!`);}}
                           
                            switch(this.aiState){
                                case 'PATROL': if(this.patrolPath && this.patrolPath.length>0){ const pt=this.patrolPath[this.currentPatrolIndex]; if(distance(this.x,this.y,pt.x,pt.y)<TILE_SIZE/2)this.currentPatrolIndex=(this.currentPatrolIndex+1)%this.patrolPath.length; this.moveTo(pt.x,pt.y,dt);}else{ if(Math.random()<0.01*(1/dt) || !this.wanderTarget){this.wanderTarget={x:this.x+(Math.random()-0.5)*TILE_SIZE*5,y:this.y+(Math.random()-0.5)*TILE_SIZE*5};} if(this.wanderTarget){if(distance(this.x,this.y,this.wanderTarget.x,this.wanderTarget.y)<TILE_SIZE/2 || game.mapManager.isColliding(this.wanderTarget.x, this.wanderTarget.y))this.wanderTarget=null;else this.moveTo(this.wanderTarget.x,this.wanderTarget.y,dt);}} break;
                                case 'CHASE': if(this.target) this.moveTo(this.target.x,this.target.y,dt); break;
                                case 'ATTACK': if(this.target && this.target.hp > 0 && Date.now()-this.lastAttackTime>=this.attackCooldown){this.lastAttackTime=Date.now(); if(this.attackEffect)this.attackEffect(this.target); else this.target.takeDamage(this.damage);} break;
                            }
                        },
                        moveTo: function(tx,ty,dt){const dx=tx-this.x, dy=ty-this.y, distVal=Math.sqrt(dx*dx+dy*dy); if(distVal<1)return; const mx=(dx/distVal)*this.speed*dt, my=(dy/distVal)*this.speed*dt; if(!this.checkMapCollision({x:this.x+mx,y:this.y,width:this.width,height:this.height}))this.x+=mx; if(!this.checkMapCollision({x:this.x,y:this.y+my,width:this.width,height:this.height}))this.y+=my;},
                        checkMapCollision: function(rect){const c=[{x:rect.x,y:rect.y},{x:rect.x+rect.width,y:rect.y},{x:rect.x,y:rect.y+rect.height},{x:rect.x+rect.width,y:rect.y+rect.height}]; for(const cn of c)if(game.mapManager.isColliding(cn.x,cn.y))return true; return false;},
                        alertToPosition(x,y){this.alertedPosition={x,y}; if(this.aiState !== 'CHASE' && this.aiState !== 'ATTACK'){this.aiState='CHASE'; addMessage(`${this.name} detected anomaly at Xperient position!`);} else {this.aiState='CHASE';} }
                    };
                },
                spawnEnemy: function(typeId, tileX, tileY, patrolPath=[]) { const newE=this.createEnemy(typeId, tileX*TILE_SIZE, tileY*TILE_SIZE, patrolPath.map(p=>({x:p.x*TILE_SIZE,y:p.y*TILE_SIZE}))); if(newE)enemies.push(newE); },
                spawnInitialEnemies: function() { enemies=[]; this.spawnEnemy('enforcer',15,15,[{x:14,y:14},{x:16,y:14},{x:16,y:16},{x:14,y:16}]); this.spawnEnemy('enforcer',20,25); this.spawnEnemy('drone',25,10); 
                    const bossX=MAP_WIDTH_TILES-10, bossY=MAP_HEIGHT_TILES-10;
                    this.spawnEnemy('warden', bossX, bossY);
                    const doc = game.itemManager.createItemById('xdata_fragment'); if(doc) itemsOnMap.push({...doc, x:bossX*TILE_SIZE, y:(bossY-1)*TILE_SIZE, width:TILE_SIZE*0.8, height:TILE_SIZE*0.8}); 
                    for(let r=0;r<MAP_HEIGHT_TILES;r++)for(let c=0;c<MAP_WIDTH_TILES;c++)if(mapData[r][c].type === TILE_TYPES.HOSTILE_SPAWN_VECTOR && Math.random()<0.3) this.spawnEnemy(Math.random()<0.7?'enforcer':'drone',c,r);
                },
                updateEnemies: function(dt) { for(let i=enemies.length-1;i>=0;i--)enemies[i].updateAI(dt); },
                renderEnemies: function() { enemies.forEach(e => { if(e.x+e.width>camera.x && e.x<camera.x+camera.width && e.y+e.height>camera.y && e.y<camera.y+camera.height){
                    ctx.fillStyle=e.color; ctx.font=`${TILE_SIZE*0.9}px Arial`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(e.char, e.x+e.width/2, e.y+e.height/2+TILE_SIZE*0.1);
                    if(e.currentHp<e.hp){ const bY=e.y-6, bH=4; ctx.fillStyle='#500'; ctx.fillRect(e.x,bY,e.width,bH); ctx.fillStyle=e.color; ctx.fillRect(e.x,bY,e.width*(e.currentHp/e.hp),bH);}}
                });}
            },
           
            hud: { update: function() { document.getElementById('playerHealth').textContent=Math.max(0,Math.ceil(game.player.hp)); document.getElementById('playerMaxHealth').textContent=game.player.maxHp; document.getElementById('playerMoney').textContent=game.player.money; }},

            shopManager: {
                shops: { // Renamed shops based on NarcotiX lore
                    'central_exchange': {name:"Central Exchange Node", welcome:"Accessing Central Exchange... Verified Xperient. Trade at will.", inventory:[{itemId:'nanite_repair',stock:10,basePriceModifier:1.0},{itemId:'adrena_rush_injector',stock:5,basePriceModifier:1.0},{itemId:'narcotix_pill',stock:Infinity,basePriceModifier:1.0}], buys:['narcotix_pill']},
                    'xemist_den': {name:"Xemist Den Interface", welcome:"Signal acquired. This is a... restricted channel. What d'you need?", inventory:[{itemId:'narcotix_pill',stock:Infinity,basePriceModifier:0.8},{itemId:'kaos_elixir',stock:3,basePriceModifier:1.2}], buys:['narcotix_pill','xdata_fragment']},
                    'xlounge_personal': {name:"XLounge (Personal Stash I/O)", welcome:"XLounge Stash Verified. All assets digital. No physical weapons permitted past this interface.", inventory:[{itemId:'nanite_repair', stock:3, basePriceModifier:0.9}], buys:[]}
                },
                initShops: function(){},
                getPriceFluctuationModifier: function(itemId){ const iDef=game.itemManager.items[itemId]; if(!iDef || iDef.type!=='commodity')return 1.0; let mod=1.0; if(itemId==='narcotix_pill')mod*=isDayTime?0.9:1.3; if(game.randomEventManager.isEventActive('Volatility Spike')){const ed=game.randomEventManager.getActiveEventDetails(); if(ed.targetItem===itemId)mod*=ed.priceMultiplier;} return mod;},
                getShopItemPrice: function(shopId,itemId){const s=this.shops[shopId],iDef=game.itemManager.items[itemId],entry=s.inventory.find(si=>si.itemId===itemId); if(!iDef||!entry)return 0; let p=iDef.buyPrice*entry.basePriceModifier*this.getPriceFluctuationModifier(itemId); return Math.ceil(p);},
                getPlayerSellPrice:function(shopId,itemId){const s=this.shops[shopId],iDef=game.itemManager.items[itemId]; if(!iDef||(!s.buys.includes(iDef.id)&&!s.buys.includes(iDef.type)))return 0; return Math.floor(iDef.sellPrice*this.getPriceFluctuationModifier(itemId));},
                populateShopUI: function(shopId){
                    const shop = this.shops[shopId];
                    document.getElementById('shopName').textContent = shop.name;
                    document.getElementById('shopWelcomeMessage').textContent = shop.welcome;
                    const sItemsDiv = document.getElementById('shopItemsForSale');
                    const pItemsDiv = document.getElementById('playerItemsToSell');
                    sItemsDiv.innerHTML = ''; pItemsDiv.innerHTML = '';

                    if (shop.inventory.length === 0 && shopId !== 'xlounge_personal' /* Stash can be empty */) sItemsDiv.innerHTML = "<p>No assets available on this node currently.</p>";
                    else if (shop.inventory.length === 0 && shopId === 'xlounge_personal') sItemsDiv.innerHTML = "<p>Stash node is clean. Secure more assets.</p>"
                    
                    shop.inventory.forEach(entry=>{const iDef=game.itemManager.items[entry.itemId];if(iDef){const p=this.getShopItemPrice(shopId,entry.itemId),div=document.createElement('div');div.className='shopItem'; div.innerHTML=`${iDef.name} - ${p}c (Stock: ${entry.stock > 9000 ? "Abundant" : entry.stock}) <button class="button" onclick="game.shopManager.buyItem('${shopId}','${entry.itemId}')">Acquire</button>`; sItemsDiv.appendChild(div);}});
                   
                    let canSellSomething = false;
                    game.player.inventory.items.forEach(pItem=>{
                        // Quest items that are part of a delivery quest might still be sellable to a specific vendor, even if their 'sellPrice' is 0
                        let sellPriceToThisVendor = this.getPlayerSellPrice(shopId,pItem.id);
                        if (pItem.questItem && game.questManager.isItemDeliverableToShop(pItem.id, shopId)) {
                             const questForThis = game.questManager.activeQuests.find(q => (q.itemToDeliverId === pItem.id || q.itemToFindId === pItem.id) && q.targetNPCId === shopId);
                             if (questForThis && questForThis.reward && questForThis.reward.money) {
                                 // For display purposes, make it clear this is a quest turn in not standard sell
                                 // Actual turn-in logic is handled via questManager.checkDeliverQuestAtShop. This is for visual.
                             }
                        }

                        if(sellPriceToThisVendor > 0 || (pItem.questItem && game.shopManager.shops[shopId].buys.includes(pItem.id)) ){
                            canSellSomething=true; const div=document.createElement('div');div.className='shopItem';
                            div.innerHTML=`${pItem.name} (x${pItem.quantity||1}) - Liquidate for ${sellPriceToThisVendor}c each <button class="button button-sell" onclick="game.shopManager.sellItem('${shopId}','${pItem.id}',1)">Sell 1</button>`;
                            if((pItem.quantity||1)>1){div.innerHTML+=`<button class="button button-sell" style="margin-left:5px;" onclick="game.shopManager.sellItem('${shopId}','${pItem.id}',${pItem.quantity||1})">Sell All</button>`;}
                            pItemsDiv.appendChild(div);
                        }
                    });
                    if (!canSellSomething) pItemsDiv.innerHTML = "<p>This node is not acquiring these asset types.</p>";
                },
                buyItem: function(shopId,itemId){const s=this.shops[shopId],iDef=game.itemManager.items[itemId],entry=s.inventory.find(si=>si.itemId===itemId); if(!iDef||!entry||entry.stock<=0){addMessage("Asset unavailable from this node.");return;}const p=this.getShopItemPrice(shopId,itemId); if(game.player.payMoney(p)){if(game.player.addItem(game.itemManager.createItemById(itemId))){entry.stock--;addMessage(`Acquired ${iDef.name} for ${p}c.`);this.populateShopUI(shopId);} else {game.player.earnMoney(p); addMessage("Data-Stash full. Transaction reversed.")}}else addMessage("Insufficient Creds for this asset.");},
                sellItem: function(shopId,itemId,qty){const iDef=game.itemManager.items[itemId]; if(!iDef || !game.player.hasItem(itemId,qty)){addMessage(`Asset count mismatch: ${qty}x ${iDef.name}.`);return;} const pPI=this.getPlayerSellPrice(shopId,itemId); if(pPI>0 || (iDef.type === 'quest_item' && this.shops[shopId].buys.includes(itemId))){game.player.removeItem(itemId,qty);const tot=(pPI * qty) || 0;game.player.earnMoney(tot);addMessage(`Liquidated ${qty}x ${iDef.name} for ${tot}c.`); const entry=this.shops[shopId].inventory.find(si=>si.itemId===itemId); if(entry && game.itemManager.items[itemId].type !== 'quest_item')entry.stock+=qty; this.populateShopUI(shopId);}else addMessage("Node not acquiring this asset type currently.");}
            },

            questManager: { // Renamed quests and quest giver
                availableQuests: [], activeQuests: [],
                initQuests: function(){ this.availableQuests = [
                    {id:'q_deliver_xdata',title:"Hot XData Packet Delivery",giverId:'glitch_codex',description:"A priority XData packet (5 NarcotiX Pills) needs to reach the Xemist Den. Discretion paramount.",type:'DELIVER_ITEM_TO_NPC',itemToDeliverId:'narcotix_pill',quantity:5,targetNPCId:'xemist_den',reward:{money:100, item:game.itemManager.createItemById('nanite_repair',1)},isCompleted:false,isAccepted:false,onAccept:()=>{const item=game.itemManager.createItemById('narcotix_pill',5); item.name += " (Secure Packet)"; item.questItem=true; if(game.player.addItem(item)){addMessage("Glitch_Codex transfers secure packet.");return true;}else{addMessage("Insufficient Stash capacity for packet!");return false;}},checkCompletion:()=>{return false;}},
                    {id:'q_defrag_zone',title:"Defrag Corrupted Zone Epsilon",giverId:'glitch_codex',description:"Corrupted Zone Epsilon (NW of XLounge Stash) is overrun by 2 System Enforcers. Sanitize the area.",type:'CLEAR_ZONE',targetZoneId:'zone_epsilon',targetEnemyType:'enforcer',requiredKills:2,currentKills:0,reward:{money:150,item:game.itemManager.createItemById('adrena_rush_injector')},isCompleted:false,isAccepted:false,onAccept:()=>{addMessage("Protocol: Defrag Zone Epsilon - ACCEPTED.");return true;},checkCompletion:function(){return this.currentKills>=this.requiredKills;}},
                    {id:'q_retrieve_formula',title:"Retrieve Leaked Xemist Formula",giverId:'glitch_codex',description:"A Zone Warden (SE Quadrant) is holding a critical XData Fragment. Secure it and return to Glitch_Codex.",type:'FIND_ITEM',itemToFindId:'xdata_fragment',reward:{money:250,item:game.itemManager.createItemById('kaos_elixir')},isCompleted:false,isAccepted:false,onAccept:()=>{addMessage("Protocol: Retrieve XData Fragment - ACCEPTED.");return true;},checkCompletion:function(){return game.player.hasItem(this.itemToFindId);}}
                ]; this.activeQuests=[]; this.renderQuestLog();},
                interactWithQuestGiver: function(giverId){
                    const activeReadyForTurnIn = this.activeQuests.find(q=>(q.giverId===giverId || q.type==='FIND_ITEM' && q.giverId===giverId) && q.checkCompletion&&q.checkCompletion()&&!q.isCompleted);
                    if(activeReadyForTurnIn) { this.completeQuest(activeReadyForTurnIn); return;}

                    const avail=this.availableQuests.filter(q=>q.giverId===giverId&&!q.isAccepted&&!q.isCompleted);
                    if(avail.length>0){const qOffer=avail[0]; const accept=confirm(`[${giverId}]: Encrypted transmission incoming...\nProtocol: ${qOffer.title}\nObjective: "${qOffer.description}"\nReward on completion: ${this.getRewardString(qOffer.reward)}\n:: Accept Transmission?`); if(accept)this.acceptQuest(qOffer);}
                    else if(this.activeQuests.some(q=>q.giverId===giverId))addMessage(`[${giverId}]: Active protocol ${this.activeQuests.find(q=>q.giverId===giverId).title} is still pending.`); else addMessage(`[${giverId}]: No further protocols available. Standby.`);
                },
                getRewardString:function(r){let s="";if(r.money)s+=`${r.money}c `; if(r.item)s+=`${r.item.name}(x${r.item.quantity||1})`; return s.trim()||"System Acknowledgment";},
                acceptQuest: function(q){if(q.onAccept&&!q.onAccept()){return;} q.isAccepted=true; this.activeQuests.push(q); const idx=this.availableQuests.findIndex(aq=>aq.id===q.id);if(idx>-1)this.availableQuests.splice(idx,1);addMessage(`Protocol "${q.title}" accepted. Details in log.`);this.renderQuestLog();game.hud.update();},
                completeQuest: function(q){q.isCompleted=true;addMessage(`Protocol "${q.title}" completed! Reward: ${this.getRewardString(q.reward)}`); if(q.reward.money)game.player.earnMoney(q.reward.money); if(q.reward.item){const iR=game.itemManager.createItemById(q.reward.item.id,q.reward.item.quantity);if(iR)game.player.addItem(iR);} if((q.type==='DELIVER_ITEM_TO_NPC'||q.type==='FIND_ITEM') && (q.itemToDeliverId || q.itemToFindId))game.player.removeItem(q.itemToDeliverId||q.itemToFindId,q.quantity||1); this.activeQuests=this.activeQuests.filter(aq=>aq.id!==q.id);this.renderQuestLog();game.hud.update();},
                notifyEnemyDefeated: function(e){this.activeQuests.forEach(q=>{if(q.type==='CLEAR_ZONE'&&!q.isCompleted){if(q.targetEnemyType && e.typeId !== q.targetEnemyType) return; const zone=game.zoneManager.getZoneById(q.targetZoneId); if(zone && game.zoneManager.isEnemyInZone(e,zone)){q.currentKills=(q.currentKills||0)+1;addMessage(`Protocol(${q.title}): ${q.currentKills}/${q.requiredKills} hostiles neutralized in ${zone.name}.`);if(q.checkCompletion&&q.checkCompletion()){addMessage(`Objective for "${q.title}" achieved! Report to ${q.giverId}.`);}}}}); this.renderQuestLog();game.hud.update();},
                checkDeliverQuestAtShop: function(shopId) {
                    const qToDeliver = this.activeQuests.find(q=>q.type==='DELIVER_ITEM_TO_NPC'&&q.targetNPCId===shopId&&!q.isCompleted);
                    if(qToDeliver){
                        const itemDef = game.itemManager.items[qToDeliver.itemToDeliverId];
                        const itemNameForQuest = itemDef ? (itemDef.name + (qToDeliver.itemToDeliverId === 'narcotix_pill' ? " (Secure Packet)" : "")) : qToDeliver.itemToDeliverId;

                        if(game.player.hasItem(qToDeliver.itemToDeliverId, qToDeliver.quantity)){
                             if(confirm(`Deliver ${qToDeliver.quantity}x ${itemNameForQuest} for Protocol "${qToDeliver.title}" to this contact?`)){this.completeQuest(qToDeliver);return true;}}
                        else {addMessage(`Need ${qToDeliver.quantity}x ${itemNameForQuest} for Protocol "${qToDeliver.title}".`); return false; }
                    } return false;
                },
                isItemDeliverableToShop: function(itemId, shopId) { // Helper for shop UI
                    return this.activeQuests.some(q => q.type === 'DELIVER_ITEM_TO_NPC' && q.itemToDeliverId === itemId && q.targetNPCId === shopId && !q.isCompleted);
                },
                renderQuestLog: function(){
                    const div=document.getElementById('activeQuestsDisplay');div.innerHTML='';
                    const hudQuestTitle = document.getElementById('activeQuestTitle');
                    if(this.activeQuests.length===0){div.innerHTML='<p>No active protocols. Interface with Xemist contacts for new directives.</p>'; hudQuestTitle.textContent="None"; return;}
                   
                    this.activeQuests.forEach(q=>{
                        const qDiv=document.createElement('div');qDiv.className='questItem';let stat="";
                        const itemToDeliverDef = q.itemToDeliverId ? game.itemManager.items[q.itemToDeliverId] : null;
                        const itemToFindDef = q.itemToFindId ? game.itemManager.items[q.itemToFindId] : null;

                        if(q.type==='CLEAR_ZONE')stat=` (${q.currentKills||0}/${q.requiredKills||'N/A'} hostiles)`;
                        else if(q.type==='FIND_ITEM') stat = game.player.hasItem(q.itemToFindId) ? ` (${itemToFindDef?itemToFindDef.name:q.itemToFindId} Acquired!)` : ` (${itemToFindDef?itemToFindDef.name:q.itemToFindId} Not Secured)`;
                        else if(q.type==='DELIVER_ITEM_TO_NPC') {
                             const playerQty = game.player.inventory.items.find(i=>i.id===q.itemToDeliverId)?.quantity || 0;
                             const itemNameForQuest = itemToDeliverDef ? (itemToDeliverDef.name + (q.itemToDeliverId === 'narcotix_pill' ? " (Secure Packet)" : "")) : q.itemToDeliverId;
                             stat = playerQty >= q.quantity ? ` (${itemNameForQuest} Ready for Transfer)` : ` (Need ${q.quantity - playerQty} more ${itemNameForQuest})`;
                        }
                        if(q.checkCompletion&&q.checkCompletion() && (q.type !== 'DELIVER_ITEM_TO_NPC') )stat+=" (Return to Contact!)";
                        else if (q.checkCompletion && q.checkCompletion() && q.type === 'DELIVER_ITEM_TO_NPC') stat += " (Deliver to Target Node!)";
                        qDiv.innerHTML=`<b>${q.title}</b>: <i>${q.description}</i>${stat}`;div.appendChild(qDiv);
                    });
                    const firstActive = this.activeQuests[0];
                    hudQuestTitle.textContent = firstActive.title.substring(0,20) + (firstActive.title.length > 20 ? "..." : "");
                },
                renderQuestMarkers: function(){this.availableQuests.forEach(q=>{if(!q.isAccepted){const gLoc=this.findLocation(q.giverId,'xemist_contact_point');if(gLoc)this.drawMarker(gLoc.x,gLoc.y,"!","yellow");}}); this.activeQuests.forEach(q=>{if(!q.isCompleted){let tLoc;let markerChar="?"; let markerCol="white"; if(q.type==='DELIVER_ITEM_TO_NPC'){tLoc=this.findLocation(q.targetNPCId,'exchange_node_entrance', q.targetNPCId); markerCol="cyan";}else if(q.type==='CLEAR_ZONE'){const z=game.zoneManager.getZoneById(q.targetZoneId);if(z)tLoc={x:z.x+z.width/2,y:z.y+z.height/2}; markerChar="X";markerCol="red";}else if(q.type==='FIND_ITEM'){const itm=itemsOnMap.find(i=>i.id===q.itemToFindId);if(itm)tLoc={x:itm.x,y:itm.y};else{const b=enemies.find(e=>e.isBoss && e.typeId === 'warden'); if(b && !game.player.hasItem(q.itemToFindId))tLoc={x:b.x,y:b.y};} markerChar="Җ"; markerCol="lightblue";} if(q.checkCompletion&&q.checkCompletion()){const gLoc=this.findLocation(q.giverId,'xemist_contact_point');if(gLoc){tLoc=gLoc; markerChar="?"; markerCol="lime";}} if(tLoc)this.drawMarker(tLoc.x,tLoc.y,markerChar,markerCol);}});},
                findLocation: function(targetId, tilePropertyType, shopOrContactId = null){
                    for(let r=0;r<MAP_HEIGHT_TILES;r++)for(let c=0;c<MAP_WIDTH_TILES;c++){
                        const t=mapData[r][c]; const tProp = TILE_PROPERTIES[t.type];
                        if(tProp && tProp.interactive && tProp.type === tilePropertyType && t.interactionTargetId === (shopOrContactId || targetId) ){
                            return{x:c*TILE_SIZE+TILE_SIZE/2,y:r*TILE_SIZE+TILE_SIZE/2};
                        }
                    } return null;},
                drawMarker: function(wX,wY,char,col){if(wX>camera.x-TILE_SIZE && wX<camera.x+camera.width+TILE_SIZE && wY>camera.y-TILE_SIZE && wY<camera.y+camera.height+TILE_SIZE){ctx.fillStyle=col;ctx.font=`bold ${TILE_SIZE*0.9}px Arial`;ctx.textAlign='center';ctx.textBaseline='bottom';ctx.fillText(char,wX,wY-TILE_SIZE/2);}},
            },

            zoneManager: { // Renamed zones
                zones:[], controlDurationThreshold:30000, passiveIncomeInterval:60000,
                initZones: function(){this.zones=[ 
                    {id:'zone_epsilon',name:"Corrupted Zone Epsilon",x:12*TILE_SIZE,y:12*TILE_SIZE,width:6*TILE_SIZE,height:6*TILE_SIZE,isControlledByPlayer:false,controlTimer:0,incomeTimer:0,enemiesInZone:0,initialEnemiesToClear:2, incomeValue: 75},
                    {id:'exchange_fringe',name:"Exchange Node Fringe",x:5*TILE_SIZE,y:5*TILE_SIZE,width:12*TILE_SIZE,height:12*TILE_SIZE,isControlledByPlayer:false,controlTimer:0,incomeTimer:0,enemiesInZone:0,initialEnemiesToClear:3, incomeValue: 120}
                ]; this.zones.forEach(z=>this.updateEnemyCountInZone(z));},
                update: function(dt){this.zones.forEach(z=>{this.updateEnemyCountInZone(z); if(z.enemiesInZone===0&&!z.isControlledByPlayer){z.controlTimer+=dt*1000; if(z.controlTimer>=this.controlDurationThreshold){z.isControlledByPlayer=true;z.incomeTimer=0;addMessage(`Zone "${z.name}" Secured. Yielding passive compounds (Creds).`);}}else if(z.enemiesInZone>0&&z.isControlledByPlayer){z.isControlledByPlayer=false;z.controlTimer=0;addMessage(`Zone "${z.name}" integrity compromised by hostiles!`);} if(z.isControlledByPlayer){z.incomeTimer+=dt*1000; if(z.incomeTimer>=this.passiveIncomeInterval){const inc= z.incomeValue || 50;game.player.earnMoney(inc);addMessage(`+${inc}c compound yield from ${z.name}.`);z.incomeTimer=0;}}});},
                updateDailyZoneResets: function(){this.zones.forEach(z=>{if(z.isControlledByPlayer||z.enemiesInZone===0){if(Math.random()<0.4){this.respawnEnemiesInZone(z,Math.ceil(z.initialEnemiesToClear/2)+Math.floor(Math.random()*2)); addMessage(`System entities repopulating ${z.name}!`); z.isControlledByPlayer=false;z.controlTimer=0;}}});},
                respawnEnemiesInZone:function(z,cnt){for(let i=0;i<cnt;i++){let att=0,spawned=false; while(att<10&&!spawned){const sX=z.x+Math.random()*z.width,sY=z.y+Math.random()*z.height; if(!game.mapManager.isColliding(sX,sY)){game.enemyManager.spawnEnemy(Math.random()<0.7?'enforcer':'drone',Math.floor(sX/TILE_SIZE),Math.floor(sY/TILE_SIZE));spawned=true;}att++;}}this.updateEnemyCountInZone(z);},
                updateEnemyCountInZone:function(z){let cnt=0;enemies.forEach(e=>{if(this.isEnemyInZone(e,z))cnt++;});z.enemiesInZone=cnt;},
                isEnemyInZone:function(e,z){const eX=e.x+e.width/2,eY=e.y+e.height/2; return eX>=z.x&&eX<=z.x+z.width&&eY>=z.y&&eY<=z.y+z.height;},
                getZoneById:function(id){return this.zones.find(z=>z.id===id);},
                notifyEnemyDefeatedInZone:function(e){ /* Covered by quest manager */},
                render:function(){this.zones.forEach(z=>{if(z.x+z.width>camera.x && z.x<camera.x+camera.width && z.y+z.height>camera.y && z.y<camera.y+camera.height){ctx.globalAlpha=0.15; let col; if(z.isControlledByPlayer)col='rgba(0,255,0,0.5)'; else if(z.enemiesInZone>0)col='rgba(255,0,0,0.5)'; else col='rgba(255,255,0,0.4)';ctx.fillStyle=col;ctx.fillRect(z.x,z.y,z.width,z.height);ctx.globalAlpha=0.6;ctx.fillStyle='#EEE';ctx.font='10px Courier New';ctx.textAlign='center';ctx.fillText(z.name,z.x+z.width/2,z.y+12);ctx.globalAlpha=1.0;}});}
            },

            randomEventManager: { // Renamed events
                activeEvent: null, eventCheckInterval:20000, lastEventCheckTime:0,
                possibleEvents: [
                    {name:"System Integrity Sweep",duration:60000,start:()=>{addMessage("EVENT: System Integrity Sweep Active! Increased Meta-Patrol Unit presence.");const q=Math.floor(Math.random()*4);let sX=0,sY=0,qW=MAP_WIDTH_TILES/2,qH=MAP_HEIGHT_TILES/2;if(q===1)sX=MAP_WIDTH_TILES/2;if(q===2)sY=MAP_HEIGHT_TILES/2;if(q===3){sX=MAP_WIDTH_TILES/2;sY=MAP_HEIGHT_TILES/2;} for(let i=0;i<3+Math.floor(Math.random()*3);i++){const rX=Math.floor(sX+Math.random()*qW),rY=Math.floor(sY+Math.random()*qH); if(!game.mapManager.isColliding(rX*TILE_SIZE,rY*TILE_SIZE))game.enemyManager.spawnEnemy('drone',rX,rY);} return{q};},end:(data)=>{addMessage("EVENT: System Integrity Sweep Concluded.");}},
                    {name:"Xemist Airdrop",duration:90000,start:()=>{let dX,dY,p=false;for(let i=0;i<20;i++){dX=Math.floor(Math.random()*MAP_WIDTH_TILES);dY=Math.floor(Math.random()*MAP_HEIGHT_TILES);if(!game.mapManager.isColliding(dX*TILE_SIZE,dY*TILE_SIZE) && mapData[dY][dX].type !== TILE_TYPES.COOLANT_RESERVOIR){p=true;break;}}if(!p){dX=MAP_WIDTH_TILES/2;dY=MAP_HEIGHT_TILES/2;} const itemPool=['nanite_repair','adrena_rush_injector','kaos_elixir']; const vItm=itemPool[Math.floor(Math.random()*itemPool.length)],qty=1,sId=`sd_${Date.now()}`;itemsOnMap.push({id:vItm,name:game.itemManager.items[vItm].name,x:dX*TILE_SIZE,y:dY*TILE_SIZE,width:TILE_SIZE,height:TILE_SIZE,char:'X',color:'#0F0',isEventItem:true,eventItemId:sId,quantity:qty});addMessage(`EVENT: Xemist Airdrop detected at grid (${dX},${dY})! Contains: ${game.itemManager.items[vItm].name}.`);return{eventItemId:sId, dropX: dX, dropY: dY};},end:(data)=>{itemsOnMap=itemsOnMap.filter(itm=>!(itm.isEventItem&&itm.eventItemId===data.eventItemId));addMessage("EVENT: Xemist Airdrop secured or degraded.");}},
                    {name:"Exchange Volatility Spike",duration:120000,start:()=>{const comId='narcotix_pill'; if(!game.itemManager.items[comId]) return null; const pM=1.4+Math.random()*0.4;addMessage(`EVENT: Volatility Spike for ${game.itemManager.items[comId].name}! Liquidation prices are ${Math.round(pM*100-100)}% higher!`);return{targetItem:comId,priceMultiplier:pM};},end:(data)=>{addMessage(`EVENT: Volatility Spike for ${game.itemManager.items[data.targetItem].name} has normalized.`);}}
                ],
                update: function(dt){const now=Date.now();if(this.activeEvent){if(now>=this.activeEvent.endTime){if(this.activeEvent.definition.end)this.activeEvent.definition.end(this.activeEvent.data);this.activeEvent=null;}}else{if(now-this.lastEventCheckTime>=this.eventCheckInterval){this.lastEventCheckTime=now;if(Math.random()<0.2)this.triggerRandomEvent();}}},
                triggerRandomEvent: function(){if(this.activeEvent||this.possibleEvents.length===0)return;const eDef=this.possibleEvents[Math.floor(Math.random()*this.possibleEvents.length)]; const eData=eDef.start?eDef.start():{}; if(eData===null)return; this.activeEvent={definition:eDef,startTime:Date.now(),endTime:Date.now()+eDef.duration,data:eData};addMessage(`Event Initialized: ${eDef.name}`);},
                isEventActive: function(eName){return this.activeEvent&&this.activeEvent.definition.name===eName;},
                getActiveEventDetails: function(){if(this.activeEvent)return{name:this.activeEvent.definition.name,...this.activeEvent.data};return null;}
            },
           
            update: function(deltaTime) {
                if (gameState === 'GAME_OVER') return;
               
                this.player.updateAbilityCooldowns(deltaTime);
                this.player.updateStatusEffects(deltaTime);
                this.player.updatePlayerStatusDisplay();

                if (gameState === 'PLAYING' || gameState === 'INVENTORY_OPEN' || gameState === 'QUESTLOG_OPEN') {
                    gameTime += deltaTime * 1000;
                    const gameMins = Math.floor(gameTime / (TICKS_PER_GAME_MINUTE * 1000));
                    const newPhase = Math.floor(gameMins / GAME_MINUTES_PER_DAY) + 1; // Day -> Phase
                    const minsInPhase = gameMins % GAME_MINUTES_PER_DAY;
                    const hrs = Math.floor(minsInPhase / 60); const mins = minsInPhase % 60;
                    if (newPhase > currentDay) { currentDay = newPhase; addMessage(`Phase ${currentDay} initiated.`); this.zoneManager.updateDailyZoneResets();this.shopManager.shops['central_exchange'].inventory.find(i=>i.itemId==='nanite_repair').stock=10;this.shopManager.shops['xemist_den'].inventory.find(i=>i.itemId==='kaos_elixir').stock=3;}
                    isDayTime = hrs >= 6 && hrs < 18; // isHighTraffic (day) vs isLowTraffic (night)
                    document.getElementById('gameTimeDisplay').textContent = `Phase ${currentDay} - ${String(hrs).padStart(2,'0')}:${String(mins).padStart(2,'0')} (${isDayTime?'High Traffic':'Low Traffic'})`;
                   
                    this.player.handleInput(deltaTime);

                    if (gameState === 'PLAYING') {
                        camera.update(this.player);
                        this.enemyManager.updateEnemies(deltaTime);
                        this.itemManager.updateItemsOnMap(deltaTime);
                        this.zoneManager.update(deltaTime);
                        this.randomEventManager.update(deltaTime);
                    }
                }
                this.hud.update();
                processTutorialQueue();
            },
            render: function() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save(); ctx.translate(-camera.x, -camera.y);
                this.mapManager.render();
                this.zoneManager.render(); 
                this.itemManager.renderItemsOnMap();
                this.enemyManager.renderEnemies();
                this.player.render();
                this.questManager.renderQuestMarkers();
                ctx.restore();
                if (gameState === 'GAME_OVER') {
                    ctx.fillStyle = 'rgba(0,0,0,0.85)'; ctx.fillRect(0,0,canvas.width,canvas.height);
                    ctx.fillStyle = 'red'; ctx.font = '48px Courier New'; ctx.textAlign = 'center';
                    ctx.fillText('S Y S T E M _ F A I L U R E', canvas.width/2, canvas.height/2 - 20);
                    ctx.font = '24px Courier New'; ctx.fillStyle = '#0FF';
                    ctx.fillText('Press R to Re-initialize Sequence', canvas.width/2, canvas.height/2 + 30);
                }
            },
            gameOver: function() { gameState = 'GAME_OVER'; addMessage("Critical System Failure. Xperient signature lost."); },
            restartGame: function() {
                mapData=[]; itemsOnMap=[]; enemies=[]; gameTime=0; currentDay=1;
                tutorialQueue.forEach(t=>t.shown=false); currentTutorial=null; document.getElementById('tutorialPopup').style.display='none';
                document.getElementById('inventoryItems').innerHTML=''; document.getElementById('shopItemsForSale').innerHTML=''; document.getElementById('playerItemsToSell').innerHTML=''; document.getElementById('activeQuestsDisplay').innerHTML='';
                gameMessages.length=0; renderMessages();
                gameState = 'PLAYING'; this.init(); addMessage("Re-initializing NarcotiX Game Client...");
            },
            openShop: function(shopId) { // shopId is now the unique key like 'central_exchange'
                let questActionTaken = false;
                if (this.questManager.activeQuests.some(q => q.targetNPCId === shopId && q.type === 'DELIVER_ITEM_TO_NPC' && !q.isCompleted)) {
                     questActionTaken = this.questManager.checkDeliverQuestAtShop(shopId);
                }
                // If a delivery quest was handled and it didn't explicitly prevent shop opening (e.g. insufficient items), or if no delivery quest active for this shop.
                if(!questActionTaken || (questActionTaken && game.player.hasItem(this.questManager.activeQuests.find(q=>q.targetNPCId===shopId && q.type === 'DELIVER_ITEM_TO_NPC')?.itemToDeliverId))) {
                    const shopData = this.shopManager.shops[shopId]; 
                    if (!shopData) { addMessage("Node connection failed or unauthorized access."); return; }
                    gameState = 'SHOP_MENU';
                    this.shopManager.populateShopUI(shopId);
                    document.getElementById('shopInterface').style.display = 'block';
                    document.getElementById('inventoryDisplay').style.display='none';
                    document.getElementById('questLog').style.display='none';
                }
            },
            closeShop: function() { gameState = 'PLAYING'; document.getElementById('shopInterface').style.display = 'none'; addMessage("Disconnected from interface node."); },
            toggleInventory: function() {
                const d = document.getElementById('inventoryDisplay');
                if (gameState === 'SHOP_MENU') return; 
                if (d.style.display === 'block') { d.style.display = 'none'; if(gameState === 'INVENTORY_OPEN') gameState = 'PLAYING'; }
                else { this.player.renderInventory(); d.style.display = 'block'; if(gameState === 'PLAYING') gameState = 'INVENTORY_OPEN'; document.getElementById('questLog').style.display='none';}
            },
            toggleQuestLog: function() {
                const d = document.getElementById('questLog');
                if (gameState === 'SHOP_MENU') return; 
                if (d.style.display === 'block') { d.style.display = 'none'; if(gameState === 'QUESTLOG_OPEN') gameState = 'PLAYING'; }
                else { this.questManager.renderQuestLog(); d.style.display = 'block'; if(gameState === 'PLAYING') gameState = 'QUESTLOG_OPEN'; document.getElementById('inventoryDisplay').style.display='none';}
            },
            interact: function() {
                if (gameState !== 'PLAYING') return;

                const pCenterTileX = Math.floor((this.player.x + this.player.width/2)/TILE_SIZE);
                const pCenterTileY = Math.floor((this.player.y + this.player.height/2)/TILE_SIZE);
                const dirs = [[0,0],[0,-1],[0,1],[-1,0],[1,0], [-1,-1],[-1,1],[1,-1],[1,1]];
                
                for (const [dx,dy] of dirs) {
                    const cX=pCenterTileX+dx, cY=pCenterTileY+dy;
                    if(this.mapManager.isValidTile(cX,cY)){
                        const tileData = mapData[cY][cX];
                        const tileProps = TILE_PROPERTIES[tileData.type];
                        if(tileProps && tileProps.interactive){
                            const tileWorldX = cX * TILE_SIZE + TILE_SIZE/2;
                            const tileWorldY = cY * TILE_SIZE + TILE_SIZE/2;
                            if (distance(this.player.x + this.player.width/2, this.player.y + this.player.height/2, tileWorldX, tileWorldY) <= TILE_SIZE * 1.2) {
                                if(tileData.interactionType){
                                    // Map interactionType from tile to shopId/questGiverId which are keys in shopManager/questManager
                                    // This assumes interactionTargetId on the tile *is* the key for the shop/quest giver
                                    if (tileData.interactionType === 'exchange_node' || tileData.interactionType === 'xlounge_stash') {
                                        this.openShop(tileData.interactionTargetId); return;
                                    } else if (tileData.interactionType === 'xemist_contact') {
                                        this.questManager.interactWithQuestGiver(tileData.interactionTargetId); return;
                                    }
                                }
                            }
                        }
                    }
                }
                addMessage("No interactive elements detected in proximity.");
            },
            getVisibleTiles: function() { const sC=Math.max(0,Math.floor(camera.x/TILE_SIZE)),eC=Math.min(MAP_WIDTH_TILES, sC+Math.ceil(camera.width/TILE_SIZE)+1),sR=Math.max(0,Math.floor(camera.y/TILE_SIZE)),eR=Math.min(MAP_HEIGHT_TILES, sR+Math.ceil(camera.height/TILE_SIZE)+1); return{startCol:sC,endCol:eC,startRow:sR,endRow:eR};}
        };

        // Input Handling
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            keysPressed[key] = true;

            if (key === 'escape') {
                if (document.getElementById('shopInterface').style.display === 'block') game.closeShop();
                else if (document.getElementById('inventoryDisplay').style.display === 'block') game.toggleInventory();
                else if (document.getElementById('questLog').style.display === 'block') game.toggleQuestLog();
                else if (gameState === 'PLAYING') { addMessage("Pause sequence (ESC)... Resuming operations."); } // Basic pause concept
                return; 
            }

            if (gameState === 'GAME_OVER' && key === 'r') { game.restartGame(); return;}
            if (gameState === 'SHOP_MENU') return; 

            if (key >= '1' && key <= '3') game.player.useAbility(key);
            if (key === 'i') game.toggleInventory();
            if (key === 'j') game.toggleQuestLog();
            
            if (gameState === 'PLAYING' || gameState === 'INVENTORY_OPEN' || gameState === 'QUESTLOG_OPEN') {
                if (key === 'e') game.interact();
                if (key === ' ') { e.preventDefault(); game.player.attack(); }
            }
        });
        window.addEventListener('keyup', (e) => { keysPressed[e.key.toLowerCase()] = false; });

        function gameLoop(currentTime) {
            const deltaTime = Math.min(0.1, (currentTime - lastTime) / 1000);
            lastTime = currentTime;

            frameCount++;
            if (currentTime - lastFpsUpdateTime > fpsUpdateInterval) {
                fps = Math.round(frameCount / ((currentTime - lastFpsUpdateTime)/1000));
                frameCount = 0; lastFpsUpdateTime = currentTime;
                document.getElementById('fpsDisplay').textContent = fps;
            }
           
            game.update(deltaTime);
            game.render();
            requestAnimationFrame(gameLoop);
        }

        window.onload = () => {
            game.init();
            lastTime = performance.now(); lastFpsUpdateTime = lastTime;
            requestAnimationFrame(gameLoop);
        };
    </script>
</body>
</html>