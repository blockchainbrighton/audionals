<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GenSynth</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            padding-top: 50px;
            background-color: #f0f0f0;
        }
        button {
            font-size: 18px;
            padding: 15px 30px;
            cursor: pointer;
        }
        #status {
            margin-top: 20px;
            font-size: 16px;
            color: #333;
        }
    </style>
</head>
<body>
    <button id="generate-button">Generate Sound</button>
    <div id="status"></div>

    <script>
        (() => {
            'use strict';

            // -------------------------
            // Synthesizer Object
            // -------------------------
            const Synthesizer = {
                context: null,
                masterGain: null,
                BPM: 120.0,
                isLoopActive: false,
                activeOscillators: new Set(),
                random: null,
                seed: null,
                currentScaleData: null,

                init() {
                    this.initAudioContext();
                    this.initRandom();
                    this.initMasterGain();
                    this.addEventListeners();
                },

                initAudioContext() {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('Audio Context initialized:', this.context);
                },

                initRandom() {
                    const fixedSeed = null; // Set to a number for deterministic results
                    this.seed = (fixedSeed !== null && isFinite(fixedSeed)) ? fixedSeed : Math.floor(Math.random() * 0xFFFFFFFF);
                    this.random = this.mulberry32(this.seed);
                    console.log(`Current Seed: ${this.seed}`);
                },

                initMasterGain() {
                    this.masterGain = this.context.createGain();
                    this.masterGain.connect(this.context.destination);
                    console.log('Master Gain connected to destination.');
                },

                addEventListeners() {
                    const generateButton = document.getElementById('generate-button');
                    if (generateButton) {
                        generateButton.addEventListener('click', () => {
                            if (this.isLoopActive) {
                                console.warn('A loop is already active. Please wait until it finishes.');
                                return;
                            }
                            try {
                                this.generateRandomLoop();
                            } catch (error) {
                                console.error('Error generating loop:', error);
                            }
                        });
                    } else {
                        console.error('Generate Button not found in the DOM.');
                    }

                    // Cleanup on page unload
                    window.addEventListener('beforeunload', () => {
                        console.log('Page is unloading. Cleaning up any active loops.');
                        this.cleanupLoop();
                    });

                    // Performance logging every 10 seconds
                    setInterval(() => {
                        console.log('--- 10-Second Performance Report ---');
                        console.log(`Is Loop Active: ${this.isLoopActive}`);
                        console.log(`Audio Context State: ${this.context.state}`);
                        console.log(`Current BPM: ${this.isLoopActive ? this.BPM.toFixed(2) : 'N/A'}`);
                        console.log('-------------------------------------');
                    }, 10000);
                },

                // -------------------------
                // Utility Functions
                // -------------------------
                mulberry32(a) {
                    return () => {
                        let t = a += 0x6D2B79F5;
                        t = Math.imul(t ^ (t >>> 15), t | 1);
                        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
                    };
                },

                clamp(v, min, max) {
                    return isFinite(v) ? Math.min(Math.max(v, min), max) : min;
                },

                setAudioParam(param, value, time) {
                    if (isFinite(value)) {
                        param.setValueAtTime(value, time);
                    } else {
                        console.warn(`Invalid value (${value}) for AudioParam. Using default value.`);
                        param.setValueAtTime(0, time);
                    }
                },

                rampAudioParam(param, value, time) {
                    if (isFinite(value)) {
                        param.linearRampToValueAtTime(value, time);
                    } else {
                        console.warn(`Invalid ramp value (${value}) for AudioParam.`);
                    }
                },

                updateStatus(msg) {
                    console.log(`Status Update: ${msg}`);
                    const statusElement = document.getElementById('status');
                    if (statusElement) {
                        statusElement.textContent = msg;
                    } else {
                        console.warn('Status element not found in the DOM.');
                    }
                },

                // -------------------------
                // BPM and Timing Utilities
                // -------------------------
                beatsToSeconds(beats) {
                    return parseFloat((beats * 60 / this.BPM).toFixed(2));
                },

                beatsToMilliseconds(beats) {
                    return this.beatsToSeconds(beats) * 1000;
                },

                beatsPerSecond() {
                    return this.BPM / 60;
                },

                // -------------------------
                // Generate Random Loop
                // -------------------------
                generateRandomLoop() {
                    try {
                        this.isLoopActive = true;
                        this.updateStatus('Generating sound loop...');
                        const generateButton = document.getElementById('generate-button');
                        if (generateButton) generateButton.disabled = true;

                        // Generate BPM between 120 and 240
                        this.BPM = this.clamp(parseFloat((this.random() * 120 + 120).toFixed(2)), 120.0, 240.0);
                        console.log(`Selected BPM: ${this.BPM}`);

                        // Define loop duration
                        const loopBars = 8; // 8 bars
                        const beatsPerBar = 4;
                        const totalBeats = loopBars * beatsPerBar;
                        console.log(`Loop Duration: ${totalBeats} beats`);

                        const scale = this.generateRandomScale();
                        if (!scale.length) {
                            console.warn('Generated scale is empty. Aborting loop generation.');
                            this.cleanupLoop();
                            return;
                        }

                        // Initialize master gain
                        this.setAudioParam(this.masterGain.gain, 0, this.context.currentTime);
                        this.rampAudioParam(this.masterGain.gain, 0.8, this.context.currentTime + this.beatsToSeconds(0.1));

                        // Set up master filter
                        const masterFilter = this.context.createBiquadFilter();
                        masterFilter.type = 'lowpass';
                        this.setAudioParam(masterFilter.frequency, 15000, this.context.currentTime);
                        this.masterGain.disconnect();
                        this.masterGain.connect(masterFilter);

                        // Apply global effects
                        const effectsChain = this.createGlobalEffectsChain(this.beatsToSeconds(totalBeats));
                        masterFilter.connect(effectsChain).connect(this.context.destination);

                        // Generate chord progression
                        const chordProgression = this.generateChordProgression(scale);

                        // Schedule musical elements
                        this.scheduleBeatsAndBars(totalBeats, scale, chordProgression);

                        this.updateStatus(`Loop active: ${loopBars} bars | BPM: ${this.BPM} | Seed: ${this.seed}`);
                        console.log('Loop generation started successfully.');
                    } catch (error) {
                        console.error('Error in generateRandomLoop:', error);
                        this.cleanupLoop();
                    }
                },

                // -------------------------
                // Scale and Chord Generation
                // -------------------------
                generateRandomScale() {
                    const SCALES = {
                        major: [0, 2, 4, 5, 7, 9, 11],
                        minor: [0, 2, 3, 5, 7, 8, 10],
                        pentatonic: [0, 2, 4, 7, 9],
                        blues: [0, 3, 5, 6, 7, 10],
                    };
                    const ROOTS = [130.81, 146.83, 164.81, 174.61, 196.00, 220.00, 246.94, 261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88];
                    const MIN_FREQ = 20;
                    const MAX_FREQ = 16000;
                    const OCTAVE_RANGE = 4;
                    const FREQUENCY_MODULATION_RANGE = 0.05;

                    const scaleTypes = Object.keys(SCALES);
                    const type = scaleTypes[Math.floor(this.random() * scaleTypes.length)] || 'major';
                    const root = ROOTS[Math.floor(this.random() * ROOTS.length)] || 261.63;
                    const scaleIntervals = SCALES[type];

                    let generatedScale = scaleIntervals.map(interval => {
                        let octaveMultiplier = Math.floor(this.random() * (2 * OCTAVE_RANGE + 1)) - OCTAVE_RANGE;
                        let freq = root * Math.pow(2, (interval + octaveMultiplier * 12) / 12);
                        freq *= 1 + (this.random() * 2 - 1) * FREQUENCY_MODULATION_RANGE;
                        return (freq >= MIN_FREQ && freq <= MAX_FREQ) ? freq : null;
                    }).filter(Boolean);

                    this.currentScaleData = { type, root, intervals: scaleIntervals, frequencies: generatedScale };
                    console.log(`Generated Scale (${type}):`, generatedScale);
                    return generatedScale;
                },

                generateChordProgression(scale) {
                    const chordDegrees = [0, 2, 4, 5, 7];
                    const progressionLength = Math.floor(this.random() * 4) + 2;
                    const progression = [];

                    for (let i = 0; i < progressionLength; i++) {
                        const degreeIndex = chordDegrees[Math.floor(this.random() * chordDegrees.length)];
                        const chord = this.buildChord(scale, degreeIndex);
                        progression.push(chord);
                    }
                    console.log('Chord Progression:', progression);
                    return progression;
                },

                buildChord(scale, rootIndex) {
                    const chordIntervals = [0, 2, 4];
                    return chordIntervals.map(interval => {
                        let noteIndex = (rootIndex + interval) % scale.length;
                        let octaveShift = Math.floor((rootIndex + interval) / scale.length);
                        return scale[noteIndex] * Math.pow(2, octaveShift);
                    });
                },

                // -------------------------
                // Scheduling Functions
                // -------------------------
                scheduleBeatsAndBars(totalBeats, scale, chordProgression) {
                    const startTime = this.context.currentTime;

                    for (let beat = 0; beat < totalBeats; beat++) {
                        const currentTime = startTime + this.beatsToSeconds(beat);
                        const evolutionFactor = parseFloat(((beat + 1) / totalBeats).toFixed(2));

                        this.scheduleMelodicElements(currentTime, scale, chordProgression, evolutionFactor);
                        this.scheduleBassLines(currentTime, scale, evolutionFactor);
                    }
                },

                scheduleMelodicElements(startTime, scale, chordProgression, evolutionFactor) {
                    const notesPerBeat = 1 + Math.floor(this.random() * Math.min(2, evolutionFactor * 2));

                    for (let i = 0; i < notesPerBeat; i++) {
                        const time = startTime + (i * this.beatsToSeconds(1) / notesPerBeat);
                        const chord = chordProgression[Math.floor(this.random() * chordProgression.length)];

                        if (this.random() > 0.5 && chord) {
                            if (this.random() > 0.5) {
                                this.scheduleChord(chord, time, this.beatsToSeconds(0.9));
                            } else {
                                this.scheduleArpeggio(chord, time, this.beatsToSeconds(0.9));
                            }
                        } else {
                            const freq = scale[Math.floor(this.random() * scale.length)];
                            const noteDuration = this.clamp(0.8 + this.random() * 0.2, 0.5, 1.0);
                            this.scheduleNote(freq, time, this.beatsToSeconds(noteDuration), true);
                        }
                    }
                },

                scheduleBassLines(startTime, scale, evolutionFactor) {
                    const bassScale = scale.map(freq => freq / 2);
                    const notesPerBeat = Math.ceil(evolutionFactor * 2);

                    for (let i = 0; i < notesPerBeat; i++) {
                        const time = startTime + (i * this.beatsToSeconds(1) / notesPerBeat);
                        const freq = bassScale[Math.floor(this.random() * bassScale.length)];
                        this.scheduleBassNote(freq, time, this.beatsToSeconds(0.9));
                    }
                },

                scheduleChord(frequencies, start, dur) {
                    frequencies.forEach(freq => {
                        this.scheduleNote(freq, start, dur, false);
                    });
                },

                scheduleArpeggio(chord, startTime, duration) {
                    const numNotes = chord.length;
                    const noteDuration = duration / numNotes;
                    chord.forEach((freq, index) => {
                        const noteTime = startTime + (index * noteDuration);
                        this.scheduleNote(freq, noteTime, noteDuration, false);
                    });
                },

                scheduleNote(freq, start, dur, isEvolutionary) {
                    try {
                        if (!isFinite(freq) || freq <= 0) return;

                        start = (isFinite(start) && start >= this.context.currentTime) ? start : this.context.currentTime;
                        dur = (isFinite(dur) && dur > 0) ? dur : this.beatsToSeconds(1);

                        const osc = this.context.createOscillator();
                        this.activeOscillators.add(osc);
                        osc.onended = () => {
                            this.activeOscillators.delete(osc);
                            osc.disconnect();
                        };

                        const gain = this.context.createGain();
                        const pan = this.context.createStereoPanner();

                        osc.frequency.setValueAtTime(freq, start);
                        const oscType = ['sine', 'square', 'sawtooth', 'triangle'][Math.floor(this.random() * 4)] || 'sine';
                        osc.type = oscType;
                        osc.connect(gain);

                        this.setAudioParam(gain.gain, 0, start);
                        this.rampAudioParam(gain.gain, this.clamp(this.random() * 0.3 + 0.2, 0.2, 1.0), start + this.beatsToSeconds(0.05));
                        this.rampAudioParam(gain.gain, 0, start + dur);

                        const panValue = this.clamp(this.random() * 2 - 1, -1, 1);
                        this.setAudioParam(pan.pan, panValue, start);

                        gain.connect(pan).connect(this.masterGain);

                        // Apply delay effect
                        if (this.random() > 0.4) {
                            this.applyDelayEffect(gain, start, dur);
                        }

                        osc.start(start);
                        osc.stop(start + dur);
                    } catch (error) {
                        console.error('Error in scheduleNote:', error);
                    }
                },

                scheduleBassNote(freq, start, dur) {
                    try {
                        const osc = this.context.createOscillator();
                        const gain = this.context.createGain();
                        const filter = this.context.createBiquadFilter();

                        osc.type = 'sawtooth';
                        this.setAudioParam(osc.frequency, freq, start);
                        this.setAudioParam(gain.gain, 0, start);
                        this.rampAudioParam(gain.gain, 0.6, start + this.beatsToSeconds(0.05));
                        this.rampAudioParam(gain.gain, 0, start + dur);
                        filter.type = 'lowpass';
                        this.setAudioParam(filter.frequency, 500, start);

                        osc.connect(filter).connect(gain).connect(this.masterGain);
                        osc.start(start);
                        osc.stop(start + dur);
                    } catch (error) {
                        console.error('Error in scheduleBassNote:', error);
                    }
                },

                // -------------------------
                // Effect Functions
                // -------------------------
                applyDelayEffect(gainNode, start, dur) {
                    try {
                        const delayNode = this.context.createDelay();
                        const feedbackGain = this.context.createGain();
                        const wetGain = this.context.createGain();
                        const dryGain = this.context.createGain();

                        const delayTime = this.clamp(this.beatsToSeconds(0.5), 0.1, 2.0);
                        const feedbackGainValue = this.clamp(this.random() * 0.5 + 0.2, 0.2, 0.7);

                        this.setAudioParam(delayNode.delayTime, delayTime, start);
                        this.setAudioParam(feedbackGain.gain, feedbackGainValue, start);
                        this.setAudioParam(wetGain.gain, 0.3, start);
                        this.setAudioParam(dryGain.gain, 0.7, start);

                        delayNode.connect(feedbackGain).connect(delayNode);

                        gainNode.connect(delayNode).connect(wetGain).connect(this.masterGain);
                        gainNode.connect(dryGain).connect(this.masterGain);
                    } catch (error) {
                        console.error('Error in applyDelayEffect:', error);
                    }
                },

                createGlobalEffectsChain(dur) {
                    const effects = [];
                    if (this.random() > 0.5) {
                        const reverb = this.createReverbEffect();
                        effects.push(reverb);
                        console.log('Global Effects Chain: Added Reverb Effect');
                    }

                    if (effects.length === 0) {
                        const bypass = this.context.createGain();
                        bypass.gain.setValueAtTime(1, this.context.currentTime);
                        return bypass;
                    }

                    let inputNode = this.context.createGain();
                    let outputNode = inputNode;

                    effects.forEach(effect => {
                        outputNode.connect(effect.input);
                        outputNode = effect.output;
                    });

                    return outputNode;
                },

                createReverbEffect() {
                    const convolver = this.context.createConvolver();
                    const noiseBuffer = this.context.createBuffer(2, this.context.sampleRate * 3, this.context.sampleRate);
                    for (let channel = 0; channel < noiseBuffer.numberOfChannels; channel++) {
                        const data = noiseBuffer.getChannelData(channel);
                        for (let i = 0; i < data.length; i++) {
                            data[i] = this.random() * 2 - 1;
                        }
                    }
                    convolver.buffer = noiseBuffer;
                    return { input: convolver, output: convolver };
                },

                // -------------------------
                // Cleanup Function
                // -------------------------
                cleanupLoop() {
                    try {
                        this.masterGain.disconnect();
                        this.masterGain.connect(this.context.destination);

                        this.setAudioParam(this.masterGain.gain, 0, this.context.currentTime);
                        this.rampAudioParam(this.masterGain.gain, 1.0, this.context.currentTime + this.beatsToSeconds(0.1));

                        this.activeOscillators.forEach(osc => {
                            osc.stop();
                            osc.disconnect();
                        });
                        this.activeOscillators.clear();

                        this.isLoopActive = false;
                        const generateButton = document.getElementById('generate-button');
                        if (generateButton) generateButton.disabled = false;
                        this.updateStatus('Loop cleaned up.');
                        console.log('Loop cleanup completed.');
                    } catch (err) {
                        console.warn('Error during loop cleanup:', err);
                    }
                },
            };

            Synthesizer.init();
        })();
    </script>
</body>
</html>
