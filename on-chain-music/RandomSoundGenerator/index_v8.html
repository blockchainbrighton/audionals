<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GenSynth</title>
    <style>
        /* Same as before, with the addition of the 'active' button styling */
        body {
            font-family: Arial, sans-serif;
            background-color: #000000; /* Black background */
            margin: 0; /* Remove default margin */
            height: 100vh; /* Full viewport height */
            display: flex; /* Flex layout for side-by-side design */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        /* Control Panel Styling */
        #control-panel {
            background-color: #1a1a1a; /* Dark gray background for the control panel */
            color: #ffffff; /* White text */
            width: 20%; /* Set control panel width */
            padding: 10px;
            box-sizing: border-box; /* Include padding in width */
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            align-items: flex-start; /* Align buttons to the left */
            gap: 10px; /* Add spacing between buttons */
        }

        #control-panel button {
            background-color: #333333; /* Darker button background */
            color: #ffffff; /* White text color */
            border: none; /* Remove default button borders */
            padding: 10px; /* Add padding to buttons */
            font-size: 14px; /* Button text size */
            cursor: pointer;
            width: 100%; /* Buttons take full width of control panel */
        }

        #control-panel button:hover {
            background-color: #444444; /* Slightly lighter background on hover */
        }

        #control-panel button.active {
            background-color: #555555; /* Even lighter background */
            color: #ffffff;
        }

        /* Main content styling */
        .main-content {
            flex: 1; /* Take up remaining space */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ffffff; /* White text for the status */
        }

        /* Style the button to remove default styles and display the image properly */
        button {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
        }

        /* Ensure the image fills 50% of the viewport height */
        button img {
            height: 50vh; /* Image fills 50% of the viewport height */
            width: auto; /* Width adjusts to maintain aspect ratio */
            display: block;
        }
    </style>
</head>
<body>
    <!-- Button replaced with an image -->
    <button id="generate-button">
        <img src="https://ordinals.com/content/01c48d3cceb02215bc3d44f9a2dc7fba63ea63719a2ef1c35d3f0c4db93ab8d5i0" alt="Generate Sound Artwork" />
    </button>
    <div id="status">Click a button to generate sound.</div>

    <!-- Control Panel -->
    <div id="control-panel">
        <button id="generate-creepy-soundscape">Creepy</button>
        <button id="generate-haunting-pads">Haunting</button>
        <button id="generate-uplifting-melodies">Melodic</button>
        <button id="generate-chill-ambient">Ambient</button>
        <button id="generate-energetic-beats">Rave</button>
        <!-- Add more buttons as needed -->
    </div>

    <!-- Include the updated JavaScript code -->
    <script>
(() => {
    "use strict";
    const Synth = {
        context: null,
        masterGain: null,
        BPM: 120,
        isLoopActive: false,
        random: null,
        seed: null,
        currentScaleData: null,
        currentFilter: null,
        currentEffectsChain: null,
        chainGain: null,
        activeStyleKey: null,
        activeOscillators: new Set(),
        activeNodes: new Set(), // To keep track of all audio nodes for cleanup
        styles: {
            'creepy-soundscape': {
                BPMRange: [40, 60],
                scales: ['blues', 'minor'],
                effects: ['reverb', 'phaser'],
                chordTypes: ['seventh', 'ninth'],
                percussiveElements: false,
                description: 'Creepy Soundscape',
                padDuration: [8, 16],
                frequencyBend: true
            },
            'haunting-pads': {
                BPMRange: [50, 80],
                scales: ['minor', 'pentatonic'],
                effects: ['reverb', 'chorus'],
                chordTypes: ['sus2', 'sus4'],
                percussiveElements: false,
                description: 'Haunting Pads',
                padDuration: [8, 16],
                frequencyBend: true
            },
            'uplifting-melodies': {
                BPMRange: [120, 140],
                scales: ['major', 'pentatonic'],
                effects: ['chorus', 'compressor'],
                chordTypes: ['triad', 'sixth'],
                percussiveElements: false,
                description: 'Uplifting Melodies',
                padDuration: [1, 2],
                frequencyBend: false
            },
            'chill-ambient': {
                BPMRange: [80, 100],
                scales: ['major', 'pentatonic'],
                effects: ['reverb', 'chorus'],
                chordTypes: ['sus2', 'sixth'],
                percussiveElements: false,
                description: 'Chill Ambient',
                padDuration: [4, 8],
                frequencyBend: true
            },
            'energetic-beats': {
                BPMRange: [140, 160],
                scales: ['minor', 'pentatonic'],
                effects: ['compressor', 'distortion'],
                chordTypes: ['triad'],
                percussiveElements: true,
                description: 'Energetic Beats',
                padDuration: [0.5, 1],
                frequencyBend: false
            }
            // Add more styles as needed
        },
        init() {
            this.initAudioContext();
            this.initRandom();
            this.initMasterGain();
            this.addEventListeners();
            this.updateStatus("Click a button to generate sound.");
        },
        initAudioContext() {
            this.context = new (window.AudioContext || window.webkitAudioContext)();
            console.log("Audio Context initialized:", this.context);
        },
        initRandom() {
            this.seed = Math.floor(4294967295 * Math.random());
            this.random = this.mulberry32(this.seed);
            console.log(`Current Seed: ${this.seed}`);
        },
        initMasterGain() {
            this.masterGain = this.context.createGain();
            this.masterGain.connect(this.context.destination);
            console.log("Master Gain connected to destination.");
        },
        addEventListeners() {
            // Add click event listeners to control panel buttons
            Object.keys(this.styles).forEach(styleKey => {
                const button = document.getElementById(`generate-${styleKey}`);
                if (button) {
                    button.addEventListener('click', () => {
                        if (this.activeStyleKey === styleKey) {
                            // Toggle off if the same style is active
                            this.cleanupLoop();
                        } else {
                            // Switch to new style
                            this.cleanupLoop();
                            try {
                                this.generateRandomLoop(styleKey, this.styles[styleKey]);
                            } catch (error) {
                                console.error("Error generating loop:", error);
                            }
                        }
                    });
                } else {
                    console.error(`Button for style ${styleKey} not found in the DOM.`);
                }
            });

            // Add beforeunload event to clean up when the page is closed or refreshed
            window.addEventListener("beforeunload", () => {
                console.log("Page is unloading. Cleaning up any active loops.");
                this.cleanupLoop();
            });

            // Performance reporting every 10 seconds
            setInterval(() => {
                console.log("--- 10-Second Performance Report ---");
                console.log(`Is Loop Active: ${this.isLoopActive}`);
                console.log(`Audio Context State: ${this.context.state}`);
                console.log(`Current BPM: ${this.isLoopActive ? this.BPM.toFixed(2) : "N/A"}`);
                console.log("-------------------------------------");
            }, 10000);
        },
        mulberry32(a) {
            return () => {
                let t = a += 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            };
        },
        clamp(value, min, max) {
            return isFinite(value) ? Math.min(Math.max(value, min), max) : min;
        },
        setAudioParam(param, value, time) {
            if (isFinite(value)) {
                param.setValueAtTime(value, time);
            } else {
                console.warn(`Invalid value (${value}) for AudioParam. Using default value.`);
                param.setValueAtTime(0, time);
            }
        },
        rampAudioParam(param, value, time) {
            if (isFinite(value)) {
                param.linearRampToValueAtTime(value, time);
            } else {
                console.warn(`Invalid ramp value (${value}) for AudioParam.`);
            }
        },
        updateStatus(message) {
            console.log(`Status Update: ${message}`);
            const statusElement = document.getElementById("status");
            if (statusElement) {
                statusElement.textContent = message;
            } else {
                console.warn("Status element not found in the DOM.");
            }
        },
        updateActiveButton() {
            // Remove 'active' class from all buttons
            Object.keys(this.styles).forEach(key => {
                const button = document.getElementById(`generate-${key}`);
                if (button) {
                    button.classList.remove('active');
                }
            });
            // Add 'active' class to the active button
            if (this.activeStyleKey) {
                const activeButton = document.getElementById(`generate-${this.activeStyleKey}`);
                if (activeButton) {
                    activeButton.classList.add('active');
                }
            }
        },
        beatsToSeconds(beats) {
            return parseFloat((60 * beats / this.BPM).toFixed(2));
        },
        beatsToMilliseconds(beats) {
            return 1000 * this.beatsToSeconds(beats);
        },
        beatsPerSecond() {
            return this.BPM / 60;
        },
        generateRandomLoop(styleKey, style) {
            try {
                this.isLoopActive = true;
                this.activeStyleKey = styleKey;
                this.updateActiveButton();
                this.updateStatus(`Generating ${style.description}...`);

                const [minBPM, maxBPM] = style.BPMRange;
                this.BPM = this.clamp(parseFloat((this.random() * (maxBPM - minBPM) + minBPM).toFixed(2)), minBPM, maxBPM);
                console.log(`Selected BPM: ${this.BPM}`);

                // Create chainGain
                this.chainGain = this.context.createGain();
                this.activeNodes.add(this.chainGain);

                // Create filter
                this.currentFilter = this.context.createBiquadFilter();
                this.currentFilter.type = "lowpass";
                this.setAudioParam(this.currentFilter.frequency, 15000, this.context.currentTime);
                this.activeNodes.add(this.currentFilter);

                // Create effects chain
                this.currentEffectsChain = this.createGlobalEffectsChain(style.effects);

                // Connect the chain
                this.chainGain.connect(this.currentFilter);
                this.currentFilter.connect(this.currentEffectsChain.input);
                this.currentEffectsChain.output.connect(this.masterGain);

                // Set initial gain
                this.setAudioParam(this.masterGain.gain, 0, this.context.currentTime);
                this.rampAudioParam(this.masterGain.gain, 0.8, this.context.currentTime + this.beatsToSeconds(0.1));

                const scale = this.generateRandomScale(style.scales);
                if (!scale.length) {
                    console.warn("Generated scale is empty. Aborting loop generation.");
                    this.cleanupLoop();
                    return;
                }

                const chordProgression = this.generateChordProgression(scale, style.chordTypes);

                // Start the loop
                this.startLoop(scale, chordProgression, style);

                this.updateStatus(`Loop active: BPM: ${this.BPM} | Style: ${style.description} | Seed: ${this.seed}`);
                console.log("Loop generation started successfully.");
            } catch (error) {
                console.error("Error in generateRandomLoop:", error);
                this.cleanupLoop();
            }
        },
        startLoop(scale, chordProgression, style) {
            const scheduleNextLoop = () => {
                if (!this.isLoopActive) return;

                const loopDuration = 16 * 4; // 16 bars
                this.scheduleBeatsAndBars(this.context.currentTime, loopDuration, scale, chordProgression, style);

                // Schedule the next loop iteration
                const nextLoopTime = this.context.currentTime + this.beatsToSeconds(loopDuration);
                setTimeout(scheduleNextLoop, (nextLoopTime - this.context.currentTime) * 1000);
            };

            scheduleNextLoop();
        },
        generateRandomScale(preferredScales) {
            /* Same as before */
            const scales = {
                major: [0, 2, 4, 5, 7, 9, 11],
                minor: [0, 2, 3, 5, 7, 8, 10],
                pentatonic: [0, 2, 4, 7, 9],
                blues: [0, 3, 5, 6, 7, 10]
            };
            const baseFrequencies = [130.81, 146.83, 164.81, 174.61, 196, 220, 246.94, 261.63];
            const scaleTypes = preferredScales || Object.keys(scales);
            const selectedScaleType = scaleTypes[Math.floor(this.random() * scaleTypes.length)] || "major";
            const rootFrequency = baseFrequencies[Math.floor(this.random() * baseFrequencies.length)] || 261.63;
            const intervals = scales[selectedScaleType];
            let frequencies = intervals.map(interval => {
                let octaveShift = Math.floor(3 * this.random());
                let freq = rootFrequency * Math.pow(2, (interval + 12 * octaveShift) / 12);
                freq *= 1 + 0.05 * (2 * this.random() - 1);
                return (freq >= 20 && freq <= 16000) ? freq : null;
            }).filter(Boolean);

            this.currentScaleData = {
                type: selectedScaleType,
                root: rootFrequency,
                intervals: intervals,
                frequencies: frequencies
            };
            console.log(`Generated Scale (${selectedScaleType}):`, frequencies);
            return frequencies;
        },
        generateChordProgression(scale, preferredChordTypes) {
            /* Same as before */
            const chordTypes = [
                { name: 'triad', degrees: [0, 2, 4] },
                { name: 'seventh', degrees: [0, 2, 4, 6] },
                { name: 'sus2', degrees: [0, 1, 4] },
                { name: 'sus4', degrees: [0, 3, 4] },
                { name: 'sixth', degrees: [0, 2, 4, 5] },
                { name: 'ninth', degrees: [0, 2, 4, 6, 8] }
            ];
            const chordTypesByName = {};
            chordTypes.forEach(ct => chordTypesByName[ct.name] = ct);

            const availableChordTypes = preferredChordTypes ? preferredChordTypes.map(name => chordTypesByName[name]).filter(Boolean) : chordTypes;

            if (availableChordTypes.length === 0) {
                console.warn("No valid chord types available. Using default 'triad'.");
                availableChordTypes.push(chordTypesByName['triad']);
            }

            const progressionPatterns = [
                [0, 3, 4, 3],
                [0, 5, 3, 4],
                [1, 4, 0, 4],
                [0, 5, 1, 4],
                [0, 3, 5, 4],
                [0, 2, 3, 4]
            ];
            const pattern = progressionPatterns[Math.floor(this.random() * progressionPatterns.length)];

            const progression = pattern.map(rootDegree => {
                const rootIndex = rootDegree % scale.length;
                const chordType = availableChordTypes[Math.floor(this.random() * availableChordTypes.length)];
                return this.buildChord(scale, rootIndex, chordType);
            });
            console.log("Chord Progression:", progression);
            return progression;
        },
        buildChord(scale, rootIndex, chordType) {
            return chordType.degrees.map(degree => {
                let index = (rootIndex + degree) % scale.length;
                let octaveShift = Math.floor((rootIndex + degree) / scale.length);
                return scale[index] * Math.pow(2, octaveShift);
            });
        },
        scheduleBeatsAndBars(startTime, loopDuration, scale, chordProgression, style) {
            const beatsPerBar = 4;
            const totalBars = loopDuration / beatsPerBar;
            for (let bar = 0; bar < totalBars; bar++) {
                for (let beat = 0; beat < beatsPerBar; beat++) {
                    const currentTime = startTime + this.beatsToSeconds(bar * beatsPerBar + beat);
                    const progress = parseFloat(((bar * beatsPerBar + beat + 1) / (totalBars * beatsPerBar)).toFixed(2));
                    this.scheduleMelodicElements(currentTime, scale, chordProgression, progress, style);
                    this.scheduleBassLines(currentTime, scale, progress, style);
                    this.schedulePercussiveElements(currentTime, progress, style);
                }
            }
        },
        scheduleMelodicElements(time, scale, chordProgression, progress, style) {
            const numElements = 1;
            for (let i = 0; i < numElements; i++) {
                const elementTime = time + i * this.beatsToSeconds(1) / numElements;
                const chord = chordProgression[Math.floor(this.random() * chordProgression.length)];
                const durationBeats = this.random() * (style.padDuration[1] - style.padDuration[0]) + style.padDuration[0];
                const duration = this.beatsToSeconds(durationBeats);

                if (style.frequencyBend) {
                    this.schedulePadWithBend(chord, elementTime, duration);
                } else {
                    this.scheduleChord(chord, elementTime, duration);
                }
            }
        },
        schedulePadWithBend(chord, time, duration) {
            chord.forEach(freq => {
                this.scheduleBendingNote(freq, time, duration);
            });
        },
        scheduleBendingNote(freq, time, duration) {
            try {
                if (!isFinite(freq) || freq <= 0) return;
                time = (isFinite(time) && time >= this.context.currentTime) ? time : this.context.currentTime;
                duration = (isFinite(duration) && duration > 0) ? duration : this.beatsToSeconds(4);

                const oscillator = this.context.createOscillator();
                this.activeOscillators.add(oscillator);
                this.activeNodes.add(oscillator);
                oscillator.onended = () => {
                    this.activeOscillators.delete(oscillator);
                    oscillator.disconnect();
                };

                const gainNode = this.context.createGain();
                this.activeNodes.add(gainNode);

                oscillator.frequency.setValueAtTime(freq, time);
                const bendAmount = freq * (0.1 + 0.2 * this.random());
                const bendDirection = this.random() > 0.5 ? 1 : -1;
                oscillator.frequency.linearRampToValueAtTime(freq + bendDirection * bendAmount, time + duration);

                oscillator.type = "sine";

                oscillator.connect(gainNode);
                gainNode.gain.setValueAtTime(0, time);
                gainNode.gain.linearRampToValueAtTime(0.8, time + this.beatsToSeconds(0.5));
                gainNode.gain.linearRampToValueAtTime(0, time + duration);

                gainNode.connect(this.chainGain);

                oscillator.start(time);
                oscillator.stop(time + duration);
            } catch (error) {
                console.error("Error in scheduleBendingNote:", error);
            }
        },
        scheduleBassLines(time, scale, progress, style) {
            if (style.percussiveElements) {
                const bassScale = scale.map(freq => freq / 2);
                const numNotes = Math.ceil(2 * progress);
                for (let i = 0; i < numNotes; i++) {
                    const noteTime = time + i * this.beatsToSeconds(1) / numNotes;
                    const bassFreq = bassScale[Math.floor(this.random() * bassScale.length)];
                    this.scheduleBassNote(bassFreq, noteTime, this.beatsToSeconds(0.5));
                }
            }
        },
        schedulePercussiveElements(time, progress, style) {
            if (!style.percussiveElements) return;
            const beatsPerBar = 4;
            const pattern = this.generatePercussionPattern(beatsPerBar);
            for (let beat = 0; beat < beatsPerBar; beat++) {
                const beatTime = time + this.beatsToSeconds(beat);
                if (pattern.kick[beat]) {
                    this.scheduleKickDrum(beatTime);
                }
                if (pattern.snare[beat]) {
                    this.scheduleSnareDrum(beatTime);
                }
                if (pattern.hihat[beat]) {
                    this.scheduleHiHat(beatTime);
                }
            }
        },
        generatePercussionPattern(beatsPerBar) {
            const pattern = {
                kick: [],
                snare: [],
                hihat: []
            };
            for (let beat = 0; beat < beatsPerBar; beat++) {
                pattern.kick[beat] = beat % 4 === 0;
                pattern.snare[beat] = beat % 4 === 2;
                pattern.hihat[beat] = true;
            }
            return pattern;
        },
        scheduleKickDrum(time) {
            const oscillator = this.context.createOscillator();
            const gainNode = this.context.createGain();

            this.activeNodes.add(oscillator);
            this.activeNodes.add(gainNode);

            oscillator.frequency.setValueAtTime(100, time);
            oscillator.frequency.exponentialRampToValueAtTime(50, time + 0.1);

            gainNode.gain.setValueAtTime(1, time);
            gainNode.gain.exponentialRampToValueAtTime(0.001, time + 0.5);

            oscillator.connect(gainNode).connect(this.chainGain);
            oscillator.start(time);
            oscillator.stop(time + 0.5);
        },
        scheduleSnareDrum(time) {
            const bufferSize = this.context.sampleRate;
            const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noise = this.context.createBufferSource();
            noise.buffer = buffer;

            const noiseGain = this.context.createGain();
            this.activeNodes.add(noise);
            this.activeNodes.add(noiseGain);

            noiseGain.gain.setValueAtTime(1, time);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);

            const filter = this.context.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(1000, time);
            this.activeNodes.add(filter);

            noise.connect(filter).connect(noiseGain).connect(this.chainGain);
            noise.start(time);
            noise.stop(time + 0.2);
        },
        scheduleHiHat(time) {
            const bufferSize = this.context.sampleRate;
            const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noise = this.context.createBufferSource();
            noise.buffer = buffer;

            const noiseGain = this.context.createGain();
            this.activeNodes.add(noise);
            this.activeNodes.add(noiseGain);

            noiseGain.gain.setValueAtTime(0.3, time);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);

            const filter = this.context.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(5000, time);
            this.activeNodes.add(filter);

            noise.connect(filter).connect(noiseGain).connect(this.chainGain);
            noise.start(time);
            noise.stop(time + 0.05);
        },
        scheduleChord(chord, time, duration) {
            chord.forEach(freq => {
                this.scheduleNote(freq, time, duration, false);
            });
        },
        scheduleNote(freq, time, duration, isMelody) {
            try {
                if (!isFinite(freq) || freq <= 0) return;
                time = (isFinite(time) && time >= this.context.currentTime) ? time : this.context.currentTime;
                duration = (isFinite(duration) && duration > 0) ? duration : this.beatsToSeconds(1);

                const oscillator = this.context.createOscillator();
                this.activeOscillators.add(oscillator);
                this.activeNodes.add(oscillator);
                oscillator.onended = () => {
                    this.activeOscillators.delete(oscillator);
                    oscillator.disconnect();
                };

                const gainNode = this.context.createGain();
                this.activeNodes.add(gainNode);

                oscillator.frequency.setValueAtTime(freq, time);
                oscillator.type = "sine";

                oscillator.connect(gainNode);
                gainNode.gain.setValueAtTime(0, time);
                gainNode.gain.linearRampToValueAtTime(0.5, time + this.beatsToSeconds(0.1));
                gainNode.gain.linearRampToValueAtTime(0, time + duration);

                gainNode.connect(this.chainGain);

                oscillator.start(time);
                oscillator.stop(time + duration);
            } catch (error) {
                console.error("Error in scheduleNote:", error);
            }
        },
        scheduleBassNote(freq, time, duration) {
            try {
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                this.activeNodes.add(oscillator);
                this.activeNodes.add(gainNode);
                this.activeNodes.add(filter);

                oscillator.type = "sawtooth";
                this.setAudioParam(oscillator.frequency, freq, time);
                this.setAudioParam(gainNode.gain, 0, time);
                this.rampAudioParam(gainNode.gain, 0.6, time + this.beatsToSeconds(0.05));
                this.rampAudioParam(gainNode.gain, 0, time + duration);

                filter.type = "lowpass";
                this.setAudioParam(filter.frequency, 500, time);

                oscillator.connect(filter).connect(gainNode).connect(this.chainGain);
                oscillator.start(time);
                oscillator.stop(time + duration);
            } catch (error) {
                console.error("Error in scheduleBassNote:", error);
            }
        },
        applyDelayEffect(sourceNode, time, duration) {
            /* Adjusted to add nodes to activeNodes */
            try {
                const delay = this.context.createDelay();
                const feedbackGain = this.context.createGain();
                const mixGain = this.context.createGain();
                const wetGain = this.context.createGain();

                this.activeNodes.add(delay);
                this.activeNodes.add(feedbackGain);
                this.activeNodes.add(mixGain);
                this.activeNodes.add(wetGain);

                const delayTime = this.clamp(this.beatsToSeconds(0.5), 0.1, 2);
                const feedbackLevel = this.clamp(0.5 * this.random() + 0.2, 0.2, 0.7);

                this.setAudioParam(delay.delayTime, delayTime, time);
                this.setAudioParam(feedbackGain.gain, feedbackLevel, time);
                this.setAudioParam(mixGain.gain, 0.3, time);
                this.setAudioParam(wetGain.gain, 0.7, time);

                delay.connect(feedbackGain).connect(delay);
                sourceNode.connect(delay).connect(mixGain).connect(this.chainGain);
                sourceNode.connect(wetGain).connect(this.chainGain);
            } catch (error) {
                console.error("Error in applyDelayEffect:", error);
            }
        },
        createGlobalEffectsChain(preferredEffects) {
            const effects = [];
            const effectFunctions = {
                'reverb': this.createReverbEffect.bind(this),
                'distortion': this.createDistortionEffect.bind(this),
                'chorus': this.createChorusEffect.bind(this),
                'phaser': this.createPhaserEffect.bind(this),
                'compressor': this.createCompressorEffect.bind(this)
            };

            const effectNodes = []; // To keep track of nodes for cleanup

            preferredEffects.forEach(effectName => {
                if (effectFunctions[effectName]) {
                    const effect = effectFunctions[effectName](effectNodes);
                    effects.push(effect);
                    console.log(`Global Effects Chain: Added ${effectName.charAt(0).toUpperCase() + effectName.slice(1)} Effect`);
                }
            });

            let inputNode = this.context.createGain();
            let outputNode = inputNode;
            this.activeNodes.add(inputNode);

            effects.forEach(effect => {
                outputNode.connect(effect.input);
                outputNode = effect.output;
            });

            return { input: inputNode, output: outputNode, nodes: effectNodes };
        },
        createReverbEffect(effectNodes) {
            const convolver = this.context.createConvolver();
            this.activeNodes.add(convolver);
            effectNodes.push(convolver);

            const buffer = this.context.createBuffer(2, 3 * this.context.sampleRate, this.context.sampleRate);
            for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                const data = buffer.getChannelData(channel);
                for (let i = 0; i < data.length; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / buffer.length, 2);
                }
            }
            convolver.buffer = buffer;
            return { input: convolver, output: convolver };
        },
        createDistortionEffect(effectNodes) {
            const distortion = this.context.createWaveShaper();
            this.activeNodes.add(distortion);
            effectNodes.push(distortion);

            const curve = new Float32Array(44100);
            const amount = this.clamp(400 * this.random(), 0, 1000);
            const deg = Math.PI / 180;
            for (let i = 0; i < 44100; ++i) {
                const x = i * 2 / 44100 - 1;
                curve[i] = (3 + amount) * x * 20 * deg / (Math.PI + amount * Math.abs(x));
            }
            distortion.curve = curve;
            distortion.oversample = '4x';
            return { input: distortion, output: distortion };
        },
        createChorusEffect(effectNodes) {
            const delayNode = this.context.createDelay();
            const lfo = this.context.createOscillator();
            const lfoGain = this.context.createGain();

            this.activeNodes.add(delayNode);
            this.activeNodes.add(lfo);
            this.activeNodes.add(lfoGain);
            effectNodes.push(delayNode, lfo, lfoGain);

            delayNode.delayTime.value = this.clamp(0.005 + 0.02 * this.random(), 0.005, 0.03);
            lfo.frequency.value = this.clamp(0.1 + 0.4 * this.random(), 0.1, 0.5);
            lfoGain.gain.value = this.clamp(0.005 + 0.005 * this.random(), 0.005, 0.01);

            lfo.connect(lfoGain).connect(delayNode.delayTime);
            lfo.start();

            return { input: delayNode, output: delayNode };
        },
        createPhaserEffect(effectNodes) {
            const phaserStages = 4;
            let inputNode = this.context.createGain();
            let lastNode = inputNode;
            this.activeNodes.add(inputNode);
            effectNodes.push(inputNode);

            const lfo = this.context.createOscillator();
            const lfoGain = this.context.createGain();

            this.activeNodes.add(lfo);
            this.activeNodes.add(lfoGain);
            effectNodes.push(lfo, lfoGain);

            lfo.frequency.value = this.clamp(0.05 + 0.2 * this.random(), 0.05, 0.25);
            lfoGain.gain.value = this.clamp(500 + 500 * this.random(), 500, 1000);

            for (let i = 0; i < phaserStages; i++) {
                const allpass = this.context.createBiquadFilter();
                allpass.type = 'allpass';
                allpass.frequency.value = 1000 * (i + 1);

                this.activeNodes.add(allpass);
                effectNodes.push(allpass);

                lfo.connect(lfoGain).connect(allpass.frequency);
                lastNode.connect(allpass);
                lastNode = allpass;
            }

            lfo.start();
            return { input: inputNode, output: lastNode };
        },
        createCompressorEffect(effectNodes) {
            const compressor = this.context.createDynamicsCompressor();
            this.activeNodes.add(compressor);
            effectNodes.push(compressor);

            compressor.threshold.value = this.clamp(-50 + -20 * this.random(), -90, 0);
            compressor.knee.value = this.clamp(10 + 30 * this.random(), 0, 40);
            compressor.ratio.value = this.clamp(4 + 8 * this.random(), 1, 20);
            compressor.attack.value = this.clamp(0.005 + 0.05 * this.random(), 0, 1);
            compressor.release.value = this.clamp(0.05 + 0.3 * this.random(), 0, 1);

            return { input: compressor, output: compressor };
        },
        cleanupEffectsChain(effectsChain) {
            if (effectsChain && effectsChain.nodes) {
                effectsChain.nodes.forEach(node => {
                    try {
                        if (node instanceof OscillatorNode) {
                            node.stop();
                        }
                        node.disconnect();
                    } catch (e) {
                        console.warn("Error cleaning up effect node:", e);
                    }
                });
            }
        },
        cleanupLoop() {
            try {
                // Stop and disconnect all active oscillators
                this.activeOscillators.forEach(osc => {
                    try {
                        osc.stop();
                    } catch (e) {
                        console.warn("Oscillator already stopped:", e);
                    }
                    osc.disconnect();
                });
                this.activeOscillators.clear();

                // Disconnect and stop all active nodes
                this.activeNodes.forEach(node => {
                    try {
                        if (node instanceof OscillatorNode || node instanceof AudioBufferSourceNode) {
                            node.stop();
                        }
                        node.disconnect();
                    } catch (e) {
                        console.warn("Error disconnecting node:", e);
                    }
                });
                this.activeNodes.clear();

                // Reset master gain
                this.setAudioParam(this.masterGain.gain, 1, this.context.currentTime);

                this.isLoopActive = false;
                this.activeStyleKey = null;
                this.updateActiveButton();
                this.updateStatus("Loop stopped.");
                console.log("Loop cleanup completed.");
            } catch (error) {
                console.warn("Error during loop cleanup:", error);
            }
        }
    };

    // Initialize the synthesizer
    Synth.init();
})();
</script>
</body>
</html>