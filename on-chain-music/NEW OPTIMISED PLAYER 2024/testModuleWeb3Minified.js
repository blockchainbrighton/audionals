// All modules after player initialisation and pako library loading
const fullscreenButton=document.getElementById("fullscreenButton"),closeButton=document.getElementById("closeButton"),artworkCanvas=document.getElementById("artworkCanvas");let closeButtonVisible=!1;fullscreenButton.addEventListener("click",(()=>{document.fullscreenElement?document.exitFullscreen():artworkCanvas.requestFullscreen()})),document.addEventListener("fullscreenchange",(()=>{document.fullscreenElement?(artworkCanvas.style.width="100vw",artworkCanvas.style.height="100vh",closeButton.style.display="block",closeButtonVisible=!0,setTimeout((()=>{closeButtonVisible&&closeButton.classList.add("fade-out")}),3e3)):(artworkCanvas.style.width="66vh",artworkCanvas.style.height="66vh",closeButton.style.display="none",closeButton.classList.remove("fade-out"),closeButtonVisible=!1)})),document.addEventListener("mousemove",(()=>{document.fullscreenElement&&(closeButton.style.display="block",closeButton.classList.remove("fade-out"),closeButtonVisible=!0,setTimeout((()=>{closeButtonVisible&&closeButton.classList.add("fade-out")}),3e3))})),closeButton.addEventListener("click",(()=>{document.exitFullscreen()})),closeButton.addEventListener("mouseover",(()=>{closeButtonVisible=!0,closeButton.style.display="block",closeButton.classList.remove("fade-out")}));const keyMap={0:"projectName",1:"artistName",2:"projectBPM",3:"currentSequence",4:"channelURLs",5:"channelVolume",6:"channelPlaybackSpeed",7:"trimSettings",8:"projectChannelNames",9:"startSliderValue",10:"endSliderValue",11:"totalSampleDuration",12:"start",13:"end",14:"projectSequences",15:"steps"},reverseKeyMap=Object.fromEntries(Object.entries(keyMap).map((([e,t])=>[t,e]))),decompressSteps=e=>e.map((e=>"number"==typeof e?{index:e,reverse:!1}:"string"==typeof e&&e.endsWith("r")?{index:parseInt(e.slice(0,-1),10),reverse:!0}:"object"==typeof e&&e.r?{index:e.r[0],reverse:Boolean(e.r[1])}:(console.warn("Unknown step format:",e),null))).filter(Boolean),letterToNumber=(()=>{const e=Object.fromEntries([...Array(16)].map(((e,t)=>[String.fromCharCode(97+t),t])));return t=>e[t.toLowerCase()]??null})(),deserialize=e=>Object.fromEntries(Object.entries(e).map((([e,t])=>{const o=keyMap[e]||e;return"projectSequences"===o?[o,Object.fromEntries(Object.entries(t).map((([e,t])=>[`Sequence${e.replace(/^s/,"")}`,Object.fromEntries(Object.entries(t).map((([e,t])=>{let o=parseInt(e.replace(/^ch/,""),10);return o=isNaN(o)?letterToNumber(e):o,null!==o?[`Channel ${o}`,{steps:(s=t[reverseKeyMap.steps]||[],s.map((e=>"number"==typeof e?{index:e,reverse:!1}:"string"==typeof e&&e.endsWith("r")?{index:parseInt(e.slice(0,-1),10),reverse:!0}:"object"==typeof e&&e.r?{index:e.r[0],reverse:Boolean(e.r[1])}:(console.warn("Unknown step format:",e),null))).filter(Boolean))}]:[];var s})).filter(Boolean))])))]:[o,t]})));class AudioPlayer{constructor(){this.initializeProperties(),this.uiHandler=new UIHandler(this),this.artworkManager=new ArtworkManager(this.uiHandler),this.uiHandler.setArtworkManager(this.artworkManager),this.audioLoader=new AudioLoader(this),this.audioProcessor=new AudioProcessor(this.audioCtx),this.playbackScheduler=new PlaybackScheduler(this.audioCtx,this.audioProcessor,this.onSongEnd.bind(this)),this.uiHandler.initEventListeners(),this.skipInterval=null}initializeProperties(){this.projectNames=[],this.songLoadCounter=0,this.totalSongs=SONGS.length,this.audioCtx=new(window.AudioContext||window.webkitAudioContext),this.isPlaying=!1,this.currentSequence=0,this.startTime=0,this.pendingTimeouts=[],this.currentSongIndex=0,this.skipSpeed=10}reset(){this.stop(),this.audioProcessor.reset(),this.playbackScheduler.reset(),this.pendingTimeouts.forEach(clearTimeout),this.pendingTimeouts=[],this.processedData={},this.currentSequence=this.startTime=0,this.toggleButtons(!0),this.artworkManager.clearArtwork()}play(){this.isPlaying||(this.isPlaying=!0,this.startTime=this.audioCtx.currentTime,console.log(`Playback started at ${this.startTime.toFixed(3)} seconds`,"isPlaying:",this.isPlaying),this.playbackScheduler.scheduleSequences(this.processedData,this.startTime,this.isPlaying,this.pendingTimeouts))}stop(){this.isPlaying&&(this.playbackScheduler.stop(),this.isPlaying=!1,console.log("Stopped song.","isPlaying:",this.isPlaying),this.pendingTimeouts.forEach(clearTimeout),this.pendingTimeouts=[])}skipSong(e){this.playbackScheduler.songEndTimeout&&(clearTimeout(this.playbackScheduler.songEndTimeout),this.playbackScheduler.songEndTimeout=null),this.currentSongIndex="forward"===e?(this.currentSongIndex+1)%SONGS.length:(this.currentSongIndex-1+SONGS.length)%SONGS.length,this.audioLoader.loadSong(SONGS[this.currentSongIndex].songUrl,this.isPlaying)}fastSkip(e){const t=document.getElementById("audioPlayer");if(t){const o="forward"===e?this.skipSpeed:-this.skipSpeed,s=t.currentTime+o;t.currentTime=Math.min(Math.max(s,0),t.duration),console.log(`Fast skipped ${e} by ${this.skipSpeed} seconds. Current time: ${t.currentTime}`)}else console.error("Audio element not found for fast skipping.")}toggleButtons(e){this.uiHandler.toggleButtons(e)}onSongEnd(){console.log("Song has ended. Skipping to the next song."),this.skipSong("forward")}}class UIHandler{constructor(e){this.audioPlayer=e,this.bindUIElements(),this.artworkManager=null,this.isFastSkipping=!1,this.seekSliderMaxValue=100}setArtworkManager(e){this.artworkManager=e}bindUIElements(){["loadButton","playButton","stopButton","skipForwardButton","skipBackButton","loadingIndicator","errorMessage","songTitle","artistName","artworkCanvas","seekSlider"].forEach((e=>this[e]=document.getElementById(e)))}initEventListeners(){this.loadButton.addEventListener("click",(()=>this.loadButtonHandler())),this.playButton.addEventListener("click",(()=>this.audioPlayer.play())),this.stopButton.addEventListener("click",(()=>this.audioPlayer.stop())),this.artworkCanvas.addEventListener("click",(()=>{this.audioPlayer.isPlaying?this.audioPlayer.stop():this.audioPlayer.play()})),this.seekSlider.addEventListener("input",(()=>{const e=document.getElementById("audioPlayer");if(e&&!e.seeking){const t=this.seekSlider.value/this.seekSliderMaxValue*e.duration;e.currentTime=t,console.log(`Seeked to ${t} seconds`)}})),this.skipForwardButton.addEventListener("click",(e=>{this.isFastSkipping||this.audioPlayer.skipSong("forward")})),this.skipForwardButton.addEventListener("mousedown",(()=>{this.isFastSkipping=!0,this.startFastSkip("forward")})),this.skipForwardButton.addEventListener("mouseup",(()=>{this.stopFastSkip(),this.isFastSkipping=!1})),this.skipForwardButton.addEventListener("mouseleave",(()=>{this.stopFastSkip(),this.isFastSkipping=!1})),this.skipBackButton.addEventListener("click",(e=>{this.isFastSkipping||this.audioPlayer.skipSong("back")})),this.skipBackButton.addEventListener("mousedown",(()=>{this.isFastSkipping=!0,this.startFastSkip("back")})),this.skipBackButton.addEventListener("mouseup",(()=>{this.stopFastSkip(),this.isFastSkipping=!1})),this.skipBackButton.addEventListener("mouseleave",(()=>{this.stopFastSkip(),this.isFastSkipping=!1}))}updateSeekSlider(e,t){const o=e/t*this.seekSliderMaxValue;this.seekSlider.value=o}enableSeekSlider(){this.seekSlider.disabled=!1}disableSeekSlider(){this.seekSlider.disabled=!0}startFastSkip(e){this.audioPlayer.skipInterval=setInterval((()=>{this.audioPlayer.fastSkip(e)}),100)}stopFastSkip(){clearInterval(this.audioPlayer.skipInterval),this.audioPlayer.skipInterval=null}loadButtonHandler(){this.showLoading(!0);const e=SONGS[this.audioPlayer.currentSongIndex].songUrl;this.audioPlayer.audioLoader.loadSong(e).then((()=>{const e=SONGS[this.audioPlayer.currentSongIndex];if(this.showSongTitle(e.projectName),this.showArtistName(e.artistName),this.artworkManager){const t=e.artworkUrl;this.artworkManager.displayArtwork(t,this.audioPlayer.currentSongIndex)}else console.warn("ArtworkManager is not linked to UIHandler.")})).catch((e=>{console.error("Error loading song:",e),this.displayError("Failed to load the song.")})).finally((()=>{this.showLoading(!1)}))}showSongTitle(e){this.songTitle.textContent=e}showArtistName(e){this.artistName.textContent=e}showLoading(e){this.loadingIndicator.style.display=e?"block":"none"}displayError(e){this.errorMessage.textContent=e,this.errorMessage.style.display="block"}toggleButtons(e){[this.playButton,this.stopButton,this.skipForwardButton,this.skipBackButton].forEach((t=>t.disabled=e))}}class ArtworkManager{constructor(e){this.artworkCanvas=e.artworkCanvas}async displayArtwork(e,t){this.artworkCanvas.innerHTML="";try{const o=await fetch(e,{method:"HEAD"});if(!o.ok)throw new Error(`Failed to fetch artwork: ${o.status}`);const s=o.headers.get("Content-Type"),r=this.createMediaElement(s,e,t);this.artworkCanvas.appendChild(r)}catch(e){console.error("Error displaying artwork:",e),this.artworkCanvas.appendChild(this.createErrorElement("Failed to load artwork."))}}createMediaElement(e,t,o){const s={image:()=>{const e=Object.assign(document.createElement("img"),{src:t,alt:`Artwork for song ${o+1}`,onload:()=>this.fitMediaElement(this.artworkCanvas,e)});return e},video:()=>Object.assign(document.createElement("video"),{src:t,controls:!0}),audio:()=>Object.assign(document.createElement("audio"),{src:t,controls:!0}),html:()=>Object.assign(document.createElement("iframe"),{src:t,width:"100%",height:"100%",frameBorder:0})},r=e.split("/")[0];return s[r]?s[r]():this.createErrorElement("Unsupported artwork format.")}fitMediaElement(e,t){if(!t||!t.naturalWidth||!t.naturalHeight)return void console.error("Element is undefined or does not have natural dimensions.");const{clientWidth:o,clientHeight:s}=e,r=t.naturalWidth/t.naturalHeight,a=o/s;t.style.width=r>a?"100%":"auto",t.style.height=r>a?"auto":"100%"}createErrorElement(e){return Object.assign(document.createElement("div"),{className:"unsupported",textContent:e})}clearArtwork(){this.artworkCanvas.innerHTML=""}}class AudioLoader{constructor(e){this.audioPlayer=e}async loadSong(e,t=!1){this.audioPlayer.reset();try{this.audioPlayer.uiHandler.showLoading(!0),console.log(`Loading song from URL: ${e}`),await this.loadGzipSongFile(e),this.audioPlayer.toggleButtons(!1);const o=SONGS[this.audioPlayer.currentSongIndex];if(o){const e=Object.keys(this.audioPlayer.processedData.projectSequences).length,t=this.audioPlayer.processedData.projectBPM,s=this.audioPlayer.processedData.globalPlaybackSpeed,r=e*64*(60/t/4)/s,a=e=>`${Math.floor(e/60)}.${(e%60).toFixed(0)} mins`;console.log(`Loaded Song Details:\n                    - Index: ${this.audioPlayer.currentSongIndex}\n                    - Project Name: ${o.projectName||"Unknown Title"}\n                    - Artist Name: ${o.artistName||"Unknown Artist"}\n                    - BPM: ${t||"N/A"}\n                    - Channels: ${Object.keys(this.audioPlayer.processedData.channelURLs).length}\n                    - Total Sequences: ${e}\n                    - Playback Time: ${a(r)}`),this.audioPlayer.uiHandler.showSongTitle(o.projectName||"Unknown Title"),this.audioPlayer.uiHandler.showArtistName(o.artistName||"Unknown Artist"),o.artworkUrl?(console.log(`Displaying artwork from URL: ${o.artworkUrl}`),await this.audioPlayer.artworkManager.displayArtwork(o.artworkUrl,this.audioPlayer.currentSongIndex)):console.warn(`No artwork URL found for song at index ${this.audioPlayer.currentSongIndex}`)}else this.audioPlayer.uiHandler.showSongTitle("Unknown Title"),this.audioPlayer.uiHandler.showArtistName("Unknown Artist"),console.warn(`No song found at index ${this.audioPlayer.currentSongIndex}`);t&&(console.log("Auto-playing the song."),this.audioPlayer.play())}catch(e){console.error("Error loading file:",e),this.audioPlayer.uiHandler.displayError("Failed to load file.")}finally{this.audioPlayer.uiHandler.showLoading(!1),console.log("Finished loading song.")}}async loadGzipSongFile(e){try{const t=await fetch(e);if(!t.ok)throw new Error(`Network response not ok: ${t.statusText}`);const o=new Uint8Array(await t.arrayBuffer()),s=JSON.parse((new TextDecoder).decode(pako.inflate(o))),r=deserialize(s),a={projectBPM:r.projectBPM,currentSequence:r.currentSequence,channelURLs:this.arrayToObject(r.channelURLs),channelVolume:this.arrayToObject(r.channelVolume,0,!0),channelPlaybackSpeed:this.arrayToObject(r.channelPlaybackSpeed,0,!0),trimSettings:this.mapTrimSettings(r.trimSettings),projectChannelNames:r.projectChannelNames,projectSequences:r.projectSequences,globalPlaybackSpeed:r.globalPlaybackSpeed||1};if(this.audioPlayer.processedData={...a,VOLUME_CONTROLS:a.channelVolume,SPEED_CONTROLS:a.channelPlaybackSpeed,songDataUrls:Object.values(a.channelURLs)},console.log(`Sequences loaded: ${Object.keys(this.audioPlayer.processedData.projectSequences).length}`),16!==this.audioPlayer.processedData.songDataUrls.length)throw new Error("Invalid channel URLs or channel count.");console.log("Fetching and processing audio data for all channels."),await this.fetchAndProcessAudioData(this.audioPlayer.processedData.songDataUrls),++this.audioPlayer.songLoadCounter===this.audioPlayer.totalSongs&&this.logProjectNames()}catch(e){throw console.error("Error loading file:",e),e}}arrayToObject(e,t=0,o=!1){return e.reduce(((e,s,r)=>(e[`Channel ${t+r}`]=o?parseFloat(s)||1:s,e)),{})}mapTrimSettings(e){return e.reduce(((e,t,o)=>(e[`Channel ${o}`]="object"==typeof t&&t?{start:t[9]||0,end:t[10]||100}:{start:0,end:"number"==typeof t?t:100},"object"!=typeof t&&"number"!=typeof t&&console.warn(`Invalid trim for Channel ${o}.`),e)),{})}async fetchAndProcessAudioData(e){console.log("Starting to fetch and process audio data for channels.");(await Promise.allSettled(e.map(this.processAudioUrl.bind(this)))).forEach(((t,o)=>{"rejected"===t.status?console.error(`Failed to load Channel ${o} (${e[o]}):`,t.reason):console.log(`Successfully loaded Channel ${o}: ${e[o]}`)})),this.audioPlayer.audioProcessor.createReversedBuffers(this.audioPlayer.processedData),console.log("Completed fetching and processing all audio data.")}async processAudioUrl(e,t){const o=`Channel ${t}`;try{const t=await fetch(e);if(!t.ok)throw new Error(`Fetch failed: ${e}, Status: ${t.status}`);const s=await this.handleResponseByType(t,t.headers.get("Content-Type"),o);s&&(this.audioPlayer.audioProcessor.logAudioBufferDetails(s,o),this.audioPlayer.audioProcessor.storeAudioBuffer(s,o,this.audioPlayer.processedData),console.log(`Processed audio for ${o}.`))}catch(e){throw console.error(`Error processing ${o}:`,e),e}}async handleResponseByType(e,t,o){if(/audio|video/.test(t))return this.fetchAndDecodeAudio(e,o);if(/json/.test(t))return this.handleResponse(e,o,"JSON");if(/html/.test(t))return this.handleResponse(e,o,"HTML");throw new Error(`Unsupported content type for ${o}: ${t}`)}async handleResponse(e,t,o){return this.handleAudioDataFromResponse(e,t,o)}async fetchAndDecodeAudio(e,t){try{const o=await e.arrayBuffer(),s=await this.audioPlayer.audioCtx.decodeAudioData(o);return console.log(`Decoded audio for ${t}.`),s}catch(e){throw console.error(`decodeAudioData failed for ${t}:`,e),new Error(`Failed to decode audio for ${t}.`)}}async handleAudioDataFromResponse(e,t,o){try{const s="JSON"===o?await e.json():await e.text(),r="JSON"===o?s.audioData:this.extractBase64FromHTML(s);if(r){const e=this.base64ToArrayBuffer(r.split(",")[1]);if(e){const s=await this.audioPlayer.audioCtx.decodeAudioData(e);return console.log(`Decoded ${o} audio data for ${t}.`),s}throw new Error(`Invalid base64 data for ${t}.`)}throw new Error(`Invalid ${o} structure for audio data in ${t}.`)}catch(e){throw console.error(`Error handling ${o} response for ${t}:`,e),e}}base64ToArrayBuffer(e){try{const t=atob(e),o=t.length,s=new Uint8Array(o);for(let e=0;e<o;e++)s[e]=t.charCodeAt(e);return console.log("Converted base64 to ArrayBuffer."),s.buffer}catch(e){return console.error("[base64ToArrayBuffer] Conversion error:",e),null}}extractBase64FromHTML(e){try{const t=(new DOMParser).parseFromString(e,"text/html"),o=t.querySelector("audio[data-audionalSampleName] source")?.getAttribute("src");if(/^data:audio\/(wav|mp3|mp4);base64,/.test(o?.toLowerCase())||/audio\//.test(o?.toLowerCase()))return console.log("Extracted base64 audio data from HTML."),o;console.error("[extractBase64FromHTML] Invalid audio source format.")}catch(e){console.error("[extractBase64FromHTML] Parsing error:",e)}return null}logProjectNames(){const e=SONGS.map((e=>e.projectName||"Unknown Title"));console.log("All Project Names Loaded:",e)}}class AudioProcessor{constructor(e){this.audioCtx=e,this.audioBuffers=[],this.reversedAudioBuffers={},this.reversedGainNodes={}}reset(){this.audioBuffers=[],this.reversedAudioBuffers={}}parseVolumeLevel(e){return Math.max(0,Math.min(parseFloat(e)||1,1))}applyTrim(e,t,o){const s=e.length,[r,a]=[t,o].map((e=>Math.floor(s*(e/100))));if(r>=a||r<0||a>s)return console.warn(`Invalid trim settings: Start = ${t}%, End = ${o}%. Using full buffer.`),e;const n=this.audioCtx.createBuffer(e.numberOfChannels,a-r,e.sampleRate);return e.numberOfChannels&&Array.from({length:e.numberOfChannels}).forEach(((t,o)=>{n.copyToChannel(e.getChannelData(o).subarray(r,a),o)})),n}storeAudioBuffer(e,t,o){const{VOLUME_CONTROLS:s,SPEED_CONTROLS:r,trimSettings:a}=o,n=this.parseVolumeLevel(s[t]),i=r[t]||1,l=a[t]||{start:0,end:100},d=this.applyTrim(e,l.start,l.end),c=this.audioCtx.createGain();c.gain.value=n,c.connect(this.audioCtx.destination),this.audioBuffers.push({buffer:d,gainNode:c,channel:t,playbackSpeed:i})}logAudioBufferDetails(e,t){console.log(`AudioBuffer for ${t}:`,{channels:e.numberOfChannels,length:e.length,sampleRate:e.sampleRate,duration:e.duration}),[...Array(e.numberOfChannels).keys()].forEach((t=>console.log(`Channel ${t} data:`,e.getChannelData(t).slice(0,10))))}createReversedBuffers(e){this.processedData=e,console.debug("Starting createReversedBuffers");const t=this.getChannelsWithReverse();console.debug("Channels requiring reversal:",Array.from(t)),this.audioBuffers.forEach((({buffer:e,channel:o})=>{if(t.has(o))if(this.reversedAudioBuffers[o])console.debug(`Buffer for channel ${o} already reversed.`);else{console.debug(`Reversing buffer for channel: ${o}`);const t=this.reverseBuffer(e);this.reversedAudioBuffers[o]=t;const s=this.audioCtx.createGain();s.gain.value=this.getVolumeForChannel(o),s.connect(this.audioCtx.destination),this.reversedGainNodes[o]=s}})),console.debug("Completed createReversedBuffers")}getVolumeForChannel(e){const{VOLUME_CONTROLS:t}=this.processedData;return this.parseVolumeLevel(t[e])}getChannelsWithReverse(){const e=new Set,t=Object.values(this.processedData.projectSequences);return t.forEach(((o,s)=>{console.debug(`Processing sequence ${s+1}/${t.length}`),Object.entries(o).forEach((([t,o])=>{o.steps.forEach((({reverse:o},s)=>{o&&(e.add(t),console.debug(`  Step ${s+1}: Reverse flag set for channel '${t}'`))}))}))})),e}reverseBuffer(e){console.debug("Starting reverseBuffer");const t=this.audioCtx.createBuffer(e.numberOfChannels,e.length,e.sampleRate);for(let o=0;o<e.numberOfChannels;o++){const s=e.getChannelData(o),r=t.getChannelData(o);console.debug(`  Reversing data for channel ${o+1}/${e.numberOfChannels}`);for(let t=0,o=e.length;t<o;t++)r[t]=s[o-t-1]}return console.debug("Completed reverseBuffer"),t}concatenateFloat32Arrays(e){const t=e.reduce(((e,t)=>e+t.length),0),o=new Float32Array(t);let s=0;return e.forEach((e=>{o.set(e,s),s+=e.length})),o}}class PlaybackScheduler{constructor(e,t,o){this.audioCtx=e,this.audioProcessor=t,this.currentSourceNodes=[],this.onSongEndCallback=o,this.songEndTimeout=null}scheduleSequences(e,t,o,s){console.debug("Scheduling sequences...");const{projectSequences:r,projectBPM:a,globalPlaybackSpeed:n}=e,i=60/a/4;let l=t;const d=Object.entries(r).map((([e],a)=>{const d=r[e];if(!d)return console.error(`No data for ${e}.`),null;const c=t+64*a*i/n;console.debug(`Scheduled ${e} at ${c.toFixed(3)}s`),Object.entries(d).forEach((([e,{steps:t}])=>{const o=this.audioProcessor.audioBuffers.find((t=>t.channel===e));o?t.forEach((({index:t,reverse:s})=>{const r=c+(t-1)*i/n,a=this.audioCtx.createBufferSource();a.buffer=s&&this.audioProcessor.reversedAudioBuffers[e]||o.buffer,a.playbackRate.value=o.playbackSpeed*n,a.connect(o.gainNode),a.start(r),this.currentSourceNodes.push(a);const d=r+a.buffer.duration/a.playbackRate.value;d>l&&(l=d)})):console.warn(`No buffer for ${e}.`)}));const u=Math.max(1e3*(c-this.audioCtx.currentTime),0);if(u<Number.MAX_SAFE_INTEGER){const t=setTimeout((()=>{o&&console.log(`Now playing ${e}`);const r=s.indexOf(t);r>-1&&s.splice(r,1)}),u);s.push(t)}else console.warn(`Delay for ${e} too long. Skipping log.`);return{id:e,startTime:c.toFixed(3)}})).filter(Boolean);console.log("Scheduled Sequences:",d);const c=l-t;this.songEndTimeout&&clearTimeout(this.songEndTimeout),this.songEndTimeout=setTimeout((()=>{console.log("Song ended. Triggering onSongEndCallback."),this.onSongEndCallback()}),1e3*c)}stop(){this.currentSourceNodes.forEach((e=>e.stop())),this.currentSourceNodes=[],this.songEndTimeout&&(clearTimeout(this.songEndTimeout),this.songEndTimeout=null)}reset(){this.stop()}}new AudioPlayer;
