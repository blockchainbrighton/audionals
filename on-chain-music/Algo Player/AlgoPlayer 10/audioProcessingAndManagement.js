// audioProcessingAndManagement.js
(async()=>{const e=window.globalData||(window.globalData={}),n=e.audioContext||(e.audioContext=new(window.AudioContext||window.webkitAudioContext)),o=e=>Uint8Array.from(atob(e),(e=>e.charCodeAt(0))).buffer,a=(e,n)=>{if("json"===n&&e.audioData){const n=e.audioData.match(/base64,([A-Za-z0-9+/=]+)/);return n?n[1]:null}if("html"===n){const n=e.match(/<audio[^>]*data-audionalSampleName[^>]*>\s*<source[^>]*src="data:audio\/[^;]+;base64,([^"]+)"/i);return n?n[1]:null}return null},t=e=>{const n=e.replace(/\s+/g,"");return n.length%4==0&&/^[A-Za-z0-9+/]+={0,2}$/.test(n)},r=(e,n=.5)=>{let o=0;for(let n=0;n<e.numberOfChannels;n++){const a=e.getChannelData(n);for(let e of a){const n=Math.abs(e);n>o&&(o=n)}}const a=o>0?n/o:1;if(1!==a){for(let n=0;n<e.numberOfChannels;n++){const o=e.getChannelData(n);for(let e=0;e<o.length;e++)o[e]*=a}console.log(`Normalized AudioBuffer to ${n} with factor ${a.toFixed(4)}`)}return e},s=e=>{const n=new Float32Array(e.length);for(let o=0,a=e.length;o<a;o++)n[o]=e[a-o-1];return n},i=e=>e.split("/").pop()||"Unknown",l=async(l,d,c)=>{const{id:u,channels:f}=l,{id:g,url:h,metadata:{trimStartTime_Percentage:m,trimEndTime_Percentage:p,requiresReversal:w}}=d;try{const l=await fetch(h);if(!l.ok)return void console.warn(`Fetch failed for ${h}. Skipping ${g}.`);const d=l.headers.get("Content-Type")||"",f=await(async(r,s,i)=>{const l=e.audioFetchCache||(e.audioFetchCache=new Map);if(l.has(i))return l.get(i);try{let e;if(/audio\/(wav|mpeg|mp4)|video\/mp4/.test(s))e=await n.decodeAudioData(await r.arrayBuffer()),console.log(`Decoded audio from ${i}`);else if(/application\/json/.test(s)){const s=JSON.parse(await r.text()),l=a(s,"json");if(!l||!t(l))return console.warn(`Invalid/missing base64 in JSON for ${i}`),null;e=await n.decodeAudioData(o(l)),console.log(`Decoded JSON audio from ${i}`)}else if(/text\/html/.test(s)){const s=await r.text(),l=a(s,"html");if(!l||!t(l))return console.warn(`Invalid/missing base64 in HTML for ${i}`),null;e=await n.decodeAudioData(o(l)),console.log(`Decoded HTML audio from ${i}`)}else{if(!/audio\//.test(s))return console.warn(`Unsupported content type (${s}) for ${i}`),null;e=await n.decodeAudioData(await r.arrayBuffer()),console.log(`Decoded audio from ${i}`)}return l.set(i,e),e}catch(e){return console.warn(`Decoding error for ${i}: ${e.message}`),null}})(l,d,h);if(!f)return void console.warn(`Decoding failed for ${u}, ${g}. Skipping.`);if(p<=m)return void console.warn(`Invalid trim percentages for ${u}, ${g}. Skipping.`);const $=Math.floor(m/100*f.duration*f.sampleRate),v=Math.floor(p/100*f.duration*f.sampleRate),y=v-$;if(y<=0)return void console.warn(`Non-positive trimmed length for ${u}, ${g}. Skipping.`);const A=n.createBuffer(f.numberOfChannels,y,f.sampleRate);for(let e=0;e<f.numberOfChannels;e++)A.getChannelData(e).set(f.getChannelData(e).subarray($,v));const C=r(A,.5);if(e.audioBuffers=e.audioBuffers||{},e.reverseAudioBuffers=e.reverseAudioBuffers||{},e.audioBuffers[u]=e.audioBuffers[u]||{},e.reverseAudioBuffers[u]=e.reverseAudioBuffers[u]||{},e.audioBuffers[u][g]=C,w){const o=(e=>{const o=n.createBuffer(e.numberOfChannels,e.length,e.sampleRate);for(let n=0;n<e.numberOfChannels;n++)o.getChannelData(n).set(s(e.getChannelData(n)));return o})(C);e.reverseAudioBuffers[u][g]=r(o,.5)}c.push({"Song ID":u,"Channel ID":g,"Audio File":i(h),"Full Duration (s)":f.duration.toFixed(2),"Trimmed Duration (s)":C.duration.toFixed(2),"Requires Reversal":w}),console.log(`Processed ${u}, ${g}${w?" (Reversed)":""}`)}catch(e){console.warn(`Error processing ${u}, ${g}: ${e.message}`)}},d=e=>{e.length?console.table(e):console.warn("No audio samples processed.")},c=async()=>{const{songsArray:o,initialSampleOrder:a}=e;if(!o.length)return void console.error("No songs to process.");const t=[],r=a.map((e=>{const n=o.find((n=>n.id===e.songId));return n&&n.channels.find((n=>n.id===e.channelId))?l(n,n.channels.find((n=>n.id===e.channelId)),t):null})).filter((e=>e));await Promise.all(r),d(t),console.log("Initial audio buffers ready."),(()=>{const o=n.createGain();o.gain.value=.7,o.connect(n.destination),e.masterGain=o,console.log("Master Gain initialized with gain:",o.gain.value)})(),document.dispatchEvent(new CustomEvent("initialAudioBuffersReady",{detail:{success:!0}}))},u=async()=>{try{await(async()=>{"suspended"===n.state&&await n.resume()})(),await c(),(async()=>{const{songsArray:n,initialSampleOrder:o}=e;if(!n.length)return void console.error("No songs to process.");const a=[],t=n.flatMap((e=>e.channels.map((n=>({song:e,channel:n}))))),r=new Set(o.map((e=>`${e.songId}-${e.channelId}`))),s=t.filter((({song:e,channel:n})=>!r.has(`${e.id}-${n.id}`))),i=[];for(;s.length;)i.push(s.splice(0,4));for(const e of i)await Promise.all(e.map((({song:e,channel:n})=>l(e,n,a))));d(a),console.log("All background audio buffers processed."),document.dispatchEvent(new CustomEvent("allAudioBuffersReady",{detail:{success:!0}}))})().catch((e=>console.error("Background processing error:",e)))}catch(e){console.error("Audio processing initialization error:",e)}};document.addEventListener("dataLoadingComplete",u),e.songsArray?.length&&u(),document.addEventListener("initialAudioBuffersReady",(()=>{console.log("Initial buffers ready. Press 'P' to play.")}))})();
