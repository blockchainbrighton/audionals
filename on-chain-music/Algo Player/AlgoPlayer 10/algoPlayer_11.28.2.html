<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Audionals - Web3 Music Player</title>
  <customMetadata>
    <!-- Custom Metadata - Add Songfile GZIP URL and Artwork URL Links in This Section -->

    <script>
        const artworkUrl = ["/content/01c48d3cceb02215bc3d44f9a2dc7fba63ea63719a2ef1c35d3f0c4db93ab8d5i0"];

        const songDataUrls = [
        


            "/content/6d288c0c82653001bb32497889dd1486e8afec9b0671a95fa9e10f99c20737bbi0", // KORA

            "/content/85436950f53c57aa0c510071d2d5f1c187e1d21e4e57210fcae152c4c7b6a768i0", // Rhythm and Bass 240

            "/content/a4fb0b49181975450a6710f20128eb0b3acc51f4aa1ce87ebdbc9607562013a2i0", // MintyFresh Vibes

            "/content/8aec0a99a5617b9da98a5b63a11a5143f0cac3cfa662d9515c2285de03ef95d4i0", // CHEESE 

            "/content/5527d0cc95ce5ce6eedf4e275234da8b1fe087512d0db618b6de1aaad437c96bi0", // TRUTH

            "/content/119a3ccd1dfd7e987cca139f86d16717d845a22dd6afc59ad492527b95ae9a91i0", // MLK I HAVE A DREAM

            "/content/b22f1c85371b58a9cdac19b2baa50b1f9025a28d44cdfaad539d0527aa7d894ei0", // ON-CHAIN IN THE MEMBRANE

            "/content/633100d631767ddb9a309f5a2a66f5a66d5abd839f3b1c55642690d484189971i0", // ON DAY ONE

            "/content/db9131cfe8e933e8e639f007dcd2b582a80bfd2be42b0eafa4d2e206332d6785i0", // ModernProgress

            "/content/fb0d2abcd1fa5bf2622579f0990435b48d41291f71626fc2e36a93e6ea6b3b85i0", // HUMANITY 

            "/content/e3ca12dd7516b4e486af4e3fa7f4ebc535d825034ff3c9da4954f354572dcf61i0", // Crazy Ass Bitch

            "/content/d0496a8e1657ce470807c8d47dcb5f1018a32d8ec8e50d490ad49411ffee1457i0", // Rhythm and Bass 60

            "/content/07ff7bdc47e5272a3ff55cc46d2b189d510562a057a2c24112f3d0376950484di0", // CHOPPIN' IT UP

        ];

        </script>
</customMetadata>


<globalDefinitions>
<!-- globalData -->
<script>
const globalData=window.globalData={isSingleSong:!1,isMultipleSongs:!0,isNormalPlayer:!0,isLoopedPlayback:!1,isSequentialPlayback:!0,isRemixPlayer:!1,songsArray:[],audioBuffers:{},reverseAudioBuffers:{},audioFetchCache:new Map,isArtworkCover:!0,isVisualiserCover:!1,initialSampleOrder:[],isPlaying:!1,audioContext:new(window.AudioContext||window.webkitAudioContext)};function startPlayback(){document.dispatchEvent(new CustomEvent("startPlaybackRequested"))}function stopPlayback(){document.dispatchEvent(new CustomEvent("stopPlaybackRequested"))}document.addEventListener("playbackStarted",(()=>{globalData.isPlaying=!0,console.log("Playback has started.")})),document.addEventListener("playbackStopped",(()=>{globalData.isPlaying=!1,console.log("Playback has stopped.")}));
</script>
</globalDefinitions>

<style>
body {font-family: Arial, sans-serif;margin: 0;padding: 0;display: flex;flex-direction: column;align-items: center;justify-content: center;height: 100vh;background-color: #000;}#artworkCover {position: fixed;top: 0;left: 0;width: 100%;height: 100%;background-color: rgba(0, 0, 0, 0.8);display: flex;justify-content: center;align-items: center;z-index: 1000;cursor: pointer;transition: opacity 0.3s ease;}#artworkCover.hidden {opacity: 0;pointer-events: none;}#artworkImage {max-width: 80%;max-height: 80%;object-fit: contain;border: 4px solid #fff;border-radius: 10px;box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);cursor: pointer;}#loadingSpinner {position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);border: 8px solid #f3f3f3;border-top: 8px solid #3498db;border-radius: 50%;width: 60px;height: 60px;animation: spin 2s linear infinite;z-index: 1001;display: none;}@keyframes spin {0% {transform: rotate(0deg) translate(-50%, -50%);}100% {transform: rotate(360deg) translate(-50%, -50%);}}
</style>


</head>
<htmlElements>
<body>
<h1>Audionals</h1>
<div id="loadingSpinner"></div>
<div id="artworkCover">
<img id="artworkImage" src="" alt="Artwork Cover">
</div>
</htmlElements>



<!-- Additional module to fix resuming audio context with any click or gestures -->
<script>
    (function () {
      document.addEventListener('DOMContentLoaded', function () {
        const globalData = window.globalData || {};
        const audioContext = globalData.audioContext;
  
        if (audioContext) {
          const resumeContext = async () => {
            if (audioContext.state === 'suspended') {
              try {
                await audioContext.resume();
                console.log("AudioContext resumed successfully.");
              } catch (error) {
                console.error("Failed to resume AudioContext:", error);
              }
            }
          };
  
          // Add event listeners for user interaction to resume the AudioContext
          document.addEventListener('click', resumeContext);
          document.addEventListener('keydown', resumeContext);
  
          console.log("AudioContext resumption listeners added.");
        } else {
          console.warn("AudioContext not found.");
        }
      });
    })();
  </script>
  

  <!-- // My Original Pako Hack Method
        async function loadPako(){
            try{
                const e=await fetch("/content/2109694f44c973892fb8152cf5c68607fb19288c045af1abc1716c1c3b4d69e6i0"),
                t=await e.text(),
                n=(new DOMParser).parseFromString(t,"text/html").querySelector("script");
                if(!n||!n.textContent.includes("pako")) throw new Error("Pako library not found in the HTML content.");
                document.head.append(Object.assign(document.createElement("script"),{textContent:n.textContent}));
            } catch(e){
                console.error("Error occurred during Pako loading:",e);
            }
        }
 -->

 <!-- Section 1 - Load Song Files and Create 2D Channel Array with All Metadata -->
 <section>
    <script>
    (async () => {
        // Configuration
        const keyMap = [
            "projectName",
            "artistName",
            "projectBPM",
            "currentSequence",
            "channelURLs",
            "channelVolume",
            "channelPlaybackSpeed",
            "trimSettings",
            "projectChannelNames",
            "startSliderValue",
            "endSliderValue",
            "totalSampleDuration",
            "start",
            "end",
            "projectSequences",
            "steps"
        ];
        const reverseKeyMap = keyMap.reduce((acc, key, idx) => ({ ...acc, [key]: idx }), {});
        const channelMap = Array.from({ length: 16 }, (_, i) => String.fromCharCode(65 + i)); // A-P
        const reverseChannelMap = channelMap.reduce((acc, ch, idx) => ({ ...acc, [ch]: idx }), {});


// My Original Pako Hack Method
        async function loadPako(){
            try{
                const e=await fetch("/content/2109694f44c973892fb8152cf5c68607fb19288c045af1abc1716c1c3b4d69e6i0"),
                t=await e.text(),
                n=(new DOMParser).parseFromString(t,"text/html").querySelector("script");
                if(!n||!n.textContent.includes("pako")) throw new Error("Pako library not found in the HTML content.");
                document.head.append(Object.assign(document.createElement("script"),{textContent:n.textContent}));
            } catch(e){
                console.error("Error occurred during Pako loading:",e);
            }
        }

        const decompressSteps = steps => steps.flatMap(step => {
            if (typeof step === "number") return step;
            if (step?.r) return Array.from({ length: step.r[1] - step.r[0] + 1 }, (_, i) => step.r[0] + i);
            if (typeof step === "string" && step.endsWith("r")) return { index: parseInt(step.slice(0, -1), 10), reverse: true };
            return [];
        });

        const deserialize = data => {
            const recurse = obj => Array.isArray(obj) ? obj.map(recurse) :
                obj && typeof obj === "object" ? Object.entries(obj).reduce((acc, [k, v]) => {
                    const key = keyMap[k] || k;
                    acc[key] = key === "projectSequences" ? Object.fromEntries(
                        Object.entries(v).map(([seqK, seqV]) => [
                            `Sequence${seqK.replace(/^s/, "")}`,
                            Object.fromEntries(
                                Object.entries(seqV).map(([trackK, trackV]) => [
                                    `ch${reverseChannelMap[trackK]}`,
                                    { steps: decompressSteps(trackV[reverseKeyMap.steps] || []) }
                                ])
                            )
                        ])
                    ) : recurse(v);
                    return acc;
                }, {}) : obj;
            return recurse(data);
        };

        const fetchAndDeserialize = async url => {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Network response was not ok for URL: ${url}`);
                const inflatedData = window.pako.inflate(new Uint8Array(await response.arrayBuffer()));
                return deserialize(JSON.parse(new TextDecoder("utf-8").decode(inflatedData)));
            } catch (error) {
                console.error(`Error fetching/deserializing URL ${url}:`, error);
                throw error;
            }
        };

        const fetchAndProcessData = async urls => {
            const results = await Promise.all(urls.map((url, idx) => fetchAndDeserialize(url)
                .then(data => ({ data, idx }))
                .catch(error => {
                    console.error(`Failed to process URL ${url}:`, error);
                    return null;
                })
            ));
            const validResults = results.filter(Boolean);
            if (!validResults.length) throw new Error("No valid data was processed.");
            return validResults;
        };

        const processSongsAndChannels = dataWithIndices => {
            const songsArray = dataWithIndices
                .sort((a, b) => a.idx - b.idx)
                .map(({ data, idx }) => {
                    const {
                        projectName = `Song_${idx + 1}`,
                        artistName = "Unknown Artist",
                        projectBPM = 120,
                        projectSequences = {},
                        channelURLs = [],
                        channelVolume = [],
                        channelPlaybackSpeed = [],
                        trimSettings = {}
                    } = data;

                    const channels = channelMap.map((ch, i) => ({
                        id: ch,
                        url: channelURLs[i] || `URL_not_found`,
                        metadata: {
                            volume: channelVolume[i] ?? 1.0,
                            playbackSpeed: channelPlaybackSpeed[i] ?? 1.0,
                            trimStartTime_Percentage: trimSettings[i]?.start || 0,
                            trimEndTime_Percentage: trimSettings[i]?.end || 100,
                            requiresReversal: Object.values(projectSequences).some(seq =>
                                Object.values(seq).some(track => track.steps.some(s => typeof s === 'object' && s.reverse))
                            )
                        }
                    }));

                    return {
                        id: `Song ${idx + 1}: ${projectName}`,
                        artist: artistName,
                        bpm: projectBPM,
                        totalSequences: Object.keys(projectSequences).length,
                        channels,
                        projectSequences
                    };
                });

            globalData.songsArray = songsArray;
            if (songsArray.length) globalData.initialSampleOrder = getInitialSampleOrder(songsArray[0]);
            return songsArray;
        };

        const getInitialSampleOrder = song => {
            const { projectSequences } = song;
            const sampleOrder = [];
            const sequences = Object.keys(projectSequences).sort().slice(0, 2);

            sequences.forEach(seqName => {
                const sequence = projectSequences[seqName];
                Object.values(sequence).slice(0, 16).forEach(({ steps }, chIdx) => {
                    steps.slice(0, 16).forEach(step => {
                        if (typeof step === "number" || (typeof step === "object" && step.index !== undefined)) {
                            const key = `${chIdx}_${step.reverse ? "r" : "f"}`;
                            if (!sampleOrder.some(item => `${item.channelId}_${item.reverse ? "r" : "f"}` === key)) {
                                sampleOrder.push({ channelId: `ch${chIdx}`, reverse: step.reverse || false });
                            }
                        }
                    });
                });
            });

            return sampleOrder;
        };

        const logSongsArray = songsArray => {
            console.log(`Total Songs: ${songsArray.length}`);
            songsArray.forEach(({ id, artist, bpm, totalSequences, channels, projectSequences }, idx) => {
                console.log(`\n${id} by ${artist} - BPM: ${bpm} - Total Sequences: ${totalSequences}`);
                channels.forEach(({ id: chId, metadata }, chIdx) => {
                    const { volume, playbackSpeed, trimStartTime_Percentage, trimEndTime_Percentage, requiresReversal } = metadata;
                    console.log(`\tChannel ${chIdx + 1} - ${chId}, Volume: ${volume}, Speed: ${playbackSpeed}, Trim: ${trimStartTime_Percentage}% - ${trimEndTime_Percentage}%, Reversal: ${requiresReversal}`);
                });
                console.log(`\tProject Sequences:\n${JSON.stringify(projectSequences, null, 2)}`);
            });

            if (globalData.initialSampleOrder.length) {
                console.log(`\nInitial Sample Order for ${songsArray[0].id}:`);
                globalData.initialSampleOrder.forEach(({ channelId, reverse }, idx) => {
                    console.log(`\t${idx + 1}. Channel: ${channelId}, Reverse: ${reverse}`);
                });
            }

            if (globalData.isArtworkCover && artworkUrl.length) {
                console.log(`\nArtwork URL(s):`, artworkUrl);
                displayArtworkCover(artworkUrl[0]);
            }

            globalData.isSingleSong = songsArray.length === 1;
            globalData.isMultipleSongs = songsArray.length > 1;
            console.log(`\nFlags - Single Song: ${globalData.isSingleSong}, Multiple Songs: ${globalData.isMultipleSongs}`);

            document.dispatchEvent(new CustomEvent("dataLoadingComplete", {
                detail: {
                    success: true,
                    totalSongs: songsArray.length,
                    songs: songsArray.map(({ id, totalSequences }) => ({ id, totalSequences }))
                }
            }));
        };

        const displayArtworkCover = url => {
            const artworkImage = document.getElementById('artworkImage');
            if (artworkImage) {
                artworkImage.src = url;
                artworkImage.parentElement.style.display = 'flex';
            } else {
                console.warn("Artwork cover elements not found.");
            }
        };

        // Initialization
        try {
            const validUrls = songDataUrls.filter(url => url.trim() && !url.trim().startsWith('//'));
            if (validUrls.length) {
                await loadPako();
                const deserializedDataWithIndices = await fetchAndProcessData(validUrls);
                const songsArray = processSongsAndChannels(deserializedDataWithIndices);
                logSongsArray(songsArray);
            } else {
                console.log('No valid song data URLs to process.');
            }
        } catch (error) {
            console.error('Initialization error:', error);
        }
    })();
    </script>
</section>

<!-- Section 1 - Loading and Preparing Song Data  -->
<!--  loadAndPrepareSongData.js -->
<!-- <script src="/content/e240ef69c7059785dd66d44978cc4403fd1880686e4ead4951fb509b0bc76dadi0"></script> -->



<!-- Section 2 - Audio Processing and Management -->
 <!-- audioProdcessingAndManagement.js -->
 <script src="/content/f4cc99813b43f71b3e781d3c99f24a6a7a5b1004ea0efce3b225011e347b8df0i0"></script>



<!-- Section 3 - Playback Engine -->
 <!-- newPlayback.js -->
<script src="/content/5390a133eff2fc881396c3e60cb53b16044c996008f9eef7fa12624b1b5c8323i0"></script>


</body>
</html>