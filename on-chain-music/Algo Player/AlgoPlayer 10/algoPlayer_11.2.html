<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Web3 Audio Sequencer Playback Engine Test</title>
</head>
<body>
    <h1>Web3 Audio Sequencer Playback Engine Test</h1>
    <p>Check the console for the 2D array of songs and channels with metadata.</p>



    <SectionOne>
        <!-- Section 1 - Load Song Files and Create 2D Channel Array with All Metadata -->
         <!-- This section also sets flags for single or multiple songs in the array -->
        
        <script>
            // ---------------------- Global Data ---------------------- //
            window.globalData = {
                isSingleSong: false,
                isMultipleSongs: false
            };
        
            // ---------------------- Configuration ---------------------- //
        
            // Key mapping for deserialization process
            const keyMap = {
                0: "projectName",
                1: "artistName",
                2: "projectBPM",
                3: "currentSequence",
                4: "channelURLs",
                5: "channelVolume",
                6: "channelPlaybackSpeed",
                7: "trimSettings",
                8: "projectChannelNames",
                9: "startSliderValue",
                10: "endSliderValue",
                11: "totalSampleDuration",
                12: "start",
                13: "end",
                14: "projectSequences",
                15: "steps"
            };
        
            // Reverse keyMap for reverse lookup
            const reverseKeyMap = Object.fromEntries(
                Object.entries(keyMap).map(([key, value]) => [value, +key])
            );
        
            // Create a map of letters 'A' to 'Z' representing channels
            const channelMap = Array.from({ length: 26 }, (_, index) => String.fromCharCode(65 + index));
        
            // Reverse map to convert channel letters back to their index
            const reverseChannelMap = Object.fromEntries(
                channelMap.map((letter, index) => [letter, index])
            );
        
            // ---------------------- Utility Functions ---------------------- //
        
            /**
             * Load the Pako library dynamically from a Web3 content endpoint.
             * 
             */
            const loadPako = async () => {
                try {
        
                    // Load Pako from Web3 content endpoint
                    const pakoUrl = "/content/2109694f44c973892fb8152cf5c68607fb19288c045af1abc1716c1c3b4d69e6i0"; // Replace with your actual Pako content endpoint
                    const response = await fetch(pakoUrl);
                    if (!response.ok) throw new Error(`Failed to fetch Pako script: ${response.statusText}`);
        
                    const textContent = await response.text();
                    const scriptContent = new DOMParser().parseFromString(textContent, "text/html").querySelector("script")?.textContent;
        
                    if (!scriptContent?.includes("pako")) {
                        throw new Error("Pako library not found in the fetched content.");
                    }
        
                    const scriptElement = document.createElement("script");
                    scriptElement.textContent = scriptContent;
                    document.head.appendChild(scriptElement);
        
                    console.log("Pako library loaded successfully from Web3 content endpoint.");
                } catch (error) {
                    console.error("Error loading Pako library:", error);
                    throw error;
                }
            };
        
            /**
             * Decompress the steps data.
             * - If the step is a number, return it as-is.
             * - If it contains a range 'r', expand the range into individual numbers.
             * - If it's a reverse step (ends with 'r'), convert it into an object with 'reverse: true'.
             * @param {Array} steps - The steps data to decompress.
             * @returns {Array} - The decompressed steps.
             */
            const decompressSteps = (steps) => steps.flatMap(step => {
                if (typeof step === "number") return step;
        
                if (step && typeof step === "object" && "r" in step) {
                    const [start, end] = step.r;
                    return Array.from({ length: end - start + 1 }, (_, i) => start + i);
                }
        
                if (typeof step === "string" && step.endsWith("r")) {
                    return { index: parseInt(step.slice(0, -1), 10), reverse: true };
                }
        
                return [];
            });
        
            /**
             * Deserialize the fetched JSON data using the provided keyMap.
             * @param {Object} data - The JSON data to deserialize.
             * @returns {Object} - The deserialized data.
             */
            const deserialize = (data) => {
                const recursiveDeserialize = (obj) => {
                    if (Array.isArray(obj)) {
                        return obj.map(item => (typeof item === "object" ? recursiveDeserialize(item) : item));
                    }
                    if (obj && typeof obj === "object") {
                        return Object.entries(obj).reduce((acc, [key, value]) => {
                            const mappedKey = keyMap[key] || key;
                            if (mappedKey === "projectSequences") {
                                acc[mappedKey] = Object.entries(value).reduce((sequenceAcc, [seqKey, seqValue]) => {
                                    const sequenceName = seqKey.replace(/^s/, "Sequence");
                                    sequenceAcc[sequenceName] = Object.entries(seqValue).reduce((trackAcc, [trackKey, trackValue]) => {
                                        const channelName = `ch${reverseChannelMap[trackKey]}`;
                                        const steps = trackValue[reverseKeyMap.steps] || [];
                                        trackAcc[channelName] = {
                                            steps: decompressSteps(steps)
                                        };
                                        return trackAcc;
                                    }, {});
                                    return sequenceAcc;
                                }, {});
                            } else {
                                acc[mappedKey] = recursiveDeserialize(value);
                            }
                            return acc;
                        }, {});
                    }
                    return obj;
                };
        
                return recursiveDeserialize(data);
            };
        
            /**
             * Fetch and deserialize data from a given URL.
             * @param {string} url - The URL to fetch data from.
             * @returns {Object} - The deserialized data.
             */
            const fetchAndDeserialize = async (url) => {
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Network response was not ok for URL: ${url}`);
        
                    const arrayBuffer = await response.arrayBuffer();
                    const inflatedData = pako.inflate(new Uint8Array(arrayBuffer));
                    const jsonString = new TextDecoder("utf-8").decode(inflatedData);
                    return deserialize(JSON.parse(jsonString));
                } catch (error) {
                    console.error(`Error in fetchAndDeserialize for URL ${url}:`, error);
                    throw error;
                }
            };
        
            /**
             * Fetch and process multiple URLs concurrently.
             * @param {Array<string>} urls - The list of URLs to process.
             * @returns {Array<Object>} - An array of deserialized data objects.
             */
            const fetchAndProcessData = async (urls) => {
                try {
                    const fetchPromises = urls.map(url => fetchAndDeserialize(url).catch(error => {
                        console.error(`Failed to process URL ${url}:`, error);
                        return null;
                    }));
        
                    const results = (await Promise.all(fetchPromises)).filter(Boolean);
        
                    if (!results.length) throw new Error("No valid data was processed.");
                    return results;
                } catch (error) {
                    console.error("Error in fetchAndProcessData:", error);
                    throw error;
                }
            };
        
            /**
             * Process the deserialized data to extract songs and their channels with metadata.
             * @param {Array<Object>} deserializedData - The array of deserialized song data.
             * @returns {Array<Object>} - A 2D array representing songs and their channels with metadata.
             */
            const processSongsAndChannels = (deserializedData) => {
                const songsArray = deserializedData.map((songData, songIndex) => {
                    const song = {
                        id: songData.projectName || `Song_${songIndex + 1}`,
                        channels: []
                    };
        
                    const channelURLs = songData.channelURLs || [];
                    const channelVolume = songData.channelVolume || [];
                    const channelPlaybackSpeed = songData.channelPlaybackSpeed || [];
                    const trimSettings = songData.trimSettings || {};
        
                    for (let i = 0; i < 16; i++) { // Up to 16 channels
                        const channel = {
                            id: channelMap[i] || `Channel_${i + 1}`,
                            url: channelURLs[i] || `URL_not_found`,
                            metadata: {
                                volume: channelVolume[i] !== undefined ? channelVolume[i] : 1.0, // Default volume
                                playbackSpeed: channelPlaybackSpeed[i] !== undefined ? channelPlaybackSpeed[i] : 1.0, // Default speed
                                trimStartTime: trimSettings[i]?.start || 0, // Default start trim
                                trimEndTime: trimSettings[i]?.end || 0 // Default end trim
                            }
                        };
                        song.channels.push(channel);
                    }
        
                    return song;
                });
        
                return songsArray;
            };
        
            /**
             * Log the structured 2D array of songs and channels with metadata in a single line format.
             * @param {Array<Object>} songsArray - The 2D array to log.
             */
            const logSongsArray = (songsArray) => {
                console.log(`Total Songs: ${songsArray.length}`);
                songsArray.forEach((song, songIndex) => {
                    song.channels.forEach((channel, channelIndex) => {
                        console.log(
                            `Song #${songIndex + 1}: ${song.id},  Channel ${channelIndex + 1} - ${channel.id}, ` +
                            `Volume: ${channel.metadata.volume}, Playback Speed: ${channel.metadata.playbackSpeed}, ` +
                            `Trim Start Time: ${channel.metadata.trimStartTime}, Trim End Time: ${channel.metadata.trimEndTime}`
                        );
                    });
                });
        
                // Set global flags based on the number of songs
                window.globalData.isSingleSong = songsArray.length === 1;
                window.globalData.isMultipleSongs = songsArray.length > 1;
        
                console.log(`Flags set - isSingleSong: ${window.globalData.isSingleSong}, isMultipleSongs: ${window.globalData.isMultipleSongs}`);
            };
        
            // ---------------------- Placeholder Variables ---------------------- //
        
            // Define placeholder variables for testing
            const VOLUME_CONTROLS = {}; // Populate as needed
            const SPEED_CONTROLS = {}; // Populate as needed
            const selectedBPM = 120; // Example BPM value
        
            // ---------------------- Initialization ---------------------- //
        
            /**
             * Initialize the data processing workflow.
             */
            const init = async () => {
                console.log('Init function called. Preparing to process song data URLs...');
        
                const songDataUrls = [
                    "/content/119a3ccd1dfd7e987cca139f86d16717d845a22dd6afc59ad492527b95ae9a91i0", // MLK I HAVE A DREAM
                    "/content/5527d0cc95ce5ce6eedf4e275234da8b1fe087512d0db618b6de1aaad437c96bi0", // TRUTH
                    "/content/6d288c0c82653001bb32497889dd1486e8afec9b0671a95fa9e10f99c20737bbi0", // KORA
                    "/content/8aec0a99a5617b9da98a5b63a11a5143f0cac3cfa662d9515c2285de03ef95d4i0", // CHEESE ** MIGHT BE THIS ONE THAT IS OUT OF SYNC??
                    "/content/db9131cfe8e933e8e639f007dcd2b582a80bfd2be42b0eafa4d2e206332d6785i0", // ModernProgress
                    "/content/07ff7bdc47e5272a3ff55cc46d2b189d510562a057a2c24112f3d0376950484di0", // CHOPPIN' IT UP
                    "/content/fb0d2abcd1fa5bf2622579f0990435b48d41291f71626fc2e36a93e6ea6b3b85i0", // HUMANITY
                    "/content/3359ce42359274ddbd2184d9f75a38b7e59b1d5f24512959e29c377fc8ca604ai0", // MintyFresh Vibes
                    "/content/633100d631767ddb9a309f5a2a66f5a66d5abd839f3b1c55642690d484189971i0", // ON DAY ONE
                    "/content/85436950f53c57aa0c510071d2d5f1c187e1d21e4e57210fcae152c4c7b6a768i0", // Rhythm and Bass 240
                    "/content/e3ca12dd7516b4e486af4e3fa7f4ebc535d825034ff3c9da4954f354572dcf61i0", // Crazy Ass Bitch
                    "/content/d0496a8e1657ce470807c8d47dcb5f1018a32d8ec8e50d490ad49411ffee1457i0", // Rhythm and Bass 60
                    "/content/b22f1c85371b58a9cdac19b2baa50b1f9025a28d44cdfaad539d0527aa7d894ei0", // ON-CHAIN IN THE MEMBRANE
                    // Add or remove song URLs as needed
                ];
        
                // Filter out any commented or invalid URLs
                const validSongUrls = songDataUrls.filter(url => !url.trim().startsWith('//') && url.trim() !== '');
        
                console.log(`Found ${validSongUrls.length} valid song data URLs to process.`);
        
                if (validSongUrls.length) {
                    try {
                        console.log('Loading Pako library...');
                        await loadPako();
        
                        console.log('Fetching and deserializing song data...');
                        const deserializedData = await fetchAndProcessData(validSongUrls);
        
                        console.log('Processing songs and channels...');
                        const songsArray = processSongsAndChannels(deserializedData);
        
                        console.log('Logging the 2D array of songs and channels with metadata:');
                        logSongsArray(songsArray);
        
                        console.log('Init function execution complete.');
                    } catch (error) {
                        console.error('Error during initialization:', error);
                    }
                } else {
                    console.log('No valid song data URLs to process.');
                }
            };
        
            // Attach the init function to window to ensure it's accessible
            window.init = init;
        
            // Automatically invoke the init function on DOMContentLoaded
            window.addEventListener('DOMContentLoaded', () => {
                window.init();
            });
        </script>
        
        <!-- By the end of Section 1, all song data is arranged in a 2D array of channels along with their metadata -->
        </SectionOne>
        

<sectionTwo>

    <!-- Section 2 is the section that deals with audio buffering and mapping -->
     <!-- Audio buffers need to be created after calculating the trimmed section of the audio to buffer from the total length of the original audio file-->
    <!-- Trim times are in percentage terms so we must first calculate the total sample length then apply the trim times as percentages to get the actual trim times -->
    <!-- Once actual trim times have been calculated buffers can be formed of the remaining audio after trims have been applied -->
    <!-- Reverse buffers of the same sections should then be created and mapped alongside the original buffers -->

    <script>
        // ---------------------- Audio Buffering and Mapping ---------------------- //

        // Placeholder variables for testing
        const audioContext = new AudioContext();
        const audioBuffers = {}; // Populate as needed
        const reverseAudioBuffers = {}; // Populate as needed

        /**
         * Calculate the total sample duration based on the provided BPM and total beats.
         * @param {number} bpm - The BPM value.
         * @param {number} totalBeats - The total number of beats.
         * @returns {number} - The total sample duration in seconds.
         */
        const calculateTotalSampleDuration = (bpm, totalBeats) => {
            const beatsPerSecond = bpm / 60;
            return totalBeats / beatsPerSecond;
        };

        /**
         * Calculate the actual trim times based on the total sample duration and trim settings.
         * @param {number} totalSampleDuration - The total sample duration in seconds.
         * @param {number} startTrimTime - The start trim time as a percentage.
         * @param {number} endTrimTime - The end trim time as a percentage.
         * @returns {Object} - The actual trim times in seconds.
         */
        const calculateActualTrimTimes = (totalSampleDuration, startTrimTime, endTrimTime) => {
            const startTrim = totalSampleDuration * startTrimTime;
            const endTrim = totalSampleDuration * endTrimTime;
            return { startTrim, endTrim };
        };

        /**
         * Create an audio buffer from the provided audio URL and trim settings.
         * @param {string} audioUrl - The URL of the audio file.
         * @param {number} startTrim - The start trim time in seconds.
         * @param {number} endTrim - The end trim time in seconds.
         * @returns {Promise<AudioBuffer>} - The created audio buffer.
         */
        const createAudioBuffer = async (audioUrl, startTrim, endTrim) => {
            try {
                const response = await fetch(audioUrl);
                if (!response.ok) throw new Error(`Network response was not ok for URL: ${audioUrl}`);

                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(startTrim, endTrim));

                return audioBuffer;
            } catch (error) {
                console.error(`Error creating audio buffer for URL ${audioUrl}:`, error);

            }
        };
                /** Create a reverse audio buffer from the provided audio buffer.
                 * @param {AudioBuffer} audioBuffer - The original audio buffer.
                 * @returns {AudioBuffer} - The created reverse audio buffer.
                 */

        const createReverseAudioBuffer = (audioBuffer) => {
            const numberOfChannels = audioBuffer.numberOfChannels;
            const sampleRate = audioBuffer.sampleRate;
            const length = audioBuffer.length;
            const reverseAudioBuffer = audioContext.createBuffer(numberOfChannels, length, sampleRate);

            for (let channel = 0; channel < numberOfChannels; channel++) {
                const originalChannelData = audioBuffer.getChannelData(channel);
                const reverseChannelData = reverseAudioBuffer.getChannelData(channel);

                for (let i = 0; i < length; i++) {
                    reverseChannelData[i] = originalChannelData[length - i - 1];
                }
            }

            return reverseAudioBuffer;
        };

        </script>         


        // By the end of Section 2, all audio buffers and reverse audio buffers are created and mapped
</sectionTwo>


</body>
</html>
