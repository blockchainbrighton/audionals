<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Audionals - Web3 Music Player</title>
    <!-- Custom Metadata -->
    <script>
        const artworkUrl = ["/content/01c48d3cceb02215bc3d44f9a2dc7fba63ea63719a2ef1c35d3f0c4db93ab8d5i0"];
        const songDataUrls = [
            "/content/8aec0a99a5617b9da98a5b63a11a5143f0cac3cfa662d9515c2285de03ef95d4i0", // CHEESE 
            "/content/5527d0cc95ce5ce6eedf4e275234da8b1fe087512d0db618b6de1aaad437c96bi0", // TRUTH
            "/content/6d288c0c82653001bb32497889dd1486e8afec9b0671a95fa9e10f99c20737bbi0", // KORA
            "/content/119a3ccd1dfd7e987cca139f86d16717d845a22dd6afc59ad492527b95ae9a91i0", // MLK I HAVE A DREAM
            "/content/db9131cfe8e933e8e639f007dcd2b582a80bfd2be42b0eafa4d2e206332d6785i0", // ModernProgress
            "/content/07ff7bdc47e5272a3ff55cc46d2b189d510562a057a2c24112f3d0376950484di0", // CHOPPIN' IT UP
            "/content/fb0d2abcd1fa5bf2622579f0990435b48d41291f71626fc2e36a93e6ea6b3b85i0", // HUMANITY
            "/content/a4fb0b49181975450a6710f20128eb0b3acc51f4aa1ce87ebdbc9607562013a2i0", // MintyFresh Vibes
            "/content/633100d631767ddb9a309f5a2a66f5a66d5abd839f3b1c55642690d484189971i0", // ON DAY ONE
            "/content/85436950f53c57aa0c510071d2d5f1c187e1d21e4e57210fcae152c4c7b6a768i0", // Rhythm and Bass 240
            "/content/e3ca12dd7516b4e486af4e3fa7f4ebc535d825034ff3c9da4954f354572dcf61i0", // Crazy Ass Bitch
            "/content/d0496a8e1657ce470807c8d47dcb5f1018a32d8ec8e50d490ad49411ffee1457i0", // Rhythm and Bass 60
            "/content/b22f1c85371b58a9cdac19b2baa50b1f9025a28d44cdfaad539d0527aa7d894ei0", // ON-CHAIN IN THE MEMBRANE
            "/content/5ee46b8f645a65b0ec8ae749a28f88e364347f89137bb79986355bf5fb94cbebi0", // Fiat Money by Solemn
            "/content/c41de57f1e062a440a9fc96d54baaccd7ec40049f48e9f3880559afc60b1b09ai0", // When You Know
            "/content/9dfa1812b211a7ac8b2f9e77119828ec8fbf2e9016b3d37a8efd70052eb4aa3ci0", // Based New Song
            "/content/4653bcc45671abdbc024b03ebbaaadb30e0cad83b80898894ab22426bbccdaaei0", // Freedom to Transact
        ];
    </script>

    <!-- Global Definitions -->
    <script>
        const globalData = window.globalData = {
            isPlaying: false,
            currentSongIndex: 0,
            songsArray: [],
            audioBuffers: {},
            reverseAudioBuffers: {},
            audioContext: new (window.AudioContext || window.webkitAudioContext)(),
            masterGain: null,
            gainNodes: {},
            isArtworkCover: true,
            isVisualiserCover: false,
        };

        // Initialize master gain node
        globalData.masterGain = globalData.audioContext.createGain();
        globalData.masterGain.connect(globalData.audioContext.destination);
    </script>

    <!-- Existing Styles -->
    <link rel="stylesheet" href="/content/d2d6df9b0c5eedacbf7005e4c0a8bdb0dce76ee278b23dbb7507213608349ecei0">

    <!-- Styles for Metadata Panel and Now Playing Container -->
    <style>
        /* Metadata Panel Styles */
        #metadataPanel {
            position: fixed;
            top: 0;
            left: -400px;
            width: 400px;
            height: 100%;
            background: rgba(20,20,20,0.95);
            color: #fff;
            padding: 10px 15px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.5);
            overflow-y: auto;
            transition: left 0.3s ease;
            z-index: 999;
        }
        #metadataPanel.visible {left: 0;}
        .metadataItem {
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }
        .metadataItem h2 {
            margin: 0;
            font-size: 1em;
            font-weight: normal;
        }
        .metadataItem p {
            margin: 0;
            font-size: 0.9em;
            color: #ffaa00;
        }
        .songTitle { color: #ffffff; }
        .artistName { color: #ffaa00; }
        #metadataContent {
            max-height: 90%;
            overflow-y: auto;
        }

        /* Now Playing Container Styles */
        #nowPlayingContainer {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(20, 20, 20, 0.95);
            color: #fff;
            padding: 10px 20px;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            z-index: 1000;
        }
        #nowPlayingText {
            display: flex;
            flex-direction: column;
        }
        #nowPlayingText .songTitle {
            font-size: 1.2em;
            font-weight: bold;
        }
        #nowPlayingText .artistName {
            font-size: 1em;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>Audionals</h1>
    <div id="loadingSpinner"></div>
    <div id="artworkCover">
        <img id="artworkImage" src="" alt="Artwork Cover">
    </div>

    <!-- Metadata Panel -->
    <div id="metadataPanel">
        <h2>Track Listings:</h2>
        <div id="metadataContent">
            <!-- Metadata items will be dynamically inserted here -->
        </div>
    </div>

    <!-- Now Playing Container -->
    <div id="nowPlayingContainer">
        <div id="nowPlayingText">
            <span class="songTitle">No song playing</span>
            <span class="artistName"></span>
        </div>
    </div>

    <!-- Combined Script for Metadata and Playback Management -->
    <script>
        (function() {
            // Project-Artist Mapping
            const projectArtistMap = {
                "I Love Cheese 2024 FINAL": "melophonic + Rex Speedway and The Denim Avengers",
                "TRUTH": "melophonic",
                "Kora Algo New": "melophonic",
                "MLK 120": "melophonic",
                "Modern Progress Vocal": "jim.btc",
                "Choppin' It Up": "Jim.btc",
                "HUMANITY": "Jim.btc",
                "Minty Fresh v2": "melophonic + Rare Scrilla",
                "How We Be - Based": "Based.btc",
                "Rhythm and Bass": "Jim.btc",
                "CrazyAssBitch": "Jim.btc + French Montana",
                "Rhythm and Bass @60": "Jim.btc",
                "On-Chain in the Membrane": "melophonic",
                "FIAT MONEY": "Solemn",
                "didd you know 1": "Solemn",
                "Bear Market Disco": "Based.btc",
                "FREEDOM TO TRANSACT REMIX": "melophonic",
                // Add more mappings as needed
            };

            // Extract project name from song ID
            function extractProjectName(id) {
                const match = id?.match(/Song\s+\d+:\s+(.+)/);
                return match && match[1] ? match[1].trim() : 'Unknown Project Name';
            }

            // Get artist name from mapping or fallback
            function getArtistName(projectName, fallbackArtist) {
                return projectArtistMap[projectName] || fallbackArtist || 'Unknown Artist Name';
            }

            // Process songs to extract metadata
            function processSongs(songs) {
                return songs.map((song, index) => {
                    const projectName = extractProjectName(song.id);
                    const artistName = getArtistName(projectName, song.artist);
                    return { projectName, artistName, trackNumber: index + 1 };
                });
            }

            // Populate metadata panel
            function populateMetadataPanel(processedSongs) {
                const metadataContent = document.getElementById('metadataContent');
                if (!metadataContent) return console.warn('Metadata content container (#metadataContent) not found.');
                metadataContent.innerHTML = '';

                processedSongs.forEach(({ trackNumber, projectName, artistName }) => {
                    const item = document.createElement('div');
                    item.className = 'metadataItem';

                    const title = document.createElement('h2');
                    title.textContent = `${trackNumber}. ${projectName}`;
                    item.appendChild(title);

                    const artist = document.createElement('p');
                    artist.textContent = artistName;
                    item.appendChild(artist);

                    metadataContent.appendChild(item);
                });
            }

            // Handle metadata display and logging
            function handleData(songs) {
                if (!Array.isArray(songs) || songs.length === 0) return console.warn('No songs data available to process.');
                const processedSongs = processSongs(songs);
                populateMetadataPanel(processedSongs);
                processedSongs.forEach(({ projectName, artistName }) => {
                    console.log(`Project Name: ${projectName}, Artist Name: ${artistName}`);
                });
            }

            // Toggle metadata panel visibility
            function toggleMetadataPanel() {
                const panel = document.getElementById('metadataPanel');
                if (panel) {
                    panel.classList.toggle('visible');
                } else {
                    console.warn('Metadata panel container (#metadataPanel) not found.');
                }
            }

            // Initialize script
            function init() {
                if (globalData && Array.isArray(globalData.songsArray) && globalData.songsArray.length > 0) {
                    handleData(globalData.songsArray);
                } else {
                    document.addEventListener('dataLoadingComplete', function(event) {
                        handleData(event.detail?.songs);
                    });
                }

                // Toggle metadata panel with 'M' key
                document.addEventListener('keydown', function(event) {
                    if (event.key.toLowerCase() === 'm') {
                        toggleMetadataPanel();
                    }
                });
            }

            init();
        })();
    </script>

    <!-- Script for Gain Node Management and Playback Engine -->
    <script>
        (function() {
            const gd = globalData;
            gd.gainNodes = gd.gainNodes || {};
            gd.normalizationFactors = {};
            gd.balancerGainNodes = {};

            let currentSongId = null;

            // Create gain nodes for song
            function createGainNodesForSong(song) {
                const songId = song.id;
                currentSongId = songId;
                if (!song.channels.length) {
                    console.warn(`No channels found for song ${songId}.`);
                    return;
                }

                gd.gainNodes[songId] = gd.gainNodes[songId] || {};

                song.channels.forEach(channel => {
                    if (!gd.gainNodes[songId][channel.id]) {
                        const gainNode = gd.audioContext.createGain();
                        gainNode.gain.value = 1;
                        gainNode.connect(gd.masterGain);
                        gd.gainNodes[songId][channel.id] = gainNode;
                    }
                });
            }

            // Cleanup gain nodes after song ends
            function cleanupGainNodesForSong(songId) {
                if (gd.gainNodes[songId]) {
                    Object.keys(gd.gainNodes[songId]).forEach(channelId => {
                        const gainNode = gd.gainNodes[songId][channelId];
                        if (gainNode) {
                            gainNode.disconnect();
                        }
                    });
                    delete gd.gainNodes[songId];
                } else {
                    console.warn(`No gain nodes found to clean up for song ${songId}.`);
                }
            }

            // Playback Engine
            (function() {
                const lookahead = 0.1;
                const schedulerInterval = 25;
                let schedulerTimerID = null;
                let sequenceStates = {};
                const missingBuffers = new Set();
                const activeSources = new Set();

                gd.togglePlayback = () => gd.isPlaying ? stopPlayback() : startPlayback();

                function startPlayback() {
                    if (gd.isPlaying) return;

                    const { songsArray, audioBuffers, reverseAudioBuffers, currentSongIndex } = gd;
                    if (!songsArray.length) return console.error("No songs available for playback.");

                    if (currentSongIndex >= songsArray.length) gd.currentSongIndex = 0;
                    const song = songsArray[gd.currentSongIndex];
                    const sequences = song.projectSequences || {};
                    console.log(`Starting playback for Song: ${song.id}`);

                    const stepDur = 60 / song.bpm / 4;
                    const seqDur = 64 * stepDur;
                    sequenceStates = {};
                    missingBuffers.clear();

                    let offset = 0;
                    for (const [name, seq] of Object.entries(sequences)) {
                        sequenceStates[name] = {
                            nextStepIndex: 0,
                            nextStepTime: gd.audioContext.currentTime + offset,
                            stepDuration: stepDur,
                            startTime: gd.audioContext.currentTime + offset,
                            endTime: gd.audioContext.currentTime + offset + seqDur,
                            completed: false
                        };
                        offset += seqDur;
                    }

                    gd.currentSongId = song.id;
                    createGainNodesForSong(song);

                    gd.isPlaying = true;
                    schedulerTimerID = setInterval(() => schedulerLoop(song, audioBuffers, reverseAudioBuffers), schedulerInterval);
                    console.log('Sequences scheduled and playback started.');
                    document.dispatchEvent(new CustomEvent("playbackStarted", { detail: { success: true } }));

                    // Update Now Playing Display
                    updateNowPlayingDisplay(song);
                }
                gd.startPlayback = startPlayback;

                function stopPlayback() {
                    if (!gd.isPlaying) return;

                    clearInterval(schedulerTimerID);
                    gd.isPlaying = false;
                    sequenceStates = {};
                    missingBuffers.clear();

                    activeSources.forEach(source => {
                        try {
                            source.stop();
                            source.disconnect();
                        } catch (e) {
                            console.error('Error stopping/disconnecting an audio source:', e);
                        }
                    });
                    activeSources.clear();

                    if (gd.currentSongId) {
                        cleanupGainNodesForSong(gd.currentSongId);
                        gd.currentSongId = null;
                    }

                    console.log('Playback stopped and sequence states reset.');
                    document.dispatchEvent(new CustomEvent("playbackStopped", { detail: { success: true } }));

                    // Reset Now Playing Display
                    resetNowPlayingDisplay();
                }
                gd.stopPlayback = stopPlayback;

                function schedulerLoop(song, audioBuffers, reverseAudioBuffers) {
                    const now = gd.audioContext.currentTime;
                    let allDone = true;

                    for (const [name, seq] of Object.entries(song.projectSequences || {})) {
                        const state = sequenceStates[name];
                        if (!state || state.completed) continue;

                        if (now >= state.endTime) {
                            state.completed = true;
                            continue;
                        }

                        allDone = false;

                        while (state.nextStepTime < now + lookahead && gd.isPlaying) {
                            const stepIdx = state.nextStepIndex;
                            const stepTime = state.nextStepTime;

                            for (const [track, data] of Object.entries(seq)) {
                                const chIdx = parseInt(track.slice(2), 10);
                                const channel = song.channels[chIdx];
                                if (!channel) continue;

                                const step = data.steps?.find(s => (typeof s === "number" ? s === stepIdx : s.index === stepIdx));
                                if (step !== undefined) {
                                    const reverse = typeof step === "object" && step.reverse;
                                    schedulePlayback(song, channel, stepTime, reverse, audioBuffers, reverseAudioBuffers, state.stepDuration);
                                }
                            }

                            state.nextStepIndex++;
                            if (state.nextStepIndex >= 64) {
                                state.completed = true;
                                break;
                            }
                            state.nextStepTime += state.stepDuration;
                        }
                    }

                    if (allDone) {
                        if (gd.isLoopedPlayback) {
                            resetPlayback();
                            startPlayback();
                        } else {
                            stopPlayback();
                        }
                    }
                }

                function schedulePlayback(song, channel, time, reverse, audioBuffers, reverseAudioBuffers, stepDur) {
                    const key = `${song.id}_${channel.id}_${reverse ? 'reverse' : 'normal'}`;
                    const buffer = reverse ? reverseAudioBuffers[song.id]?.[channel.id] : audioBuffers[song.id]?.[channel.id];

                    if (!buffer) {
                        if (!missingBuffers.has(key)) {
                            missingBuffers.add(key);
                            console.warn(`Audio buffer missing for Song: ${song.id}, Channel: ${channel.id}${reverse ? " (Reverse)" : ""}`);
                        }
                        return;
                    }

                    const source = gd.audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.playbackRate.value = channel.metadata.playbackSpeed || 1;

                    const gainNode = gd.gainNodes?.[song.id]?.[channel.id];
                    source.connect(gainNode || gd.masterGain);
                    source.start(time);
                    activeSources.add(source);

                    source.onended = () => activeSources.delete(source);
                }

                function resetPlayback() {
                    clearInterval(schedulerTimerID);
                    sequenceStates = {};
                    missingBuffers.clear();

                    activeSources.forEach(source => {
                        try {
                            source.stop();
                            source.disconnect();
                        } catch (e) {
                            console.error('Error stopping/disconnecting an audio source:', e);
                        }
                    });
                    activeSources.clear();

                    if (gd.currentSongId) {
                        cleanupGainNodesForSong(gd.currentSongId);
                        gd.currentSongId = null;
                    }

                    console.log('Playback reset for the next song.');
                    resetNowPlayingDisplay();
                }
                gd.resetPlayback = resetPlayback;

                // Initialize Playback Engine
                function initializePlaybackEngine() {
                    if (!gd.songsArray.length) {
                        console.error("No songs available for playback.");
                        return;
                    }
                    console.log("Playback Engine Initialization Complete.");
                    console.log("Playback is ready. Click the artwork to start.");
                }
                gd.initializePlaybackEngine = initializePlaybackEngine;

                // Setup Event Listeners
                function setupEventListeners() {
                    document.addEventListener("initialAudioBuffersReady", e => {
                        if (e.detail.success) {
                            initializePlaybackEngine();
                            console.log("Initial audio buffers are ready.");
                        }
                    });

                    ["playbackStarted", "playbackStopped"].forEach(eventName => {
                        document.addEventListener(eventName, e => {
                            if (e.detail.success) {
                                console.log(`Playback has been successfully ${eventName === "playbackStarted" ? "started" : "stopped"}.`);
                            }
                        });
                    });
                }

                // Setup Artwork Click Listener
                function setupArtworkClickListener() {
                    document.addEventListener('DOMContentLoaded', () => {
                        const cover = document.getElementById('artworkCover');
                        const img = document.getElementById('artworkImage');
                        const spinner = document.getElementById('loadingSpinner');
                        const showCover = () => {
                            cover.classList.remove('hidden');
                            spinner.style.display = 'none';
                        };
                        if (gd.isArtworkCover && artworkUrl.length > 0) {
                            img.src = artworkUrl[0];
                            showCover();
                            img.addEventListener('click', gd.togglePlayback);
                            console.log("Artwork cover is set up for playback toggle.");
                        } else {
                            console.warn("Artwork cover is not enabled or no artwork URL provided.");
                        }
                    });
                }

                // Update Now Playing Display
                function updateNowPlayingDisplay(song) {
                    const nowPlayingContainer = document.getElementById('nowPlayingContainer');
                    if (!nowPlayingContainer) {
                        console.warn("Now Playing Container not found.");
                        return;
                    }

                    const songTitleElement = nowPlayingContainer.querySelector('.songTitle');
                    const artistNameElement = nowPlayingContainer.querySelector('.artistName');

                    const projectName = extractProjectName(song.id);
                    const artistName = getArtistName(projectName, song.artist);

                    songTitleElement.textContent = projectName;
                    artistNameElement.textContent = artistName;
                }

                // Reset Now Playing Display
                function resetNowPlayingDisplay() {
                    const nowPlayingContainer = document.getElementById('nowPlayingContainer');
                    if (!nowPlayingContainer) {
                        console.warn("Now Playing Container not found.");
                        return;
                    }

                    const songTitleElement = nowPlayingContainer.querySelector('.songTitle');
                    const artistNameElement = nowPlayingContainer.querySelector('.artistName');

                    songTitleElement.textContent = 'No song playing';
                    artistNameElement.textContent = '';
                }

                // Start Setup
                function startSetup() {
                    setupEventListeners();
                    setupArtworkClickListener();
                    if (Object.keys(gd.audioBuffers || {}).length) initializePlaybackEngine();
                }

                startSetup();
            })();

            // Keyboard Controls and Event Listeners
            (function() {
                const gd = globalData;

                // Debounce timer to prevent rapid skips
                let debounceTimer = null;
                const DEBOUNCE_DELAY = 300;

                // Keydown event listener for arrow key navigation
                document.addEventListener('keydown', (event) => {
                    if (event.key !== 'ArrowRight' && event.key !== 'ArrowLeft') return;

                    if (debounceTimer) clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => handleSkip(event.key), DEBOUNCE_DELAY);
                });

                // Handle skip logic
                function handleSkip(key) {
                    const totalSongs = gd.songsArray.length;
                    if (totalSongs === 0) {
                        console.error("No songs available to skip.");
                        return;
                    }

                    if (key === 'ArrowRight') {
                        gd.currentSongIndex = (gd.currentSongIndex + 1) % totalSongs;
                        console.log(`Skipped to next song: ${gd.songsArray[gd.currentSongIndex].id}`);
                    } else if (key === 'ArrowLeft') {
                        gd.currentSongIndex = (gd.currentSongIndex - 1 + totalSongs) % totalSongs;
                        console.log(`Skipped to previous song: ${gd.songsArray[gd.currentSongIndex].id}`);
                    }

                    if (gd.isPlaying) {
                        gd.stopPlayback();
                        gd.startPlayback();
                    } else {
                        console.log("Playback is not active. Next song is cued and ready to play.");
                    }
                }

                // Resume AudioContext on user interaction
                document.addEventListener('DOMContentLoaded', function () {
                    if (gd.audioContext) {
                        const resumeContext = async () => {
                            if (gd.audioContext.state === 'suspended') {
                                try {
                                    await gd.audioContext.resume();
                                    console.log("AudioContext resumed successfully.");
                                } catch (error) {
                                    console.error("Failed to resume AudioContext:", error);
                                }
                            }
                        };

                        document.addEventListener('click', resumeContext);
                        document.addEventListener('keydown', resumeContext);

                        console.log("AudioContext resumption listeners added.");
                    } else {
                        console.warn("AudioContext not found.");
                    }
                });
            })();
        })();
    </script>

    <!-- Load and Prepare Song Data -->
    <script src="/content/44088e23250de51c70149b344a11ba29fe39850ac9b3bf2aa99e73f5d29c4825i0"></script>
</body>
</html>
