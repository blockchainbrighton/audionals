<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Audionals - Web3 Music Player</title>
    <custommetadata>
        <script>
            const artworkUrl = ["/content/01c48d3cceb02215bc3d44f9a2dc7fba63ea63719a2ef1c35d3f0c4db93ab8d5i0"];
            const songDataUrls = [
                "/content/8aec0a99a5617b9da98a5b63a11a5143f0cac3cfa662d9515c2285de03ef95d4i0", // CHEESE 
                "/content/5527d0cc95ce5ce6eedf4e275234da8b1fe087512d0db618b6de1aaad437c96bi0", // TRUTH
                "/content/6d288c0c82653001bb32497889dd1486e8afec9b0671a95fa9e10f99c20737bbi0", // KORA
                "/content/119a3ccd1dfd7e987cca139f86d16717d845a22dd6afc59ad492527b95ae9a91i0", // MLK I HAVE A DREAM
                "/content/db9131cfe8e933e8e639f007dcd2b582a80bfd2be42b0eafa4d2e206332d6785i0", // ModernProgress
                "/content/07ff7bdc47e5272a3ff55cc46d2b189d510562a057a2c24112f3d0376950484di0", // CHOPPIN' IT UP
                "/content/fb0d2abcd1fa5bf2622579f0990435b48d41291f71626fc2e36a93e6ea6b3b85i0", // HUMANITY // Turn Down Channels 1 + 2 (Apollo 13) Turn down Channel 5 - Hindenburg /  Turn channel 8 up - Hi hats
                "/content/a4fb0b49181975450a6710f20128eb0b3acc51f4aa1ce87ebdbc9607562013a2i0", // MintyFresh Vibes
                "/content/633100d631767ddb9a309f5a2a66f5a66d5abd839f3b1c55642690d484189971i0", // ON DAY ONE
                "/content/85436950f53c57aa0c510071d2d5f1c187e1d21e4e57210fcae152c4c7b6a768i0", // Rhythm and Bass 240
                "/content/e3ca12dd7516b4e486af4e3fa7f4ebc535d825034ff3c9da4954f354572dcf61i0", // Crazy Ass Bitch
                "/content/d0496a8e1657ce470807c8d47dcb5f1018a32d8ec8e50d490ad49411ffee1457i0", // Rhythm and Bass 60
                "/content/b22f1c85371b58a9cdac19b2baa50b1f9025a28d44cdfaad539d0527aa7d894ei0", // ON-CHAIN IN THE MEMBRANE
                "/content/5ee46b8f645a65b0ec8ae749a28f88e364347f89137bb79986355bf5fb94cbebi0", // Fiat Money by Solemn
                "/content/c41de57f1e062a440a9fc96d54baaccd7ec40049f48e9f3880559afc60b1b09ai0", // When You Know
                "/content/9dfa1812b211a7ac8b2f9e77119828ec8fbf2e9016b3d37a8efd70052eb4aa3ci0", // Based New Song
                "/content/4653bcc45671abdbc024b03ebbaaadb30e0cad83b80898894ab22426bbccdaaei0", // Freedom to Transact

            ];

            // Define the projectArtistMap globally
                window.projectArtistMap = {
                    "I Love Cheese 2024 FINAL": "melophonic + Rex Speedway and The Denim Avengers",
                    "TRUTH": "melophonic",
                    "Kora Algo New": "melophonic",
                    "MLK 120": "melophonic",
                    "Modern Progress Vocal": "jim.btc",
                    "Choppin' It Up": "Jim.btc",
                    "HUMANITY": "Jim.btc",
                    "Minty Fresh v2": "melophonic + Rare Scrilla",
                    "How We Be - Based": "Based.btc",
                    "Rhythm and Bass": "Jim.btc",
                    "CrazyAssBitch": "French Montana + Audionals",
                    "Rhythm and Bass @60": "Jim.btc",
                    "On-Chain in the Membrane": "melophonic",
                    "FIAT MONEY": "Solemn",
                    "didd you know 1": "Solemn",
                    "Bear Market Disco": "Based.btc",
                    "FREEDOM TO TRANSACT REMIX": "melophonic",

                    // Add more mappings here as needed
                };
        </script>
    </custommetadata>
    <globaldefinitions>
        <script>
            const globalData = window.globalData = {
                isInRemixMode: false,               // Indicates if the player is in remix mode
                isPlaying: false,                  // Indicates if playback is active
                currentSongIndex: 0,               // Index of the currently playing song
                songsArray: [],                    // Array holding the list of songs
                audioBuffers: {},                  // Loaded audio buffers for normal playback
                reverseAudioBuffers: {},           // Loaded audio buffers for reverse playback
                audioContext: new (window.AudioContext || window.webkitAudioContext)(), // Web Audio API context
                masterGain: null,                  // Master gain node (initialized below)
                gainNodes: {},                     // Gain nodes per song and channel
                startPlayback: null,               // Function to start playback
                stopPlayback: null,                // Function to stop playback
                togglePlayback: null,              // Function to toggle playback
                resetPlayback: null,               // Function to reset playback
                isArtworkCover: true,
                isVisualiserCover: false,
                // Continuous playback is now default
            };

        
            // Initialize master gain node
            globalData.masterGain = globalData.audioContext.createGain();
            globalData.masterGain.connect(globalData.audioContext.destination);
        </script>
    </globaldefinitions>
    
 <!-- Existing Styles -->
 <link rel="stylesheet" href="/content/d2d6df9b0c5eedacbf7005e4c0a8bdb0dce76ee278b23dbb7507213608349ecei0">


<!-- New Styles for Metadata Panels and Buttons-->
<style>
/* new styles for metadata displays */
#trackListingPanel {position: fixed;top: 0;left: -420px;width: 400px;height: 100%;background: rgba(45, 45, 45, 0.95);color: #ffffff;padding: 10px 15px;box-shadow: 2px 0 12px rgba(0, 0, 0, 0.8);overflow-y: auto;transition: left 0.3s ease;z-index: 2999;}#trackListingPanel.visible {left: 0;}#infoPanel {position: fixed;top: 20px;left: 50%;transform: translateX(-50%);width: 300px;padding: 20px;background-color: rgba(0, 0, 0, 0.9);color: #ffffff;border-radius: 8px;box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.5);z-index: 1003;display: none;text-align: left;}#infoPanel.visible {display: block;}.hidden {display: none;}#toggleInstruction {top: 10px;right: 20px;background-color: #3498db;color: #fff;border: none;padding: 10px 20px;border-radius: 5px;cursor: pointer;}.metadataItem {margin-bottom: 5px;display: flex;justify-content: space-between;}.metadataItem h2 {margin: 0;font-size: 1em;}.metadataItem p {margin: 0;font-size: 0.9em;color: #ffaa00;}#metadataContent {max-height: 90%;overflow-y: auto;}#nowPlayingContainer {position: fixed;bottom: 0;left: 50%;transform: translateX(-50%);width: auto;background-color: rgba(20, 20, 20, 0.95);color: #fff;padding: 10px;display: flex;justify-content: center;align-items: center;box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.5);z-index: 1000;text-align: center;}#nowPlayingText {display: flex;flex-direction: column;align-items: center;}#nowPlayingText .songTitle {font-size: 1.2em;font-weight: bold;}#nowPlayingText .artistName {font-size: 1em;margin-top: 5px;}#buttonContainer {position: fixed;top: 0;left: 50%;transform: translateX(-50%);background-color: rgba(0, 0, 0, 0.9);padding: 10px;display: flex;gap: 15px;z-index: 1002;}#buttonContainer button {background-color: #3498db;color: #fff;padding: 10px 20px;border: none;border-radius: 5px;cursor: pointer;transition: background-color 0.3s ease;}#buttonContainer button:hover {background-color: #2980b9;}
</style>


</head>
<htmlElements>
        <body>
        <h1>Audionals</h1>
        <div id="loadingSpinner"></div>
        <div id="artworkCover">
            <img id="artworkImage" src="" alt="Artwork Cover">
        </div>

        <!-- New Metadata Panel -->
        <div id="trackListingPanel">
            <h2>Track Listings:</h2>
            <div id="metadataContent">
                <!-- Metadata items will be dynamically inserted here -->
            </div>
        </div>

        <!-- New Now Playing Container -->
        <div id="nowPlayingContainer">
            <div id="nowPlayingText">
                <!-- Now Playing info will be dynamically inserted here -->
                <span class="songTitle">No song playing</span>
                <span class="artistName"></span>
            </div>
        </div>

<!-- Button Container -->
<div id="buttonContainer">
    <button id="playButton" onclick="globalData.togglePlayback()">Play / Stop</button>
    <!-- Updated Previous and Next Buttons -->
    <button id="prevButton" onclick="globalData.previousSong()">Previous</button>
    <button id="nextButton" onclick="globalData.nextSong()">Next</button>
    <button id="toggleInstruction" onclick="globalData.toggleInfo()">Info</button>

</div>

<!-- Information Panel -->
<div id="infoPanel" class="hidden">
    <h2>Audional Player Info</h2>
    <ul>
        <li>Press <strong>T</strong> to view the Track List.</li>
        <li>Use <strong>Left</strong> and <strong>Right</strong> arrows to navigate the Track List.</li>

    </ul>
</div>


</htmlElements>   



<!-- Global Project-Artist Mapping and Helper Function -->
<script>
//projectArtistMapping.js
function getProjectAndArtist(t){let n="Unknown Project Name",e="Unknown Artist Name";if(t.id){const e=t.id.match(/Song\s+\d+:\s+(.+)/);e&&e[1]&&(n=e[1].trim())}return window.projectArtistMap&&window.projectArtistMap[n]?e=window.projectArtistMap[n]:t.artist&&(e=t.artist),{projectName:n,artistName:e}}globalData.toggleInfo=function(){document.getElementById("infoPanel").classList.toggle("visible")};
</script>


<!-- Unified Metadata Management and Logging Script -->
<script>
// unifiedMetadataManagement.js
(()=>{const t=t=>t?.match(/Song\s+\d+:\s+(.+)/)?.[1]?.trim()||"UNKNOWN PROJECT NAME",a=(t,a,e)=>a?.[t]||e||"Unknown Artist Name",e=e=>{if(!Array.isArray(e)||!e.length)return void console.warn("No songs data available to process.");const n=(e=>{const n=window.globalData?.projectArtistMap||window.projectArtistMap||{};return e.map(((e,o)=>({trackNumber:o+1,projectName:t(e.id),artistName:a(t(e.id),n,e.artist)})))})(e);(t=>{const a=document.getElementById("metadataContent");if(!a)return console.warn("Metadata content container (#metadataContent) not found.");a.innerHTML=t.map((({trackNumber:t,projectName:a,artistName:e})=>`<div class="metadataItem"><h2>${t}. ${a}</h2><p>${e}</p></div>`)).join("")})(n),(t=>{t.forEach((({projectName:t,artistName:a})=>console.log(`Project Name: ${t}, Artist Name: ${a}`)))})(n)},n=()=>{window.globalData?.songsArray?.length?e(window.globalData.songsArray):document.addEventListener("dataLoadingComplete",(({detail:{songs:t}={}})=>e(t))),document.addEventListener("keydown",(({key:t})=>{"t"===t.toLowerCase()&&(()=>{const t=document.getElementById("trackListingPanel");t?t.classList.toggle("visible"):console.warn("Metadata panel container (#trackListingPanel) not found.")})()}))};try{n()}catch(t){console.error("Error initializing Metadata Management and Logging:",t)}})();
</script>




<!-- Section 1a - Loading and Preparing Song Data  -->
<script src="/content/44088e23250de51c70149b344a11ba29fe39850ac9b3bf2aa99e73f5d29c4825i0"></script>





<!-- Section 1.5 - Gain Nodes and Helpers -->
<script>
// GainNodeHelpers.js
window.GainNodeHelper=(()=>{const n=window.globalData||(window.globalData={gainNodes:{}}),{gainNodes:o,audioContext:e,masterGain:a}=n;a||(n.masterGain=e.createGain(),n.masterGain.connect(e.destination));let t=null,l=null,s=!1;const c=(a,c=!1)=>{const{id:i,channels:r}=a;c?l=i:t=i,r.length?(o[i]=o[i]??{},r.forEach((({id:a})=>{if(!o[i][a]){const t=e.createGain();t.gain.value=1,t.connect(n.masterGain),o[i][a]=t}})),t&&l&&!s&&(console.log("Gain Nodes Map:",{currentSong:o[t]??{},nextSong:o[l]??{}}),s=!0)):console.warn(`No channels found for song ${i}.`)};return{createGainNodesForSong:n=>c(n,!1),prepareNextSong:n=>c(n,!0),cleanupGainNodesForSong:n=>{const e=o[n];e?(Object.values(e).forEach((n=>n.disconnect())),console.log(`Cleaned up gain nodes for Song ID: ${n}`),delete o[n],n!==t&&n!==l||(n===t&&(t=null),n===l&&(l=null),s=!1)):console.warn(`No gain nodes found to clean up for song ${n}.`)}}})();
</script>







<!-- Section 2 - audioProcessingAndManagement.js -->
<script src="/content/f4cc99813b43f71b3e781d3c99f24a6a7a5b1004ea0efce3b225011e347b8df0i0"></script>


<!-- Section 2 - Audio Processing and Management -->
<section2>
    <script>
    (async () => {
        const globalData = window.globalData || (window.globalData = {});
        const audioContext = globalData.audioContext || (globalData.audioContext = new (window.AudioContext || window.webkitAudioContext)());

        // Utility Functions
        const base64ToArrayBuffer = base64 => Uint8Array.from(atob(base64), c => c.charCodeAt(0)).buffer;

        const extractBase64 = (data, type) => {
            if (type === 'json' && data.audioData) {
                const match = data.audioData.match(/base64,([A-Za-z0-9+/=]+)/);
                return match ? match[1] : null;
            } 
            if (type === 'html') {
                const match = data.match(/<audio[^>]*data-audionalSampleName[^>]*>\s*<source[^>]*src="data:audio\/[^;]+;base64,([^"]+)"/i);
                return match ? match[1] : null;
            }
            return null;
        };

        const isValidBase64 = str => {
            const cleaned = str.replace(/\s+/g, '');
            return cleaned.length % 4 === 0 && /^[A-Za-z0-9+/]+={0,2}$/.test(cleaned);
        };

        /**
         * Normalizes an AudioBuffer to a target peak amplitude.
         * @param {AudioBuffer} buffer 
         * @param {number} targetPeak 
         * @returns {AudioBuffer}
         */
        const normalizeAudioBuffer = (buffer, targetPeak = 0.5) => {
            let max = 0;
            for (let i = 0; i < buffer.numberOfChannels; i++) {
                const data = buffer.getChannelData(i);
                for (let sample of data) {
                    const abs = Math.abs(sample);
                    if (abs > max) max = abs;
                }
            }
            const factor = max > 0 ? targetPeak / max : 1;
            if (factor !== 1) {
                for (let i = 0; i < buffer.numberOfChannels; i++) {
                    const data = buffer.getChannelData(i);
                    for (let j = 0; j < data.length; j++) {
                        data[j] *= factor;
                    }
                }
                console.log(`Normalized AudioBuffer to ${targetPeak} with factor ${factor.toFixed(4)}`);
            }
            return buffer;
        };

        /**
         * Fetches and decodes audio based on content type.
         * @param {Response} response 
         * @param {string} contentType 
         * @param {string} url 
         * @returns {Promise<AudioBuffer|null>}
         */
        const fetchAndDecodeAudio = async (response, contentType, url) => {
            const cache = globalData.audioFetchCache || (globalData.audioFetchCache = new Map());
            if (cache.has(url)) return cache.get(url);
    
            try {
                let buffer;
                if (/audio\/(wav|mpeg|mp4)|video\/mp4/.test(contentType)) {
                    buffer = await audioContext.decodeAudioData(await response.arrayBuffer());
                    console.log(`Decoded audio from ${url}`);
                } else if (/application\/json/.test(contentType)) {
                    const json = JSON.parse(await response.text());
                    const base64 = extractBase64(json, 'json');
                    if (base64 && isValidBase64(base64)) {
                        buffer = await audioContext.decodeAudioData(base64ToArrayBuffer(base64));
                        console.log(`Decoded JSON audio from ${url}`);
                    } else {
                        console.warn(`Invalid/missing base64 in JSON for ${url}`);
                        return null;
                    }
                } else if (/text\/html/.test(contentType)) {
                    const html = await response.text();
                    const base64 = extractBase64(html, 'html');
                    if (base64 && isValidBase64(base64)) {
                        buffer = await audioContext.decodeAudioData(base64ToArrayBuffer(base64));
                        console.log(`Decoded HTML audio from ${url}`);
                    } else {
                        console.warn(`Invalid/missing base64 in HTML for ${url}`);
                        return null;
                    }
                } else if (/audio\//.test(contentType)) {
                    buffer = await audioContext.decodeAudioData(await response.arrayBuffer());
                    console.log(`Decoded audio from ${url}`);
                } else {
                    console.warn(`Unsupported content type (${contentType}) for ${url}`);
                    return null;
                }
    
                cache.set(url, buffer);
                return buffer;
            } catch (error) {
                console.warn(`Decoding error for ${url}: ${error.message}`);
                return null;
            }
        };

        const reverseArray = array => {
            const reversed = new Float32Array(array.length);
            for (let i = 0, len = array.length; i < len; i++) {
                reversed[i] = array[len - i - 1];
            }
            return reversed;
        };

        const createReverseAudioBuffer = buffer => {
            const reversed = audioContext.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
            for (let i = 0; i < buffer.numberOfChannels; i++) {
                reversed.getChannelData(i).set(reverseArray(buffer.getChannelData(i)));
            }
            return reversed;
        };

        const extractFileName = url => url.split('/').pop() || "Unknown";

        /**
         * Randomly selects 16 channels from all songs and calculates adjusted playback speeds.
         * The first random channel's song tempo (BPM) will be used as the new song BPM.
         * @param {Array} songsArray - Array of song objects.
         * @param {number} numberOfChannels - Number of channels to select (default is 16).
         * @returns {Object} - Contains selected channels and new song BPM.
         */
        const selectRandomChannelsWithAdjustedSpeeds = (songsArray, numberOfChannels = 16) => {
            // Flatten all channels with their song reference
            const allChannels = songsArray.flatMap(song => 
                song.channels.map(channel => ({ song, channel }))
            );

            // Shuffle the array randomly
            for (let i = allChannels.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allChannels[i], allChannels[j]] = [allChannels[j], allChannels[i]];
            }

            // Select the first N channels
            const selectedChannels = allChannels.slice(0, numberOfChannels);

            if (selectedChannels.length === 0) {
                throw new Error("No channels available for selection.");
            }

            // Set new song BPM to the BPM of the first selected channel's song
            const newSongBPM = selectedChannels[0].song.bpm;

            // For each selected channel, calculate playback speed adjustment
            selectedChannels.forEach((item, index) => {
                const channelOriginalBPM = item.song.bpm;
                // Calculate playback speed ratio
                const speedRatio = newSongBPM / channelOriginalBPM;

                // Store the adjusted playback speed in the channel's metadata
                item.channel.metadata.adjustedPlaybackSpeed = item.channel.metadata.playbackSpeed * speedRatio;
            });

            // Return selected channels and new song BPM
            return { selectedChannels, newSongBPM };
        };

        /**
         * Processes an individual audio channel.
         * @param {Object} song - The song object.
         * @param {Object} channel - The channel object.
         * @param {Array} logs - Array to store logs.
         */
        const processChannel = async (song, channel, logs) => {
            const { id: songId } = song;
            const { id: channelId, url, metadata } = channel;
            const { trimStartTime_Percentage, trimEndTime_Percentage, requiresReversal, adjustedPlaybackSpeed } = metadata;

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    console.warn(`Fetch failed for ${url}. Skipping ${channelId}.`);
                    return;
                }

                const contentType = response.headers.get("Content-Type") || "";
                const audioBuffer = await fetchAndDecodeAudio(response, contentType, url);
                if (!audioBuffer) {
                    console.warn(`Decoding failed for ${channelId}. Skipping.`);
                    return;
                }

                if (trimEndTime_Percentage <= trimStartTime_Percentage) {
                    console.warn(`Invalid trim percentages for ${channelId}. Skipping.`);
                    return;
                }

                const start = Math.floor((trimStartTime_Percentage / 100) * audioBuffer.duration * audioBuffer.sampleRate);
                const end = Math.floor((trimEndTime_Percentage / 100) * audioBuffer.duration * audioBuffer.sampleRate);
                const length = end - start;

                if (length <= 0) {
                    console.warn(`Non-positive trimmed length for ${channelId}. Skipping.`);
                    return;
                }

                const trimmedBuffer = audioContext.createBuffer(audioBuffer.numberOfChannels, length, audioBuffer.sampleRate);
                for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
                    trimmedBuffer.getChannelData(i).set(audioBuffer.getChannelData(i).subarray(start, end));
                }

                const normalizedBuffer = normalizeAudioBuffer(trimmedBuffer, 0.5);

                // Store the audio buffer
                globalData.audioBuffers = globalData.audioBuffers || {};
                globalData.audioBuffers[channelId] = normalizedBuffer;

                if (requiresReversal) {
                    const reversedBuffer = createReverseAudioBuffer(normalizedBuffer);
                    globalData.reverseAudioBuffers = globalData.reverseAudioBuffers || {};
                    globalData.reverseAudioBuffers[channelId] = reversedBuffer;
                }

                // Store adjusted playback speed
                globalData.adjustedPlaybackSpeeds = globalData.adjustedPlaybackSpeeds || {};
                globalData.adjustedPlaybackSpeeds[channelId] = adjustedPlaybackSpeed;

                logs.push({
                    "Channel ID": channelId,
                    "Audio File": extractFileName(url),
                    "Trimmed Duration (s)": normalizedBuffer.duration.toFixed(2),
                    "Adjusted Playback Speed": adjustedPlaybackSpeed.toFixed(3),
                    "Requires Reversal": requiresReversal
                });

                console.log(`Processed ${channelId}${requiresReversal ? " (Reversed)" : ""}`);
            } catch (error) {
                console.warn(`Error processing ${channelId}: ${error.message}`);
            }
        };

        const logDetailedInfo = logs => {
            if (logs.length) {
                console.table(logs);
            } else {
                console.warn("No audio samples processed.");
            }
        };

        /**
         * Creates a new remix song using the selected channels.
         * @param {Array} selectedChannels - Array of selected channels with song reference.
         * @param {number} newSongBPM - The BPM for the new song.
         */
        const createRemixSong = (selectedChannels, newSongBPM) => {
            const newSong = {
                id: 'Remix Song',
                artist: 'Various Artists',
                bpm: newSongBPM,
                totalSequences: 1,
                channels: [],
                projectSequences: {}
            };

            // Map channels to the new song
            newSong.channels = selectedChannels.map((item, index) => {
                const newChannelId = `ch${index}`;
                // Update channel ID and metadata
                item.channel.id = newChannelId;
                return {
                    id: newChannelId,
                    url: item.channel.url,
                    metadata: item.channel.metadata
                };
            });

            // Create a default sequence using the selected channels
            const sequenceName = 'Sequence1';
            newSong.projectSequences[sequenceName] = {};

            newSong.channels.forEach((channel, index) => {
                // Create steps (e.g., play on every beat)
                const steps = Array.from({ length: 16 }, (_, i) => i);
                newSong.projectSequences[sequenceName][`ch${index}`] = { steps };
            });

            // Update globalData with the new song
            globalData.remixSong = newSong;
            console.log("Remix song created:", newSong);
        };

        /**
         * Processes the selected channels for the remix song.
         */
        const processRemixChannels = async () => {
            const { songsArray } = globalData;
            if (!songsArray.length) {
                console.error("No songs to process.");
                return;
            }

            // Select 16 random channels with adjusted speeds
            const { selectedChannels, newSongBPM } = selectRandomChannelsWithAdjustedSpeeds(songsArray, 16);

            console.log(`New song BPM is set to ${newSongBPM} based on the first selected channel.`);

            const logs = [];
            const processingPromises = selectedChannels.map(({ song, channel }) => {
                return processChannel(song, channel, logs);
            });

            await Promise.all(processingPromises);

            logDetailedInfo(logs);
            console.log("Remix audio buffers ready.");

            // Create a new song object using the selected channels
            createRemixSong(selectedChannels, newSongBPM);

            document.dispatchEvent(new CustomEvent("initialAudioBuffersReady", { detail: { success: true } }));
        };

        /**
         * Initializes the audio processing for the remix song.
         */
        const initRemixAudioProcessing = async () => {
            try {
                await ensureAudioContextRunning();
                await processRemixChannels();
                // No need to process remaining channels in the background
            } catch (error) {
                console.error("Audio processing initialization error:", error);
            }
        };

        /**
         * Initializes playback for the remix song.
         */
        const initRemixPlayback = () => {
            const { remixSong } = globalData;
            if (!remixSong) {
                console.error("Remix song not found.");
                return;
            }

            // Implement playback setup for the remix song
            // This should use the remixSong object and globalData.audioBuffers
            // During playback, use the adjustedPlaybackSpeed stored in each channel's metadata
            setupPlayback(remixSong);
        };

        /**
         * Ensures the AudioContext is running.
         */
        const ensureAudioContextRunning = async () => {
            if (audioContext.state === 'suspended') await audioContext.resume();
        };

        /**
         * Initializes the Master Gain Node.
         */
        const initializeMasterGain = () => {
            const masterGain = audioContext.createGain();
            masterGain.gain.value = 0.7;
            masterGain.connect(audioContext.destination);
            globalData.masterGain = masterGain;
            console.log("Master Gain initialized with gain:", masterGain.gain.value);
        };

        /**
         * Starts the setup process.
         */
        const startSetup = () => {
            document.addEventListener("dataLoadingComplete", initRemixAudioProcessing);
            if (globalData.songsArray?.length) {
                initRemixAudioProcessing();
            }

            // Setup listener for initial buffers ready
            document.addEventListener("initialAudioBuffersReady", () => {
                console.log("Remix buffers ready. Initializing playback.");
                initializeMasterGain();
                initRemixPlayback();
            });
        };

        // Initialization
        startSetup();
    })();
    </script>
</section2>


<!-- Section 2.5 - Rebalancing channel volumes after normalisation -->
<script>
// DynamicGainBalancer.js
const DynamicGainBalancer=(()=>{const n=window.globalData||(window.globalData={normalizationFactors:{},balancerGainNodes:{}}),{normalizationFactors:o,balancerGainNodes:a,audioContext:e,masterGain:t}=n,r=(n,a,e)=>{o[n]=o[n]??{},o[n][a]=e,console.log(`Stored normalization factor for Song ID: ${n}, Channel ID: ${a}: ${e}`)},c=({id:n,channels:r})=>{r.length?r.forEach((({id:r})=>((n,r)=>{const c=o[n]?.[r];if(c&&1!==c){const o=1/c,l=e.createGain();l.gain.value=o,l.connect(t),a[n]=a[n]??{},a[n][r]=l,console.log(`Applied inverse gain for Song ID: ${n}, Channel ID: ${r}, Gain: ${o}`)}})(n,r))):console.warn(`No channels found for song ${n}.`)},l=n=>{const o=a[n];o?(Object.values(o).forEach((n=>{n.disconnect()})),console.log(`Cleaned up balancer gain nodes for Song ID: ${n}`),delete a[n]):console.warn(`No balancer gain nodes found to clean up for song ${n}.`)};return document.addEventListener("audioBufferNormalized",(({detail:{songId:n,channelId:o,normalizationFactor:a}})=>{r(n,o,a)})),document.addEventListener("songPlaybackStarted",(({detail:{currentSong:n}})=>{c(n)})),document.addEventListener("songPlaybackEnded",(({detail:{songId:n}})=>{l(n)})),{storeNormalizationFactor:r,createBalancerGainNodesForSong:c,cleanupBalancerGainNodesForSong:l}})();
</script>





<!-- Section 3 - Playback Engine (Updated for Enhanced Reliability) -->
<!-- Playback Engine Script -->
<script>
// playbackEngine.js
(()=>{const e=window.globalData||(window.globalData={isPlaying:!1,currentSongIndex:0,songsArray:[],audioBuffers:{},reverseAudioBuffers:{},audioContext:new(window.AudioContext||window.webkitAudioContext),masterGain:null,gainNodes:{},isArtworkCover:!0,isVisualiserCover:!1}),{audioContext:n}=e,t=.1,o=25;let a=null,r={};const s=new Set,i=new Set;function c(){const{songsArray:i,currentSongIndex:l}=e;if(!i.length)return console.error("No songs available for playback.");const p=i[l%i.length],y=p.projectSequences||{},f=60/p.bpm/4,m=64*f;e.currentSongIndex%=i.length,r={},s.clear(),console.log(`Starting playback for Song: ${p.id} (${e.currentSongIndex+1}/${i.length}) with ${Object.keys(y).length} sequences.`),console.log(`Song BPM: ${p.bpm}`);let b=0;for(const[e,t]of Object.entries(y))r[e]={nextStepIndex:0,nextStepTime:n.currentTime+b,stepDuration:f,endTime:n.currentTime+b+m,completed:!1},b+=m;e.currentSongId=p.id,GainNodeHelper.createGainNodesForSong(p),GainNodeHelper.prepareNextSong(i[(e.currentSongIndex+1)%i.length]),e.isPlaying=!0,a=setInterval((()=>function(o){const a=n.currentTime;let s=!0;for(const[n,i]of Object.entries(o.projectSequences||{})){const c=r[n];if(c&&!c.completed)if(a>=c.endTime)c.completed=!0,console.log(`Sequence ${n} has completed.`);else for(s=!1;c.nextStepTime<a+t&&e.isPlaying;){const{nextStepIndex:e,nextStepTime:t,stepDuration:a}=c;for(const[n,a]of Object.entries(i)){const r=parseInt(n.slice(2),10),s=o.channels[r];if(!s){console.warn(`Channel index ${r} not found in song ${o.id}.`);continue}const i=a.steps?.find((n=>"number"==typeof n?n===e:n.index===e));if(void 0!==i){const e="object"==typeof i&&i.reverse;u(o,s,t,e)}}if(c.nextStepIndex++,c.nextStepIndex>=64){c.completed=!0,console.log(`Sequence ${n} has completed all steps.`);break}c.nextStepTime+=a}}s&&(console.log("All sequences have completed."),function(){if(!e.isPlaying)return;e.currentSongIndex=(e.currentSongIndex+1)%e.songsArray.length,setTimeout((()=>{e.isPlaying&&d({preserveIsPlaying:!0,callback:c})}),200)}())}(p)),o),console.log("Sequences scheduled and playback started."),document.dispatchEvent(new CustomEvent("playbackStarted",{detail:{success:!0}})),g(p)}function l(){if(!e.isPlaying)return console.log("Playback is not in progress.");d(),console.log("Playback stopped."),document.dispatchEvent(new CustomEvent("playbackStopped",{detail:{success:!0}})),p()}function d(n={}){clearInterval(a),n.preserveIsPlaying||(e.isPlaying=!1),r={},s.clear(),i.forEach((e=>{try{e.stop(),e.disconnect()}catch(e){console.error("Error stopping/disconnecting an audio source:",e)}})),i.clear(),e.currentSongId&&(GainNodeHelper.cleanupGainNodesForSong(e.currentSongId),e.currentSongId=null),n.callback&&n.callback()}e.masterGain||(e.masterGain=n.createGain(),e.masterGain.connect(n.destination)),e.togglePlayback=()=>e.isPlaying?l():c(),e.startPlayback=c,e.stopPlayback=l,e.resetPlayback=()=>d({callback:c});const u=(t,o,a,r)=>{const c=`${t.id}_${o.id}_${r?"reverse":"normal"}`,l=r?e.reverseAudioBuffers[t.id]?.[o.id]:e.audioBuffers[t.id]?.[o.id];if(!l)return void(s.has(c)||(s.add(c),console.warn(`Audio buffer missing for Song: ${t.id}, Channel: ${o.id}${r?" (Reverse)":""}`)));const d=n.createBufferSource();d.buffer=l,d.playbackRate.value=o.metadata.playbackSpeed||1;const u=e.gainNodes?.[t.id]?.[o.id]||e.masterGain;d.connect(u),d.start(a),i.add(d),d.onended=()=>i.delete(d)};e.initializePlaybackEngine=()=>{if(!e.songsArray.length)return console.error("No songs available for playback.");console.log("Playback Engine Initialization Complete."),console.log("Playback is ready. Click the artwork to start.")};const g=e=>{const n=document.getElementById("nowPlayingContainer");if(!n)return console.warn("Now Playing Container not found.");const{projectName:t,artistName:o}=getProjectAndArtist(e);n.querySelector(".songTitle").textContent=t,n.querySelector(".artistName").textContent=o},p=()=>{const e=document.getElementById("nowPlayingContainer");if(!e)return console.warn("Now Playing Container not found.");e.querySelector(".songTitle").textContent="No song playing",e.querySelector(".artistName").textContent=""},y=()=>{document.addEventListener("DOMContentLoaded",(()=>{const n=document.getElementById("artworkCover"),t=document.getElementById("artworkImage"),o=document.getElementById("loadingSpinner");e.isArtworkCover&&artworkUrl.length?(t.src=artworkUrl[0],n.classList.remove("hidden"),o.style.display="none",t.addEventListener("click",e.togglePlayback),console.log("Artwork cover is set up for playback toggle.")):console.warn("Artwork cover is not enabled or no artwork URL provided.")}))};document.addEventListener("initialAudioBuffersReady",(n=>{n.detail.success&&(e.initializePlaybackEngine(),console.log("Initial audio buffers are ready."))})),["playbackStarted","playbackStopped"].forEach((e=>{document.addEventListener(e,(n=>{n.detail.success&&console.log(`Playback has been successfully ${"playbackStarted"===e?"started":"stopped"}.`)}))})),y(),Object.keys(e.audioBuffers).length&&e.initializePlaybackEngine()})();
</script>




    

<!-- Keyboard Controls and Event Listeners Script -->
<script>
// keyboardControlsAndEventListeners.js
(()=>{const e=window.globalData||(window.globalData={}),o=e.audioContext;let n=null;const t=o=>{const n=e.songsArray.length;0!==n?("ArrowRight"===o?(e.currentSongIndex=(e.currentSongIndex+1)%n,console.log(`Skipped to next song: ${e.songsArray[e.currentSongIndex].id}`)):"ArrowLeft"===o&&(e.currentSongIndex=(e.currentSongIndex-1+n)%n,console.log(`Skipped to previous song: ${e.songsArray[e.currentSongIndex].id}`)),e.isPlaying?e.resetPlayback():(console.log("Playback is not active. Next song is cued and ready to play."),r(e.currentSongIndex))):console.error("No songs available to skip.")};e.nextSong=()=>t("ArrowRight"),e.previousSong=()=>t("ArrowLeft"),document.addEventListener("keydown",(e=>{"ArrowRight"!==e.key&&"ArrowLeft"!==e.key||(n&&clearTimeout(n),n=setTimeout((()=>{t(e.key)}),300))}));const r=o=>{const n=e.songsArray[o],t=document.getElementById("artworkImage"),r=document.getElementById("songTitle");t&&n.title&&n.title.length>0&&(t.src=n.artworkUrl||"default-artwork.png",console.log(`UI updated for Song: ${n.id}`)),r&&(r.textContent=n.title||"Unknown Title")};document.addEventListener("initialAudioBuffersReady",(function(e){e.detail.success&&console.log("Debugging Script: Audio buffers are ready.")})),o?(o.onstatechange=function(){console.log(`Debugging Script: AudioContext state changed to: ${o.state}`)},console.log("Debugging Script: AudioContext state change listener added.")):console.warn("Debugging Script: AudioContext not found."),["playbackStarted","playbackStopped"].forEach((e=>{document.addEventListener(e,(function(){console.log(`Debugging Script: '${e}' event dispatched.`)}))})),document.addEventListener("DOMContentLoaded",(function(){if(o){const e=async()=>{if("suspended"===o.state)try{await o.resume(),console.log("AudioContext resumed successfully.")}catch(e){console.error("Failed to resume AudioContext:",e)}};document.addEventListener("click",e),document.addEventListener("keydown",e),console.log("AudioContext resumption listeners added.")}else console.warn("AudioContext not found.")}))})();
</script>

    
    
    

</html>
