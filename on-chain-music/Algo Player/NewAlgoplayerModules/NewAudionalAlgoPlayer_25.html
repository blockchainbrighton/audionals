<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Audionals - Web3 Music Player</title>
    <custommetadata>
        <script>
            const artworkUrl = ["/content/01c48d3cceb02215bc3d44f9a2dc7fba63ea63719a2ef1c35d3f0c4db93ab8d5i0"];
            const songDataUrls = [
                "/content/8aec0a99a5617b9da98a5b63a11a5143f0cac3cfa662d9515c2285de03ef95d4i0", // CHEESE 
                "/content/5527d0cc95ce5ce6eedf4e275234da8b1fe087512d0db618b6de1aaad437c96bi0", // TRUTH
                "/content/6d288c0c82653001bb32497889dd1486e8afec9b0671a95fa9e10f99c20737bbi0", // KORA
                "/content/119a3ccd1dfd7e987cca139f86d16717d845a22dd6afc59ad492527b95ae9a91i0", // MLK I HAVE A DREAM
                "/content/db9131cfe8e933e8e639f007dcd2b582a80bfd2be42b0eafa4d2e206332d6785i0", // ModernProgress
                "/content/07ff7bdc47e5272a3ff55cc46d2b189d510562a057a2c24112f3d0376950484di0", // CHOPPIN' IT UP
                "/content/fb0d2abcd1fa5bf2622579f0990435b48d41291f71626fc2e36a93e6ea6b3b85i0", // HUMANITY // Turn Down Channels 1 + 2 (Apollo 13) Turn down Channel 5 - Hindenburg /  Turn channel 8 up - Hi hats
                "/content/a4fb0b49181975450a6710f20128eb0b3acc51f4aa1ce87ebdbc9607562013a2i0", // MintyFresh Vibes
                "/content/633100d631767ddb9a309f5a2a66f5a66d5abd839f3b1c55642690d484189971i0", // ON DAY ONE
                "/content/85436950f53c57aa0c510071d2d5f1c187e1d21e4e57210fcae152c4c7b6a768i0", // Rhythm and Bass 240
                "/content/e3ca12dd7516b4e486af4e3fa7f4ebc535d825034ff3c9da4954f354572dcf61i0", // Crazy Ass Bitch
                "/content/d0496a8e1657ce470807c8d47dcb5f1018a32d8ec8e50d490ad49411ffee1457i0", // Rhythm and Bass 60
                "/content/b22f1c85371b58a9cdac19b2baa50b1f9025a28d44cdfaad539d0527aa7d894ei0", // ON-CHAIN IN THE MEMBRANE
                "/content/5ee46b8f645a65b0ec8ae749a28f88e364347f89137bb79986355bf5fb94cbebi0", // Fiat Money by Solemn
                "/content/c41de57f1e062a440a9fc96d54baaccd7ec40049f48e9f3880559afc60b1b09ai0", // When You Know
                "/content/9dfa1812b211a7ac8b2f9e77119828ec8fbf2e9016b3d37a8efd70052eb4aa3ci0", // Based New Song
                "/content/4653bcc45671abdbc024b03ebbaaadb30e0cad83b80898894ab22426bbccdaaei0", // Freedom to Transact

            ];

            // Define the projectArtistMap globally
                window.projectArtistMap = {
                    "I Love Cheese 2024 FINAL": "melophonic + Rex Speedway and The Denim Avengers",
                    "TRUTH": "melophonic",
                    "Kora Algo New": "melophonic",
                    "MLK 120": "melophonic",
                    "Modern Progress Vocal": "jim.btc",
                    "Choppin' It Up": "Jim.btc",
                    "HUMANITY": "Jim.btc",
                    "Minty Fresh v2": "melophonic + Rare Scrilla",
                    "How We Be - Based": "Based.btc",
                    "Rhythm and Bass": "Jim.btc",
                    "CrazyAssBitch": "French Montana + Audionals",
                    "Rhythm and Bass @60": "Jim.btc",
                    "On-Chain in the Membrane": "melophonic",
                    "FIAT MONEY": "Solemn",
                    "didd you know 1": "Solemn",
                    "Bear Market Disco": "Based.btc",
                    "FREEDOM TO TRANSACT REMIX": "melophonic",

                    // Add more mappings here as needed
                };
        </script>
    </custommetadata>
    <globaldefinitions>
        <script>
            const globalData = window.globalData = {
                isInRemixMode: false,               // Indicates if the player is in remix mode
                isPlaying: false,                  // Indicates if playback is active
                currentSongIndex: 0,               // Index of the currently playing song
                songsArray: [],                    // Array holding the list of songs
                audioBuffers: {},                  // Loaded audio buffers for normal playback
                reverseAudioBuffers: {},           // Loaded audio buffers for reverse playback
                audioContext: new (window.AudioContext || window.webkitAudioContext)(), // Web Audio API context
                masterGain: null,                  // Master gain node (initialized below)
                gainNodes: {},                     // Gain nodes per song and channel
                startPlayback: null,               // Function to start playback
                stopPlayback: null,                // Function to stop playback
                togglePlayback: null,              // Function to toggle playback
                resetPlayback: null,               // Function to reset playback
                isArtworkCover: true,
                isVisualiserCover: false,
                // Continuous playback is now default
            };

        
            // Initialize master gain node
            globalData.masterGain = globalData.audioContext.createGain();
            globalData.masterGain.connect(globalData.audioContext.destination);
        </script>
    </globaldefinitions>
    
 <!-- Existing Styles -->
 <link rel="stylesheet" href="/content/d2d6df9b0c5eedacbf7005e4c0a8bdb0dce76ee278b23dbb7507213608349ecei0">


<!-- New Styles for Metadata Panels and Buttons-->
<style>
/* new styles for metadata displays */
#trackListingPanel {position: fixed;top: 0;left: -420px;width: 400px;height: 100%;background: rgba(45, 45, 45, 0.95);color: #ffffff;padding: 10px 15px;box-shadow: 2px 0 12px rgba(0, 0, 0, 0.8);overflow-y: auto;transition: left 0.3s ease;z-index: 2999;}#trackListingPanel.visible {left: 0;}#infoPanel {position: fixed;top: 20px;left: 50%;transform: translateX(-50%);width: 300px;padding: 20px;background-color: rgba(0, 0, 0, 0.9);color: #ffffff;border-radius: 8px;box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.5);z-index: 1003;display: none;text-align: left;}#infoPanel.visible {display: block;}.hidden {display: none;}#toggleInstruction {top: 10px;right: 20px;background-color: #3498db;color: #fff;border: none;padding: 10px 20px;border-radius: 5px;cursor: pointer;}.metadataItem {margin-bottom: 5px;display: flex;justify-content: space-between;}.metadataItem h2 {margin: 0;font-size: 1em;}.metadataItem p {margin: 0;font-size: 0.9em;color: #ffaa00;}#metadataContent {max-height: 90%;overflow-y: auto;}#nowPlayingContainer {position: fixed;bottom: 0;left: 50%;transform: translateX(-50%);width: auto;background-color: rgba(20, 20, 20, 0.95);color: #fff;padding: 10px;display: flex;justify-content: center;align-items: center;box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.5);z-index: 1000;text-align: center;}#nowPlayingText {display: flex;flex-direction: column;align-items: center;}#nowPlayingText .songTitle {font-size: 1.2em;font-weight: bold;}#nowPlayingText .artistName {font-size: 1em;margin-top: 5px;}#buttonContainer {position: fixed;top: 0;left: 50%;transform: translateX(-50%);background-color: rgba(0, 0, 0, 0.9);padding: 10px;display: flex;gap: 15px;z-index: 1002;}#buttonContainer button {background-color: #3498db;color: #fff;padding: 10px 20px;border: none;border-radius: 5px;cursor: pointer;transition: background-color 0.3s ease;}#buttonContainer button:hover {background-color: #2980b9;}
</style>


</head>
<htmlElements>
        <body>
        <h1>Audionals</h1>
        <div id="loadingSpinner"></div>
        <div id="artworkCover">
            <img id="artworkImage" src="" alt="Artwork Cover">
        </div>

        <!-- New Metadata Panel -->
        <div id="trackListingPanel">
            <h2>Track Listings:</h2>
            <div id="metadataContent">
                <!-- Metadata items will be dynamically inserted here -->
            </div>
        </div>

        <!-- New Now Playing Container -->
        <div id="nowPlayingContainer">
            <div id="nowPlayingText">
                <!-- Now Playing info will be dynamically inserted here -->
                <span class="songTitle">No song playing</span>
                <span class="artistName"></span>
            </div>
        </div>

<!-- Button Container -->
<div id="buttonContainer">
    <button id="playButton" onclick="globalData.togglePlayback()">Play / Stop</button>
    <!-- Updated Previous and Next Buttons -->
    <!-- <button id="prevButton" onclick="globalData.previousSong()">Previous</button>
    <button id="nextButton" onclick="globalData.nextSong()">Next</button> -->
    <button id="toggleInstruction" onclick="globalData.toggleInfo()">Info</button>

</div>

<!-- Information Panel -->
<div id="infoPanel" class="hidden">
    <h2>Audional Player Info</h2>
    <ul>
        <li>Press <strong>T</strong> to view the Track List.</li>
        <li>Use <strong>Left</strong> and <strong>Right</strong> arrows to navigate the Track List.</li>

    </ul>
</div>


</htmlElements>   



<!-- Global Project-Artist Mapping and Helper Function -->
<script>
  // projectArtistMapping.js
  function getProjectAndArtist(song) {
      let projectName = "Unknown Project Name";
      let artistName = "Unknown Artist Name";
      if (song.id) {
          const match = song.id.match(/Song\s+\d+:\s+(.+)/);
          if (match && match[1]) {
              projectName = match[1].trim();
          }
      }
      if (window.projectArtistMap && window.projectArtistMap[projectName]) {
          artistName = window.projectArtistMap[projectName];
      } else if (song.artist) {
          artistName = song.artist;
      }
      return { projectName, artistName };
  }
  globalData.toggleInfo = function () {
      document.getElementById("infoPanel").classList.toggle("visible");
  };
  </script>


<!-- Unified Metadata Management and Logging Script -->
<script>
// unifiedMetadataManagement.js
(()=>{const t=t=>t?.match(/Song\s+\d+:\s+(.+)/)?.[1]?.trim()||"UNKNOWN PROJECT NAME",a=(t,a,e)=>a?.[t]||e||"Unknown Artist Name",e=e=>{if(!Array.isArray(e)||!e.length)return void console.warn("No songs data available to process.");const n=(e=>{const n=window.globalData?.projectArtistMap||window.projectArtistMap||{};return e.map(((e,o)=>({trackNumber:o+1,projectName:t(e.id),artistName:a(t(e.id),n,e.artist)})))})(e);(t=>{const a=document.getElementById("metadataContent");if(!a)return console.warn("Metadata content container (#metadataContent) not found.");a.innerHTML=t.map((({trackNumber:t,projectName:a,artistName:e})=>`<div class="metadataItem"><h2>${t}. ${a}</h2><p>${e}</p></div>`)).join("")})(n),(t=>{t.forEach((({projectName:t,artistName:a})=>console.log(`Project Name: ${t}, Artist Name: ${a}`)))})(n)},n=()=>{window.globalData?.songsArray?.length?e(window.globalData.songsArray):document.addEventListener("dataLoadingComplete",(({detail:{songs:t}={}})=>e(t))),document.addEventListener("keydown",(({key:t})=>{"t"===t.toLowerCase()&&(()=>{const t=document.getElementById("trackListingPanel");t?t.classList.toggle("visible"):console.warn("Metadata panel container (#trackListingPanel) not found.")})()}))};try{n()}catch(t){console.error("Error initializing Metadata Management and Logging:",t)}})();
</script>




<!-- Section 1a - Loading and Preparing Song Data  -->
<script src="/content/44088e23250de51c70149b344a11ba29fe39850ac9b3bf2aa99e73f5d29c4825i0"></script>





<!-- Section 1.5 - Gain Nodes and Helpers -->
<script>
// GainNodeHelpers.js
window.GainNodeHelper=(()=>{const n=window.globalData||(window.globalData={gainNodes:{}}),{gainNodes:o,audioContext:e,masterGain:a}=n;a||(n.masterGain=e.createGain(),n.masterGain.connect(e.destination));let t=null,l=null,s=!1;const c=(a,c=!1)=>{const{id:i,channels:r}=a;c?l=i:t=i,r.length?(o[i]=o[i]??{},r.forEach((({id:a})=>{if(!o[i][a]){const t=e.createGain();t.gain.value=1,t.connect(n.masterGain),o[i][a]=t}})),t&&l&&!s&&(console.log("Gain Nodes Map:",{currentSong:o[t]??{},nextSong:o[l]??{}}),s=!0)):console.warn(`No channels found for song ${i}.`)};return{createGainNodesForSong:n=>c(n,!1),prepareNextSong:n=>c(n,!0),cleanupGainNodesForSong:n=>{const e=o[n];e?(Object.values(e).forEach((n=>n.disconnect())),console.log(`Cleaned up gain nodes for Song ID: ${n}`),delete o[n],n!==t&&n!==l||(n===t&&(t=null),n===l&&(l=null),s=!1)):console.warn(`No gain nodes found to clean up for song ${n}.`)}}})();
</script>







<!-- Section 2 - audioProcessingAndManagement.js -->
<!-- <script src="/content/f4cc99813b43f71b3e781d3c99f24a6a7a5b1004ea0efce3b225011e347b8df0i0"></script> -->




<!-- Section 2.5 - Rebalancing channel volumes after normalisation -->
<script>
// DynamicGainBalancer.js
const DynamicGainBalancer=(()=>{const n=window.globalData||(window.globalData={normalizationFactors:{},balancerGainNodes:{}}),{normalizationFactors:o,balancerGainNodes:a,audioContext:e,masterGain:t}=n,r=(n,a,e)=>{o[n]=o[n]??{},o[n][a]=e,console.log(`Stored normalization factor for Song ID: ${n}, Channel ID: ${a}: ${e}`)},c=({id:n,channels:r})=>{r.length?r.forEach((({id:r})=>((n,r)=>{const c=o[n]?.[r];if(c&&1!==c){const o=1/c,l=e.createGain();l.gain.value=o,l.connect(t),a[n]=a[n]??{},a[n][r]=l,console.log(`Applied inverse gain for Song ID: ${n}, Channel ID: ${r}, Gain: ${o}`)}})(n,r))):console.warn(`No channels found for song ${n}.`)},l=n=>{const o=a[n];o?(Object.values(o).forEach((n=>{n.disconnect()})),console.log(`Cleaned up balancer gain nodes for Song ID: ${n}`),delete a[n]):console.warn(`No balancer gain nodes found to clean up for song ${n}.`)};return document.addEventListener("audioBufferNormalized",(({detail:{songId:n,channelId:o,normalizationFactor:a}})=>{r(n,o,a)})),document.addEventListener("songPlaybackStarted",(({detail:{currentSong:n}})=>{c(n)})),document.addEventListener("songPlaybackEnded",(({detail:{songId:n}})=>{l(n)})),{storeNormalizationFactor:r,createBalancerGainNodesForSong:c,cleanupBalancerGainNodesForSong:l}})();
</script>





<!-- Section 3 - Playback Engine (Updated for Enhanced Reliability) -->
<!-- Playback Engine Script -->
<!-- <script>
// playbackEngine.js
(()=>{const e=window.globalData||(window.globalData={isPlaying:!1,currentSongIndex:0,songsArray:[],audioBuffers:{},reverseAudioBuffers:{},audioContext:new(window.AudioContext||window.webkitAudioContext),masterGain:null,gainNodes:{},isArtworkCover:!0,isVisualiserCover:!1}),{audioContext:n}=e,t=.1,o=25;let a=null,r={};const s=new Set,i=new Set;function c(){const{songsArray:i,currentSongIndex:l}=e;if(!i.length)return console.error("No songs available for playback.");const p=i[l%i.length],y=p.projectSequences||{},f=60/p.bpm/4,m=64*f;e.currentSongIndex%=i.length,r={},s.clear(),console.log(`Starting playback for Song: ${p.id} (${e.currentSongIndex+1}/${i.length}) with ${Object.keys(y).length} sequences.`),console.log(`Song BPM: ${p.bpm}`);let b=0;for(const[e,t]of Object.entries(y))r[e]={nextStepIndex:0,nextStepTime:n.currentTime+b,stepDuration:f,endTime:n.currentTime+b+m,completed:!1},b+=m;e.currentSongId=p.id,GainNodeHelper.createGainNodesForSong(p),GainNodeHelper.prepareNextSong(i[(e.currentSongIndex+1)%i.length]),e.isPlaying=!0,a=setInterval((()=>function(o){const a=n.currentTime;let s=!0;for(const[n,i]of Object.entries(o.projectSequences||{})){const c=r[n];if(c&&!c.completed)if(a>=c.endTime)c.completed=!0,console.log(`Sequence ${n} has completed.`);else for(s=!1;c.nextStepTime<a+t&&e.isPlaying;){const{nextStepIndex:e,nextStepTime:t,stepDuration:a}=c;for(const[n,a]of Object.entries(i)){const r=parseInt(n.slice(2),10),s=o.channels[r];if(!s){console.warn(`Channel index ${r} not found in song ${o.id}.`);continue}const i=a.steps?.find((n=>"number"==typeof n?n===e:n.index===e));if(void 0!==i){const e="object"==typeof i&&i.reverse;u(o,s,t,e)}}if(c.nextStepIndex++,c.nextStepIndex>=64){c.completed=!0,console.log(`Sequence ${n} has completed all steps.`);break}c.nextStepTime+=a}}s&&(console.log("All sequences have completed."),function(){if(!e.isPlaying)return;e.currentSongIndex=(e.currentSongIndex+1)%e.songsArray.length,setTimeout((()=>{e.isPlaying&&d({preserveIsPlaying:!0,callback:c})}),200)}())}(p)),o),console.log("Sequences scheduled and playback started."),document.dispatchEvent(new CustomEvent("playbackStarted",{detail:{success:!0}})),g(p)}function l(){if(!e.isPlaying)return console.log("Playback is not in progress.");d(),console.log("Playback stopped."),document.dispatchEvent(new CustomEvent("playbackStopped",{detail:{success:!0}})),p()}function d(n={}){clearInterval(a),n.preserveIsPlaying||(e.isPlaying=!1),r={},s.clear(),i.forEach((e=>{try{e.stop(),e.disconnect()}catch(e){console.error("Error stopping/disconnecting an audio source:",e)}})),i.clear(),e.currentSongId&&(GainNodeHelper.cleanupGainNodesForSong(e.currentSongId),e.currentSongId=null),n.callback&&n.callback()}e.masterGain||(e.masterGain=n.createGain(),e.masterGain.connect(n.destination)),e.togglePlayback=()=>e.isPlaying?l():c(),e.startPlayback=c,e.stopPlayback=l,e.resetPlayback=()=>d({callback:c});const u=(t,o,a,r)=>{const c=`${t.id}_${o.id}_${r?"reverse":"normal"}`,l=r?e.reverseAudioBuffers[t.id]?.[o.id]:e.audioBuffers[t.id]?.[o.id];if(!l)return void(s.has(c)||(s.add(c),console.warn(`Audio buffer missing for Song: ${t.id}, Channel: ${o.id}${r?" (Reverse)":""}`)));const d=n.createBufferSource();d.buffer=l,d.playbackRate.value=o.metadata.playbackSpeed||1;const u=e.gainNodes?.[t.id]?.[o.id]||e.masterGain;d.connect(u),d.start(a),i.add(d),d.onended=()=>i.delete(d)};e.initializePlaybackEngine=()=>{if(!e.songsArray.length)return console.error("No songs available for playback.");console.log("Playback Engine Initialization Complete."),console.log("Playback is ready. Click the artwork to start.")};const g=e=>{const n=document.getElementById("nowPlayingContainer");if(!n)return console.warn("Now Playing Container not found.");const{projectName:t,artistName:o}=getProjectAndArtist(e);n.querySelector(".songTitle").textContent=t,n.querySelector(".artistName").textContent=o},p=()=>{const e=document.getElementById("nowPlayingContainer");if(!e)return console.warn("Now Playing Container not found.");e.querySelector(".songTitle").textContent="No song playing",e.querySelector(".artistName").textContent=""},y=()=>{document.addEventListener("DOMContentLoaded",(()=>{const n=document.getElementById("artworkCover"),t=document.getElementById("artworkImage"),o=document.getElementById("loadingSpinner");e.isArtworkCover&&artworkUrl.length?(t.src=artworkUrl[0],n.classList.remove("hidden"),o.style.display="none",t.addEventListener("click",e.togglePlayback),console.log("Artwork cover is set up for playback toggle.")):console.warn("Artwork cover is not enabled or no artwork URL provided.")}))};document.addEventListener("initialAudioBuffersReady",(n=>{n.detail.success&&(e.initializePlaybackEngine(),console.log("Initial audio buffers are ready."))})),["playbackStarted","playbackStopped"].forEach((e=>{document.addEventListener(e,(n=>{n.detail.success&&console.log(`Playback has been successfully ${"playbackStarted"===e?"started":"stopped"}.`)}))})),y(),Object.keys(e.audioBuffers).length&&e.initializePlaybackEngine()})();
</script> -->



<!-- Section 2 - Audio Processing and Management -->
<section2>
    <script>
    (async () => {
        const globalData = window.globalData || (window.globalData = {});
        const audioContext = globalData.audioContext || (globalData.audioContext = new (window.AudioContext || window.webkitAudioContext)());

        // Utility Functions
        const base64ToArrayBuffer = base64 => Uint8Array.from(atob(base64), c => c.charCodeAt(0)).buffer;

        const extractBase64 = (data, type) => {
            if (type === 'json' && data.audioData) {
                const match = data.audioData.match(/base64,([A-Za-z0-9+/=]+)/);
                return match ? match[1] : null;
            } 
            if (type === 'html') {
                const match = data.match(/<audio[^>]*data-audionalSampleName[^>]*>\s*<source[^>]*src="data:audio\/[^;]+;base64,([^"]+)"/i);
                return match ? match[1] : null;
            }
            return null;
        };

        const isValidBase64 = str => {
            const cleaned = str.replace(/\s+/g, '');
            return cleaned.length % 4 === 0 && /^[A-Za-z0-9+/]+={0,2}$/.test(cleaned);
        };

        /**
         * Normalizes an AudioBuffer to a target peak amplitude.
         * @param {AudioBuffer} buffer 
         * @param {number} targetPeak 
         * @returns {AudioBuffer}
         */
        const normalizeAudioBuffer = (buffer, targetPeak = 0.5) => {
            let max = 0;
            for (let i = 0; i < buffer.numberOfChannels; i++) {
                const data = buffer.getChannelData(i);
                for (let sample of data) {
                    const abs = Math.abs(sample);
                    if (abs > max) max = abs;
                }
            }
            const factor = max > 0 ? targetPeak / max : 1;
            if (factor !== 1) {
                for (let i = 0; i < buffer.numberOfChannels; i++) {
                    const data = buffer.getChannelData(i);
                    for (let j = 0; j < data.length; j++) {
                        data[j] *= factor;
                    }
                }
                console.log(`Normalized AudioBuffer to ${targetPeak} with factor ${factor.toFixed(4)}`);
            }
            return buffer;
        };

        /**
         * Fetches and decodes audio based on content type.
         * @param {Response} response 
         * @param {string} contentType 
         * @param {string} url 
         * @returns {Promise<AudioBuffer|null>}
         */
        const fetchAndDecodeAudio = async (response, contentType, url) => {
            const cache = globalData.audioFetchCache || (globalData.audioFetchCache = new Map());
            if (cache.has(url)) return cache.get(url);
    
            try {
                let buffer;
                if (/audio\/(wav|mpeg|mp4)|video\/mp4/.test(contentType)) {
                    buffer = await audioContext.decodeAudioData(await response.arrayBuffer());
                    console.log(`Decoded audio from ${url}`);
                } else if (/application\/json/.test(contentType)) {
                    const json = JSON.parse(await response.text());
                    const base64 = extractBase64(json, 'json');
                    if (base64 && isValidBase64(base64)) {
                        buffer = await audioContext.decodeAudioData(base64ToArrayBuffer(base64));
                        console.log(`Decoded JSON audio from ${url}`);
                    } else {
                        console.warn(`Invalid/missing base64 in JSON for ${url}`);
                        return null;
                    }
                } else if (/text\/html/.test(contentType)) {
                    const html = await response.text();
                    const base64 = extractBase64(html, 'html');
                    if (base64 && isValidBase64(base64)) {
                        buffer = await audioContext.decodeAudioData(base64ToArrayBuffer(base64));
                        console.log(`Decoded HTML audio from ${url}`);
                    } else {
                        console.warn(`Invalid/missing base64 in HTML for ${url}`);
                        return null;
                    }
                } else if (/audio\//.test(contentType)) {
                    buffer = await audioContext.decodeAudioData(await response.arrayBuffer());
                    console.log(`Decoded audio from ${url}`);
                } else {
                    console.warn(`Unsupported content type (${contentType}) for ${url}`);
                    return null;
                }
    
                cache.set(url, buffer);
                return buffer;
            } catch (error) {
                console.warn(`Decoding error for ${url}: ${error.message}`);
                return null;
            }
        };

        const reverseArray = array => {
            const reversed = new Float32Array(array.length);
            for (let i = 0, len = array.length; i < len; i++) {
                reversed[i] = array[len - i - 1];
            }
            return reversed;
        };

        const createReverseAudioBuffer = buffer => {
            const reversed = audioContext.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
            for (let i = 0; i < buffer.numberOfChannels; i++) {
                reversed.getChannelData(i).set(reverseArray(buffer.getChannelData(i)));
            }
            return reversed;
        };

        const extractFileName = url => url.split('/').pop() || "Unknown";

        /**
         * Randomly selects 16 channels from all songs and calculates adjusted playback speeds.
         * The first random channel's song tempo (BPM) will be used as the new song BPM.
         * @param {Array} songsArray - Array of song objects.
         * @param {number} numberOfChannels - Number of channels to select (default is 16).
         * @returns {Object} - Contains selected channels and new song BPM.
         */
        const selectRandomChannelsWithAdjustedSpeeds = (songsArray, numberOfChannels = 16) => {
            // Flatten all channels with their song reference
            const allChannels = songsArray.flatMap(song => 
                song.channels.map(channel => ({ song, channel }))
            );

            // Shuffle the array randomly
            for (let i = allChannels.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allChannels[i], allChannels[j]] = [allChannels[j], allChannels[i]];
            }

            // Select the first N channels
            const selectedChannels = allChannels.slice(0, numberOfChannels);

            if (selectedChannels.length === 0) {
                throw new Error("No channels available for selection.");
            }

            // Set new song BPM to the BPM of the first selected channel's song
            const newSongBPM = selectedChannels[0].song.bpm;

            // For each selected channel, calculate playback speed adjustment
            selectedChannels.forEach((item) => {
                const channelOriginalBPM = item.song.bpm;
                // Calculate playback speed ratio
                const speedRatio = newSongBPM / channelOriginalBPM;

                // Store the adjusted playback speed in the channel's metadata
                item.channel.metadata.adjustedPlaybackSpeed = item.channel.metadata.playbackSpeed * speedRatio;
            });

            // Return selected channels and new song BPM
            return { selectedChannels, newSongBPM };
        };

        /**
         * Processes an individual audio channel.
         * @param {Object} song - The song object.
         * @param {Object} channel - The channel object.
         * @param {Array} logs - Array to store logs.
         */
        const processChannel = async (song, channel, logs) => {
            const { id: songId } = song;
            const { id: channelId, url, metadata } = channel;
            const { trimStartTime_Percentage, trimEndTime_Percentage, requiresReversal, adjustedPlaybackSpeed } = metadata;

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    console.warn(`Fetch failed for ${url}. Skipping ${channelId}.`);
                    return;
                }

                const contentType = response.headers.get("Content-Type") || "";
                const audioBuffer = await fetchAndDecodeAudio(response, contentType, url);
                if (!audioBuffer) {
                    console.warn(`Decoding failed for ${channelId}. Skipping.`);
                    return;
                }

                if (trimEndTime_Percentage <= trimStartTime_Percentage) {
                    console.warn(`Invalid trim percentages for ${channelId}. Skipping.`);
                    return;
                }

                const start = Math.floor((trimStartTime_Percentage / 100) * audioBuffer.duration * audioBuffer.sampleRate);
                const end = Math.floor((trimEndTime_Percentage / 100) * audioBuffer.duration * audioBuffer.sampleRate);
                const length = end - start;

                if (length <= 0) {
                    console.warn(`Non-positive trimmed length for ${channelId}. Skipping.`);
                    return;
                }

                const trimmedBuffer = audioContext.createBuffer(audioBuffer.numberOfChannels, length, audioBuffer.sampleRate);
                for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
                    trimmedBuffer.getChannelData(i).set(audioBuffer.getChannelData(i).subarray(start, end));
                }

                const normalizedBuffer = normalizeAudioBuffer(trimmedBuffer, 0.5);

                // Store the audio buffer
                globalData.audioBuffers = globalData.audioBuffers || {};
                globalData.audioBuffers[channelId] = normalizedBuffer;

                if (requiresReversal) {
                    const reversedBuffer = createReverseAudioBuffer(normalizedBuffer);
                    globalData.reverseAudioBuffers = globalData.reverseAudioBuffers || {};
                    globalData.reverseAudioBuffers[channelId] = reversedBuffer;
                }

                // Store adjusted playback speed
                globalData.adjustedPlaybackSpeeds = globalData.adjustedPlaybackSpeeds || {};
                globalData.adjustedPlaybackSpeeds[channelId] = adjustedPlaybackSpeed;

                logs.push({
                    "Channel ID": channelId,
                    "Audio File": extractFileName(url),
                    "Trimmed Duration (s)": normalizedBuffer.duration.toFixed(2),
                    "Adjusted Playback Speed": adjustedPlaybackSpeed.toFixed(3),
                    "Requires Reversal": requiresReversal
                });

                console.log(`Processed ${channelId}${requiresReversal ? " (Reversed)" : ""}`);
            } catch (error) {
                console.warn(`Error processing ${channelId}: ${error.message}`);
            }
        };

        const logDetailedInfo = logs => {
            if (logs.length) {
                console.table(logs);
            } else {
                console.warn("No audio samples processed.");
            }
        };

        /**
         * Creates a new remix song using the selected channels.
         * @param {Array} selectedChannels - Array of selected channels with song reference.
         * @param {number} newSongBPM - The BPM for the new song.
         */
         const createRemixSong = (selectedChannels, newSongBPM) => {
            const newSong = {
                id: 'Remix Song',
                artist: 'Various Artists',
                bpm: newSongBPM,
                totalSequences: 1,
                channels: [],
                projectSequences: {}
            };

            // Map channels to the new song
            newSong.channels = selectedChannels.map((item) => {
                return {
                    id: item.newChannelId,
                    url: item.channel.url,
                    metadata: item.channel.metadata
                };
            });

            // Create a single sequence
            const sequenceName = 'Sequence1';
            newSong.projectSequences[sequenceName] = {};

            selectedChannels.forEach((item) => {
                const newChannelId = item.newChannelId;
                const originalChannelIndex = item.originalChannelIndex;
                const bpmRatio = item.bpmRatio;
                const originalSequences = item.song.projectSequences || {};

                // Collect steps from all sequences
                let combinedSteps = [];

                for (const [sequenceId, sequenceData] of Object.entries(originalSequences)) {
                    // Access the channel sequence using 'ch' + originalChannelIndex
                    const channelKey = `ch${originalChannelIndex}`;
                    const channelSequence = sequenceData[channelKey];
                    if (channelSequence && channelSequence.steps) {
                        // Adjust step indices according to BPM ratio
                        const adjustedSteps = channelSequence.steps.map(step => {
                            if (typeof step === 'number') {
                                // Forward step
                                let stepIndex = Math.round(step * bpmRatio);
                                if (stepIndex >= 64) stepIndex = 63; // Clamp to max step index
                                return stepIndex;
                            } else if (typeof step === 'object' && step.index !== undefined) {
                                // Reverse step
                                let stepIndex = Math.round(step.index * bpmRatio);
                                if (stepIndex >= 64) stepIndex = 63;
                                return { ...step, index: stepIndex };
                            }
                            return null;
                        }).filter(s => s !== null);

                        combinedSteps = combinedSteps.concat(adjustedSteps);
                    }
                }

                // Remove duplicates and sort steps
                combinedSteps = Array.from(new Set(combinedSteps.map(s => JSON.stringify(s)))).map(s => JSON.parse(s));
                combinedSteps.sort((a, b) => {
                    const indexA = typeof a === 'number' ? a : a.index;
                    const indexB = typeof b === 'number' ? b : b.index;
                    return indexA - indexB;
                });

                // Assign combined steps to the new sequence
                newSong.projectSequences[sequenceName][newChannelId] = {
                    steps: combinedSteps
                };
            });

            globalData.remixSong = newSong;
            console.log("Remix song created:", newSong);
        };




        /**
     * Processes the selected channels for the remix song.
     */
     const processRemixChannels = async () => {
        const { songsArray } = globalData;
        if (!songsArray.length) {
            console.error("No songs to process.");
            return;
        }

        // Select 16 random channels with adjusted speeds
        const { selectedChannels, newSongBPM } = selectRandomChannelsWithAdjustedSpeeds(songsArray, 16);

        console.log(`New song BPM is set to ${newSongBPM} based on the first selected channel.`);

        // Assign new channel IDs and store mappings
        selectedChannels.forEach((item, index) => {
            const newChannelId = `ch${index}`;
            item.newChannelId = newChannelId;
            item.originalChannelId = item.channel.id; // Store the original channel ID (e.g., 'A', 'B', etc.)
            item.originalChannelIndex = item.song.channels.findIndex(ch => ch.id === item.originalChannelId);
            item.channel.id = newChannelId; // Update the channel's ID
            // Store BPM ratio for adjusting steps
            item.bpmRatio = item.song.bpm / newSongBPM; // Corrected BPM ratio
        });

        const logs = [];
        const processingPromises = selectedChannels.map(({ song, channel }) => {
            return processChannel(song, channel, logs);
        });

        await Promise.all(processingPromises);

        logDetailedInfo(logs);
        console.log("Remix audio buffers ready.");

        // Create a new song object using the selected channels
        createRemixSong(selectedChannels, newSongBPM);

        // Dispatch event indicating that the remix song and audio buffers are ready
        document.dispatchEvent(new CustomEvent("remixAudioBuffersReady", { detail: { success: true } }));
    };




        /**
         * Initializes the audio processing for the remix song.
         */
        const initRemixAudioProcessing = async () => {
            try {
                await ensureAudioContextRunning();
                await processRemixChannels();
                // No need to process remaining channels in the background
            } catch (error) {
                console.error("Audio processing initialization error:", error);
            }
        };

        /**
         * Ensures the AudioContext is running.
         */
        const ensureAudioContextRunning = async () => {
            if (audioContext.state === 'suspended') await audioContext.resume();
        };

        /**
         * Initializes the Master Gain Node.
         */
        const initializeMasterGain = () => {
            const masterGain = audioContext.createGain();
            masterGain.gain.value = 0.7;
            masterGain.connect(audioContext.destination);
            globalData.masterGain = masterGain;
            console.log("Master Gain initialized with gain:", masterGain.gain.value);
        };

        /**
         * Starts the setup process.
         */
        const startSetup = () => {
            document.addEventListener("dataLoadingComplete", initRemixAudioProcessing);
            if (globalData.songsArray?.length) {
                initRemixAudioProcessing();
            }
        };

        // Initialization
        startSetup();
    })();
    </script>
</section2>


<!-- Section 3 - Remix Playback Engine -->
<script>
  (function () {
      const globalData = window.globalData || (window.globalData = {});
      const audioContext = globalData.audioContext;
      globalData.isPlaying = false;
      
      let playbackInterval = null;
      let scheduler = {};
      const missingAudioBuffers = new Set();
      let activeBufferSources = [];

      // Assign playback functions to globalData
      globalData.togglePlayback = () => {
          globalData.isPlaying ? globalData.stopPlayback() : globalData.startPlayback();
      };

      globalData.startPlayback = () => {
          if (globalData.isPlaying) {
              console.log("Playback is already in progress.");
              return;
          }

          const { remixSong, audioBuffers, reverseAudioBuffers } = globalData;
          if (!remixSong) {
              console.error("Remix song is not available for playback.");
              return;
          }

          const song = remixSong;
          const projectSequences = song.projectSequences || {};
          console.log(`Starting playback for Remix Song: ${song.id}`);
          console.log(`Song BPM: ${song.bpm}`);

          const stepDuration = 60 / song.bpm / 4; // Each step is a sixteenth note
          const sequenceLength = 64 * stepDuration; // Assuming 64 steps per sequence

          scheduler = {};
          missingAudioBuffers.clear();
          let startOffset = 0;

          for (const [sequenceId, sequence] of Object.entries(projectSequences)) {
              const startTime = audioContext.currentTime + startOffset;
              scheduler[sequenceId] = {
                  nextStepIndex: 0,
                  nextStepTime: startTime,
                  stepDuration: stepDuration,
                  startTime: startTime,
                  endTime: startTime + sequenceLength,
                  completed: false
              };
              console.log(`Initialized scheduler for sequence: ${sequenceId} starting at +${startOffset.toFixed(2)}s`);
              startOffset += sequenceLength;
          }

          globalData.isPlaying = true;
          playbackInterval = setInterval(() => scheduleSteps(song, audioBuffers, reverseAudioBuffers), 25);
          console.log("Playback started.");
          document.dispatchEvent(new CustomEvent("playbackStarted", { detail: { success: true } }));

          // Update Now Playing UI
          updateNowPlayingUI(song);
      };

      globalData.stopPlayback = () => {
          if (!globalData.isPlaying) {
              console.log("Playback is not in progress.");
              return;
          }

          if (playbackInterval) clearInterval(playbackInterval);
          globalData.isPlaying = false;
          scheduler = {};
          missingAudioBuffers.clear();

          // Stop all active buffer sources immediately
          activeBufferSources.forEach(bufferSource => {
              bufferSource.stop();
              bufferSource.disconnect();
          });
          activeBufferSources = [];

          console.log("Playback stopped and sequence states reset.");
          document.dispatchEvent(new CustomEvent("playbackStopped", { detail: { success: true } }));

          // Reset Now Playing UI
          resetNowPlayingUI();
      };

      // Schedules steps for playback
      const scheduleSteps = (song, audioBuffers, reverseAudioBuffers) => {
        const currentTime = audioContext.currentTime;
        let allSequencesCompleted = true;

        for (const [sequenceId, sequence] of Object.entries(song.projectSequences || {})) {
            const sequenceScheduler = scheduler[sequenceId];
            if (!sequenceScheduler || sequenceScheduler.completed) continue;

            if (currentTime >= sequenceScheduler.endTime) {
                sequenceScheduler.completed = true;
                console.log(`Sequence ${sequenceId} has completed.`);
            } else {
                allSequencesCompleted = false;
                while (sequenceScheduler.nextStepTime < currentTime + 0.1 && globalData.isPlaying) {
                    const stepIndex = sequenceScheduler.nextStepIndex;
                    const stepTime = sequenceScheduler.nextStepTime;

                    for (const [channelId, channelSequence] of Object.entries(sequence)) {
                        const channel = song.channels.find(ch => ch.id === channelId);
                        if (!channel) {
                            console.warn(`Channel ${channelId} not found in remix song.`);
                            continue;
                        }

                        const steps = channelSequence.steps || [];

                        // Find if there is a step to play at the current index
                        let stepToPlay = null;
                        for (const step of steps) {
                            if (typeof step === 'number' && step === stepIndex) {
                                stepToPlay = step;
                                break;
                            } else if (typeof step === 'object' && step.index === stepIndex) {
                                stepToPlay = step;
                                break;
                            }
                        }

                        if (stepToPlay !== null) {
                            // Determine if the step is reversed
                            let isReversed = false;
                            if (typeof stepToPlay === 'object' && stepToPlay.reverse) {
                                isReversed = true;
                            }
                            playAudioBuffer(song, channel, stepTime, isReversed, audioBuffers, reverseAudioBuffers, sequenceScheduler.stepDuration);
                        }
                    }

                    sequenceScheduler.nextStepIndex += 1;
                    if (sequenceScheduler.nextStepIndex >= 64) {
                        sequenceScheduler.completed = true;
                        console.log(`Sequence ${sequenceId} has completed all steps.`);
                        break;
                    }

                    sequenceScheduler.nextStepTime += sequenceScheduler.stepDuration;
                }
            }
        }

        if (allSequencesCompleted) {
            console.log("All sequences have completed.");
            handlePlaybackCompletion(song);
        }
    };


      // Plays the audio buffer for a given step
      const playAudioBuffer = (song, channel, startTime, isReversed, audioBuffers, reverseAudioBuffers, stepDuration) => {
          const channelId = channel.id;
          const buffer = isReversed ? reverseAudioBuffers[channelId] : audioBuffers[channelId];

          if (!buffer) {
              if (!missingAudioBuffers.has(channelId)) {
                  missingAudioBuffers.add(channelId);
                  console.warn(`Audio buffer missing for Channel: ${channelId}${isReversed ? " (Reverse)" : ""}`);
              }
              return;
          }

          const bufferSource = audioContext.createBufferSource();
          bufferSource.buffer = buffer;

          // Use the adjusted playback speed
          const adjustedPlaybackSpeed = globalData.adjustedPlaybackSpeeds[channelId] || 1;
          bufferSource.playbackRate.value = adjustedPlaybackSpeed;

          bufferSource.connect(globalData.masterGain || audioContext.destination);
          bufferSource.start(startTime);
          activeBufferSources.push(bufferSource);
      };

      // Resets playback state
      const resetPlaybackState = () => {
          if (playbackInterval) clearInterval(playbackInterval);
          scheduler = {};
          missingAudioBuffers.clear();
          console.log("Playback reset.");
      };

      // Handles playback completion logic
      const handlePlaybackCompletion = (song) => {
          console.log("Playback has completed the remix song.");
          globalData.stopPlayback();
      };

      // Updates the Now Playing UI
      const updateNowPlayingUI = (song) => {
          const nowPlayingContainer = document.getElementById("nowPlayingContainer");
          if (!nowPlayingContainer) return;

          const { projectName, artistName } = getProjectAndArtist(song);
          nowPlayingContainer.querySelector(".songTitle").textContent = projectName;
          nowPlayingContainer.querySelector(".artistName").textContent = artistName;
      };

      // Resets the Now Playing UI
      const resetNowPlayingUI = () => {
          const nowPlayingContainer = document.getElementById("nowPlayingContainer");
          if (!nowPlayingContainer) return;

          nowPlayingContainer.querySelector(".songTitle").textContent = "No song playing";
          nowPlayingContainer.querySelector(".artistName").textContent = "";
      };

      // Initializes playback engine
      const initializePlaybackEngine = () => {
          const { remixSong } = globalData;
          if (remixSong) {
              console.log("Playback Engine Initialization Complete.");
              console.log("Playback is ready. Click the artwork to start.");
          } else {
              console.error("Remix song is not available for playback.");
          }
      };

      // Sets up artwork click listener for playback toggle
      const setupArtworkClickListener = () => {
          document.addEventListener("DOMContentLoaded", () => {
              const artworkCover = document.getElementById("artworkCover");
              const artworkImage = document.getElementById("artworkImage");
              if (globalData.isArtworkCover && window.artworkUrl && window.artworkUrl.length > 0) {
                  artworkImage.src = window.artworkUrl[0];
                  artworkCover.classList.remove("hidden");
                  const loadingSpinner = document.getElementById("loadingSpinner");
                  if (loadingSpinner) loadingSpinner.style.display = "none";
                  artworkImage.addEventListener("click", globalData.togglePlayback);
              }
          });
      };

      // Event listeners for audio buffer readiness and playback events
      document.addEventListener("remixAudioBuffersReady", (event) => {
          if (event.detail.success) {
              initializeMasterGain();
              initializePlaybackEngine();
              console.log("Remix audio buffers are ready.");
          }
      });

      document.addEventListener("playbackStarted", (event) => {
          if (event.detail.success) {
              console.log("Playback has been successfully started.");
          }
      });

      document.addEventListener("playbackStopped", (event) => {
          if (event.detail.success) {
              console.log("Playback has been successfully stopped.");
          }
      });

      // Initializes the Master Gain Node.
      const initializeMasterGain = () => {
          if (!globalData.masterGain) {
              const masterGain = audioContext.createGain();
              masterGain.gain.value = 0.7;
              masterGain.connect(audioContext.destination);
              globalData.masterGain = masterGain;
              console.log("Master Gain initialized with gain:", masterGain.gain.value);
          }
      };

      // Start the setup
      setupArtworkClickListener();
      if (globalData.remixSong && Object.keys(globalData.audioBuffers || {}).length) {
          initializeMasterGain();
          initializePlaybackEngine();
      }
  })();
  </script>

  <!-- Keyboard Controls and Event Listeners Script -->
  <script>
  // keyboardControlsAndEventListeners.js
  (() => {
      const globalData = window.globalData || (window.globalData = {});
      const audioContext = globalData.audioContext;

      // Removed nextSong and previousSong functions as they are not applicable in Remix Mode
      // Also removed the keydown event listener for song navigation

      // Ensuring AudioContext is resumed on user interaction
      document.addEventListener("DOMContentLoaded", () => {
          if (audioContext) {
              const resumeAudioContext = async () => {
                  if (audioContext.state === 'suspended') {
                      try {
                          await audioContext.resume();
                          console.log("AudioContext resumed successfully.");
                      } catch (error) {
                          console.error("Failed to resume AudioContext:", error);
                      }
                  }
              };
              document.addEventListener("click", resumeAudioContext);
              document.addEventListener("keydown", resumeAudioContext);
              console.log("AudioContext resumption listeners added.");
          } else {
              console.warn("AudioContext not found.");
          }
      });
  })();
  </script>

    
    
    

</html>
