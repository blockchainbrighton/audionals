// gainNodeHelper.js
window.GainNodeHelper=(()=>{const n=window.globalData||(window.globalData={gainNodes:{},audioContext:new(window.AudioContext||window.webkitAudioContext),masterGain:null});n.masterGain||(n.masterGain=n.audioContext.createGain(),n.masterGain.connect(n.audioContext.destination));const e={targetLoudness:.9,transientThreshold:1.2,smoothingFactor:.7},o=(o,t=!1)=>{const i=o.id;if(!o.channels||0===o.channels.length)return void console.warn(`[GainNodeHelper] No channels found for Song "${i}".`);n.gainNodes[i]=n.gainNodes[i]||{},o.channels.forEach((e=>{if(!n.gainNodes[i][e.id]){const o=n.audioContext.createGain();o.gain.value=e.metadata.volume||1,o.connect(n.masterGain),n.gainNodes[i][e.id]=o}}));const s=o.channels.map((n=>n.metadata.volume||1)),d=Math.max(...s);o.channels.forEach((n=>{const o=(n.metadata.volume||1)/d*e.targetLoudness;a(i,n.id,o)})),o.channels.forEach((o=>{const a=n.gainNodes?.[i]?.[o.id];if(a){const o=Math.min(a.gain.value*e.transientThreshold,e.targetLoudness);a.gain.setTargetAtTime(o,n.audioContext.currentTime,e.smoothingFactor)}}))},a=(e,o,a)=>{const t=n.gainNodes?.[e]?.[o];t?t.gain.setValueAtTime(a,n.audioContext.currentTime):console.warn(`[GainNodeHelper] No GainNode found for Channel "${o}" of Song "${e}".`)};return{createGainNodesForSong:o,prepareNextSongGainNodes:n=>{o(n,!0)},cleanupGainNodesForSong:e=>{const o=n.gainNodes[e];o?(Object.values(o).forEach((n=>n.disconnect())),delete n.gainNodes[e]):console.warn(`[GainNodeHelper] No GainNodes found to clean up for Song "${e}".`)},setChannelGain:a,setMasteringControls:n=>{Object.assign(e,n)}}})();
