// initialiseSongsWithEffects.js
document.addEventListener("dataReady",(async()=>{window.allChannels&&window.globalData?(await window.waitForEffects(),(async()=>{function e(e){let n=e;const o=6364136223846793005n,a=1442695040888963407n,t=18446744073709551616n;return function(){return n=(o*n+a)%t,Number(n)/Number(t)}}const n=(e,n,o)=>{const a=[...e];for(let e=a.length-1;e>0;e--){const n=Math.floor(o()*(e+1));[a[e],a[n]]=[a[n],a[e]]}return a.slice(0,n)};function o(e,n=100){const o=[e];let a;try{a=BigInt(e)}catch(n){console.error(`[Seed Generation] Invalid initial seed "${e}". Defaulting to 0n.`),a=0n}for(let e=1;e<n;e++){a+=1n;let e=a.toString();e.length<16?e=e.padStart(16,"0"):e.length>16&&(e=e.slice(-16)),o.push(e)}return o}const a=(e,n,o=.01)=>Math.abs(e-n)<o||Math.abs(e-2*n)<o||Math.abs(e-n/2)<o;async function t(o,t){console.log(`[loopedSamplesDebug] Generating mix #${t} with seed "${o}"`);const l=[15,30,30.8333,50,52.5,60,61.6667,70,75,80,90,92.5,100,105,120,140,150,160,180,185,200,210,225,240,280,300,320],s=[];let i;try{i=BigInt(o),console.log(`[loopedSamplesDebug] Parsed seed string "${o}" to BigInt: ${i}`)}catch(e){console.error(`[loopedSamplesDebug] Invalid seed string: "${o}". Using base seed 0.`),i=0n}const d=i||1n,c=e(d),r=(n=>{const o=e(n);return l[Math.floor(o()*l.length)]})(d);console.log(`[loopedSamplesDebug] Selected BPM based on seed ${d}: ${r}`);const g=window.allChannels.filter((e=>{const n=e.url.split("/").pop();console.log(`[loopedSamplesDebug] Processing Channel ID ${e.id} with Sample ID ${n}`);const o=window.globalData.getLoopSampleInfo(n);return o?a(o.bpm,r)?(console.log(`[loopedSamplesDebug] Including loop sample with Sample ID ${n} and BPM ${o.bpm} as it is harmonically related to Song BPM ${r}`),!0):(console.log(`[loopedSamplesDebug] Excluding loop sample with Sample ID ${n} due to BPM mismatch (Loop BPM: ${o.bpm}, Song BPM: ${r})`),!1):(console.log(`[loopedSamplesDebug] Including non-loop sample from Channel ID ${e.id}`),!0)}));console.log(`[loopedSamplesDebug] Total channels after loop filtering: ${g.length}`);const p=n(g,24,c);console.log(`[loopedSamplesDebug] Selected ${p.length} random channels for the mix.`);const m=[{startSeq:1,count:p.length}];console.log("[loopedSamplesDebug] Defined activation points:",m);const u=m.reduce(((e,{count:n})=>e+n),0);let h=0;const w=m.map((({startSeq:e,count:n})=>{const o=Math.round(n/u*p.length);return h+=o,{startSeq:e,count:o}}));let S=p.length-h;if(0!==S)for(let e=0;Math.abs(S)>0;e=(e+1)%w.length)S>0?(w[e].count++,S--):w[e].count>0&&(w[e].count--,S++);console.log("[loopedSamplesDebug] Adjusted activation points:",w);let f=0;const b=w.flatMap((({startSeq:e,count:n})=>{const o=[];for(let a=0;a<n;a++){const n=p[f];if(f++,n){const a={...n};a.activationSeq=e,console.log(`[loopedSamplesDebug] Channel ID ${a.id} assigned to activation sequence starting at ${e}.`),o.push({channel:a,activationSeq:e})}}return o}));console.log(`[loopedSamplesDebug] Total channels with activation: ${b.length}`);const D=new Set(b.flatMap((({channel:e})=>e.metadata.channelSequence?.map((e=>e.sequenceName))||[])));console.log("[loopedSamplesDebug] Unique sequence names collected from channels:",Array.from(D));let q=[...D].sort(((e,n)=>(parseInt(e.replace("Sequence",""))||0)-(parseInt(n.replace("Sequence",""))||0)));console.log("[loopedSamplesDebug] Sorted sequences:",q),q=q.slice(0,48),console.log("[loopedSamplesDebug] Limited sequences to first 48:",q);const y={id:`The Infinite Ordinal Remix ${t}`,projectName:`The Infinite Ordinal Remix ${t}`,artist:"By melophonic And Whoever Mines This Mix",bpm:r,totalSequences:q.length,totalChannels:b.length,channels:[],projectSequences:Object.fromEntries(q.map((e=>[e,{}]))),seed:o};console.log("[loopedSamplesDebug] Initialized new song object:",y);const{audioContext:$}=window.globalData,v=.7,M=4;await window.waitForEffects();const I={harmonyChannelsAdded:0,maxHarmonyChannels:window.EffectsModule?.effectsConfig?.harmonize?.maxHarmonyChannels||2,totalGain:0,maxTotalGain:1,channelLayers:{}};return await Promise.all(b.map((async({channel:e,activationSeq:n},o)=>{const a=`ch${o}`,t={id:a,url:e.url,metadata:{...e.metadata,originalBPM:y.bpm,activationSeq:n}};await function(e,n,o,a,t,l,s){console.log(`[effectsDebug][Song: "${o.id}"] Applying effects to Channel "${e.id}"...`);const i=new Set(["harmonize","delay","delayBpmLinked"]),d=new Set,c=[{name:"pitchShift",apply:(e,n)=>window.applyRandomPitchShift(e,n,s)},{name:"harmonize",apply:(e,a)=>window.addHarmony(e,n,o,a,l,s)}].sort((()=>.5-Math.random()));let r=0;for(const{name:n,apply:g}of c){if(r>=3)break;const c=window.EffectsModule.getEffectParams(n,a,t,s);if(c){if(g(e,c),r++,i.has(n)){l.channelLayers[e.id]=Math.min((l.channelLayers[e.id]||1)+1,M);const a=l.channelLayers[e.id],t=1/a*v**(a-1);e.metadata.volume=t,GainNodeHelper.setChannelGain(o.id,e.id,t),d.add(n)}d.add(n)}}const[g,p,m]=[.5,1.5,2],[u,h]=[-340282e33,1541.27];if(l.totalGain>m){const n=m/l.totalGain;e.metadata.volume=(e.metadata.volume||1)*n,d.add("normalization")}l.totalGain+=e.metadata.volume||1,e.metadata.volume<g?(e.metadata.volume=g,d.add("clamping_min")):e.metadata.volume>p&&(e.metadata.volume=p,d.add("clamping_max")),GainNodeHelper.setChannelGain(o.id,e.id,e.metadata.volume||1)}(t,o,y,n,y.bpm,I,c),y.channels.push(t),e.metadata.channelSequence?.forEach((e=>{if(y.projectSequences[e.sequenceName]){const o=63*(n-1),t=e.steps.filter((e=>e>=o)).map((e=>e-o));y.projectSequences[e.sequenceName]={...y.projectSequences[e.sequenceName],[a]:{steps:t}}}}))}))),console.log("[loopedSamplesDebug] Final projectSequences mapping:",y.projectSequences),s.push(y),console.log("[loopedSamplesDebug] New song added to the songs list."),s}!function(){if(window.globalData.seedList&&window.globalData.seedList.length>1)console.log(`[Seed Initialization] Using user-provided seedList with ${window.globalData.seedList.length} seeds.`);else if(window.globalData.seedList&&1===window.globalData.seedList.length){const e=window.globalData.seedList[0],n=o(e,100).slice(1);window.globalData.seedList=window.globalData.seedList.concat(n),console.log(`[Seed Initialization] Single seed provided. Generated 99 additional sequential seeds from "${e}". Total seeds: ${window.globalData.seedList.length}.`)}else{const e=function(){let e="";for(let n=0;n<16;n++)e+=Math.floor(10*Math.random()).toString();return e}();window.globalData.seedList=o(e,100),console.log(`[Seed Initialization] No user-provided seeds. Generated random seed "${e}" and created ${window.globalData.seedList.length} sequential seeds.`)}}();const l=await async function(e){const n=[];for(let o=0;o<e.length;o++){const a=e[o],l=o+1,s=await t(a,l);n.push(...s)}return n}(window.globalData.seedList);console.log(`[Mix Generation] Generated ${l.length} songs based on seedList.`),window.globalData.initialized||Object.assign(window.globalData,{songsArray:l,songsByBPM:window.globalData.songsByBPM||{},currentSongIndex:0,currentSequenceIndex:0,isSingleSong:1===l.length,isMultipleSongs:l.length>1,initialized:!0}),window.globalData.songsArray.forEach((e=>{GainNodeHelper.createGainNodesForSong(e)})),window.globalData.isArtworkCover&&artworkUrl.length&&setArtworkImage(artworkUrl[0]),document.dispatchEvent(new CustomEvent("dataLoadingComplete",{detail:{success:!0,totalSongs:window.globalData.songsArray.length,songs:window.globalData.songsArray.map((({id:e,totalSequences:n})=>({id:e,totalSequences:n})))}})),window.generateMixBySeed=t})()):console.error("Required data is not available.")}));
