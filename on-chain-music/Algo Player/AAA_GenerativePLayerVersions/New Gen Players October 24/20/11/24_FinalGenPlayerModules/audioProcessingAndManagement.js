// audioProcessingAndManagement.js
(async()=>{const e=window.globalData||(window.globalData={}),t=e.audioContext||(e.audioContext=new(window.AudioContext||window.webkitAudioContext)),n=e=>{try{if(!r(e))throw new Error("Invalid base64 string.");const t=atob(e),n=t.length,a=new Uint8Array(n);for(let e=0;e<n;e++)a[e]=t.charCodeAt(e);return a.buffer}catch(e){return console.error(`[base64ToArrayBuffer] Error converting base64 to ArrayBuffer: ${e.message}`),null}},a=e=>{const t=(4-e.length%4)%4;return e+"=".repeat(t)},o=(e,t)=>{if("json"===t&&e.audioData){const t=e.audioData.match(/base64,([A-Za-z0-9+/=]+)/);return t?(console.log(`[extractBase64] Found base64 data in JSON audioData. Length: ${t[1].length}`),t[1]):(console.warn("[extractBase64] No base64 data found in JSON audioData."),null)}if("html"===t)try{const t=(new DOMParser).parseFromString(e,"text/html"),n=t.querySelectorAll('source[src^="data:audio/"]');for(const e of n){const t=e.getAttribute("src");if(!t||!t.includes("base64,"))continue;let n=t.split("base64,")[1];if(n){if(n=n.replace(/\s+/g,""),n=a(n),console.log(`[extractBase64] Extracted base64 string from <source> tag. Length: ${n.length}`),r(n))return console.log("[extractBase64] Valid base64 string found in <source> tag."),n;console.warn("[extractBase64] Invalid base64 string in <source> tag."),console.log(`[extractBase64] Base64 Data Snippet: "${n.substring(0,30)}..."`)}}const o=t.querySelectorAll("audio");for(const e of o){const t=e.querySelector('source[src^="data:audio/"]');if(t){const e=t.getAttribute("src");if(!e||!e.includes("base64,"))continue;let n=e.split("base64,")[1];if(!n)continue;if(n=n.replace(/\s+/g,""),n=a(n),console.log(`[extractBase64] Extracted base64 string from <audio> tag's <source>. Length: ${n.length}`),r(n))return console.log("[extractBase64] Valid base64 string found in <audio> tag's <source>."),n;console.warn("[extractBase64] Invalid base64 string in <audio> tag's <source>."),console.log(`[extractBase64] Base64 Data Snippet: "${n.substring(0,30)}..."`)}}const s=t.querySelectorAll('*[src^="data:audio/"]');for(const e of s){const t=e.getAttribute("src");if(!t||!t.includes("base64,"))continue;let n=t.split("base64,")[1];if(n){if(n=n.replace(/\s+/g,""),n=a(n),console.log(`[extractBase64] Extracted base64 string from element with src. Length: ${n.length}`),r(n))return console.log("[extractBase64] Valid base64 string found in element with src."),n;console.warn("[extractBase64] Invalid base64 string in element with src."),console.log(`[extractBase64] Base64 Data Snippet: "${n.substring(0,30)}..."`)}}const i=t.querySelectorAll("Audional_Base64_Sample_Text");for(const e of i){const t=e.querySelectorAll("audio, source");for(const e of t){const t=e.getAttribute("src");if(!t||!t.includes("base64,"))continue;let n=t.split("base64,")[1];if(n){if(n=n.replace(/\s+/g,""),n=a(n),console.log(`[extractBase64] Extracted base64 string from audio element within custom tag. Length: ${n.length}`),r(n))return console.log("[extractBase64] Valid base64 string found in audio element within custom tag."),n;console.warn("[extractBase64] Invalid base64 string in audio element within custom tag."),console.log(`[extractBase64] Base64 Data Snippet: "${n.substring(0,30)}..."`)}}}const l=e.toString(),c=/data:audio\/[a-zA-Z0-9]+;base64,([A-Za-z0-9+/=]+)/g;let u;for(;null!==(u=c.exec(l));){let e=u[1].replace(/\s+/g,"");if(e=a(e),console.log(`[extractBase64] Extracted base64 string using regex. Length: ${e.length}`),r(e))return console.log("[extractBase64] Valid base64 string found using regex."),e;console.log(`[extractBase64] Base64 Data Snippet: "${e.substring(0,30)}..."`)}return null}catch(e){return null}},r=e=>{const t=e.replace(/\s+/g,"");if(t.length%4!=0)return!1;const n=/^[A-Za-z0-9+/]+={0,2}$/.test(t);return n},s=(e,t=.75)=>{let n=0;for(let t=0;t<e.numberOfChannels;t++){const a=e.getChannelData(t);for(const e of a){const t=Math.abs(e);t>n&&(n=t)}}const a=n>0?t/n:1;if(1!==a)for(let t=0;t<e.numberOfChannels;t++){const n=e.getChannelData(t);for(let e=0;e<n.length;e++)n[e]*=a}return e},i=async(i,c,u)=>{const{id:d}=i,{id:g,url:f,metadata:{trimStartTime_Percentage:h,trimEndTime_Percentage:p,requiresReversal:m}}=c;try{const i=await fetch(f);if(!i.ok)return void console.error(`[ProcessChannel][Song: "${d}"] Fetch failed for URL: "${f}" - Status: ${i.status} ${i.statusText}. Skipping Channel ID: "${g}".`);const c=i.headers.get("Content-Type")||"",w=await(async(s,i,l,c,u)=>{const d=e.audioFetchCache||(e.audioFetchCache=new Map);if(d.has(l))return d.get(l);try{let e;if(l.startsWith("data:audio/")){const o=l.split(",")[1];if(!o)return null;let s=o.replace(/\s+/g,"");if(s=a(s),!r(s))return null;const i=n(s);if(!i)return null;e=await t.decodeAudioData(i)}else if(/audio\/(wav|mpeg|mp4)|video\/mp4/.test(i)){const n=await s.arrayBuffer();e=await t.decodeAudioData(n)}else if(/application\/json/.test(i)){const a=await s.json(),i=o(a,"json");if(!i||!r(i))return null;const l=n(i);if(!l)return null;e=await t.decodeAudioData(l)}else if(/text\/html/.test(i)){const a=await s.text(),i=o(a,"html");if(!i||!r(i))return null;const l=n(i);if(!l)return null;e=await t.decodeAudioData(l)}else{if(!/audio\//.test(i))return null;const n=await s.arrayBuffer();e=await t.decodeAudioData(n)}return d.set(l,e),e}catch(e){return null}})(i,c,f);if(!w)return void console.error(`[ProcessChannel][Song: "${d}"] Decoding failed for Channel ID: "${g}". Skipping.`);if(p<=h)return void console.error(`[ProcessChannel][Song: "${d}", Channel: "${g}"] Invalid trim percentages - Start: ${h}%, End: ${p}%. Skipping.`);const B=Math.floor(h/100*w.duration*w.sampleRate),x=Math.floor(p/100*w.duration*w.sampleRate),A=x-B;if(A<=0)return void console.error(`[ProcessChannel][Song: "${d}", Channel: "${g}"] Non-positive trimmed length: ${A} samples. Skipping.`);const $=t.createBuffer(w.numberOfChannels,A,w.sampleRate);for(let e=0;e<w.numberOfChannels;e++)$.getChannelData(e).set(w.getChannelData(e).subarray(B,x));const C=s($,.5);if(e.audioBuffers=e.audioBuffers||{},e.reverseAudioBuffers=e.reverseAudioBuffers||{},e.audioBuffers[d]=e.audioBuffers[d]||{},e.reverseAudioBuffers[d]=e.reverseAudioBuffers[d]||{},e.audioBuffers[d][g]=C,m)try{const t=l(C);e.reverseAudioBuffers[d][g]=t}catch(e){console.error(`[ProcessChannel][Song: "${d}", Channel: "${g}"] Error reversing AudioBuffer: ${e.message}`)}const S=e=>{try{const t=new URL(e,window.location.origin).pathname;return t.split("/").pop()||""}catch(t){return console.error(`[getSampleIdFromURL] Invalid URL: "${e}" - ${t.message}`),""}},v=S(f),D=window.globalData.loopSampleData.some((e=>e.id===v));D&&console.log(`[LoopedSample] Processing looped audio sample ID: "${v}" for Song: "${d}", Channel: "${g}".`),u.push({"Song ID":d,"Channel ID":g,"Audio File":(b=f,b.split("/").pop()||"Unknown"),"Full Duration (s)":w.duration.toFixed(2),"Trimmed Duration (s)":$.duration.toFixed(2),"Requires Reversal":m,"Is Looped Sample":D})}catch(e){console.error(`[ProcessChannel][Song: "${d}", Channel: "${g}"] Unexpected error: ${e.message}`)}var b},l=e=>{const n=t.createBuffer(e.numberOfChannels,e.length,e.sampleRate);for(let t=0;t<e.numberOfChannels;t++){const a=e.getChannelData(t),o=n.getChannelData(t);for(let e=0;e<a.length;e++)o[e]=a[a.length-e-1]}return s(n,.5)},c=e=>{e.length&&console.table(e)},u=async()=>{try{"suspended"===t.state&&await t.resume(),await(async()=>{const{songsArray:n}=e;if(!n||!n.length)return void console.error("No songs to process.");const a=[],o=new Map;for(const[e,t]of o.entries()){const o=n.find((t=>t.id===e));if(!o)continue;const r=t.map((e=>{const t=o.channels.find((t=>t.id===e));return t?i(o,t,a):Promise.resolve(null)}));await Promise.all(r)}c(a);const r=t.createGain();r.gain.value=.7,r.connect(t.destination),e.masterGain=r,document.dispatchEvent(new CustomEvent("initialAudioBuffersReady",{detail:{success:!0}}))})();try{const{songsArray:t}=e;if(!t||!t.length)return void console.error("No songs to process.");const n=[],a=t.flatMap((e=>e.channels.map((t=>({song:e,channel:t}))))),o=[];for(;a.length;)o.push(a.splice(0,4));for(const e of o){const t=e.map((({song:e,channel:t})=>i(e,t,n)));await Promise.all(t)}c(n),document.dispatchEvent(new CustomEvent("allAudioBuffersReady",{detail:{success:!0}}))}catch(e){console.error("Background processing error:",e)}}catch(e){console.error("Audio processing initialization error:",e)}};document.addEventListener("dataLoadingComplete",u),e.songsArray?.length&&u(),document.addEventListener("initialAudioBuffersReady",(()=>{}))})();
