<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Audionals - Web3 Music Player</title>
    <link rel="stylesheet" href="/content/7a309a161e838ba93740684338b3d97f3c1226c046d8b1137afc2353b4bf16e1i0">
    <script>
        // Artwork URL
        const artworkUrl = [
            "/content/01c48d3cceb02215bc3d44f9a2dc7fba63ea63719a2ef1c35d3f0c4db93ab8d5i0"
        ];

        // Song Data URLs
        const songDataUrls = [
            "/content/6d288c0c82653001bb32497889dd1486e8afec9b0671a95fa9e10f99c20737bbi0", // Kora Algo New
            "/content/5527d0cc95ce5ce6eedf4e275234da8b1fe087512d0db618b6de1aaad437c96bi0", // TRUTH
            "/content/b22f1c85371b58a9cdac19b2baa50b1f9025a28d44cdfaad539d0527aa7d894ei0", // On Chain in the Membrane
            "/content/a4fb0b49181975450a6710f20128eb0b3acc51f4aa1ce87ebdbc9607562013a2i0", // Minty Fresh
            "/content/633100d631767ddb9a309f5a2a66f5a66d5abd839f3b1c55642690d484189971i0", // On Day One
            "/content/5ee46b8f645a65b0ec8ae749a28f88e364347f89137bb79986355bf5fb94cbebi0", // Fiat Money // ** ONLY 2 SEQUENCES LONG
            "/content/78c254c23d4da7d2379358590e74cf5452147702e2f293b3c3bf40f51d5ee0fdi0", // Butterfly Effect
            "/content/8aec0a99a5617b9da98a5b63a11a5143f0cac3cfa662d9515c2285de03ef95d4i0", // Cheese
            "/content/9dfa1812b211a7ac8b2f9e77119828ec8fbf2e9016b3d37a8efd70052eb4aa3ci0", // Bear Market Disco
            "/content/c41de57f1e062a440a9fc96d54baaccd7ec40049f48e9f3880559afc60b1b09ai0", // Did You Know // ** ONLY 2 SEQUENCES LONG
            "/content/119a3ccd1dfd7e987cca139f86d16717d845a22dd6afc59ad492527b95ae9a91i0", // MLK
            "/content/db9131cfe8e933e8e639f007dcd2b582a80bfd2be42b0eafa4d2e206332d6785i0", // Modern Progress
            "/content/07ff7bdc47e5272a3ff55cc46d2b189d510562a057a2c24112f3d0376950484di0", // Choppin' It Up
            "/content/fb0d2abcd1fa5bf2622579f0990435b48d41291f71626fc2e36a93e6ea6b3b85i0", // Humanity
            "/content/85436950f53c57aa0c510071d2d5f1c187e1d21e4e57210fcae152c4c7b6a768i0", // Rhythm and Bass 240
            "/content/e3ca12dd7516b4e486af4e3fa7f4ebc535d825034ff3c9da4954f354572dcf61i0", // Crazy Ass Bitch
            "/content/d0496a8e1657ce470807c8d47dcb5f1018a32d8ec8e50d490ad49411ffee1457i0", // Rhythm and Bass 60
            "/content/776fdd58a85170df78d41ca838287cc41404a4ab5398ff1333bcdcb79a5e6151i0"  // Rainbow
        ];

        // Project Artist Mapping
        window.projectArtistMap = {
            "I Love Cheese 2024 FINAL": "Rex Speedway and The Denim Avengers + jim.btc",
            "TRUTH": "melophonic",
            "Kora Algo New": "melophonic",
            "MLK 120": "Audionals",
            "Modern Progress Vocal": "Audionals",
            "Choppin' It Up": "Audionals",
            "HUMANITY": "Audionals",
            "Minty Fresh v2": "melophonic + Rare Scrilla",
            "How We Be - Based": "Based.btc",
            "Rhythm and Bass": "Audionals",
            "CrazyAssBitch": "French Montana + Audionals",
            "Rhythm and Bass @60": "Audionals",
            "On-Chain in the Membrane": "melophonic",
            "FIAT MONEY": "Solemn",
            "didd you know 1": "Solemn",
            "Bear Market Disco": "Based.btc",
            "Butterfly Effect": "Based.btc",
            "FREEDOM TO TRANSACT REMIX": "melophonic"
        };
    </script>
</head>
<body>
    <h1>Audionals</h1>
    <div id="loadingSpinner"></div>
    <div id="artworkCover">
        <img id="artworkImage" src="" alt="Artwork Cover">
    </div>
    <div id="trackListingPanel">
        <h2>Track Listings:</h2>
        <div id="metadataContent"></div>
    </div>
    <div id="nowPlayingContainer">
        <div id="nowPlayingText">
            <span class="songTitle">No song playing</span>
            <span class="artistName"></span>
        </div>
    </div>
    <div id="buttonContainer">
        <button id="playButton" onclick="globalData.togglePlayback()">Play / Stop</button>
        <button id="prevButton" onclick="globalData.previousSong()">Previous</button>
        <button id="nextButton" onclick="globalData.nextSong()">Next</button>
        <button id="toggleInstruction" onclick="globalData.toggleInfo()">Info</button>
    </div>
    <div id="infoPanel" class="hidden">
        <h2>Audional Player Info</h2>
        <ul>
            <li>Press <strong>T</strong> to view the Track List.</li>
            <li>Use <strong>Left</strong> and <strong>Right</strong> arrows to navigate the Track List.</li>
        </ul>
    </div>

    <!-- Audio Context Created Here in Global Data-->
    <script src="/content/e8496fa0bcb3cad6bc173cd1ef2564b9548b43b306634bdafce47083efd7619ai0"></script> 

    <!-- Pako loading, deserialization, and dynamic song file creation -->
    <script>
        (async () => {
            console.log("[Initialization] Script started.");

            // Define the list of loop sample IDs
            const loopSampleIds = new Set([
                "7c42769c1763cc8f045aada7914e8158223e45e7a4f197b49f918b1c005d36fci0", // Minty Fresh - Channel F
                "3364803cb3032ce95f4138a214c15a9b36dcb70f574a477f27615d448e1cdeb8i0", // I love cheese - Channel 4/E
            ]);

            const keyNames = [
                "projectName", "artistName", "projectBPM", "currentSequence",
                "channelURLs", "channelVolume", "channelPlaybackSpeed",
                "trimSettings", "projectChannelNames", "startSliderValue",
                "endSliderValue", "totalSampleDuration", "start", "end",
                "projectSequences", "steps"
            ];

            const keyMap = keyNames.reduce((map, key, index) => ({ ...map, [key]: index }), {});

            const channelIds = Array.from({ length: 16 }, (_, i) => String.fromCharCode(65 + i));
            const channelIdMap = channelIds.reduce((map, id, idx) => ({ ...map, [id]: idx }), {});

            /**
             * Fetches, decompresses, and processes song data from a given URL.
             * @param {string} url - The URL to fetch the song data from.
             * @returns {object} - The processed song data.
             */
            const fetchAndProcessSongData = async (url) => {
                console.log(`[Initialization] Fetching and processing data from URL: ${url}`);

                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Network error for ${url}`);

                    const compressedData = new Uint8Array(await response.arrayBuffer());
                    const inflatedData = window.pako.inflate(compressedData);
                    const jsonString = new TextDecoder("utf-8").decode(inflatedData);
                    const parsedData = JSON.parse(jsonString);

                    const processParsedData = (data) => {
                        const recurse = (obj) => {
                            if (Array.isArray(obj)) return obj.map(recurse);
                            if (obj && typeof obj === "object") {
                                return Object.entries(obj).reduce((acc, [key, value]) => {
                                    const mappedKey = keyNames[key] || key;
                                    acc[mappedKey] = mappedKey === "projectSequences"
                                        ? Object.fromEntries(
                                            Object.entries(value).map(([seqKey, seqValue]) => {
                                                const sequenceName = `Sequence${seqKey.replace(/^s/, "")}`;
                                                const channels = Object.fromEntries(
                                                    Object.entries(seqValue).map(([channelKey, channelValue]) => {
                                                        const steps = channelValue[keyMap.steps] || [];
                                                        const processedSteps = steps.flatMap(step => {
                                                            if (typeof step === "number") return step;
                                                            if (step?.r) return Array.from({ length: step.r[1] - step.r[0] + 1 }, (_, idx) => step.r[0] + idx);
                                                            if (typeof step === "string" && step.endsWith("r")) return { index: parseInt(step.slice(0, -1), 10), reverse: true };
                                                            return [];
                                                        });
                                                        return [`ch${channelIdMap[channelKey]}`, { steps: processedSteps }];
                                                    })
                                                );
                                                return [sequenceName, channels];
                                            })
                                        )
                                        : recurse(value);
                                    return acc;
                                }, {});
                            }
                            return obj;
                        };
                        return recurse(data);
                    };

                    return processParsedData(parsedData);
                } catch (error) {
                    console.error(`[Initialization] Error fetching/deserializing ${url}:`, error);
                    throw error;
                }
            };

            /**
             * Prepares the initial sample order for the song.
             * @param {object} songData - The song data object.
             * @returns {Array} - The initial sample order array.
             */
            const prepareInitialSampleOrder = (songData) => {
                const { projectSequences } = songData;
                const sampleOrder = [];

                Object.keys(projectSequences)
                    .sort((a, b) => parseInt(a.replace('Sequence', ''), 10) - parseInt(b.replace('Sequence', ''), 10))
                    .forEach(sequenceKey => {
                        const sequence = projectSequences[sequenceKey];
                        Object.entries(sequence).forEach(([channelId, { steps }]) => {
                            steps.forEach(step => {
                                const identifier = `${channelId}_${step.reverse ? "r" : "f"}`;
                                if (!sampleOrder.some(item => `${item.channelId}_${item.reverse ? "r" : "f"}` === identifier)) {
                                    sampleOrder.push({ channelId, reverse: step.reverse || false });
                                }
                            });
                        });
                    });

                return sampleOrder;
            };

            /**
             * Sets the artwork image on the page.
             * @param {string} url - The URL of the artwork image.
             */
            const setArtworkImage = (url) => {
                const artworkElement = document.getElementById("artworkImage");
                if (artworkElement) {
                    artworkElement.src = url;
                    artworkElement.parentElement.style.display = "flex";
                    console.log("[Initialization] Artwork image set and displayed.");
                } else {
                    console.warn("[Initialization] Artwork cover elements not found.");
                }
            };

            // --- Effects Configuration ---
            const effectsConfig = { 
                pitchShift: { // pitchShift sounds great set to 1 on its own.
                    enabled: true, // Enabled for testing
                    defaultProbability: 1, // Always apply for testing
                    shifts: [0.25, 0.5, 1, 2, 4],
                    sequenceConfig: {}
                },
                harmonize: { // Harmonize seems more like a delay. needs to be low probability 0.01 - 0.02 seems good on its own.
                    enabled: true, // Enabled for testing
                    defaultProbability: 0.02, // Set to 0.02 as per comment
                    intervals: [1.2599, 1.4983],
                    maxHarmonyChannels: 2,
                    sequenceConfig: {}
                },
                delay: {
                    enabled: true, // Enabled based on user update
                    defaultProbability: 0.1, // Increased probability
                    noteValue: 'sixteenth',
                    maxDelayRepeats: 3,
                    sequenceConfig: {}
                },
                reverse: {
                    enabled: true, // Can't hear this effect at all
                    defaultProbability: 1,
                    sequenceConfig: {}
                },
                volumeChange: {
                    enabled: false,
                    defaultProbability: 0.0,
                    range: [0.5, 1.5],
                    sequenceConfig: {}
                },
                pan: {
                    enabled: true,
                    defaultProbability: 1,
                    positions: [-1, 1],
                    sequenceConfig: {}
                },
                reverb: {
                    enabled: true, // Can't hear this effect either!
                    defaultProbability: 1, // Increased probability for testing
                    decayTimeRange: [2, 7], // Increased decay time for more noticeable reverb
                    mixRange: [0.3, 0.9],   // Increased mix range for more prominent wet signal
                    sequenceConfig: {}
                },
                filter: {
                    enabled: true, // Can't hear this either
                    defaultProbability: 0.7, // Adjusted probability
                    types: ['lowpass', 'highpass', 'bandpass'], // Added 'bandpass' for more variety
                    frequencyRange: [300, 8000], // Expanded frequency range for more noticeable filtering
                    QRange: [1, 10], // Added Q factor for resonance
                    sequenceConfig: {}
                },
                tremolo: {
                    enabled: true, // Can't hear this
                    defaultProbability: 0.6, // Adjusted probability
                    rateRange: [4, 12],   // Increased rate range for more noticeable modulation
                    depthRange: [0.6, 1], // Increased depth range
                    sequenceConfig: {}
                },
                distortion: {
                    enabled: true, // I don't think I can hear this either
                    defaultProbability: 0.5, // Adjusted probability
                    amountRange: [1, 15], // Increased amount range for more noticeable distortion
                    sequenceConfig: {}
                },
                bitcrusher: {
                    enabled: true, // Can't hear this effect either
                    defaultProbability: 0.3, // Reduced probability to prevent excessive artifacts
                    bitDepthRange: [2, 6],    // Reduced bit depth range for more noticeable effect
                    sampleRateRange: [8000, 22050], // Lowered sample rate range for clearer bitcrushing
                    sequenceConfig: {}
                },
                // Add more effects as needed
            };

            /**
             * Helper function to get effect parameters based on current sequence.
             * @param {string} effectName - Name of the effect.
             * @param {number} currentSequence - The current sequence number.
             * @returns {object|null} - Effect parameters or null if not applied.
             */
            const getEffectParams = (effectName, currentSequence) => {
                const effect = effectsConfig[effectName];
                if (!effect.enabled) return null;

                const seqConfig = effect.sequenceConfig?.[currentSequence];
                const probability = seqConfig?.probability ?? effect.defaultProbability;

                return Math.random() < probability ? { ...effect, ...seqConfig } : null;
            };

            /**
             * Generalized function to apply an effect based on its type.
             * @param {string} effectType - Type of the effect.
             * @param {object} channel - The channel object.
             * @param {object} effectParams - Parameters for the effect.
             * @param {object} newSong - The new song object.
             * @param {number} index - Channel index.
             * @param {object} effectsContext - Context for tracking effects.
             */
            const applyEffect = (effectType, channel, effectParams, newSong, index, effectsContext) => {
                switch(effectType) {
                    case 'pitchShift':
                        const shift = effectParams.shifts[Math.floor(Math.random() * effectParams.shifts.length)];
                        const originalSpeed = channel.metadata.playbackSpeed;
                        channel.metadata.playbackSpeed *= shift;
                        console.log(`[effectsDebug] Pitch shifted channel ${channel.id} from ${originalSpeed.toFixed(2)}x to ${channel.metadata.playbackSpeed.toFixed(2)}x`);
                        break;
                    case 'harmonize':
                        if (effectsContext.harmonyChannelsAdded >= effectParams.maxHarmonyChannels) return;
                        effectParams.intervals.forEach(interval => {
                            if (effectsContext.harmonyChannelsAdded >= effectParams.maxHarmonyChannels) return;
                            const harmonyChannel = JSON.parse(JSON.stringify(channel)); // Deep clone
                            harmonyChannel.id = `${channel.id}_harmony_${index}_${interval}`;
                            const originalSpeedH = harmonyChannel.metadata.playbackSpeed;
                            harmonyChannel.metadata.playbackSpeed *= interval;
                            harmonyChannel.metadata.volume = (harmonyChannel.metadata.volume || 1) * 0.8;
                            newSong.channels.push(harmonyChannel);
                            effectsContext.harmonyChannelsAdded++;
                            console.log(`[effectsDebug] Added harmony channel ${harmonyChannel.id} with playback speed changed from ${originalSpeedH.toFixed(2)}x to ${harmonyChannel.metadata.playbackSpeed.toFixed(2)}x (Interval factor: ${interval})`);
                        });
                        break;
                    case 'delay':
                        const delayTime = calculateDelayTime(effectParams.noteValue, newSong.bpm);
                        channel.metadata.delay = { time: delayTime, repeats: effectParams.maxDelayRepeats };
                        console.log(`[effectsDebug] Applied delay to channel ${channel.id} with time ${delayTime}ms and repeats ${effectParams.maxDelayRepeats}`);
                        break;
                    case 'reverse':
                        channel.metadata.requiresReversal = true;
                        console.log(`[effectsDebug] Reversed channel ${channel.id}`);
                        break;
                    case 'volumeChange':
                        const [minV, maxV] = effectParams.range;
                        const volumeMultiplier = Math.random() * (maxV - minV) + minV;
                        const originalVolume = channel.metadata.volume || 1;
                        channel.metadata.volume = originalVolume * volumeMultiplier;
                        console.log(`[effectsDebug] Changed volume of channel ${channel.id} from ${originalVolume.toFixed(2)} to ${channel.metadata.volume.toFixed(2)}`);
                        break;
                    case 'pan':
                        const panPosition = effectParams.positions[Math.floor(Math.random() * effectParams.positions.length)];
                        channel.metadata.pan = panPosition;
                        console.log(`[effectsDebug] Applied pan of ${panPosition} to channel ${channel.id}`);
                        break;
                    case 'reverb':
                        const decayTime = randomInRange(effectParams.decayTimeRange);
                        const mix = randomInRange(effectParams.mixRange);
                        channel.metadata.reverb = { decayTime, mix };
                        console.log(`[effectsDebug] Applied reverb to channel ${channel.id} with decay time ${decayTime.toFixed(2)}s and mix ${mix.toFixed(2)}`);
                        break;
                    case 'filter':
                        const filterType = effectParams.types[Math.floor(Math.random() * effectParams.types.length)];
                        const cutoffFrequency = randomInRange(effectParams.frequencyRange);
                        const Q = randomInRange(effectParams.QRange);
                        channel.metadata.filter = { type: filterType, frequency: cutoffFrequency, Q };
                        console.log(`[effectsDebug] Applied ${filterType} filter to channel ${channel.id} with cutoff frequency ${cutoffFrequency.toFixed(2)}Hz and Q factor ${Q.toFixed(2)}`);
                        break;
                    case 'tremolo':
                        const rate = randomInRange(effectParams.rateRange);
                        const depth = randomInRange(effectParams.depthRange);
                        channel.metadata.tremolo = { rate, depth };
                        console.log(`[effectsDebug] Applied tremolo to channel ${channel.id} with rate ${rate.toFixed(2)}Hz and depth ${depth.toFixed(2)}`);
                        break;
                    case 'distortion':
                        const amount = randomInRange(effectParams.amountRange);
                        channel.metadata.distortion = { amount };
                        console.log(`[effectsDebug] Applied distortion to channel ${channel.id} with amount ${amount.toFixed(2)}`);
                        break;
                    case 'bitcrusher':
                        const bitDepth = Math.floor(randomInRange(effectParams.bitDepthRange));
                        const sampleRate = randomInRange(effectParams.sampleRateRange);
                        channel.metadata.bitcrusher = { bitDepth, sampleRate };
                        console.log(`[effectsDebug] Applied bitcrusher to channel ${channel.id} with bit depth ${bitDepth} and sample rate ${sampleRate.toFixed(0)}Hz`);
                        break;
                    default:
                        console.warn(`[effectsDebug] Unknown effect type: ${effectType}`);
                }
            };

            /**
             * Generates a random number within a specified range.
             * @param {Array} range - The range [min, max].
             * @returns {number} - The generated random number.
             */
            const randomInRange = ([min, max]) => Math.random() * (max - min) + min;

            /**
             * Calculates delay time based on BPM and note value.
             * @param {string} noteValue - The note value ('quarter', 'eighth', 'sixteenth').
             * @param {number} bpm - Beats per minute.
             * @returns {number} - Delay time in milliseconds.
             */
            const calculateDelayTime = (noteValue, bpm) => {
                const beatDuration = 60000 / bpm; // Duration of one beat in ms
                const delayMap = {
                    'quarter': beatDuration,
                    'eighth': beatDuration / 2,
                    'sixteenth': beatDuration / 4
                };
                return delayMap[noteValue] || beatDuration;
            };

            /**
             * Applies enabled effects to the channel based on current sequence and BPM.
             * Includes checks to prevent overdriving and infinite loops.
             */
            const applyEffects = (channel, index, newSong, currentSequence, bpm, effectsContext) => {
                Object.keys(effectsConfig).forEach(effectType => {
                    const params = getEffectParams(effectType, currentSequence);
                    if (params) applyEffect(effectType, channel, params, newSong, index, effectsContext);
                });

                // Adjust overall volume if cumulative gain exceeds threshold
                if (effectsContext.totalGain > effectsContext.maxTotalGain) {
                    const reductionFactor = effectsContext.maxTotalGain / effectsContext.totalGain;
                    channel.metadata.volume = (channel.metadata.volume || 1) * reductionFactor;
                    console.log(`[effectsDebug] Adjusted volume of channel ${channel.id} to prevent overdrive.`);
                }

                // Update total gain
                effectsContext.totalGain += channel.metadata.volume || 1;
            };

            try {
                const validSongDataUrls = songDataUrls.filter(url => url.trim() && !url.trim().startsWith("//"));
                console.log(`[Initialization] Valid song data URLs count: ${validSongDataUrls.length}`);

                if (validSongDataUrls.length) {
                    // Load Pako library
                    await (async () => {
                        try {
                            const response = await fetch("/content/2109694f44c973892fb8152cf5c68607fb19288c045af1abc1716c1c3b4d69e6i0");
                            const textContent = await response.text();
                            const scriptElement = new DOMParser().parseFromString(textContent, "text/html").querySelector("script");

                            if (!scriptElement || !scriptElement.textContent.includes("pako")) {
                                throw new Error("Pako library not found.");
                            }

                            const scriptTag = document.createElement("script");
                            scriptTag.textContent = scriptElement.textContent;
                            document.head.appendChild(scriptTag);
                            console.log("[Initialization] Pako library loaded successfully.");
                        } catch (error) {
                            console.error("[Initialization] Error loading Pako:", error);
                        }
                    })();

                    // Fetch and process song data from all URLs
                    const songDataArray = await (async (urls) => {
                        const dataArray = await Promise.all(
                            urls.map((url, index) =>
                                fetchAndProcessSongData(url)
                                    .then(data => ({ data, index }))
                                    .catch(error => {
                                        console.error(`[Initialization] Failed ${url}:`, error);
                                        return null;
                                    })
                            )
                        );
                        const validDataArray = dataArray.filter(Boolean);
                        if (!validDataArray.length) throw new Error("[Initialization] No valid data.");
                        return validDataArray;
                    })(validSongDataUrls);

                    // Process the song data into 'originalSongs'
                    const originalSongs = songDataArray
                        .sort((a, b) => a.index - b.index)
                        .map(({ data, index }) => {
                            const {
                                projectName = `Song_${index + 1}`, // Ensuring original song name
                                artistName = "Unknown Artist",
                                projectBPM = 120, // Ensuring original BPM
                                projectSequences = {},
                                channelURLs = [],
                                channelVolume = [],
                                channelPlaybackSpeed = [],
                                trimSettings = {}
                            } = data;

                            const channels = channelIds.map((id, idx) => {
                                const channelSequence = Object.entries(projectSequences).reduce((acc, [sequenceName, sequenceData]) => {
                                    const channelData = sequenceData[`ch${idx}`];
                                    if (channelData) {
                                        acc.push({ sequenceName, steps: channelData.steps });
                                    }
                                    return acc;
                                }, []);

                                const metadata = {
                                    volume: channelVolume[idx] ?? 1,
                                    playbackSpeed: channelPlaybackSpeed[idx] ?? 1,
                                    trimStartTime_Percentage: trimSettings[idx]?.start || 0,
                                    trimEndTime_Percentage: trimSettings[idx]?.end || 100,
                                    requiresReversal: channelSequence.some(seq =>
                                        seq.steps.some(step => typeof step === "object" && step.reverse)
                                    ),
                                    channelSequence,
                                    originalBPM: projectBPM
                                };

                                const sampleId = channelURLs[idx];
                                if (loopSampleIds.has(sampleId)) {
                                    metadata.isLoop = true;
                                    console.log(`[effectsDebug] ID ${sampleId} is identified as a loop and has been included in song ${`Song ${index + 1}: ${projectName}`}`);
                                }

                                return {
                                    id, // Channel ID (A-P)
                                    url: sampleId || "URL_not_found",
                                    metadata
                                };
                            });

                            const songId = `Song ${index + 1}: ${projectName}`;
                            const song = {
                                id: songId, // Including original song name in ID
                                artist: artistName,
                                bpm: projectBPM, // Including original BPM
                                totalSequences: Object.keys(projectSequences).length,
                                totalChannels: channels.length,
                                channels,
                                projectSequences
                            };

                            // **Log Each Original Song's Details Immediately After Processing**
                            console.log(`[Original Song Processed] ${song.id}`);
                            console.log(`Artist: ${song.artist}`);
                            console.log(`BPM: ${song.bpm}`);
                            console.log(`Total Sequences: ${song.totalSequences}`);
                            console.log(`Total Channels: ${song.totalChannels}`);
                            console.log("Channels and Metadata:");
                            song.channels.forEach(channel => {
                                console.log(`  Channel ID: ${channel.id}`);
                                console.log(`    URL: ${channel.url}`);
                                console.log(`    Metadata:`, channel.metadata);
                            });
                            console.log("---------------------------------------------------");

                            return song;
                        });

                    // Collect all channels from original songs
                    const allChannels = originalSongs.flatMap(song => song.channels);

                    /**
                     * Shuffles an array in place.
                     * @param {Array} array - The array to shuffle.
                     * @returns {Array} - The shuffled array.
                     */
                    const shuffle = (array) => array.sort(() => 0.5 - Math.random());

              
                    /**
                     * Generates random mixes with dynamic BPM selection and custom rules for specific songs.
                     * Includes checks to prevent overdriving and infinite loops.
                     * @param {number} numMixes - The number of mixes to generate.
                     * @returns {Array} - The array of generated song objects.
                     */
                    const generateRandomMixes = (numMixes) => {
                        const newSongs = [];
                        const bpmOptions = [60, 120, 140, 160, 180, 240];
                        const specialSongIds = [
                            "/content/5ee46b8f645a65b0ec8ae749a28f88e364347f89137bb79986355bf5fb94cbebi0", // Fiat Money
                            "/content/c41de57f1e062a440a9fc96d54baaccd7ec40049f48e9f3880559afc60b1b09ai0"  // Did You Know
                        ];

                        for (let songIndex = 0; songIndex < numMixes; songIndex++) {
                            const selectedBPM = bpmOptions[Math.floor(Math.random() * bpmOptions.length)];
                            const randomChannels = getRandomSubset(allChannels, 28);

                            const activationPoints = [
                                { startSeq: 1, count: 16 },   // Channels 1-16 active from sequence 1
                                { startSeq: 5, count: 4 },   // Channels 17-20 activate at sequence 5
                                { startSeq: 17, count: 4 },  // Channels 21-24 activate at sequence 17
                                { startSeq: 25, count: 4 }   // Channels 25-28 activate at sequence 25
                            ];

                            const channelsWithActivation = activationPoints.flatMap(point => {
                                return getRandomSubset(randomChannels.slice(), point.count).map(channel => ({
                                    channel: { ...channel },
                                    activationSeq: point.startSeq
                                }));
                            }).slice(0, 28); // Ensure maximum of 28 channels

                            const sequenceSet = new Set();
                            channelsWithActivation.forEach(({ channel }) => {
                                channel.metadata.channelSequence?.forEach(seqData => sequenceSet.add(seqData.sequenceName));
                            });

                            const sequences = Array.from(sequenceSet).sort((a, b) => parseInt(a.replace('Sequence', ''), 10) - parseInt(b.replace('Sequence', ''), 10));

                            const newSong = {
                                id: `Generated Song ${songIndex + 1}`,
                                artist: `Generated Artist ${songIndex + 1}`,
                                bpm: selectedBPM,
                                totalSequences: sequences.length,
                                totalChannels: channelsWithActivation.length,
                                channels: [],
                                projectSequences: Object.fromEntries(sequences.map(seq => [seq, {}]))
                            };

                            const effectsContext = {
                                harmonyChannelsAdded: 0,
                                maxHarmonyChannels: effectsConfig.harmonize.maxHarmonyChannels || 2,
                                totalGain: 0,
                                maxTotalGain: 10 // Arbitrary threshold for total gain
                            };

                            channelsWithActivation.forEach(({ channel, activationSeq }, index) => {
                                const chId = `ch${index}`;
                                const newChannel = {
                                    id: chId,
                                    url: channel.url,
                                    metadata: {
                                        ...channel.metadata,
                                        originalBPM: newSong.bpm,
                                        activationSeq
                                    }
                                };

                                // Apply Effects
                                applyEffects(newChannel, index, newSong, activationSeq, newSong.bpm, effectsContext);

                                if (newChannel.metadata.isLoop) {
                                    console.log(`[effectsDebug] ID ${newChannel.url} is identified as a loop and has been included in remix ${newSong.id}`);
                                }

                                newSong.channels.push(newChannel);

                                // Assign sequences
                                channel.metadata.channelSequence?.forEach(({ sequenceName, steps }) => {
                                    if (newSong.projectSequences[sequenceName]) {
                                        newSong.projectSequences[sequenceName][chId] = { steps };
                                    }
                                });

                                // Handle special channels
                                if (specialSongIds.includes(channel.url)) {
                                    const activationRule = getRandomActivationRule();
                                    newChannel.metadata.activationRule = activationRule;
                                    newChannel.metadata.customActivationEvents = generateActivationEvents(activationRule, newSong.totalSequences);
                                }
                            });

                            newSongs.push(newSong);

                            // **Logging the Remix Data**
                            console.log(`[Remix Generated] ${newSong.id}`);
                            console.log(`Artist: ${newSong.artist}`);
                            console.log(`BPM: ${newSong.bpm}`);
                            console.log(`Total Sequences: ${newSong.totalSequences}`);
                            console.log(`Total Channels: ${newSong.totalChannels}`);
                            console.log("Channels and Metadata:");
                            newSong.channels.forEach(channel => {
                                console.log(`  Channel ID: ${channel.id}`);
                                console.log(`    URL: ${channel.url}`);
                                console.log(`    Metadata:`, channel.metadata);
                            });
                            console.log("---------------------------------------------------");
                        }

                        return newSongs;
                    };

                    /**
                     * Determines if a channel is from a special song.
                     * @param {object} channel - The channel object.
                     * @returns {boolean} - True if from a special song, else false.
                     */
                    const isChannelFromSpecialSong = (channel) => {
                        const specialSongIds = [
                            "/content/5ee46b8f645a65b0ec8ae749a28f88e364347f89137bb79986355bf5fb94cbebi0", // Fiat Money
                            "/content/c41de57f1e062a440a9fc96d54baaccd7ec40049f48e9f3880559afc60b1b09ai0"  // Did You Know
                        ];
                        return specialSongIds.includes(channel.url);
                    };

                    /**
                     * Selects a random activation rule.
                     * @returns {number} - The selected rule number.
                     */
                    const getRandomActivationRule = () => {
                        const rules = [1, 2, 3, 4];
                        return rules[Math.floor(Math.random() * rules.length)];
                    };

                    /**
                     * Generates activation events based on the selected rule.
                     * @param {number} rule - The activation rule number.
                     * @param {number} totalSequences - Total number of sequences in the song.
                     * @returns {Array} - Array of activation events.
                     */
                    const generateActivationEvents = (rule, totalSequences) => {
                        const events = [];
                        const addEvent = (type, seq) => {
                            if (seq <= totalSequences) events.push({ type, seq });
                        };

                        switch (rule) {
                            case 1:
                                addEvent('activate', 1);
                                addEvent('deactivate', 3);
                                break;
                            case 2:
                                for (let seq = 1; seq <= totalSequences; seq += 4) {
                                    addEvent('activate', seq);
                                    addEvent('deactivate', seq + 2);
                                }
                                break;
                            case 3:
                                addEvent('activate', 9);
                                for (let seq = 9; seq <= 20; seq += 4) {
                                    addEvent('activate', seq);
                                    addEvent('deactivate', seq + 2);
                                }
                                addEvent('activate', 41);
                                break;
                            case 4:
                                const possibleStarts = [1, 5, 9, 16, 21, 25, 29, 33, 37, 41, 45];
                                const selectedStarts = getRandomSubset(possibleStarts, Math.floor(Math.random() * 3) + 1);
                                selectedStarts.forEach(startSeq => {
                                    addEvent('activate', startSeq);
                                    addEvent('deactivate', startSeq + 2);
                                });
                                break;
                            default:
                                addEvent('activate', 1);
                                addEvent('deactivate', 3);
                        }
                        return events;
                    };

                    /**
                     * Generates a random subset from an array.
                     * @param {Array} array - The array to select from.
                     * @param {number} size - Number of elements to select.
                     * @returns {Array} - The selected subset.
                     */
                    const getRandomSubset = (array, size) => shuffle(array).slice(0, size);

                    // **Generate initial 100 mixes**
                    const generatedSongs = generateRandomMixes(100);

                    // **Set globalData.songsArray to generated songs only**
                    globalData.songsArray = generatedSongs;

                    // Set up a function to check and generate more mixes
                    globalData.checkAndGenerateMoreMixes = function() {
                        const songsLeft = globalData.songsArray.length - globalData.currentSongIndex - 1;
                        if (songsLeft <= 5) {
                            const moreMixes = generateRandomMixes(10);
                            globalData.songsArray.push(...moreMixes);
                            console.log("[Dynamic Mix Generation] Added 10 more mixes.");
                        }
                    };

                    // Prepare initial sample order for the first generated song
                    if (globalData.songsArray.length > 0) {
                        globalData.initialSampleOrder = prepareInitialSampleOrder(globalData.songsArray[0]);
                    }

                    // Set artwork image if applicable
                    if (globalData.isArtworkCover && artworkUrl.length) {
                        setArtworkImage(artworkUrl[0]);
                    }

                    // Update flags
                    globalData.isSingleSong = globalData.songsArray.length === 1;
                    globalData.isMultipleSongs = globalData.songsArray.length > 1;

                    // Dispatch event indicating data loading is complete
                    document.dispatchEvent(
                        new CustomEvent("dataLoadingComplete", {
                            detail: {
                                success: true,
                                totalSongs: globalData.songsArray.length,
                                songs: globalData.songsArray.map(({ id, totalSequences }) => ({ id, totalSequences }))
                            }
                        })
                    );
                    console.log("[Initialization] Data loading complete event dispatched.");

                    // **Log the Original Songs Array with Names and BPMs**
                    console.log("Original Songs Data:");
                    originalSongs.forEach(song => {
                        console.log(`ID: ${song.id}`);
                        console.log(`Artist: ${song.artist}`);
                        console.log(`BPM: ${song.bpm}`);
                        console.log(`Total Sequences: ${song.totalSequences}`);
                        console.log(`Total Channels: ${song.totalChannels}`);
                        console.log("Channels and Metadata:");
                        song.channels.forEach(channel => {
                            console.log(`  Channel ID: ${channel.id}`);
                            console.log(`    URL: ${channel.url}`);
                            console.log(`    Metadata:`, channel.metadata);
                        });
                        console.log("---------------------------------------------------");
                    });

                } else {
                    console.log("[Initialization] No valid song data URLs to process.");
                }
            } catch (error) {
                console.error("[Initialization] Initialization error:", error);
            }
        })();
    </script>

    <!-- Load Player Scripts AFTER data loading is complete -->
    <script>
        // Listen for the 'dataLoadingComplete' event before loading player scripts
        document.addEventListener("dataLoadingComplete", (event) => {
            console.log("[Script Loader] dataLoadingComplete event received. Loading player scripts...");

            const remainingScriptUrls = [
                "/content/5c03e882ab5a531271b2e93a80d8a9d72cb533c580bec1567020f5cd61595560i0", // projectArtistMapping
                "/content/016f153f011f6a23b8fccd0efcc7945913ee97f241c7a2df7c71c4fa7c9a5fb3i0", // unifiedMetadataManagement
                "/content/ef622be8aeeac45fdbdc291dd0db739d24c2c667c5c3ce7662f2b8c7f2c3de58i0", // GainNodeHelpers
                "/content/f4cc99813b43f71b3e781d3c99f24a6a7a5b1004ea0efce3b225011e347b8df0i0", // audioProcessingAndManagement
                "/content/7b305327f2951d219532ef0cb46b2039b23f2cfd0d8d0e827f3fe1b2b754b5a9i0", // DynamicGainBalancing
                "/content/7f1e3b45f22f943ddfb90a0b9811671185f720bb303f002215b9e0fd932f299ci0", // playbackEngine
                "/content/8b5b09cfedbc0c6a187816181f8d33f90c5bbd15fc10af47008176effb866a47i0"  // keyboardControlsAndEventListeners
            ];

            const loadScriptsSequentially = async (urls) => {
                for (const src of urls) {
                    try {
                        await new Promise((resolve, reject) => {
                            const script = document.createElement("script");
                            script.src = src;
                            script.async = false; // Ensure scripts are executed in order
                            script.onload = () => {
                                console.log(`[Script Loader] Loaded script: ${src}`);
                                resolve();
                            };
                            script.onerror = (e) => {
                                console.error(`[Script Loader] Error loading script: ${src}`, e);
                                resolve(); // Continue loading remaining scripts even if one fails
                            };
                            document.body.appendChild(script);
                        });
                    } catch (error) {
                        console.error(`[Script Loader] Failed to load script: ${src}`, error);
                    }
                }
                console.log("[Script Loader] All player scripts loaded.");
            };

            loadScriptsSequentially([...remainingScriptUrls]);
        });
    </script>

    <script>
        // Playback Controls

        globalData.togglePlayback = function() {
            if (!globalData.audioContext) {
                globalData.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            if (globalData.audioContext.state === 'suspended') {
                globalData.audioContext.resume().then(proceedWithPlayback);
            } else {
                proceedWithPlayback();
            }
        };

        const proceedWithPlayback = () => {
            globalData.isPlaying ? stopPlayback() : startPlayback();
        };

        const startPlayback = () => {
            if (globalData.source) globalData.source.stop(); // Stop any existing playback

            globalData.source = globalData.audioContext.createBufferSource();
            globalData.source.buffer = globalData.currentBuffer; // Assuming buffer is loaded
            globalData.source.connect(globalData.audioContext.destination);
            globalData.source.start(0); // Start playback from the beginning
            globalData.isPlaying = true;
            console.log("Playback started");
        };

        const stopPlayback = () => {
            if (globalData.source) {
                globalData.source.stop(); // Stop playback
                globalData.isPlaying = false;
                console.log("Playback stopped");
            }
        };
    </script>
</body>
</html>
