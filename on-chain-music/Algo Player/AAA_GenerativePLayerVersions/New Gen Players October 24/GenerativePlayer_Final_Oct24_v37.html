<!--Tracks are not progressing through seeds during normal playback -->
<!-- Could do with some more balances to help with repetitive loops -->


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Audionals - Web3 Music Player</title>
    <link rel="stylesheet" href="/content/7a309a161e838ba93740684338b3d97f3c1226c046d8b1137afc2353b4bf16e1i0">

    <style>
        :root {
            --panel-bg-color: #333;
            --panel-text-color: #fff;
            --track-list-panel-bg-color: #444;
            --button-bg-color: #444;
            --button-hover-bg-color: #555;
            --button-active-bg-color: #777;
            --input-bg-color: #555;
            --border-radius: 8px;
            --padding: 10px;
            --box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            --transition-duration: 0.3s;
            --text-color: #fff;
            --bpm-bg-color: orange;
            --seed-bg-color: green;
            --font-size: 16px;
        }
        /* Common Panel Styles */
        #seed-management-panel,
        #track-list-panel {
            position: fixed;
            background-color: var(--panel-bg-color);
            color: var(--panel-text-color);
            padding: var(--padding);
            border-radius: var(--border-radius);
            z-index: 10000;
            box-shadow: var(--box-shadow);
            transition: all var(--transition-duration) ease;
        }
        /* Specific Panel Positions and Sizes */
        #seed-management-panel {
            top: 10px;
            right: 10px;
            width: 320px;
        }
        #track-list-panel {
            bottom: 10px;
            left: 10px;
            width: 300px;
            background-color: var(--track-list-panel-bg-color);
        }
        .hidden {
            display: none;
        }
        @media (max-width: 600px) {
            #seed-management-panel,
            #track-list-panel {
                width: 90%;
                left: 5%;
                right: 5%;
            }
        }
        /* Canvas Styling */
        #seed-mgmt-canvas {
            width: 100%;
            height: 100px;
            border: 1px solid #555;
            border-radius: 4px;
            background-color: #222;
        }
        /* Previous Seeds Container */
        #previous-seeds-container {
            margin-top: 15px;
        }
        #previous-seeds-container h3,
        #seed-input-section h3 {
            margin-bottom: 5px;
        }
        #previous-seeds-container ul {
            list-style: none;
            padding: 0;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #555;
            border-radius: 4px;
            background-color: #444;
        }
        #previous-seeds-container li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            border-bottom: 1px solid #555;
        }
        #previous-seeds-container li:last-child {
            border-bottom: none;
        }
        #previous-seeds-container button {
            background-color: #666;
            color: #fff;
            border: none;
            border-radius: 4px;
            padding: 2px 6px;
            cursor: pointer;
            transition: background-color var(--transition-duration) ease;
            margin-left: 10px;
        }
        #previous-seeds-container button:hover {
            background-color: #888;
        }
        /* Seed Input Section */
        #seed-input-section {
            margin-top: 15px;
        }
        #seed-input {
            width: 100%;
            padding: 8px;
            margin-bottom: 5px;
            border: 1px solid #555;
            border-radius: 4px;
            background-color: var(--input-bg-color);
            color: var(--panel-text-color);
            transition: border 0.2s ease;
        }
        #seed-input:focus {
            border: 2px solid #00f;
            outline: none;
        }
        /* Clear Seeds Section */
        #clear-seeds-section {
            margin-top: 15px;
            text-align: center;
        }
        #clear-seeds-button {
            width: 100%;
            padding: 8px;
            background-color: #b22222;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color var(--transition-duration) ease;
            margin-top: 5px;
        }
        #clear-seeds-button:hover {
            background-color: #ff6347;
        }
        /* Button Styles */
        button {
            background-color: var(--button-bg-color);
            color: var(--panel-text-color);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color var(--transition-duration) ease;
            padding: 10px 15px;
            margin: 5px;
        }
        button:hover {
            background-color: var(--button-hover-bg-color);
        }
        button:active {
            background-color: var(--button-active-bg-color);
        }
        button:focus {
            outline: 2px solid #00f;
        }
        /* Canvas and Now Playing */
        #loadingSpinner {
            z-index: 1000;
        }
        #artworkCover img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
        }
        #nowPlayingContainer {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(20, 20, 20, 0.95);
            color: #fff;
            padding: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.5);
            z-index: 10000;
            text-align: center;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            transition: background-color 0.3s ease;
        }
        #nowPlayingContainer:hover {
            background-color: rgba(20, 20, 20, 1);
        }
        #nowPlayingText {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 5px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        #nowPlayingContainer .current-seed {
            display: block;
            font-size: 0.9em;
            color: #ccc;
            margin-bottom: 5px;
        }
        #nowPlayingContainer .title {
            display: block;
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
        }
    </style>
</head>
<body>

    <HTMLsection>
        <span class="songTitle">The Infinite Ordinal Remix</span>
        <h1>Audionals</h1>
        
        <!-- Seed Management Panel -->
        <div id="seed-management-panel" class="hidden" role="dialog" aria-labelledby="seed-panel-title" aria-hidden="true">
            <h2 id="seed-panel-title">Seed Management</h2>
            
            <!-- Seed and BPM Display -->
            <canvas id="seed-mgmt-canvas" width="300" height="100" aria-label="Seed and BPM Information"></canvas>
            
            <!-- Previous Seeds List -->
            <div id="previous-seeds-container">
                <h3>Previous Seeds</h3>
                <ul></ul>
            </div>
            
            <!-- Seed Input Section -->
            <div id="seed-input-section">
                <h3>Load a Specific Seed</h3>
                <input type="text" id="seed-input" placeholder="Enter 16-digit Seed" aria-label="Enter Seed">
                <button id="load-seed-button" aria-label="Load Seed">Load Seed</button>
            </div>
            
            <!-- BPM Selection Section -->
            <div class="bpm-selection">
                <h3>Select BPM(s) to Filter</h3>
                <div class="bpm-options, hidden">
                    <div class="bpm-option">
                        <input type="checkbox" id="bpm-60" value="60" checked>
                        <label for="bpm-60">60 BPM</label>
                    </div>
                    <div class="bpm-option">
                        <input type="checkbox" id="bpm-120" value="120" checked>
                        <label for="bpm-120">120 BPM</label>
                    </div>
                    <div class="bpm-option">
                        <input type="checkbox" id="bpm-140" value="140" checked>
                        <label for="bpm-140">140 BPM</label>
                    </div>
                    <div class="bpm-option">
                        <input type="checkbox" id="bpm-160" value="160" checked>
                        <label for="bpm-160">160 BPM</label>
                    </div>
                    <div class="bpm-option">
                        <input type="checkbox" id="bpm-180" value="180" checked>
                        <label for="bpm-180">180 BPM</label>
                    </div>
                    <div class="bpm-option">
                        <input type="checkbox" id="bpm-240" value="240" checked>
                        <label for="bpm-240">240 BPM</label>
                    </div>
                </div>
            </div>
            
            <!-- Clear Seeds Button -->
            <div id="clear-seeds-section">
                <button id="clear-seeds-button" aria-label="Clear Previous Seeds">Clear Previous Seeds</button>
            </div>
            
            <!-- Generate Mixes Button -->
            <div id="generate-mixes-section" style="margin-top: 15px; text-align: center;">
                <button id="generate-mixes-button" aria-label="Generate Mixes">Generate Mixes</button>
            </div>
        </div>
        
        <div id="loadingSpinner"></div>
        <div id="artworkCover"><img id="artworkImage" src="" alt="Artwork Cover"></div>
        <div id="trackListingPanel">
            <h2>Track Listings:</h2>
            <div id="metadataContent"></div>
        </div>
        
        <!-- Updated Now Playing Container -->
        <div id="nowPlayingContainer">
            <span class="current-seed">Seed: N/A</span>
            <span class="title">The Infinite Ordinal Remix</span>
            <span class="artistName">melophonic</span>
            <span class="songBPM">BPM: N/A</span> <!-- New BPM Display -->
            <span class="totalSequences">Sequences: N/A</span> <!-- New Sequences Display -->
            <span class="timeLeft">Time Left: N/A</span> <!-- New Countdown Display -->
            <!-- Hidden Elements for Playback Engine -->
            <span class="songTitle" style="display: none;"></span>
        </div>
        
        <div id="buttonContainer">
            <button id="playButton" onclick="globalData.togglePlayback()" aria-label="Play or Stop Music">Play / Stop</button>
            <button id="prevButton" onclick="handlePreviousSong()" aria-label="Previous Song">Previous</button>
            <button id="nextButton" onclick="handleNextSong()" aria-label="Next Song">Next</button>
            <button id="toggle-track-panel-button" onclick="toggleTrackListAndPopulate()" class = "hidden" aria-label="Toggle Track List Panel">Track List</button>
            <button id="toggle-seed-panel-button" onclick="togglePanel('seed-management-panel')" aria-label="Toggle Seed Management Panel">Seed Panel</button>
        </div>
        
        <!-- Track List Panel -->
        <div id="track-list-panel" class="hidden" role="dialog" aria-labelledby="track-list-title" aria-hidden="true">
            <h2 id="track-list-title" class="hidden">Track List</h2>
            <div id="track-list-container"></div>
        </div>
    </HTMLsection>

    <!-- Songs and Artwork -->
    <script src="/content/616ef4c1bef02cb6c0f785ef76b98df4e379e8f01e2b31e2ae9e68449485f2bci0"></script> 
    <!-- Global Data -->
    <script src="/content/e8496fa0bcb3cad6bc173cd1ef2564b9548b43b306634bdafce47083efd7619ai0"></script> 

    

<!-- Seed Management -->
<script>
    // Notes //
    /* 
#region Seed Management
**Purpose:**
Handles the generation, validation, storage, and display of unique seeds used within the application. Manages seed-related UI interactions and ensures seeds are persistently stored for user reference.

**Key Functionalities:**
- **Seed Generation & Validation:**
  - Generates a 16-digit numeric seed ensuring it doesn't exceed `Number.MAX_SAFE_INTEGER`.
  - Validates incoming seeds from URL parameters, generating a new one if invalid.
  
- **BPM Mapping:**
  - Converts the seed into a Beats Per Minute (BPM) value using a hashing mechanism to select from predefined BPM options.
  
- **UI Management:**
  - Toggles visibility of UI panels (e.g., track list).
  - Populates track lists dynamically based on global data.
  
- **Seed Persistence:**
  - Saves unique seeds to `localStorage` to maintain a history of previously used seeds.
  - Displays saved seeds with options to copy them to the clipboard.
  - Provides functionality to clear the seed history upon user confirmation.
  
- **Canvas Display:**
  - Visually represents the current seed and BPM on a canvas element for enhanced user clarity.
  
- **Event Listeners:**
  - Initializes seed display on DOM content loaded.
  - Handles user interactions such as loading a new seed or clearing seed history.
  - Ensures seamless user experience by managing input events and updating the UI accordingly.
  
**Overall Functionality:**
This script ensures robust management of seeds within the application, providing users with the ability to generate, view, and manage seeds effectively. It enhances user experience by maintaining a history of interactions and offering intuitive UI controls for seed-related operations.
#endregion
*/
        (() => {
            const log = (msg) => console.log(`[${new Date().toISOString()}] ${msg}`);
            const toggleClass = 'hidden';

            window.togglePanel = (panelId) => {
                const panel = document.getElementById(panelId);
                if (panel) {
                    panel.classList.toggle(toggleClass);
                    const isHidden = panel.classList.contains(toggleClass);
                    panel.setAttribute('aria-hidden', isHidden);
                } else {
                    console.error(`${panelId.replace(/-/g, ' ')} not found.`);
                }
            };

            window.populateTrackList = () => {
                const container = document.getElementById('track-list-container');
                container.innerHTML = '';
                const songs = globalData?.songsArray;
                if (songs?.length) {
                    songs.forEach(({ id, artist }) => {
                        const trackItem = document.createElement('div');
                        trackItem.className = 'track-item';
                        trackItem.innerHTML = `<div class="track-name">${id}</div><div class="track-artist">${artist}</div>`;
                        container.appendChild(trackItem);
                    });
                } else {
                    container.textContent = "No tracks available.";
                }
            };

            window.toggleTrackListAndPopulate = () => {
                togglePanel('track-list-panel');
                const panel = document.getElementById('track-list-panel');
                if (panel && !panel.classList.contains(toggleClass)) populateTrackList();
            };

            const generateSeed = () => {
                let seed = '';
                while (true) {
                    seed = Array.from({ length: 16 }, () => Math.floor(Math.random() * 10)).join('');
                    if (BigInt(seed) <= BigInt(Number.MAX_SAFE_INTEGER)) break;
                }
                return seed;
            };

            const mapSeedToBpm = (seed) => {
                const hash = seed.split("").reduce((acc, char) => {
                    const digit = parseInt(char, 10);
                    return (10 * acc + (isNaN(digit) ? 0 : digit)) % 1000000007;
                }, 0);
                const bpm = bpmOptions[hash % bpmOptions.length];
                log(`Seed: ${seed}, Hash: ${hash}, Selected BPM: ${bpm}`);
                return bpm;
            };

            const getQueryParam = (param) => new URLSearchParams(window.location.search).get(param);
            const fixedProductionSeed = "";
            let initialSeed = getQueryParam('seed') || generateSeed();
                if (!/^\d{16}$/.test(initialSeed) || BigInt(initialSeed) > BigInt(Number.MAX_SAFE_INTEGER)) {
                    log(`Invalid seed provided: "${initialSeed}". Generating a new seed.`);
                    initialSeed = generateSeed();
                }
                window.seed = initialSeed;
                log(`Using seed: ${window.seed}`);

                // Remove the seed parameter from the URL to prevent reuse on reloads
                if (getQueryParam('seed')) {
                    const url = new URL(window.location);
                    url.searchParams.delete('seed');
                    history.replaceState(null, '', url.toString());
                }

            const prngSeedNumber = BigInt(window.seed);
            log(`Converted seed to BigInt: ${prngSeedNumber}`);

            const bpmOptions = [80, 100, 120, 140, 160, 180, 240];
            const bpm = mapSeedToBpm(window.seed);

            const loadPreviousSeeds = () => {
                const seeds = JSON.parse(localStorage.getItem("previousSeeds")) || [];
                displayPreviousSeeds(seeds);
                return seeds;
            };

            const saveSeed = (seed) => {
                const seeds = loadPreviousSeeds();
                if (!seeds.includes(seed)) {
                    seeds.push(seed);
                    localStorage.setItem("previousSeeds", JSON.stringify(seeds));
                    displayPreviousSeeds(seeds);
                    log(`Seed saved: ${seed}`);
                }
            };

            const displayPreviousSeeds = (seeds) => {
                const container = document.getElementById("previous-seeds-container");
                if (!container) return;
                const ul = container.querySelector('ul');
                if (!ul) return;
                ul.innerHTML = seeds.length ? seeds.map(seed => `
                    <li>
                        <span>${seed}</span>
                        <button onclick="copyToClipboard('${seed}')">Copy</button>
                    </li>`).join('') : "<li>No previous seeds.</li>";
            };

            window.copyToClipboard = (seed) => {
                navigator.clipboard.writeText(seed)
                    .then(() => alert(`Seed copied to clipboard: ${seed}`))
                    .catch(err => console.error("Could not copy text:", err));
            };

            const clearPreviousSeeds = () => {
                if (confirm("Are you sure you want to clear all previous seeds?")) {
                    localStorage.removeItem("previousSeeds");
                    displayPreviousSeeds([]);
                    log("All previous seeds have been cleared.");
                }
            };

            const displaySeedAndBPM = (seed, bpm, title = "The Infinite Ordinal Remix") => {
                const canvas = document.getElementById("seed-mgmt-canvas");
                if (!canvas) return;
                const ctx = canvas.getContext("2d");
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--seed-bg-color') || 'green';
                ctx.fillRect(0, 0, canvas.width, canvas.height / 2);
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bpm-bg-color') || 'orange';
                ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-color') || 'white';
                ctx.font = `${getComputedStyle(document.documentElement).getPropertyValue('--font-size') || '16px'} Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(`Seed: ${seed}`, canvas.width / 2, canvas.height / 4);
                ctx.fillText(`BPM: ${bpm}`, canvas.width / 2, (3 * canvas.height) / 4);
                saveSeed(seed);
                const seedDisplay = document.querySelector('#nowPlayingContainer .current-seed');
                if (seedDisplay) {
                    seedDisplay.textContent = `Seed: ${seed}`;
                    log(`Updated current seed display: ${seed}`);
                }
                const titleDisplay = document.querySelector('#nowPlayingContainer .title');
                if (titleDisplay && title) {
                    titleDisplay.textContent = title;
                    log(`Updated current song title: ${title}`);
                }
            };

            window.displaySeedAndBPM = displaySeedAndBPM;

            const validateSeedInput = (seed) => {
                if (!/^\d{16}$/.test(seed)) {
                    alert("Seed must be a 16-digit numeric string.");
                    return false;
                }
                if (BigInt(seed) > BigInt(Number.MAX_SAFE_INTEGER)) {
                    alert(`Seed must be a number up to ${Number.MAX_SAFE_INTEGER}.`);
                    return false;
                }
                return true;
            };

            const setupEventListeners = () => {
                document.addEventListener("DOMContentLoaded", () => {
                    // Ensure that songsArray has at least one song
                    if (globalData.songsArray.length > 0) {
                        const firstSong = globalData.songsArray[0];
                        displaySeedAndBPM(firstSong.seed, firstSong.bpm, firstSong.id);
                        // Set currentSongIndex to 0 to point to the first song
                        globalData.currentSongIndex = 0;
                    } else {
                        console.warn("No song mixes generated.");
                    }
                    loadPreviousSeeds();
                });
                document.getElementById("clear-seeds-button")?.addEventListener("click", clearPreviousSeeds);

                document.getElementById("load-seed-button")?.addEventListener("click", () => {
                    const seedInput = document.getElementById("seed-input").value.trim();
                    if (!seedInput) {
                        alert("Please enter a seed.");
                        return;
                    }
                    if (!validateSeedInput(seedInput)) return;
                    const url = new URL(window.location);
                    url.searchParams.set('seed', seedInput);
                    window.location.href = url.toString();
                });

                const seedInputField = document.getElementById("seed-input");
                if (seedInputField) {
                    seedInputField.addEventListener("keypress", (e) => {
                        if (e.key === "Enter") {
                            e.preventDefault();
                            document.getElementById("load-seed-button").click();
                        }
                    });
                }
            };




            setupEventListeners();
        })();
</script>

<!-- Effects Configuration Script (effects.js) -->
<script>
// Notes //
    /* 
#region Effects Configuration Script (effects.js)
**Purpose:**
Establishes a comprehensive framework for managing and configuring various audio effects within the application. Enables dynamic and randomized application of audio effects based on predefined configurations and probabilities.

**Key Functionalities:**
- **Effects Module Initialization:**
  - Initializes or utilizes an existing `EffectsModule` within the global `window` object to store and manage effects configurations.

- **Effects Configuration:**
  - Defines a variety of audio effects (e.g., pitchShift, harmonize, delay, chorus, leslie, synthBass, synth) with specific properties:
    - **enabled:** Boolean flag to activate or deactivate the effect.
    - **defaultProbability:** Determines the likelihood of the effect being applied.
    - **Parameter Ranges:** Specifies ranges or options for effect-specific parameters (e.g., rate, depth, feedback).

- **Parameter Generation (`getEffectParams`):**
  - Generates random parameters for each effect based on their configurations and a pseudo-random number generator (`prng`).
  - Ensures that effects are applied with varied and dynamic settings each time they are triggered.
  - Handles different parameter requirements for each effect type, allowing for extensibility and customization.

- **Event Dispatching:**
  - Emits an `effectsLoaded` event once the effects configurations are fully set up, signaling other parts of the application that the effects system is ready for use.

- **Extensibility:**
  - Designed to easily incorporate additional effects by adding new configurations and corresponding parameter generation logic.
  - Facilitates scalability, allowing the effects system to grow with application requirements.

**Overall Functionality:**
This script provides a flexible and scalable approach to audio effect management, enabling rich and randomized audio experiences tailored to user interactions or predefined conditions. By centralizing effect configurations and parameter generation, it ensures consistency and ease of maintenance across the application's audio processing components.
#endregion
*/
     (() => {
        window.EffectsModule = window.EffectsModule || {};
        window.EffectsModule.effectsConfig = { 
            pitchShift: { 
                enabled: true, 
                defaultProbability: 1, 
                shifts: [0.25, 0.5, 1, 2, 4]
            },
            harmonize: { 
                enabled: false, 
                defaultProbability: 1, 
                intervals: [1.2599, 2.6],
                maxHarmonyChannels: 1
            },
            delay: {
                enabled: true, 
                defaultProbability: 1, 
                noteValue: 'sixteenth',
                maxDelayRepeats: 16
            },
            reverse: {
                enabled: true, 
                defaultProbability: 1
            },
            pan: {
                enabled: true,
                defaultProbability: 1,
                positions: [-1, 1]
            },
            reverb: {
                enabled: true, 
                defaultProbability: 1, 
                decayTimeRange: [2, 7], 
                mixRange: [0.3, 0.9]
            },
            filter: {
                enabled: true, 
                defaultProbability: 0.7, 
                types: ['lowpass', 'highpass', 'bandpass'], 
                frequencyRange: [300, 8000], 
                QRange: [1, 10]
            },
            tremolo: {
                enabled: true, 
                defaultProbability: 0.6, 
                rateRange: [4, 12],   
                depthRange: [0.6, 1]
            },
            distortion: {
                enabled: true, 
                defaultProbability: 0.5, 
                amountRange: [1, 15]
            },
            bitcrusher: {
                enabled: true, 
                defaultProbability: 0.3, 
                bitDepthRange: [2, 6],    
                sampleRateRange: [8000, 22050]
            },
            // **Chorus Effect**
            chorus: {
                enabled: true,
                defaultProbability: 0.5, // 50% chance to apply chorus
                rateRange: [0.1, 5],       // Hz
                depthRange: [0.1, 1],      // 0 to 1
                feedbackRange: [0, 0.5],   // 0 to 0.5
                mixRange: [0, 1]            // 0 (dry) to 1 (wet)
            },
            // **New Leslie Effect**
            leslie: {
                enabled: true,
                defaultProbability: 0.3, // 30% chance to apply Leslie effect
                speedRange: [0.5, 1.5],    // Rotation speed multiplier based on BPM
                depthRange: [0.5, 1],      // Depth of the effect
                mixRange: [0, 1]            // Wet/Dry mix
            },
            // **New BPM-Linked Delay Effect**
            delayBpmLinked: {
                enabled: true,
                defaultProbability: 0.4, // 40% chance to apply BPM-linked delay
                delayTimes: ['quarter', 'eighth', 'sixteenth'], // Note values
                feedbackRange: [0.3, 0.7],
                mixRange: [0, 1]
            },
            // **New Synth Bass Line Effect**
                synthBass: {
                        enabled: true,
                        defaultProbability: 0.5, // 50% chance to add synth bass
                        waveform: ['sine', 'square', 'triangle'], // Types of waveforms
                        octaveRange: [1, 3],      // Octave shifts
                        volumeRange: [0.5, 1]     // Volume levels
                        },
                        // **New Synth Effect**
                        
                synth: {
                            enabled: true,
                            defaultProbability: 0.5, // 50% chance to add synth note
                            waveforms: ['sine', 'square', 'triangle', 'sawtooth'],
                            attackRange: [10, 500],    // ms
                            releaseRange: [100, 2000], // ms
                            cutoffRange: [200, 2000],  // Hz
                            resonanceRange: [1, 10],
                            volumeRange: [50, 100]     // 0 to 100
                        }
                    };

        window.EffectsModule.getEffectParams = function(effectName, currentSequence, bpm, prng) {
            const effect = this.effectsConfig[effectName];
            if (!effect || !effect.enabled) return null;
            if (prng() < effect.defaultProbability) {
                // Generate random parameters within the specified ranges
                const params = {};
                switch(effectName) {
                    case 'pitchShift':
                        params.shifts = effect.shifts;
                        break;
                    case 'harmonize':
                        params.intervals = effect.intervals;
                        params.maxHarmonyChannels = effect.maxHarmonyChannels;
                        break;
                    case 'delay':
                        params.noteValue = effect.noteValue;
                        params.maxDelayRepeats = effect.maxDelayRepeats;
                        break;
                    case 'chorus':
                        params.rate = prng() * (effect.rateRange[1] - effect.rateRange[0]) + effect.rateRange[0];
                        params.depth = prng() * (effect.depthRange[1] - effect.depthRange[0]) + effect.depthRange[0];
                        params.feedback = prng() * (effect.feedbackRange[1] - effect.feedbackRange[0]) + effect.feedbackRange[0];
                        params.mix = prng() * (effect.mixRange[1] - effect.mixRange[0]) + effect.mixRange[0];
                        break;
                    case 'leslie':
                        params.speed = prng() * (effect.speedRange[1] - effect.speedRange[0]) + effect.speedRange[0];
                        params.depth = prng() * (effect.depthRange[1] - effect.depthRange[0]) + effect.depthRange[0];
                        params.mix = prng() * (effect.mixRange[1] - effect.mixRange[0]) + effect.mixRange[0];
                        break;
                    case 'delayBpmLinked':
                        params.delayTime = effect.delayTimes[Math.floor(prng() * effect.delayTimes.length)];
                        params.feedback = prng() * (effect.feedbackRange[1] - effect.feedbackRange[0]) + effect.feedbackRange[0];
                        params.mix = prng() * (effect.mixRange[1] - effect.mixRange[0]) + effect.mixRange[0];
                        break;
                    case 'synthBass':
                        params.waveform = effect.waveform[Math.floor(prng() * effect.waveform.length)];
                        params.octave = Math.floor(prng() * (effect.octaveRange[1] - effect.octaveRange[0] + 1)) + effect.octaveRange[0];
                        params.volume = prng() * (effect.volumeRange[1] - effect.volumeRange[0]) + effect.volumeRange[0];
                        break;
                    case 'synth':
                        params.waveform = effect.waveforms[Math.floor(prng() * effect.waveforms.length)];
                        params.attack = prng() * (effect.attackRange[1] - effect.attackRange[0]) + effect.attackRange[0];
                        params.release = prng() * (effect.releaseRange[1] - effect.releaseRange[0]) + effect.releaseRange[0];
                        params.cutoff = prng() * (effect.cutoffRange[1] - effect.cutoffRange[0]) + effect.cutoffRange[0];
                        params.resonance = prng() * (effect.resonanceRange[1] - effect.resonanceRange[0]) + effect.resonanceRange[0];
                        params.volume = prng() * (effect.volumeRange[1] - effect.volumeRange[0]) + effect.volumeRange[0];
                        break;
                    // Add cases for other effects as needed
                    default:
                        // For effects without additional parameters
                        break;
                }
                return { ...effect, ...params };
            }
            return null;
        };

        document.dispatchEvent(new Event('effectsLoaded'));
    })();
</script>



<!-- Main Script (main.js) -->
<script>
    (async () => {
        function waitForEffects() {
            return new Promise((resolve) => {
                if (window.EffectsModule && window.EffectsModule.effectsConfig) {
                    resolve();
                } else {
                    document.addEventListener('effectsLoaded', resolve, { once: true });
                }
            });
        }
        await waitForEffects();

        // Function to trigger synth notes based on generated channels
        function triggerSynthNotes(song) {
            song.channels.forEach(channel => {
                if (channel.metadata.synthBass) {
                    // Calculate the frequency based on the octave
                    const baseFrequency = 55; // A1
                    const frequency = baseFrequency * Math.pow(2, channel.metadata.synthBass.octave);

                    // Set the frequency in the channel data
                    channel.frequency = frequency;

                    // Apply Synth effect
                    applySynthEffect(channel, {
                        waveform: channel.metadata.synthBass.waveform,
                        attack: 10, // Example value, could be randomized or based on other parameters
                        release: 500, // Example value
                        cutoff: 2000, // Example value
                        resonance: 5, // Example value
                        volume: channel.metadata.synthBass.volume
                    });
                }
            });
        }


        function applyEffects(channel, index, newSong, currentSequence, bpm, effectsContext, prng) {
            const effectsMap = [
                { name: 'pitchShift', applyFn: (ch, params) => applyRandomPitchShift(ch, params, prng) },
                { name: 'harmonize', applyFn: (ch, params) => addHarmony(ch, index, newSong, params, effectsContext, prng) },
                { name: 'delay', applyFn: (ch, params) => applyIntermittentDelay(ch, params, bpm) },
                { name: 'reverse', applyFn: (ch, params) => applyReverseEffect(ch) },
                { name: 'filter', applyFn: (ch, params) => applyFilterEffect(ch, params, prng) },
                { name: 'tremolo', applyFn: (ch, params) => applyTremoloEffect(ch, params, prng) },
                { name: 'distortion', applyFn: (ch, params) => applyDistortionEffect(ch, params, prng) },
                { name: 'bitcrusher', applyFn: (ch, params) => applyBitcrusherEffect(ch, params, prng) },
                { name: 'pan', applyFn: (ch, params) => applyPanEffect(ch, params, prng) },
                { name: 'reverb', applyFn: (ch, params) => applyReverbEffect(ch, params, prng) },
                { name: 'volumeChange', applyFn: (ch, params) => applyVolumeChange(ch, params, prng) },
                { name: 'chorus', applyFn: (ch, params) => applyChorusEffect(ch, params, prng) },
                // **New Leslie Effect**
                { name: 'leslie', applyFn: (ch, params) => applyLeslieEffect(ch, params, bpm) },
                // **New BPM-Linked Delay Effect**
                { name: 'delayBpmLinked', applyFn: (ch, params) => applyBpmLinkedDelay(ch, params, bpm) },
                // **New Synth Bass Line Effect**
                { name: 'synthBass', applyFn: (ch, params) => applySynthBassEffect(ch, params) }
            ];

            effectsMap.forEach(effect => {
                const effectParams = window.EffectsModule.getEffectParams(effect.name, currentSequence, bpm, prng);
                if (effectParams) effect.applyFn(channel, effectParams);
            });

            // After applying effects, load and process the sample
            const sampleParams = {
                reversed: channel.metadata.requiresReversal,
                playbackSpeed: channel.metadata.playbackSpeed,
                // Include other processing parameters as needed
            };

            if (effectsContext.totalGain > effectsContext.maxTotalGain) {
                const reductionFactor = effectsContext.maxTotalGain / effectsContext.totalGain;
                channel.metadata.volume = (channel.metadata.volume || 1) * reductionFactor;
            }
            effectsContext.totalGain += channel.metadata.volume || 1;
        }

        // **Chorus Effect Applied**
        const applyChorusEffect = (channel, { rate, depth, feedback, mix }, prng) => {
            channel.metadata.chorus = {
                rate,       // Modulation rate in Hz
                depth,      // Modulation depth (0 to 1)
                feedback,   // Feedback amount (0 to 0.5)
                mix         // Wet/Dry mix (0 to 1)
            };
        };

        // Reintroduce the applyRandomPitchShift function
        const applyRandomPitchShift = (channel, { shifts }, prng) => {
            const shift = shifts[Math.floor(prng() * shifts.length)];
            channel.metadata.playbackSpeed *= shift;
        };

        const addHarmony = (originalChannel, index, newSong, { intervals, maxHarmonyChannels }, context, prng) => {
            if (context.harmonyChannelsAdded >= maxHarmonyChannels) return;
            intervals.forEach(interval => {
                if (context.harmonyChannelsAdded >= maxHarmonyChannels) return;
                const harmony = JSON.parse(JSON.stringify(originalChannel));
                harmony.id = `${originalChannel.id}_harmony_${index}_${interval}`;
                harmony.metadata.playbackSpeed *= interval;
                harmony.metadata.volume = (harmony.metadata.volume || 1) * 0.8;
                newSong.channels.push(harmony);
                context.harmonyChannelsAdded++;
            });
        };

        const applyIntermittentDelay = (channel, { noteValue, maxDelayRepeats }, bpm) => {
            const beatDuration = 60000 / bpm;
            const delayMap = { 'quarter': beatDuration, 'eighth': beatDuration / 2, 'sixteenth': beatDuration / 4 };
            channel.metadata.delay = { time: delayMap[noteValue] || beatDuration, repeats: maxDelayRepeats };
        };

        const applyReverseEffect = channel => {
            channel.metadata.requiresReversal = true;
        };

        const applyVolumeChange = (channel, { range }, prng) => {
            const [min, max] = range;
            channel.metadata.volume = (channel.metadata.volume || 1) * (prng() * (max - min) + min);
        };

        const applyPanEffect = (channel, { positions }, prng) => {
            channel.metadata.pan = positions[Math.floor(prng() * positions.length)];
        };

        const applyReverbEffect = (channel, { decayTimeRange, mixRange }, prng) => {
            channel.metadata.reverb = {
                decayTime: prng() * (decayTimeRange[1] - decayTimeRange[0]) + decayTimeRange[0],
                mix: prng() * (mixRange[1] - mixRange[0]) + mixRange[0]
            };
        };

        const applyFilterEffect = (channel, { types, frequencyRange, QRange }, prng) => {
            channel.metadata.filter = {
                type: types[Math.floor(prng() * types.length)],
                frequency: prng() * (frequencyRange[1] - frequencyRange[0]) + frequencyRange[0],
                Q: prng() * (QRange[1] - QRange[0]) + QRange[0]
            };
        };

        const applyTremoloEffect = (channel, { rateRange, depthRange }, prng) => {
            channel.metadata.tremolo = {
                rate: prng() * (rateRange[1] - rateRange[0]) + rateRange[0],
                depth: prng() * (depthRange[1] - depthRange[0]) + depthRange[0]
            };
        };

        const applyDistortionEffect = (channel, { amountRange }, prng) => {
            channel.metadata.distortion = {
                amount: prng() * (amountRange[1] - amountRange[0]) + amountRange[0]
            };
        };

        const applyBitcrusherEffect = (channel, { bitDepthRange, sampleRateRange }, prng) => {
            channel.metadata.bitcrusher = {
                bitDepth: Math.floor(prng() * (bitDepthRange[1] - bitDepthRange[0] + 1)) + bitDepthRange[0],
                sampleRate: prng() * (sampleRateRange[1] - sampleRateRange[0]) + sampleRateRange[0]
            };
        };

        // **Synth Bass Line Function**
        const applySynthBassEffect = (channel, { waveform, octave, volume }) => {
            channel.metadata.synthBass = {
                waveform, // e.g., 'sine', 'square', 'triangle'
                octave,   // e.g., 1 for one octave below, 2 for two octaves, etc.
                volume    // Volume level for the synth bass
            };
        };

        // **Leslie Effect Function**
        const applyLeslieEffect = (channel, { rotationSpeed, depth, mix }, bpm) => {
            channel.metadata.leslie = {
                rotationSpeed, // Rotation speed in Hz
                depth,         // Depth of the effect
                mix            // Wet/Dry mix
            };
        };

        // **BPM-Linked Delay Function**
        const applyBpmLinkedDelay = (channel, { time, feedback, mix }, bpm) => {
            channel.metadata.delayBpmLinked = {
                time,       // Delay time in ms
                feedback,   // Feedback amount (0 to 1)
                mix         // Wet/Dry mix (0 to 1)
            };
        };



        const loopSampleIds = new Set([
            "7c42769c1763cc8f045aada7914e8158223e45e7a4f197b49f918b1c005d36fci0",
            "3364803cb3032ce95f4138a214c15a9b36dcb70f574a477f27615d448e1cdeb8i0",
        ]);

        const keyNames = [
            "projectName",
            "artistName",
            "projectBPM",
            "currentSequence",
            "channelURLs",
            "channelVolume",
            "channelPlaybackSpeed",
            "trimSettings",
            "projectChannelNames",
            "startSliderValue",
            "endSliderValue",
            "totalSampleDuration",
            "start",
            "end",
            "projectSequences",
            "steps"
        ];

        const keyMap = keyNames.reduce((map, key, index) => {
            map[key] = index;
            return map;
        }, {});

        const channelIds = Array.from({ length: 16 }, (_, index) => String.fromCharCode(65 + index)); // 'A' to 'P'
        const channelIdMap = channelIds.reduce((map, id, index) => {
            map[id] = index;
            return map;
        }, {});

        const fetchAndProcessSongData = async (url) => {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Network error for ${url}`);
                const compressedData = new Uint8Array(await response.arrayBuffer());
                const inflatedData = window.pako.inflate(compressedData);
                const jsonString = new TextDecoder("utf-8").decode(inflatedData);
                const parsedData = JSON.parse(jsonString);
                const processParsedData = (data) => {
                    const recurse = (obj) => {
                        if (Array.isArray(obj)) {
                            return obj.map(recurse);
                        } else if (obj && typeof obj === "object") {
                            return Object.entries(obj).reduce((accumulator, [key, value]) => {
                                const mappedKey = keyNames[key] || key;
                                accumulator[mappedKey] = mappedKey === "projectSequences"
                                    ? Object.fromEntries(
                                        Object.entries(value).map(([seqKey, seqValue]) => {
                                            const sequenceName = `Sequence${seqKey.replace(/^s/, "")}`;
                                            const channels = Object.fromEntries(
                                                Object.entries(seqValue).map(([channelKey, channelValue]) => {
                                                    const steps = channelValue[keyMap.steps] || [];
                                                    const processedSteps = steps.flatMap((step) => {
                                                        if (typeof step === "number") {
                                                            return step;
                                                        } else if (step?.r) {
                                                            const [start, end] = step.r;
                                                            return Array.from({ length: end - start + 1 }, (_, idx) => start + idx);
                                                        } else if (typeof step === "string" && step.endsWith("r")) {
                                                            return { index: parseInt(step.slice(0, -1), 10), reverse: true };
                                                        } else {
                                                            return [];
                                                        }
                                                    });
                                                    return [`ch${channelIdMap[channelKey]}`, { steps: processedSteps }];
                                                })
                                            );
                                            return [sequenceName, channels];
                                        })
                                    )
                                    : recurse(value);
                                return accumulator;
                            }, {});
                        } else {
                            return obj;
                        }
                    };
                    return recurse(data);
                };
                return processParsedData(parsedData);
            } catch (error) {
                console.error(`[Initialization] Error fetching/deserializing ${url}:`, error);
                throw error;
            }
        };

        const prepareInitialSampleOrder = ({ projectSequences }) => {
            const sampleSet = new Set();
            const sampleOrder = [];
            Object.keys(projectSequences)
                .sort((a, b) => +a.slice(9) - +b.slice(9))
                .forEach(seqK => {
                    Object.entries(projectSequences[seqK]).forEach(([chId, { steps }]) => {
                        steps.forEach(step => {
                            if (typeof step === "number" || step?.index !== undefined) {
                                const id = `${chId}_${step.reverse ? 'r' : 'f'}`;
                                if (!sampleSet.has(id)) {
                                    sampleSet.add(id);
                                    sampleOrder.push({ channelId: chId, reverse: step.reverse || false });
                                }
                            }
                        });
                    });
                });
            return sampleOrder;
        };

        const setArtworkImage = url => {
            const el = document.getElementById("artworkImage");
            if (el) {
                el.src = url;
                el.parentElement.style.display = "flex";
            }
        };

        // Global Sample Cache
         const sampleCache = {};

        // Function to generate a unique key for each sample based on URL and processing parameters
        const generateSampleKey = (url, params = {}) => {
            let key = url;
            if (params.reversed) key += '_reversed';
            if (params.playbackSpeed && params.playbackSpeed !== 1) key += `_speed_${params.playbackSpeed}`;
            // Include other parameters as needed
            return key;
        };

        // Function to load and process a sample
        const loadAndProcessSample = async (url, params = {}) => {
            const key = generateSampleKey(url, params);

            // Check if the processed sample is already in the cache
            if (sampleCache[key]) {
                console.log(`Reusing cached sample: ${key}`);
                return sampleCache[key];
            }

            // Load the sample (fetch the audio data)
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();

            // Decode the audio data
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            let audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

            // Apply processing if needed
            if (params.reversed) {
                // Reverse the audio buffer
                for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
                    Array.prototype.reverse.call(audioBuffer.getChannelData(i));
                }
            }

            if (params.playbackSpeed && params.playbackSpeed !== 1) {
                // Adjust playback speed (time-stretching or pitch-shifting)
                // Implement time-stretching or pitch-shifting as needed
                // For simplicity, let's assume we adjust the playback rate during playback
            }

            // Store the processed sample in the cache
            sampleCache[key] = audioBuffer;

            console.log(`Processed and cached sample: ${key}`);

            return audioBuffer;
        };

            // **New Function: generateMuteSchedule**
            const generateMuteSchedule = (prng, totalSequences) => {
                const muteSchedule = [];
                const evenSequences = [];
                for (let seq = 2; seq <= totalSequences; seq += 2) {
                    evenSequences.push(seq);
                }

                evenSequences.forEach(seq => {
                    // Decide whether to mute or unmute at this sequence
                    const action = prng() < 0.5 ? 'mute' : 'unmute';
                    // Decide number of channels to affect (1 to 4)
                    const numChannels = Math.floor(prng() * 4) + 1;
                    // Placeholder: actual channel selection will be handled during mix generation
                    muteSchedule.push({ sequence: seq, action, numChannels });
                });

                return muteSchedule;
            };

            const validSongDataUrls = songDataUrls.filter((url) => url.trim() && !url.trim().startsWith("//"));

        if (validSongDataUrls.length) {
            if (!window.pako) {
                await (async function loadPako() {
                    try {
                        const response = await fetch("/content/2109694f44c973892fb8152cf5c68607fb19288c045af1abc1716c1c3b4d69e6i0");
                        const textContent = await response.text();
                        const scriptElement = new DOMParser().parseFromString(textContent, "text/html").querySelector("script");
                        if (!scriptElement || !scriptElement.textContent.includes("pako")) {
                            throw new Error("Pako library not found.");
                        }
                        document.head.append(
                            Object.assign(document.createElement("script"), { textContent: scriptElement.textContent })
                        );
                    } catch (error) {
                        console.error("[Initialization] Error loading Pako:", error);
                    }
                })();
            }
            const songDataArray = await Promise.all(
                validSongDataUrls.map(async (url, index) => {
                    try {
                        const data = await fetchAndProcessSongData(url);
                        return { data, index };
                    } catch (error) {
                        console.error(`[Initialization] Failed ${url}:`, error);
                        return null;
                    }
                })
            ).then(dataArray => {
                const validDataArray = dataArray.filter(Boolean);
                if (!validDataArray.length) throw new Error("[Initialization] No valid data.");
                return validDataArray;
            });

            const originalSongs = songDataArray
                .sort((a, b) => a.index - b.index)
                .map(({ data, index }) => {
                    const {
                        projectName = "The Infinite Ordinal",
                        artistName = "melophonic",
                        projectBPM = 120,
                        projectSequences = {},
                        channelURLs = [],
                        channelVolume = [],
                        channelPlaybackSpeed = [],
                        trimSettings = {}
                    } = data;

                    const channels = channelIds.map((id, idx) => {
                        const channelSequence = Object.entries(projectSequences).reduce((acc, [sequenceName, sequenceData]) => {
                            const channelData = sequenceData[`ch${idx}`];
                            if (channelData) acc.push({ sequenceName, steps: channelData.steps });
                            return acc;
                        }, []);
                        const metadata = {
                            volume: channelVolume[idx] ?? 1,
                            playbackSpeed: channelPlaybackSpeed[idx] ?? 1,
                            trimStartTime_Percentage: trimSettings[idx]?.start || 0,
                            trimEndTime_Percentage: trimSettings[idx]?.end || 100,
                            requiresReversal: channelSequence.some(seq => seq.steps.some(step => typeof step === "object" && step.reverse)),
                            channelSequence,
                            originalBPM: projectBPM
                        };
                        const sampleId = channelURLs[idx];
                        if (loopSampleIds.has(sampleId)) {
                            metadata.isLoop = true;
                        }
                        return { id, url: sampleId || "URL_not_found", metadata };
                    });
                    return {
                        id: `Song ${index + 1}: ${projectName}`,
                        artist: artistName,
                        bpm: projectBPM,
                        totalSequences: Object.keys(projectSequences).length,
                        totalChannels: channels.length,
                        channels,
                        projectSequences
                    };
                });

            const allChannels = originalSongs.flatMap(song => song.channels);

            function lcg64(seed) {
                let state = seed;
                const a = 6364136223846793005n;
                const c = 1442695040888963407n;
                const m = 18446744073709551616n; // 2^64
                return function() {
                    state = (a * state + c) % m;
                    return Number(state) / Number(m);
                }
            }

            const getRandomChannels = (channelsArray, num, prng) => {
                const shuffled = [...channelsArray];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(prng() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled.slice(0, num);
            };

            // **New Function: selectChannelsForMuting**
            const selectChannelsForMuting = (channels, num, prng) => {
                const availableChannels = channels.filter(ch => !ch.isMuted); // Assuming channel object has 'isMuted' flag
                const shuffled = [...availableChannels];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(prng() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled.slice(0, num).map(ch => ch.id);
            };

            // **New Function: selectChannelsForUnmuting**
            const selectChannelsForUnmuting = (channels, num, prng) => {
                const mutedChannels = channels.filter(ch => ch.isMuted);
                const shuffled = [...mutedChannels];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(prng() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled.slice(0, num).map(ch => ch.id);
            };

            // Generate song mixes asynchronously and map them by BPM
            async function generateMixesBySeed(seedString, numMixes = 100, filteredBPMs = null) {
                const bpmOptions = [60, 120, 140, 160, 180, 240];
                const newSongs = [];
                const songsByBPM = {}; // Object to store songs categorized by BPM

                // Initialize base seed with error handling
                let baseSeed;
                try {
                    baseSeed = BigInt(seedString);
                } catch (error) {
                    console.error(`[seedDebug] Invalid seed string: "${seedString}". Using base seed 0.`);
                    baseSeed = 0n;
                }

                let currentSeed = baseSeed || 1n;

                // Function to derive BPM from a seed using PRNG
                const getBPMFromSeed = (seed) => {
                    const prng = lcg64(seed);
                    return bpmOptions[Math.floor(prng() * bpmOptions.length)];
                };

                // Function to find the next valid seed that matches the target BPM
                const findNextValidSeed = (startingSeed, targetBPM, maxAttempts = 1e6) => {
                    for (let seed = startingSeed, attempt = 0; attempt < maxAttempts; attempt++, seed += 1n) {
                        if (getBPMFromSeed(seed) === targetBPM) return seed;
                    }
                    throw new Error(`[seedDebug] Could not find seed producing BPM ${targetBPM} within ${maxAttempts} attempts.`);
                };

                // Main loop to generate each mix
                for (let mixIndex = 0; mixIndex < numMixes; mixIndex++) {
                    // If filtering by BPM, find the next seed that matches the desired BPM
                    if (filteredBPMs !== null) {
                        try {
                            currentSeed = findNextValidSeed(currentSeed, filteredBPMs);
                        } catch (error) {
                            console.error(error.message);
                            break; // Exit the loop if unable to find a valid seed
                        }
                    }

                    const prng = lcg64(currentSeed);
                    const selectedBPM = filteredBPMs !== null ? filteredBPMs : getBPMFromSeed(currentSeed);

                    // Select random channels for the mix
                    const randomChannels = getRandomChannels(allChannels, 20, prng);
                    const activationPoints = [
                        { startSeq: 1, count: 16 },
                        { startSeq: 5, count: 4 },
                        { startSeq: 17, count: 4 },
                        { startSeq: 25, count: 4 }
                    ];

                    // Assign activation sequences to channels
                    const channelsWithActivation = activationPoints.flatMap(({ startSeq, count }) =>
                        Array.from({ length: count }, (_, i) => {
                            const channel = randomChannels[i];
                            return channel ? { channel: JSON.parse(JSON.stringify(channel)), activationSeq: startSeq } : null;
                        }).filter(Boolean)
                    );

                    // Collect unique sequence names from channels
                    const sequenceSet = new Set(
                        channelsWithActivation.flatMap(({ channel }) => 
                            channel.metadata.channelSequence?.map(seq => seq.sequenceName) || []
                        )
                    );

                    // Sort sequences numerically based on their suffix
                    let sequences = [...sequenceSet].sort((a, b) =>
                        (parseInt(a.replace('Sequence', '')) || 0) - (parseInt(b.replace('Sequence', '')) || 0)
                    );

                    // Limit the number of sequences to 28
                    sequences = sequences.slice(0, 28);


                    // Initialize the new song object
                    const newSong = {
                        id: `The Infinite Ordinal Remix #${mixIndex + 1}`,
                        projectName: `The Infinite Ordinal`,
                        artist: `melophonic`,
                        bpm: selectedBPM,
                        totalSequences: sequences.length,
                        totalChannels: channelsWithActivation.length,
                        channels: [],
                        projectSequences: Object.fromEntries(sequences.map(seq => [seq, {}])),
                        seed: currentSeed.toString(),
                        // **New Property: muteSchedule**
                        muteSchedule: [] // To be populated
                    };

                    // Initialize effects context for the song
                    const effectsContext = {
                        harmonyChannelsAdded: 0,
                        maxHarmonyChannels: window.EffectsModule?.effectsConfig?.harmonize?.maxHarmonyChannels || 2,
                        totalGain: 0,
                        maxTotalGain: 10
                    };

                    // **Generate Mute Schedule for the Song**
                    const totalSequences = sequences.length;
                    const muteSchedule = generateMuteSchedule(prng, totalSequences);
                    newSong.muteSchedule = muteSchedule;

                    // Process each channel asynchronously and apply effects
                    await Promise.all(channelsWithActivation.map(async ({ channel, activationSeq }, index) => {
                        const chId = `ch${index}`;
                        const newChannel = {
                            id: chId,
                            url: channel.url,
                            metadata: { ...channel.metadata, originalBPM: newSong.bpm, activationSeq, isMuted: false } // Initialize isMuted flag
                        };
                        await applyEffects(newChannel, index, newSong, activationSeq, newSong.bpm, effectsContext, prng);
                        newSong.channels.push(newChannel);

                        // Map sequences to the new channel
                        channel.metadata.channelSequence?.forEach(seqData => {
                            if (newSong.projectSequences[seqData.sequenceName]) {
                                newSong.projectSequences[seqData.sequenceName] = {
                                    ...newSong.projectSequences[seqData.sequenceName],
                                    [chId]: { steps: seqData.steps }
                                };
                            }
                        });
                    }));

                    // **Assign Channels to Mute Schedule**
                    muteSchedule.forEach(actionItem => {
                        const { sequence, action, numChannels } = actionItem;
                        if (action === 'mute') {
                            const channelsToMute = selectChannelsForMuting(newSong.channels, numChannels, prng);
                            actionItem.channels = channelsToMute;
                            // Update channel metadata
                            channelsToMute.forEach(chId => {
                                const ch = newSong.channels.find(c => c.id === chId);
                                if (ch) ch.metadata.isMuted = true;
                            });
                        } else if (action === 'unmute') {
                            const channelsToUnmute = selectChannelsForUnmuting(newSong.channels, numChannels, prng);
                            actionItem.channels = channelsToUnmute;
                            // Update channel metadata
                            channelsToUnmute.forEach(chId => {
                                const ch = newSong.channels.find(c => c.id === chId);
                                if (ch) ch.metadata.isMuted = false;
                            });
                        }
                    });

                    // Log the generated song's seed and BPM
                    console.log(`[seedDebug] Generated Song with Seed: ${currentSeed} | BPM: ${selectedBPM}`);

                    // Add the new song to the songs list
                    newSongs.push(newSong);

                    // Add the new song to the songsByBPM map
                    if (!songsByBPM[selectedBPM]) {
                        songsByBPM[selectedBPM] = [];
                    }
                    songsByBPM[selectedBPM].push(newSong);

                    // Increment the seed for the next mix
                    currentSeed += 1n;
                }

                // Log the total number of generated mixes and the BPM map for debugging
                console.log(`[seedDebug] Generated ${newSongs.length} song mixes.`);
                console.log(`[seedDebug] Songs by BPM:`, songsByBPM);

                // Assign songsByBPM to globalData for access by other functions
                globalData.songsByBPM = songsByBPM;

                // Return the list of songs
                return newSongs;
            }

            // **New Function: applyChorusEffect** (Already defined above)

            // **New Functions for Channel Mute Scheduling**
            // selectChannelsForMuting and selectChannelsForUnmuting are defined above

            // **After generating the songs, ensure that samples are processed and cached**
            const generatedSongs = await generateMixesBySeed(window.seed);


            if (typeof globalData.initialized === 'undefined') {
                Object.assign(globalData, {
                    songsArray: generatedSongs,
                    currentSongIndex: 0,
                    currentSequenceIndex: 0,
                    initialSampleOrder: generatedSongs.length ? prepareInitialSampleOrder(generatedSongs[0]) : null,
                    isSingleSong: generatedSongs.length === 1,
                    isMultipleSongs: generatedSongs.length > 1,
                    initialized: true
                });
            }
            if (globalData.isArtworkCover && artworkUrl.length) setArtworkImage(artworkUrl[0]);
            document.dispatchEvent(new CustomEvent("dataLoadingComplete", {
                detail: {
                    success: true,
                    totalSongs: globalData.songsArray.length,
                    songs: globalData.songsArray.map(({ id, totalSequences }) => ({ id, totalSequences }))
                }
            }));
            window.generateMixesBySeed = generateMixesBySeed;
        } else {
            console.log("[Initialization] No valid song data URLs to process.");
        }
    })();
</script>




<!-- Load Player Scripts AFTER data loading is complete -->
<script>
         function updateSeedDisplay() {
            const currentSong = globalData.songsArray[globalData.currentSongIndex];
            if (currentSong) {
                const seed = currentSong.seed;
                const bpm = currentSong.bpm;
                const title = currentSong.id;
                displaySeedAndBPM(seed, bpm, title);
            } else {
                console.warn("Current song index is out of bounds.");
            }
        }
        window.updateSeedDisplay = updateSeedDisplay;

        /**
         * Handles transitioning to the next song in the playlist.
         */
        window.handleNextSong = function() {
            globalData.nextSong();
            updateSeedDisplay();
        };

        /**
         * Handles transitioning to the previous song in the playlist.
         */
        window.handlePreviousSong = function() {
            globalData.previousSong();
            updateSeedDisplay();
        };

        document.addEventListener("dataLoadingComplete", (event) => {
            const remainingScriptUrls = [
                "/content/5c03e882ab5a531271b2e93a80d8a9d72cb533c580bec1567020f5cd61595560i0", // projectArtistMapping
                "/content/016f153f011f6a23b8fccd0efcc7945913ee97f241c7a2df7c71c4fa7c9a5fb3i0", // unifiedMetadataManagement
                "/content/ef622be8aeeac45fdbdc291dd0db739d24c2c667c5c3ce7662f2b8c7f2c3de58i0", // GainNodeHelpers
                "/content/f4cc99813b43f71b3e781d3c99f24a6a7a5b1004ea0efce3b225011e347b8df0i0", // audioProcessingAndManagement
                "/content/7b305327f2951d219532ef0cb46b2039b23f2cfd0d8d0e827f3fe1b2b754b5a9i0", // DynamicGainBalancing
                "/content/8b5b09cfedbc0c6a187816181f8d33f90c5bbd15fc10af47008176effb866a47i0", // keyboardControlsAndEventListeners

                ];

            const loadScriptsSequentially = (urls) => {
                if (urls.length === 0) return;
                const src = urls.shift();
                const script = document.createElement("script");
                script.src = src;
                script.async = false;
                script.onload = () => loadScriptsSequentially(urls);
                script.onerror = (e) => {
                    console.error(`[Script Loader] Error loading script: ${src}`, e);
                    loadScriptsSequentially(urls);
                };
                document.body.appendChild(script);
            };

            loadScriptsSequentially([...remainingScriptUrls]);
            updateSeedDisplay(); // Update seed display after loading is complete
        });
</script>

<!-- Synth Script -->
<script>
    class Synth {
        constructor(audioContext) {
            // Initialize Audio Context
            this.context = audioContext || new (window.AudioContext || window.webkitAudioContext)();
            this.gainNode = this.context.createGain();
            this.gainNode.connect(this.context.destination);

            // Initialize Synth Parameters with defaults
            this.waveform = 'sine';      // Waveform type ('sine', 'square', 'triangle', 'sawtooth')
            this.attack = 0.01;          // Attack time in seconds
            this.decay = 0.1;            // Decay time in seconds
            this.sustain = 0.1;          // Sustain level (0.0 to 1.0)
            this.release = 0.02;         // Release time in seconds
            this.cutoff = 1000;          // Filter cutoff frequency in Hz
            this.resonance = 1;          // Filter resonance (Q factor)
            this.volume = 1.0;           // Volume (0.0 to 2.0)
            this.octaveShift = 0;        // Octave shift (-2, -1, 0, 1, 2)
            this.isPolyphonic = false;   // Polyphonic mode (true or false)

            // Initialize BPM and Timing
            this.BPM = 60;                // Default BPM
            this.updateTimings();

            // Playback Control Variables
            this.currentOscillators = {}; // Track active oscillators for polyphony

            // **New: Rate Limiting Properties**
            this.rateDivider = 4;         // Play a note every 4 calls
            this.stepCounter = 0;         // Counts the number of playNote calls

            console.log(`Synth initialized at ${this.BPM} BPM with default settings.`);
            console.log(`Rate Divider set to ${this.rateDivider}. Synth will play a note every ${this.rateDivider} calls to playNote.`);
        }

        /**
         * Updates BPM and recalculates timings.
         * @param {number} newBPM - The new BPM to set.
         */
        updateBPM(newBPM) {
            if (typeof newBPM !== 'number' || newBPM <= 0) {
                console.warn(`Invalid BPM value: ${newBPM}. BPM must be a positive number.`);
                return;
            }

            // Update BPM
            this.BPM = newBPM;
            this.updateTimings();
            console.log(`Synth BPM updated to ${this.BPM} BPM.`);
        }

        /**
         * Recalculates beat and bar durations based on BPM.
         */
        updateTimings() {
            this.BEAT_DURATION = 60 / this.BPM;          // Duration of one beat in seconds
            this.BAR_DURATION = this.BEAT_DURATION * 4; // Assuming 4/4 time signature
            console.log(`Timings updated: ${this.BEAT_DURATION.toFixed(3)}s per beat, ${this.BAR_DURATION.toFixed(3)}s per bar.`);
        }

        /**
         * **New: Sets the rate divider to control note output rate.**
         * @param {number} divider - The number of playNote calls to skip before playing a note.
         */
        setRateDivider(divider) {
            if (typeof divider !== 'number' || divider < 1) {
                console.warn(`Invalid rate divider: ${divider}. It must be a positive integer.`);
                return;
            }
            this.rateDivider = Math.floor(divider);
            console.log(`Rate Divider set to ${this.rateDivider}. Synth will play a note every ${this.rateDivider} calls to playNote.`);
        }

        /**
         * **New: Gets the current rate divider.**
         * @returns {number} The current rate divider.
         */
        getRateDivider() {
            return this.rateDivider;
        }

        /**
         * Plays the F♯2 note at a scheduled time, considering the rate divider.
         * @param {number} time - The time (in seconds) when the note should start.
         */
        playNote(time) {
            this.stepCounter += 1;

            // Check if the current call should trigger a note
            if (this.stepCounter % this.rateDivider !== 0) {
                console.log(`playNote call ${this.stepCounter}: Note skipped due to rate divider.`);
                return; // Skip playing the note
            }

            const baseFrequency = 92.50; // Frequency for F♯2
            const frequency = baseFrequency * Math.pow(2, this.octaveShift); // Apply octave shift

            // Monophonic mode: stop existing notes
            if (!this.isPolyphonic) {
                this.stopAllNotes();
            }

            const oscillator = this.context.createOscillator();
            const gain = this.context.createGain();
            const filter = this.context.createBiquadFilter();

            // Configure Oscillator
            oscillator.type = this.waveform;
            oscillator.frequency.setValueAtTime(frequency, time);

            // Configure Filter
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(this.cutoff, time);
            filter.Q.setValueAtTime(this.resonance, time);

            // Configure Gain (Envelope)
            gain.gain.setValueAtTime(0, time);
            gain.gain.linearRampToValueAtTime(this.volume, time + this.attack); // Attack
            gain.gain.linearRampToValueAtTime(this.volume * this.sustain, time + this.attack + this.decay); // Decay to Sustain level

            // Connect Nodes
            oscillator.connect(filter);
            filter.connect(gain);
            gain.connect(this.gainNode);

            // Start Oscillator
            oscillator.start(time);

            // Schedule Note Stop (Staccato: 0.5 seconds duration)
            const noteDuration = 0.5; // Fixed duration for staccato
            oscillator.stop(time + noteDuration);

            // Handle release phase after note ends
            oscillator.onended = () => {
                gain.gain.cancelScheduledValues(time);
                gain.gain.setValueAtTime(gain.gain.value, time);
                gain.gain.linearRampToValueAtTime(0, time + this.release);
                setTimeout(() => {
                    gain.disconnect();
                }, this.release * 1000);
                delete this.currentOscillators[oscillator];
            };

            // Keep track of active oscillators
            this.currentOscillators[oscillator] = oscillator;

            console.log(`Scheduled note F♯2 (${frequency.toFixed(2)} Hz) at ${new Date(time * 1000).toLocaleTimeString()}`);
        }

        /**
         * Stops all currently playing notes.
         */
        stopAllNotes() {
            for (let osc in this.currentOscillators) {
                if (this.currentOscillators.hasOwnProperty(osc)) {
                    try {
                        this.currentOscillators[osc].stop();
                    } catch (e) {
                        console.warn('Error stopping oscillator:', e);
                    }
                }
            }
            this.currentOscillators = {};
            console.log('All active oscillators have been stopped.');
        }

        /**
         * Sets the waveform type.
         * @param {string} waveform - The waveform type ('sine', 'square', 'triangle', 'sawtooth').
         */
        setWaveform(waveform) {
            const validWaveforms = ['sine', 'square', 'triangle', 'sawtooth'];
            if (validWaveforms.includes(waveform)) {
                this.waveform = waveform;
                console.log(`Waveform set to ${waveform}.`);
            } else {
                console.warn(`Invalid waveform type: ${waveform}. Valid options are ${validWaveforms.join(', ')}.`);
            }
        }

        /**
         * Sets the envelope parameters.
         * @param {object} envelope - Object containing attack, decay, sustain, and release.
         */
        setEnvelope({ attack, decay, sustain, release }) {
            if (attack !== undefined) this.attack = attack;
            if (decay !== undefined) this.decay = decay;
            if (sustain !== undefined) this.sustain = sustain;
            if (release !== undefined) this.release = release;
            console.log(`Envelope updated: Attack=${this.attack}s, Decay=${this.decay}s, Sustain=${this.sustain}, Release=${this.release}s.`);
        }

        /**
         * Sets the filter parameters.
         * @param {object} filterParams - Object containing cutoff and resonance.
         */
        setFilter({ cutoff, resonance }) {
            if (cutoff !== undefined) this.cutoff = cutoff;
            if (resonance !== undefined) this.resonance = resonance;
            console.log(`Filter updated: Cutoff=${this.cutoff}Hz, Resonance=${this.resonance}.`);
        }

        /**
         * Sets the volume (gain).
         * @param {number} volume - Volume level (0.0 to 2.0).
         */
        setVolume(volume) {
            if (typeof volume === 'number' && volume >= 0 && volume <= 2) {
                this.volume = volume;
                console.log(`Volume set to ${this.volume}.`);
            } else {
                console.warn(`Invalid volume level: ${volume}. Must be between 0.0 and 2.0.`);
            }
        }

        /**
         * Sets the octave shift.
         * @param {number} shift - Octave shift (-2, -1, 0, 1, 2).
         */
        setOctaveShift(shift) {
            const validShifts = [-2, -1, 0, 1, 2];
            if (validShifts.includes(shift)) {
                this.octaveShift = shift;
                console.log(`Octave shift set to ${shift} (${shift >= 0 ? '+' : ''}${shift} octaves).`);
            } else {
                console.warn(`Invalid octave shift: ${shift}. Valid options are ${validShifts.join(', ')}.`);
            }
        }

        /**
         * Sets polyphonic or monophonic mode.
         * @param {boolean} isPolyphonic - True for polyphonic, false for monophonic.
         */
        setPolyphony(isPolyphonic) {
            this.isPolyphonic = isPolyphonic;
            console.log(`Polyphony mode set to ${isPolyphonic ? 'polyphonic' : 'monophonic'}.`);
        }
    }

    // Make Synth globally accessible
    window.Synth = Synth;
    window.synth = new Synth();

    // **New: Initialize Rate Divider**
    // Set the rate divider to 4 to reduce note rate by four
    window.synth.setRateDivider(4);

    window.addEventListener('keydown', (event) => {
        if (event.code === 'Space') {
            event.preventDefault(); // Prevent default spacebar behavior (e.g., scrolling)
            const currentTime = window.synth.context.currentTime + 0.05; // Schedule slightly in the future
            window.synth.playNote(currentTime);
            console.log('Spacebar pressed: Manually triggered F♯2 note.');
        }
    });

    // Example Usage:
    // Set initial parameters
    synth.setWaveform('sawtooth'); // Options: 'sine', 'square', 'triangle', 'sawtooth'
    synth.setVolume(1.5);           // Volume between 0.0 and 2.0
    synth.setEnvelope({
        attack: 0.01,   // Attack time in seconds
        decay: 0.1,     // Decay time in seconds
        sustain: 0.2,   // Sustain level (0.0 to 1.0)
        release: 0.02   // Release time in seconds
    });
    synth.setFilter({
        cutoff: 800,     // Cutoff frequency in Hz
        resonance: 1     // Resonance (Q factor)
    });
    synth.setOctaveShift(-1);      // Shift down 1 octave (-2, -1, 0, 1, 2)
    synth.setPolyphony(false);     // Set to monophonic mode (true or false)

    // Initial Log
    console.log('Synth is ready. Press spacebar to manually trigger the F♯2 note for testing.');
</script>

<!-- Playback -->
<script>
    // playbackEngine.js
    (() => {
        // Initialize global data or use existing globalData
        const globalData = window.globalData || (window.globalData = {
            isPlaying: false,
            currentSongIndex: 0,
            songsArray: [],
            audioBuffers: {},
            reverseAudioBuffers: {},
            audioContext: new (window.AudioContext || window.webkitAudioContext)(),
            masterGain: null,
            gainNodes: {},
            isArtworkCover: true,
            isVisualiserCover: false,
            // Retained properties for step and sequence tracking
            currentStep: 0,
            currentSequence: 0
        });

        const { audioContext } = globalData;
        const scheduleAheadTime = 0.1; // Time in seconds to schedule ahead
        const schedulerInterval = 25;   // Interval in milliseconds for the scheduler
        let nextNoteTime = audioContext.currentTime;

        let playbackInterval = null;
        let sequenceStates = {};

        const missingAudioBuffers = new Set();
        const activeAudioSources = new Set();

        // New: Event Targets for Step Events
        const stepEventTarget = new EventTarget();

        // Function to allow other modules to subscribe to step events
        globalData.onStepUpdate = (callback) => {
            stepEventTarget.addEventListener('stepPlayed', callback);
        };

        // Function to emit step updates
        function emitStepUpdate(stepInfo) {
            const event = new CustomEvent('stepPlayed', { detail: stepInfo });
            stepEventTarget.dispatchEvent(event);
        }

        // Function to initialize countdown timer (unchanged)
        function initializeCountdown(song) {
            // Clear any existing interval
            if (window.countdownInterval) {
                clearInterval(window.countdownInterval);
            }

            const nowPlayingContainer = document.getElementById("nowPlayingContainer");
            if (!nowPlayingContainer) return;

            const timeLeftElement = nowPlayingContainer.querySelector(".timeLeft");
            if (!timeLeftElement) return;

            // Calculate total duration in seconds
            const stepDuration = 60 / song.bpm / 4;
            const stepsPerSequence = 64;
            const totalSequences = Object.keys(song.projectSequences).length;
            const totalDuration = stepDuration * stepsPerSequence * totalSequences;

            let timeLeft = totalDuration;

            // Update the display immediately
            updateTimeLeftDisplay(timeLeftElement, timeLeft);

            // Update every second
            window.countdownInterval = setInterval(() => {
                if (globalData.isPlaying) {
                    timeLeft -= 1;
                    if (timeLeft <= 0) {
                        timeLeft = 0;
                        clearInterval(window.countdownInterval);
                    }
                    updateTimeLeftDisplay(timeLeftElement, timeLeft);
                } else {
                    clearInterval(window.countdownInterval);
                }
            }, 1000);
        }

       // Function to update the countdown display (unchanged)
       function updateTimeLeftDisplay(element, timeLeftInSeconds) {
            const minutes = Math.floor(timeLeftInSeconds / 60);
            const seconds = Math.floor(timeLeftInSeconds % 60);
            element.textContent = `Time Left: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // Function to emit synchronization events periodically
        function emitSyncEvent(song) {
            // Define how frequently to emit sync events (e.g., every 16 sequences)
            const syncInterval = 16;

            // Create a loop to emit sync events at defined intervals
            playbackInterval = setInterval(() => {
                if (!globalData.isPlaying) return;

                // Emit sync event with current step and sequence
                emitStepUpdate({
                    step: globalData.currentStep,
                    sequence: globalData.currentSequence,
                    timestamp: audioContext.currentTime
                });

                console.log(`Sync Event Emitted -> Step: ${globalData.currentStep} | Sequence: ${globalData.currentSequence}`);
            }, (60 / song.bpm / 4) * 64 * syncInterval * 1000); // Calculate interval based on BPM and syncInterval
        }


        // Function to start playback (updated)
        function startPlayback() {
            const { songsArray, currentSongIndex } = globalData;

            if (!songsArray.length) {
                console.error("No songs available for playback.");
                return;
            }

            // Get the current song and its sequences
            const song = songsArray[currentSongIndex % songsArray.length];
            const projectSequences = song.projectSequences || {};

            const stepDuration = 60 / song.bpm / 4;       // Duration of a single step
            const sequenceDuration = 64 * stepDuration;   // Total duration of a sequence

            // Reset states and logs
            globalData.currentSongIndex %= songsArray.length;
            sequenceStates = {};
            missingAudioBuffers.clear();

            console.log(`Starting playback for Song: ${song.id} (${globalData.currentSongIndex + 1}/${songsArray.length}) with ${Object.keys(projectSequences).length} sequences.`);
            console.log(`Song BPM: ${song.bpm}`);

            // **Update Synth's BPM Here**
            if (window.synth && typeof window.synth.updateBPM === 'function') {
                window.synth.updateBPM(song.bpm);
                console.log(`Synth BPM updated to ${song.bpm} BPM.`);
            } else {
                console.warn("Synth instance not found or updateBPM method unavailable.");
            }

            let sequenceStartTimeOffset = 0;

            // Initialize sequence states
            for (const [sequenceId, sequenceData] of Object.entries(projectSequences)) {
                sequenceStates[sequenceId] = {
                    nextStepIndex: 0,
                    nextStepTime: audioContext.currentTime + sequenceStartTimeOffset,
                    stepDuration: stepDuration,
                    endTime: audioContext.currentTime + sequenceStartTimeOffset + sequenceDuration,
                    completed: false
                };
                sequenceStartTimeOffset += sequenceDuration;
            }

            globalData.currentSongId = song.id;

            // Prepare gain nodes for the song
            GainNodeHelper.createGainNodesForSong(song);
            GainNodeHelper.prepareNextSong(songsArray[(globalData.currentSongIndex + 1) % songsArray.length]);
            globalData.isPlaying = true;

            // Reset timing counters
            globalData.currentStep = 0;
            globalData.currentSequence = 0;

            // Emit initial sync event
            emitStepUpdate({
                step: globalData.currentStep,
                sequence: globalData.currentSequence,
                timestamp: audioContext.currentTime
            });

            console.log("Playback started. Synth is responsible for scheduling notes.");
            document.dispatchEvent(new CustomEvent("playbackStarted", { detail: { success: true } }));

            // Update Now Playing information
            updateNowPlaying(song);

            // Initialize countdown timer
            initializeCountdown(song);

            // Start emitting synchronization events
            emitSyncEvent(song);
        }

        // Function to stop playback
        function stopPlayback() {
            if (!globalData.isPlaying) return;

            globalData.isPlaying = false;

            // Clear synchronization interval
            if (playbackInterval) {
                clearInterval(playbackInterval);
                playbackInterval = null;
            }

            // Clear countdown timer
            if (window.countdownInterval) {
                clearInterval(window.countdownInterval);
                window.countdownInterval = null;
            }

            // Stop all sequences if necessary
            // Implement any additional cleanup as required

            console.log("Playback stopped.");
            document.dispatchEvent(new CustomEvent("playbackStopped", { detail: { success: true } }));
        }

        // Expose startPlayback and stopPlayback to the global scope
        window.startPlayback = startPlayback;
        window.stopPlayback = stopPlayback;


    // Function to reset playback
    function resetPlayback(options = {}) {
        clearInterval(playbackInterval);
        playbackInterval = null;
        if (!options.preserveIsPlaying) {
            globalData.isPlaying = false;
        }

        sequenceStates = {};
        missingAudioBuffers.clear();

        // Stop and disconnect all active audio sources
        activeAudioSources.forEach(source => {
            try {
                source.stop();
                source.disconnect();
            } catch (error) {
                console.error("Error stopping/disconnecting an audio source:", error);
            }
        });
        activeAudioSources.clear();

        // Clean up gain nodes
        if (globalData.currentSongId) {
            GainNodeHelper.cleanupGainNodesForSong(globalData.currentSongId);
            globalData.currentSongId = null;
        }

        // Clear countdown timer
        if (countdownInterval) {
            clearInterval(countdownInterval);
            countdownInterval = null;
        }

        // Execute callback if provided
        if (options.callback) {
            options.callback();
        }
    }

    // Initialize master gain node if it doesn't exist
    if (!globalData.masterGain) {
        globalData.masterGain = audioContext.createGain();
        globalData.masterGain.connect(audioContext.destination);
    }

    // Toggle playback function
    globalData.togglePlayback = () => globalData.isPlaying ? stopPlayback() : startPlayback();
    globalData.startPlayback = startPlayback;
    globalData.stopPlayback = stopPlayback;
    globalData.resetPlayback = () => resetPlayback({ callback: startPlayback });

    // Function to update the current sequence display
    function updateCurrentSequenceDisplay() {
        const nowPlayingContainer = document.getElementById("nowPlayingContainer");
        if (!nowPlayingContainer) return;
        const currentSequenceElement = nowPlayingContainer.querySelector(".current-sequence");
        if (currentSequenceElement) {
            currentSequenceElement.textContent = `Current Sequence: ${globalData.currentSequence || 0}`;
        }
    }


        // Function to schedule sequences
        function scheduleSequences(song) {
            const currentTime = audioContext.currentTime;
            let allSequencesCompleted = true;

            for (const [sequenceId, sequenceData] of Object.entries(song.projectSequences || {})) {
                const sequenceState = sequenceStates[sequenceId];

                if (sequenceState && !sequenceState.completed) {
                    if (currentTime >= sequenceState.endTime) {
                        sequenceState.completed = true;
                        console.log(`Sequence ${sequenceId} has completed.`);
                    } else {
                        allSequencesCompleted = false;

                        while (sequenceState.nextStepTime < currentTime + scheduleAheadTime && globalData.isPlaying) {
                            const { nextStepIndex, nextStepTime, stepDuration } = sequenceState;

                            // **Log when a new sequence starts**
                            if (nextStepIndex === 0 && !sequenceState.loggedStart) {
                                console.log(`Starting Sequence ${sequenceId} at step ${nextStepIndex}.`);
                                sequenceState.loggedStart = true; // Prevent logging again
                                // Optionally, update UI here if needed
                            }

                            for (const [channelKey, noteData] of Object.entries(sequenceData)) {
                                const channelIndex = parseInt(channelKey.slice(2), 10);
                                const channel = song.channels[channelIndex];

                                if (!channel) {
                                    console.warn(`Channel index ${channelIndex} not found in song ${song.id}.`);
                                    continue;
                                }

                                const step = noteData.steps?.find(step => typeof step === 'number' ? step === nextStepIndex : step.index === nextStepIndex);

                                if (step !== undefined) {
                                    const reverse = typeof step === 'object' && step.reverse;
                                    playNote(song, channel, nextStepTime, reverse);
                                }
                            }

                            // Move to the next step
                            sequenceState.nextStepIndex++;
                            if (sequenceState.nextStepIndex >= 64) {
                                sequenceState.completed = true;
                                console.log(`Sequence ${sequenceId} has completed all steps.`);
                                break;
                            }
                            sequenceState.nextStepTime += stepDuration;

                            // **Update the Current Sequence Counter and Log**
                            const sequenceNumber = parseInt(sequenceId.replace('Sequence', ''), 10);
                            if (sequenceNumber > globalData.currentSequence) {
                                globalData.currentSequence = sequenceNumber;
                                console.log(`Current Sequence updated to: ${globalData.currentSequence}`);
                                updateCurrentSequenceDisplay();

                                // **Progress the Seed**
                                globalData.currentSeed = (globalData.currentSeed !== undefined ? BigInt(globalData.currentSeed) : 1n) + 1n;
                                console.log(`Seed progressed to: ${globalData.currentSeed}`);
                            }
                        }
                    }
                }
            }

            if (allSequencesCompleted) {
                console.log("All sequences have completed.");
                proceedToNextSong();
            }

            // Apply mute/unmute actions based on the current sequence
            applyMuteSchedule(song, globalData.currentSequence);
        }


        // In playbackEngine.js

        // Function to apply mute/unmute actions based on the current sequence
        function applyMuteSchedule(song, currentSequence) {
            const { muteSchedule } = song;
            if (!muteSchedule || !Array.isArray(muteSchedule)) return;

            // Find actions scheduled for the current sequence
            const actions = muteSchedule.filter(actionItem => actionItem.sequence === currentSequence);

            actions.forEach(actionItem => {
                const { action, channels } = actionItem;
                channels.forEach(channelId => {
                    const channel = song.channels.find(ch => ch.id === channelId);
                    if (channel) {
                        if (action === 'mute') {
                            muteChannel(channel);
                        } else if (action === 'unmute') {
                            unmuteChannel(channel);
                        }
                    }
                });
            });
        }

        function muteChannel(channel) {
            if (!channel.metadata.isMuted) {
                channel.metadata.isMuted = true;
                const gainNode = globalData.gainNodes[song.id]?.[channel.id];
                if (gainNode) {
                    gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                    gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5); // 0.5 second fade-out
                    console.log(`Channel ${channel.id} muted with fade-out.`);
                }
            }
        }

        function unmuteChannel(channel) {
            if (channel.metadata.isMuted) {
                channel.metadata.isMuted = false;
                const gainNode = globalData.gainNodes[song.id]?.[channel.id];
                if (gainNode) {
                    gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.5); // 0.5 second fade-in
                    console.log(`Channel ${channel.id} unmuted with fade-in.`);
                }
            }
        }


    
        // Function to proceed to the next song
        function proceedToNextSong() {
            if (!globalData.isPlaying) return;

            globalData.currentSongIndex = (globalData.currentSongIndex + 1) % globalData.songsArray.length;

            setTimeout(() => {
                if (globalData.isPlaying) {
                    resetPlayback({ preserveIsPlaying: true, callback: startPlayback });
                }
            }, 200);
        }
    
        // Function to play a note
        const playNote = (song, channel, time, reverse) => {
            const bufferKey = `${song.id}_${channel.id}_${reverse ? "reverse" : "normal"}`;
            const buffer = reverse
                ? globalData.reverseAudioBuffers[song.id]?.[channel.id]
                : globalData.audioBuffers[song.id]?.[channel.id];
    
            if (!buffer) {
                if (!missingAudioBuffers.has(bufferKey)) {
                    missingAudioBuffers.add(bufferKey);
                    console.warn(`Audio buffer missing for Song: ${song.id}, Channel: ${channel.id}${reverse ? " (Reverse)" : ""}`);
                }
                return;
            }
    
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.playbackRate.value = channel.metadata.playbackSpeed || 1;
    
            const gainNode = globalData.gainNodes?.[song.id]?.[channel.id] || globalData.masterGain;
            source.connect(gainNode);
            source.start(time);
            activeAudioSources.add(source);
            source.onended = () => activeAudioSources.delete(source);
        };
    
        // Function to initialize playback engine
        globalData.initializePlaybackEngine = () => {
            if (!globalData.songsArray.length) {
                console.error("No songs available for playback.");
                return;
            }
            console.log("Playback Engine Initialization Complete.");
            console.log("Playback is ready. Click the artwork to start.");
        };
    
        // Function to get project name and artist name from song object
        function getProjectAndArtist(song) {
            return {
                projectName: song.projectName || song.id || "Unknown Project",
                artistName: song.artist || "Unknown Artist"
            };
        }
        // Function to update Now Playing information
        const updateNowPlaying = (song) => {
            const nowPlayingContainer = document.getElementById("nowPlayingContainer");
            if (!nowPlayingContainer) {
                console.warn("Now Playing Container not found.");
                return;
            }
            const { projectName, artistName } = getProjectAndArtist(song);
            nowPlayingContainer.querySelector(".songTitle").textContent = projectName;
            nowPlayingContainer.querySelector(".artistName").textContent = artistName;
            nowPlayingContainer.querySelector(".songBPM").textContent = `BPM: ${song.bpm}`;
            nowPlayingContainer.querySelector(".totalSequences").textContent = `Sequences: ${Object.keys(song.projectSequences).length}`;
            
            // Initialize countdown timer
            initializeCountdown(song);
        };
    
        // Function to clear Now Playing information
        const clearNowPlaying = () => {
            const nowPlayingContainer = document.getElementById("nowPlayingContainer");
            if (!nowPlayingContainer) {
                console.warn("Now Playing Container not found.");
                return;
            }
            nowPlayingContainer.querySelector(".songTitle").textContent = "No song playing";
            nowPlayingContainer.querySelector(".artistName").textContent = "";
            nowPlayingContainer.querySelector(".songBPM").textContent = "BPM: N/A";
            nowPlayingContainer.querySelector(".totalSequences").textContent = "Sequences: N/A";
            nowPlayingContainer.querySelector(".timeLeft").textContent = "Time Left: N/A";
        };
        // Set up artwork cover for playback toggle
        const setupArtworkCover = () => {
            document.addEventListener("DOMContentLoaded", () => {
                const artworkCover = document.getElementById("artworkCover");
                const artworkImage = document.getElementById("artworkImage");
                const loadingSpinner = document.getElementById("loadingSpinner");
    
                if (globalData.isArtworkCover && artworkUrl.length) {
                    artworkImage.src = artworkUrl[0];
                    artworkCover.classList.remove("hidden");
                    loadingSpinner.style.display = "none";
                    artworkImage.addEventListener("click", globalData.togglePlayback);
                    console.log("Artwork cover is set up for playback toggle.");
                } else {
                    console.warn("Artwork cover is not enabled or no artwork URL provided.");
                }
            });
        };
    
        // Event listener for initial audio buffers ready
        document.addEventListener("initialAudioBuffersReady", (event) => {
            if (event.detail.success) {
                globalData.initializePlaybackEngine();
                console.log("Initial audio buffers are ready.");
            }
        });
    
        // Event listeners for playback started and stopped
        ["playbackStarted", "playbackStopped"].forEach((eventType) => {
            document.addEventListener(eventType, (event) => {
                if (event.detail.success) {
                    console.log(`Playback has been successfully ${eventType === "playbackStarted" ? "started" : "stopped"}.`);
                }
            });
        });
    
        // Initialize artwork cover setup
        setupArtworkCover();
    
        // Initialize playback engine if audio buffers are already loaded
        if (Object.keys(globalData.audioBuffers).length) {
            globalData.initializePlaybackEngine();
        }
    })();
    </script>




</body>
</html>


