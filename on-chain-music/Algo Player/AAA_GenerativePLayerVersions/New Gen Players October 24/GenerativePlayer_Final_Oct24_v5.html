
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Audionals - Web3 Music Player</title>


<link rel="stylesheet" href="/content/7a309a161e838ba93740684338b3d97f3c1226c046d8b1137afc2353b4bf16e1i0">

<style>
    /* Enhanced CSS with CSS Variables and Distinct IDs */

    :root {
        --seed-panel-bg-color: #333;
        --seed-panel-text-color: #fff;
        --track-list-panel-bg-color: #444;
        --track-list-panel-text-color: #fff;
        --button-bg-color: #444;
        --button-hover-bg-color: #555;
        --button-active-bg-color: #777;
        --button-text-color: #fff;
        --input-bg-color: #555;
        --input-text-color: #fff;
        --border-radius: 8px;
        --padding: 10px;
        --box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        --transition-duration: 0.3s;
    }

    /* Seed Management Panel */
    #seed-management-panel {
        position: fixed;
        top: 10px;
        right: 10px;
        width: 320px;
        background-color: var(--seed-panel-bg-color);
        color: var(--seed-panel-text-color);
        padding: var(--padding);
        border-radius: var(--border-radius);
        z-index: 10000;
        box-shadow: var(--box-shadow);
        transition: all var(--transition-duration) ease;
    }

    #seed-management-panel.hidden {
        display: none;
    }

    /* Canvas Styling */
    #info-canvas {
        width: 100%;
        height: 100px;
        border: 1px solid #555;
        border-radius: 4px;
        background-color: #222;
    }

    /* Previous Seeds Container */
    #previous-seeds-container ul {
        list-style-type: none;
        padding: 0;
    }

    #previous-seeds-container li {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
    }

    #previous-seeds-container button {
        margin-left: 10px;
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
        border: none;
        border-radius: 4px;
        padding: 3px 6px;
        cursor: pointer;
        transition: background-color var(--transition-duration) ease;
    }

    #previous-seeds-container button:hover {
        background-color: var(--button-hover-bg-color);
    }

    /* Seed Input */
    #seed-input {
        width: calc(100% - 20px);
        padding: 5px;
        margin-top: 10px;
        border: 1px solid #555;
        border-radius: 4px;
        background-color: var(--input-bg-color);
        color: var(--input-text-color);
        transition: border 0.2s ease;
    }

    #seed-input:focus {
        border: 2px solid #00f;
        outline: none;
    }

    /* Load and Clear Buttons */
    #load-seed-button,
    #clear-seeds-button {
        margin-top: 5px;
        padding: 5px 10px;
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color var(--transition-duration) ease;
    }

    #load-seed-button:hover,
    #clear-seeds-button:hover {
        background-color: var(--button-hover-bg-color);
    }

    #load-seed-button:active,
    #clear-seeds-button:active {
        background-color: var(--button-active-bg-color);
    }

    /* Track List Panel */
    #track-list-panel {
        position: fixed;
        bottom: 10px;
        left: 10px;
        width: 300px;
        background-color: var(--track-list-panel-bg-color);
        color: var(--track-list-panel-text-color);
        padding: var(--padding);
        border-radius: var(--border-radius);
        z-index: 10000;
        box-shadow: var(--box-shadow);
        transition: all var(--transition-duration) ease;
    }

    #track-list-panel.hidden {
        display: none;
    }

        /* Responsive Design */
        @media (max-width: 600px) {
        #seed-management-panel {
            width: 90%;
            left: 5%;
            right: 5%;
            top: 10px;
        }


    }



    /* Other Elements Styling */
    #loadingSpinner {
    z-index: 1000;   
    }

    #artworkCover img {
        max-width: 100%;
        height: auto;
        border-radius: 4px;
    }



    #buttonContainer button {
        padding: 10px 15px;
        margin: 5px;
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color var(--transition-duration) ease;
    }

    #buttonContainer button:hover {
        background-color: var(--button-hover-bg-color);
    }


    /* Focus Styles for Accessibility */
    #load-seed-button:focus,
    #clear-seeds-button:focus,
    #previous-seeds-container button:focus,
    #buttonContainer button:focus {
        outline: 2px solid #00f;
    }
</style>
<script>
    // Function to toggle Seed Management Panel
    function toggleSeedManagementPanel() {
        const seedPanel = document.getElementById('seed-management-panel');
        if (seedPanel) {
            seedPanel.classList.toggle('hidden');
        } else {
            console.error("Seed Management Panel not found.");
        }
    }

    // Function to toggle General Info Panel
    function toggleTrackListPanel() {
        const infoPanel = document.getElementById('track-list-panel');
        if (infoPanel) {
            infoPanel.classList.toggle('hidden');
        } else {
            console.error("Track List Panel not found.");
        }
    }

    // Listener to toggle Seed Management Panel when 's' key is pressed
    document.addEventListener('keydown', function(event) {
        if (event.key === 's' || event.key === 'S') {
            toggleSeedManagementPanel();
        }
    });

    // Function to populate the track list
    function populateTrackList() {
        const trackListContainer = document.getElementById('track-list-container');
        trackListContainer.innerHTML = ''; // Clear any existing tracks

        if (globalData.songsArray && globalData.songsArray.length > 0) {
            globalData.songsArray.forEach((song, index) => {
                const trackItem = document.createElement('div');
                trackItem.classList.add('track-item');
                trackItem.innerHTML = `
                    <div class="track-name"> ${song.id}</div>
                    <div class="track-artist">${song.artist}</div>`;
                trackListContainer.appendChild(trackItem);
            });
        } else {
            const noTracksMessage = document.createElement('div');
            noTracksMessage.textContent = "No tracks available.";
            trackListContainer.appendChild(noTracksMessage);
        }
    }

    // Function to toggle Track List Panel and populate the list
    function toggleTrackListAndPopulate() {
        toggleTrackListPanel();
        if (!document.getElementById('track-list-panel').classList.contains('hidden')) {
            populateTrackList();
        }
    }
</script>


    
</head>
<body>
    <span class="songTitle">The Generative Ordinal</span>

    <h1>Audionals</h1>

    <!-- HTML Structure for Seed Management -->
    <div id="seed-management-panel" class="hidden" role="dialog" aria-labelledby="seed-panel-title" aria-hidden="true">
        <h2 id="seed-panel-title">Seed Management</h2>
        <canvas id="info-canvas" width="300" height="100" aria-label="Seed and BPM Information"></canvas>
        <div id="previous-seeds-container">
            <ul>
                <!-- Previous seeds will be dynamically inserted here -->
            </ul>
        </div>
        <input type="text" id="seed-input" placeholder="Enter Seed" aria-label="Enter Seed">
        <button id="load-seed-button" aria-label="Load Seed">Load Seed</button>
        <button id="clear-seeds-button" aria-label="Clear Previous Seeds">Clear Previous Seeds</button>
    </div>

    <div id="loadingSpinner"></div>
    <div id="artworkCover">
      <img id="artworkImage" src="" alt="Artwork Cover">
    </div>
    <div id="trackListingPanel">
        <h2>Track Listings:</h2>
        <div id="metadataContent"></div>
    </div>
    <div id="nowPlayingContainer">
        <span class="Title">The Infinite Ordinal Remix</span>
        <!-- Display the Currently Playing Song here need the generative remix number -->
      </div>
    </div>
    <div id="buttonContainer">
      <button id="playButton" onclick="globalData.togglePlayback()" aria-label="Play or Stop Music">Play / Stop</button>
      <button id="prevButton" onclick="globalData.previousSong()" aria-label="Previous Song">Previous</button>
      <button id="nextButton" onclick="globalData.nextSong()" aria-label="Next Song">Next</button>
      <button id="toggle-track-panel-button" onclick="toggleTrackListAndPopulate()" aria-label="Toggle Track List Panel">Track List</button>
      <button id="toggle-seed-panel-button" onclick="toggleSeedManagementPanel()" aria-label="Toggle Seed Management Panel">Seed Panel</button>
    </div>

    <!-- Track List Panel -->
    <div id="track-list-panel" class="hidden" role="dialog" aria-labelledby="track-list-title" aria-hidden="true">
        <h2 id="track-list-title">Track List</h2>
        <div id="track-list-container">
            <!-- Tracks will be dynamically inserted here -->
        </div>
    </div>


    <script>
        // songsAndArtwork.js ADDED TO TEMPORARILY LOAD LESS SONGS
        
        // Artwork URL
        const artworkUrl = [
            "/content/01c48d3cceb02215bc3d44f9a2dc7fba63ea63719a2ef1c35d3f0c4db93ab8d5i0"
        ];
        
        // Song Data URLs
        const songDataUrls = [
            "/content/6d288c0c82653001bb32497889dd1486e8afec9b0671a95fa9e10f99c20737bbi0", // Kora Algo New
            "/content/5527d0cc95ce5ce6eedf4e275234da8b1fe087512d0db618b6de1aaad437c96bi0", // TRUTH
            "/content/b22f1c85371b58a9cdac19b2baa50b1f9025a28d44cdfaad539d0527aa7d894ei0", // On Chain in the Membrane
            "/content/a4fb0b49181975450a6710f20128eb0b3acc51f4aa1ce87ebdbc9607562013a2i0", // Minty Fresh
            "/content/633100d631767ddb9a309f5a2a66f5a66d5abd839f3b1c55642690d484189971i0", // On Day One
            "/content/5ee46b8f645a65b0ec8ae749a28f88e364347f89137bb79986355bf5fb94cbebi0", // Fiat Money // ** ONLY 2 SEQUENCES LONG
            "/content/78c254c23d4da7d2379358590e74cf5452147702e2f293b3c3bf40f51d5ee0fdi0", // Butterfly Effect
            "/content/8aec0a99a5617b9da98a5b63a11a5143f0cac3cfa662d9515c2285de03ef95d4i0", // Cheese
            "/content/9dfa1812b211a7ac8b2f9e77119828ec8fbf2e9016b3d37a8efd70052eb4aa3ci0", // Bear Market Disco
            "/content/c41de57f1e062a440a9fc96d54baaccd7ec40049f48e9f3880559afc60b1b09ai0", // Did You Know // ** ONLY 2 SEQUENCES LONG
            "/content/119a3ccd1dfd7e987cca139f86d16717d845a22dd6afc59ad492527b95ae9a91i0", // MLK
            "/content/db9131cfe8e933e8e639f007dcd2b582a80bfd2be42b0eafa4d2e206332d6785i0", // Modern Progress
            "/content/07ff7bdc47e5272a3ff55cc46d2b189d510562a057a2c24112f3d0376950484di0", // Choppin' It Up
            "/content/fb0d2abcd1fa5bf2622579f0990435b48d41291f71626fc2e36a93e6ea6b3b85i0", // Humanity
            "/content/85436950f53c57aa0c510071d2d5f1c187e1d21e4e57210fcae152c4c7b6a768i0", // Rhythm and Bass 240
            "/content/e3ca12dd7516b4e486af4e3fa7f4ebc535d825034ff3c9da4954f354572dcf61i0", // Crazy Ass Bitch
            "/content/d0496a8e1657ce470807c8d47dcb5f1018a32d8ec8e50d490ad49411ffee1457i0", // Rhythm and Bass 60
            "/content/776fdd58a85170df78d41ca838287cc41404a4ab5398ff1333bcdcb79a5e6151i0"  // Rainbow
        ];
        
        // Project Artist Mapping
        window.projectArtistMap = {
            "I Love Cheese 2024 FINAL": "Rex Speedway and The Denim Avengers + jim.btc",
            "TRUTH": "melophonic",
            "Kora Algo New": "melophonic",
            "MLK 120": "Audionals",
            "Modern Progress Vocal": "Audionals",
            "Choppin' It Up": "Audionals",
            "HUMANITY": "Audionals",
            "Minty Fresh v2": "melophonic + Rare Scrilla",
            "How We Be - Based": "Based.btc",
            "Rhythm and Bass": "Audionals",
            "CrazyAssBitch": "French Montana + Audionals",
            "Rhythm and Bass @60": "Audionals",
            "On-Chain in the Membrane": "melophonic",
            "FIAT MONEY": "Solemn",
            "didd you know 1": "Solemn",
            "Bear Market Disco": "Based.btc",
            "Butterfly Effect": "Based.btc",
            "FREEDOM TO TRANSACT REMIX": "melophonic"
        };
        </script>

<!-- Audio Context Created Here in Global Data-->
<script src="/content/e8496fa0bcb3cad6bc173cd1ef2564b9548b43b306634bdafce47083efd7619ai0"></script> 


<!-- Include the Seed and BPM Manager Script Early in Your HTML -->
<script id="seedAndBpmManagement">
    (function() {
        /**
         * Seeded PRNG using Mulberry32 algorithm.
         * @param {number} a - Seed number.
         * @returns {function} - PRNG function.
         */
        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            }
        }

        /**
         * Seed and BPM Manager
         */
        window.SeedAndBpmManager = (function() {
            // Utility Functions
            function getQueryParam(param) {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get(param);
            }

            function generateSeed() {
                const fixedSeed = window.fixedSeed;
                if (typeof fixedSeed === "string" && fixedSeed.length > 0) {
                    return fixedSeed;
                }
                return Array.from({ length: 20 }, () => Math.floor(Math.random() * 10)).join("");
            }

            function log(message) {
                console.log(`[${new Date().toISOString()}] ${message}`);
            }

            // Initialize fixedSeed from query parameter if available
            const seedFromURL = getQueryParam('seed') || "";
            window.fixedSeed = seedFromURL;

            log("Generating new seed...");
            const newSeed = generateSeed();
            log(`New seed generated: ${newSeed}`);

            Object.defineProperty(window, "seed", {
                value: newSeed,
                writable: false,
                configurable: false,
                enumerable: true
            });

            // Initialize PRNG with a numerical seed derived from the newSeed
            // For simplicity, use the first 8 digits of the seed as the seed number
            const prngSeedNumber = parseInt(newSeed.slice(0, 8), 10) || 0;
            log(`Initializing PRNG with seed number: ${prngSeedNumber}`);
            const prng = mulberry32(prngSeedNumber);

            // Seed to BPM Mapping
            const bpmOptions = [80, 100, 120, 140, 160, 180, 240];
            function mapSeedToBpm(seed) {
                const hash = seed.split("").reduce((acc, char) => {
                    return (10 * acc + parseInt(char, 10)) % 1000000007;
                }, 0);
                const selectedBpm = bpmOptions[hash % bpmOptions.length];
                log(`Seed: ${seed}, Hash: ${hash}, Selected BPM: ${selectedBpm}`);
                return selectedBpm;
            }

            const bpm = mapSeedToBpm(newSeed);

            // Seed History Management
            function loadPreviousSeeds() {
                const previousSeeds = JSON.parse(localStorage.getItem("previousSeeds")) || [];
                displayPreviousSeeds(previousSeeds);
                return previousSeeds;
            }

            function saveSeed(seed) {
                const previousSeeds = loadPreviousSeeds();
                if (!previousSeeds.includes(seed)) {
                    previousSeeds.push(seed);
                    localStorage.setItem("previousSeeds", JSON.stringify(previousSeeds));
                    displayPreviousSeeds(previousSeeds);
                }
            }

            function displayPreviousSeeds(seeds) {
                const previousSeedsContainer = document.getElementById("previous-seeds-container");
                if (!previousSeedsContainer) {
                    log("Previous seeds container element not found.");
                    return;
                }

                previousSeedsContainer.innerHTML = "";

                const seedList = document.createElement("ul");

                seeds.forEach(seed => {
                    const listItem = document.createElement("li");
                    listItem.textContent = seed;

                    const copyButton = document.createElement("button");
                    copyButton.textContent = "Copy";
                    copyButton.onclick = () => copyToClipboard(seed);
                    listItem.appendChild(copyButton);

                    seedList.appendChild(listItem);
                });

                previousSeedsContainer.appendChild(seedList);
            }

            function copyToClipboard(seed) {
                navigator.clipboard.writeText(seed).then(() => {
                    alert("Seed copied to clipboard: " + seed);
                }).catch(err => {
                    console.error("Could not copy text: ", err);
                });
            }

            function clearPreviousSeeds() {
                if (confirm("Are you sure you want to clear all previous seeds?")) {
                    localStorage.removeItem("previousSeeds");
                    displayPreviousSeeds([]);
                }
            }


            // Display Seed and BPM on Canvas
            function displaySeedAndBPM(seed, bpm) {
                const infoCanvas = document.getElementById("info-canvas");
                if (!infoCanvas) {
                    log("Info canvas element not found.");
                    return;
                }
                const ctx = infoCanvas.getContext("2d");

                // Clear the canvas before drawing
                ctx.clearRect(0, 0, infoCanvas.width, infoCanvas.height);

                // Draw background rectangles
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--seed-bg-color') || 'green';
                ctx.fillRect(0, 0, infoCanvas.width, infoCanvas.height / 2);

                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bpm-bg-color') || 'orange';
                ctx.fillRect(0, infoCanvas.height / 2, infoCanvas.width, infoCanvas.height / 2);

                // Set text properties for Seed
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-color') || 'white';
                ctx.font = `${getComputedStyle(document.documentElement).getPropertyValue('--font-size') || '16px'} Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(`Seed: ${seed}`, infoCanvas.width / 2, infoCanvas.height / 4);

                // Set text properties for BPM
                ctx.fillText(`BPM: ${bpm}`, infoCanvas.width / 2, (3 * infoCanvas.height) / 4);

                // Save the seed to local storage
                saveSeed(seed);
            }

            // Initialize Info Panel
            function initializeInfoPanel() {
                const infoPanel = document.getElementById("info-panel");
                if (!infoPanel) {
                    log("Info panel element not found.");
                    return;
                }
                const isHidden = localStorage.getItem("infoPanelHidden") === "true";
                if (isHidden) {
                    infoPanel.classList.add("hidden");
                }
            }

            // Setup Event Listeners
            function setupEventListeners() {
                window.addEventListener("DOMContentLoaded", () => {
                    displaySeedAndBPM(newSeed, bpm);
                    loadPreviousSeeds();
                });



                const clearSeedsButton = document.getElementById("clear-seeds-button");
                if (clearSeedsButton) {
                    clearSeedsButton.addEventListener("click", clearPreviousSeeds);
                }

                const loadSeedButton = document.getElementById("load-seed-button");
                if (loadSeedButton) {
                    loadSeedButton.addEventListener("click", () => {
                        const seedInput = document.getElementById("seed-input").value.trim();
                        if (seedInput.length === 0) {
                            alert("Please enter a seed.");
                            return;
                        }
                        if (!/^\d+$/.test(seedInput)) {
                            alert("Seed must be numeric.");
                            return;
                        }
                        const url = new URL(window.location.href);
                        url.searchParams.set('seed', seedInput);
                        window.location.href = url.toString();
                    });
                }
            }

            // Increment Seed and Reload
            function incrementSeedAndReload() {
                let currentSeedInt = parseInt(window.seed, 10);
                if (isNaN(currentSeedInt)) {
                    currentSeedInt = 0;
                }
                const newSeedInt = currentSeedInt + 1;
                window.fixedSeed = newSeedInt.toString();

                const url = new URL(window.location.href);
                url.searchParams.set('seed', window.fixedSeed);
                window.location.href = url.toString();
            }

            // Initialize Info Panel and Event Listeners
            initializeInfoPanel();
            setupEventListeners();

            return {
                seed: newSeed,
                bpm: bpm,
                getRandom: prng,
                incrementSeedAndReload: incrementSeedAndReload,
                generateAdditionalSeed: function() {
                    const additionalSeed = generateSeed();
                    log(`Generating additional seed: ${additionalSeed}`);
                    return additionalSeed;
                }
            };
        })();
    })();
</script>


<!-- Effects Configuration Script (effects.js) -->
<script>
    (function() {
        console.log("[EffectsModule] Script started.");

        // Define the EffectsModule namespace
        window.EffectsModule = window.EffectsModule || {};

        window.EffectsModule.effectsConfig = { 
            pitchShift: { 
                enabled: true, 
                defaultProbability: 1, 
                shifts: [0.25, 0.5, 1, 2, 4],
                sequenceConfig: {}
            },
            harmonize: { 
                enabled: true, 
                defaultProbability: 0.02, 
                intervals: [1.2599, 1.4983],
                maxHarmonyChannels: 2,
                sequenceConfig: {}
            },
            delay: {
                enabled: true, 
                defaultProbability: 1, 
                noteValue: 'quarter',
                maxDelayRepeats: 16,
                sequenceConfig: {}
            },
            reverse: {
                enabled: true, 
                defaultProbability: 1,
                sequenceConfig: {}
            },
            volumeChange: {
                enabled: false,
                defaultProbability: 0.0,
                range: [0.5, 1.5],
                sequenceConfig: {}
            },
            pan: {
                enabled: true,
                defaultProbability: 1,
                positions: [-1, 1],
                sequenceConfig: {}
            },
            reverb: {
                enabled: true, 
                defaultProbability: 1, 
                decayTimeRange: [2, 7], 
                mixRange: [0.3, 0.9],
                sequenceConfig: {}
            },
            filter: {
                enabled: true, 
                defaultProbability: 0.7, 
                types: ['lowpass', 'highpass', 'bandpass'], 
                frequencyRange: [300, 8000], 
                QRange: [1, 10],
                sequenceConfig: {}
            },
            tremolo: {
                enabled: true, 
                defaultProbability: 0.6, 
                rateRange: [4, 12],   
                depthRange: [0.6, 1], 
                sequenceConfig: {}
            },
            distortion: {
                enabled: true, 
                defaultProbability: 0.5, 
                amountRange: [1, 15], 
                sequenceConfig: {}
            },
            bitcrusher: {
                enabled: true, 
                defaultProbability: 0.3, 
                bitDepthRange: [2, 6],    
                sampleRateRange: [8000, 22050], 
                sequenceConfig: {}
            },
            // Add more effects as needed
        };

        /**
         * Helper function to get effect parameters based on current sequence.
         * @param {string} effectName - Name of the effect.
         * @param {number} currentSequence - The current sequence number.
         * @returns {object|null} - Effect parameters or null if not applied.
         */
        window.EffectsModule.getEffectParams = function(effectName, currentSequence) {
            const effect = window.EffectsModule.effectsConfig[effectName];
            if (!effect || !effect.enabled) return null;

            let seqConfig = effect.sequenceConfig && effect.sequenceConfig[currentSequence];
            let probability = seqConfig ? seqConfig.probability : effect.defaultProbability;

            if (Math.random() < probability) {
                return { ...effect, ...seqConfig };
            }
            return null;
        };

        console.log("[EffectsModule] Effects configuration loaded.");

        // Dispatch an event to signal that the effects configuration is loaded
        document.dispatchEvent(new Event('effectsLoaded'));
    })();
</script>


<!-- Main Script (main.js) -->
<script>
    (async () => {
        console.log("[MainScript] Script started.");

        /**
         * Waits for the 'effectsLoaded' event if the EffectsModule is not yet available.
         */
        function waitForEffects() {
            return new Promise((resolve) => {
                if (window.EffectsModule && window.EffectsModule.effectsConfig) {
                    resolve();
                } else {
                    document.addEventListener('effectsLoaded', resolve, { once: true });
                }
            });
        }

        // Wait for the effects configuration to be loaded
        await waitForEffects();
        console.log("[MainScript] Effects configuration is available.");

        // Now you can safely use EffectsModule.effectsConfig and EffectsModule.getEffectParams

        // Define the list of loop sample IDs
        const loopSampleIds = new Set([
            "7c42769c1763cc8f045aada7914e8158223e45e7a4f197b49f918b1c005d36fci0", // Minty Fresh - Channel F
            "3364803cb3032ce95f4138a214c15a9b36dcb70f574a477f27615d448e1cdeb8i0", // I love cheese - Channel 4/E
        ]);

        const keyNames = [
            "projectName",
            "artistName",
            "projectBPM",
            "currentSequence",
            "channelURLs",
            "channelVolume",
            "channelPlaybackSpeed",
            "trimSettings",
            "projectChannelNames",
            "startSliderValue",
            "endSliderValue",
            "totalSampleDuration",
            "start",
            "end",
            "projectSequences",
            "steps"
        ];

        const keyMap = keyNames.reduce((map, key, index) => {
            map[key] = index;
            return map;
        }, {});

        const channelIds = Array.from({ length: 16 }, (_, index) => String.fromCharCode(65 + index));
        const channelIdMap = channelIds.reduce((map, id, index) => {
            map[id] = index;
            return map;
        }, {});

        /**
         * Fetches, decompresses, and processes song data from a given URL.
         * @param {string} url - The URL to fetch the song data from.
         * @returns {object} - The processed song data.
         */
        const fetchAndProcessSongData = async (url) => {
            console.log(`[Initialization] Fetching and processing data from URL: ${url}`);

            try {
                const response = await fetch(url);

                if (!response.ok) throw new Error(`Network error for ${url}`);

                const compressedData = new Uint8Array(await response.arrayBuffer());
                const inflatedData = window.pako.inflate(compressedData);

                const jsonString = new TextDecoder("utf-8").decode(inflatedData);
                const parsedData = JSON.parse(jsonString);

                const processParsedData = (data) => {
                    const recurse = (obj) => {
                        if (Array.isArray(obj)) {
                            return obj.map(recurse);
                        } else if (obj && typeof obj === "object") {
                            return Object.entries(obj).reduce((accumulator, [key, value]) => {
                                const mappedKey = keyNames[key] || key;
                                accumulator[mappedKey] = mappedKey === "projectSequences"
                                    ? Object.fromEntries(
                                        Object.entries(value).map(([seqKey, seqValue]) => {
                                            const sequenceName = `Sequence${seqKey.replace(/^s/, "")}`;
                                            const channels = Object.fromEntries(
                                                Object.entries(seqValue).map(([channelKey, channelValue]) => {
                                                    const steps = channelValue[keyMap.steps] || [];
                                                    const processedSteps = steps.flatMap((step) => {
                                                        if (typeof step === "number") {
                                                            return step;
                                                        } else if (step?.r) {
                                                            const [start, end] = step.r;
                                                            return Array.from({ length: end - start + 1 }, (_, idx) => start + idx);
                                                        } else if (typeof step === "string" && step.endsWith("r")) {
                                                            return { index: parseInt(step.slice(0, -1), 10), reverse: true };
                                                        } else {
                                                            return [];
                                                        }
                                                    });
                                                    return [`ch${channelIdMap[channelKey]}`, { steps: processedSteps }];
                                                })
                                            );
                                            return [sequenceName, channels];
                                        })
                                    )
                                    : recurse(value);
                                return accumulator;
                            }, {});
                        } else {
                            return obj;
                        }
                    };
                    return recurse(data);
                };

                const processedData = processParsedData(parsedData);

                return processedData;

            } catch (error) {
                console.error(`[Initialization] Error fetching/deserializing ${url}:`, error);
                throw error;
            }
        };

        /**
         * Prepares the initial sample order for the song.
         * @param {object} songData - The song data object.
         * @returns {Array} - The initial sample order array.
         */
        const prepareInitialSampleOrder = (songData) => {
            const { projectSequences } = songData;
            const sampleOrder = [];

            Object.keys(projectSequences)
                .sort((a, b) => {
                    const numA = parseInt(a.replace('Sequence', ''), 10);
                    const numB = parseInt(b.replace('Sequence', ''), 10);
                    return numA - numB;
                })
                .forEach((sequenceKey) => {
                    const sequence = projectSequences[sequenceKey];

                    Object.entries(sequence)
                        .forEach(([channelId, channelData]) => {
                            const { steps } = channelData;

                            steps.forEach((step) => {
                                if (typeof step === "number" || (typeof step === "object" && step.index !== undefined)) {
                                    const identifier = `${channelId}_${step.reverse ? "r" : "f"}`;
                                    if (!sampleOrder.some((item) => `${item.channelId}_${item.reverse ? "r" : "f"}` === identifier)) {
                                        sampleOrder.push({
                                            channelId: channelId,
                                            reverse: step.reverse || false
                                        });
                                    }
                                }
                            });
                        });
                });

            return sampleOrder;
        };

        /**
         * Sets the artwork image on the page.
         * @param {string} url - The URL of the artwork image.
         */
        const setArtworkImage = (url) => {
            const artworkElement = document.getElementById("artworkImage");
            if (artworkElement) {
                artworkElement.src = url;
                artworkElement.parentElement.style.display = "flex";
                console.log("[Initialization] Artwork image set and displayed.");
            } else {
                console.warn("[Initialization] Artwork cover elements not found.");
            }
        };

        // --- Effect Application Functions ---

        /**
         * Applies a random pitch shift to the channel based on the effect parameters.
         */
        function applyRandomPitchShift(channel, effectParams) {
            const shifts = effectParams.shifts;
            const shift = shifts[Math.floor(Math.random() * shifts.length)];
            const originalSpeed = channel.metadata.playbackSpeed;
            channel.metadata.playbackSpeed *= shift;
            console.log(`[effectsDebug] Pitch shifted channel ${channel.id} from ${originalSpeed.toFixed(2)}x to ${channel.metadata.playbackSpeed.toFixed(2)}x`);
        }

        /* Adds harmony channels by duplicating the original channel and applying pitch shifts.
         */
        function addHarmony(originalChannel, index, newSong, effectParams, effectsContext) {
            if (effectsContext.harmonyChannelsAdded >= effectParams.maxHarmonyChannels) {
                console.log(`[effectsDebug] Maximum harmony channels reached for song ${newSong.id}`);
                return;
            }

            effectParams.intervals.forEach(interval => {
                if (effectsContext.harmonyChannelsAdded >= effectParams.maxHarmonyChannels) return;

                const harmonyChannel = JSON.parse(JSON.stringify(originalChannel)); // Deep clone
                harmonyChannel.id = `${originalChannel.id}_harmony_${index}_${interval}`; // Unique ID
                const originalSpeed = harmonyChannel.metadata.playbackSpeed;
                harmonyChannel.metadata.playbackSpeed *= interval;
                harmonyChannel.metadata.volume = (harmonyChannel.metadata.volume || 1) * 0.8; // Reduce volume to prevent overdrive
                newSong.channels.push(harmonyChannel);
                effectsContext.harmonyChannelsAdded++;

                console.log(`[effectsDebug] Added harmony channel ${harmonyChannel.id} with playback speed changed from ${originalSpeed.toFixed(2)}x to ${harmonyChannel.metadata.playbackSpeed.toFixed(2)}x (Interval factor: ${interval})`);
            });
        }

        /**
         * Applies delay to the channel based on the effect parameters.
         */
        function applyIntermittentDelay(channel, effectParams, bpm) {
            const delayTime = calculateDelayTime(bpm, effectParams.noteValue);
            channel.metadata.delay = {
                time: delayTime,
                repeats: effectParams.maxDelayRepeats
            };
            console.log(`[effectsDebug] Applied delay to channel ${channel.id} with time ${delayTime}ms and repeats ${effectParams.maxDelayRepeats}`);
        }

        /**
         * Calculates delay time based on BPM and note value.
         */
        function calculateDelayTime(bpm, noteValue = 'quarter') {
            const beatDuration = 60000 / bpm; // Duration of one beat in ms
            const delayMap = {
                'quarter': beatDuration,
                'eighth': beatDuration / 2,
                'sixteenth': beatDuration / 4
            };
            return delayMap[noteValue] || beatDuration;
        }

        /**
         * Applies reverse effect to the channel.
         */
        function applyReverseEffect(channel, effectParams) {
            channel.metadata.requiresReversal = true;
            console.log(`[effectsDebug] Reversed channel ${channel.id}`);
        }

        /**
         * Applies volume change to the channel.
         */
        function applyVolumeChange(channel, effectParams) {
            const [minVolume, maxVolume] = effectParams.range;
            const volumeMultiplier = Math.random() * (maxVolume - minVolume) + minVolume;
            const originalVolume = channel.metadata.volume || 1;
            channel.metadata.volume = originalVolume * volumeMultiplier;
            console.log(`[effectsDebug] Changed volume of channel ${channel.id} from ${originalVolume.toFixed(2)} to ${channel.metadata.volume.toFixed(2)}`);
        }

        /**
         * Applies panning to the channel.
         */
        function applyPanEffect(channel, effectParams) {
            const positions = effectParams.positions;
            const panPosition = positions[Math.floor(Math.random() * positions.length)];
            channel.metadata.pan = panPosition;
            console.log(`[effectsDebug] Applied pan of ${panPosition} to channel ${channel.id}`);
        }

        /**
         * Applies reverb effect to the channel.
         */
        function applyReverbEffect(channel, effectParams) {
            const [minDecay, maxDecay] = effectParams.decayTimeRange;
            const decayTime = Math.random() * (maxDecay - minDecay) + minDecay;
            const [minMix, maxMix] = effectParams.mixRange;
            const mix = Math.random() * (maxMix - minMix) + minMix;
            channel.metadata.reverb = {
                decayTime: decayTime,
                mix: mix
            };
            console.log(`[effectsDebug] Applied reverb to channel ${channel.id} with decay time ${decayTime.toFixed(2)}s and mix ${mix.toFixed(2)}`);
        }

        /**
         * Applies filter effect to the channel.
         */
        function applyFilterEffect(channel, effectParams) {
            const filterType = effectParams.types[Math.floor(Math.random() * effectParams.types.length)];
            const [minFreq, maxFreq] = effectParams.frequencyRange;
            const cutoffFrequency = Math.random() * (maxFreq - minFreq) + minFreq;
            const [minQ, maxQ] = effectParams.QRange;
            const Q = Math.random() * (maxQ - minQ) + minQ;
            channel.metadata.filter = {
                type: filterType,
                frequency: cutoffFrequency,
                Q: Q
            };
            console.log(`[effectsDebug] Applied ${filterType} filter to channel ${channel.id} with cutoff frequency ${cutoffFrequency.toFixed(2)}Hz and Q factor ${Q.toFixed(2)}`);
        }

        /**
         * Applies tremolo effect to the channel.
         */
        function applyTremoloEffect(channel, effectParams) {
            const [minRate, maxRate] = effectParams.rateRange;
            const rate = Math.random() * (maxRate - minRate) + minRate;
            const [minDepth, maxDepth] = effectParams.depthRange;
            const depth = Math.random() * (maxDepth - minDepth) + minDepth;
            channel.metadata.tremolo = {
                rate: rate,
                depth: depth
            };
            console.log(`[effectsDebug] Applied tremolo to channel ${channel.id} with rate ${rate.toFixed(2)}Hz and depth ${depth.toFixed(2)}`);
        }

        /**
         * Applies distortion effect to the channel.
         */
        function applyDistortionEffect(channel, effectParams) {
            const [minAmount, maxAmount] = effectParams.amountRange;
            const amount = Math.random() * (maxAmount - minAmount) + minAmount;
            channel.metadata.distortion = {
                amount: amount
            };
            console.log(`[effectsDebug] Applied distortion to channel ${channel.id} with amount ${amount.toFixed(2)}`);
        }

        /**
         * Applies bitcrusher effect to the channel.
         */
        function applyBitcrusherEffect(channel, effectParams) {
            const [minBitDepth, maxBitDepth] = effectParams.bitDepthRange;
            const bitDepth = Math.floor(Math.random() * (maxBitDepth - minBitDepth + 1)) + minBitDepth;
            const [minSampleRate, maxSampleRate] = effectParams.sampleRateRange;
            const sampleRate = Math.random() * (maxSampleRate - minSampleRate) + minSampleRate;
            channel.metadata.bitcrusher = {
                bitDepth: bitDepth,
                sampleRate: sampleRate
            };
            console.log(`[effectsDebug] Applied bitcrusher to channel ${channel.id} with bit depth ${bitDepth} and sample rate ${sampleRate.toFixed(0)}Hz`);
        }

        /**
         * Applies enabled effects to the channel based on current sequence and BPM.
         * Includes checks to prevent overdriving and infinite loops.
         */
        function applyEffects(channel, index, newSong, currentSequence, bpm, effectsContext) {
            let effectParams;

            // Apply Pitch Shift
            effectParams = window.EffectsModule.getEffectParams('pitchShift', currentSequence);
            if (effectParams) {
                applyRandomPitchShift(channel, effectParams);
            }

            // Apply Harmonization
            effectParams = window.EffectsModule.getEffectParams('harmonize', currentSequence);
            if (effectParams) {
                addHarmony(channel, index, newSong, effectParams, effectsContext);
            }

            // Apply Delay
            effectParams = window.EffectsModule.getEffectParams('delay', currentSequence);
            if (effectParams) {
                applyIntermittentDelay(channel, effectParams, bpm);
            }

            // Apply Reverse
            effectParams = window.EffectsModule.getEffectParams('reverse', currentSequence);
            if (effectParams) {
                applyReverseEffect(channel, effectParams);
            }

            // Apply Volume Change
            effectParams = window.EffectsModule.getEffectParams('volumeChange', currentSequence);
            if (effectParams) {
                applyVolumeChange(channel, effectParams);
            }

            // Apply Pan
            effectParams = window.EffectsModule.getEffectParams('pan', currentSequence);
            if (effectParams) {
                applyPanEffect(channel, effectParams);
            }

            // Apply Reverb
            effectParams = window.EffectsModule.getEffectParams('reverb', currentSequence);
            if (effectParams) {
                applyReverbEffect(channel, effectParams);
            }

            // Apply Filter
            effectParams = window.EffectsModule.getEffectParams('filter', currentSequence);
            if (effectParams) {
                applyFilterEffect(channel, effectParams);
            }

            // Apply Tremolo
            effectParams = window.EffectsModule.getEffectParams('tremolo', currentSequence);
            if (effectParams) {
                applyTremoloEffect(channel, effectParams);
            }

            // Apply Distortion
            effectParams = window.EffectsModule.getEffectParams('distortion', currentSequence);
            if (effectParams) {
                applyDistortionEffect(channel, effectParams);
            }

            // Apply Bitcrusher
            effectParams = window.EffectsModule.getEffectParams('bitcrusher', currentSequence);
            if (effectParams) {
                applyBitcrusherEffect(channel, effectParams);
            }

            // Adjust overall volume if cumulative gain exceeds threshold
            if (effectsContext.totalGain > effectsContext.maxTotalGain) {
                const reductionFactor = effectsContext.maxTotalGain / effectsContext.totalGain;
                channel.metadata.volume = (channel.metadata.volume || 1) * reductionFactor;
                console.log(`[effectsDebug] Adjusted volume of channel ${channel.id} to prevent overdrive.`);
            }

            // Update total gain
            effectsContext.totalGain += channel.metadata.volume || 1;
        }

        // [applyEffects function remains unchanged]

        try {
            const validSongDataUrls = songDataUrls.filter((url) => url.trim() && !url.trim().startsWith("//"));
            console.log(`[Initialization] Valid song data URLs count: ${validSongDataUrls.length}`);

            if (validSongDataUrls.length) {
                // Load Pako library if not already loaded
                if (!window.pako) {
                    await (async function loadPako() {
                        try {
                            const response = await fetch("/content/2109694f44c973892fb8152cf5c68607fb19288c045af1abc1716c1c3b4d69e6i0");
                            const textContent = await response.text();
                            const scriptElement = new DOMParser().parseFromString(textContent, "text/html").querySelector("script");

                            if (!scriptElement || !scriptElement.textContent.includes("pako")) {
                                throw new Error("Pako library not found.");
                            }

                            document.head.append(
                                Object.assign(document.createElement("script"), { textContent: scriptElement.textContent })
                            );
                            console.log("[Initialization] Pako library loaded successfully.");
                        } catch (error) {
                            console.error("[Initialization] Error loading Pako:", error);
                        }
                    })();
                }

                // Fetch and process song data from all URLs
                const songDataArray = await (async (urls) => {
                    const dataArray = await Promise.all(
                        urls.map((url, index) =>
                            fetchAndProcessSongData(url)
                                .then((data) => ({ data, index }))
                                .catch((error) => {
                                    console.error(`[Initialization] Failed ${url}:`, error);
                                    return null;
                                })
                        )
                    );
                    const validDataArray = dataArray.filter(Boolean);
                    if (!validDataArray.length) throw new Error("[Initialization] No valid data.");
                    return validDataArray;
                })(validSongDataUrls);

                // Process the song data into 'originalSongs'
                const originalSongs = songDataArray
                    .sort((a, b) => a.index - b.index)
                    .map(({ data, index }) => {
                        const {
                            projectName = `The Infinite Ordinal`,
                            artistName = "melophonic",
                            projectBPM = 120,
                            projectSequences = {},
                            channelURLs = [],
                            channelVolume = [],
                            channelPlaybackSpeed = [],
                            trimSettings = {}
                        } = data;

                        const channels = channelIds.map((id, idx) => {
                            const channelSequence = Object.entries(projectSequences).reduce((acc, [sequenceName, sequenceData]) => {
                                const channelData = sequenceData[`ch${idx}`];
                                if (channelData) {
                                    acc.push({
                                        sequenceName,
                                        steps: channelData.steps
                                    });
                                }
                                return acc;
                            }, []);

                            const metadata = {
                                volume: channelVolume[idx] ?? 1,
                                playbackSpeed: channelPlaybackSpeed[idx] ?? 1,
                                trimStartTime_Percentage: trimSettings[idx]?.start || 0,
                                trimEndTime_Percentage: trimSettings[idx]?.end || 100,
                                requiresReversal: channelSequence.some((seq) =>
                                    seq.steps.some((step) => typeof step === "object" && step.reverse)
                                ),
                                channelSequence,
                                originalBPM: projectBPM
                            };

                            const sampleId = channelURLs[idx];
                            if (loopSampleIds.has(sampleId)) {
                                metadata.isLoop = true;
                                // **Enhanced Logging: Loop Sample Included in Original Song**
                                const songId = `Song ${index + 1}: ${projectName}`;
                                console.log(`[effectsDebug] ID ${sampleId} is identified as a loop and has been included in song ${songId}`);
                            }

                            return {
                                id: id, // Channel ID (A-P)
                                url: sampleId || "URL_not_found",
                                metadata
                            };
                        });

                        const songId = `Song ${index + 1}: ${projectName}`;
                        const song = {
                            id: songId, // Including original song name in ID
                            artist: artistName,
                            bpm: projectBPM, // Including original BPM
                            totalSequences: Object.keys(projectSequences).length,
                            totalChannels: channels.length,
                            channels,
                            projectSequences
                        };

                        // **Log Each Original Song's Details Immediately After Processing**
                        console.log(`[Original Song Processed] ${song.id}`);
                        console.log(`Artist: ${song.artist}`);
                        console.log(`BPM: ${song.bpm}`);
                        console.log(`Total Sequences: ${song.totalSequences}`);
                        console.log(`Total Channels: ${song.totalChannels}`);
                        console.log("Channels and Metadata:");
                        song.channels.forEach(channel => {
                            console.log(`  Channel ID: ${channel.id}`);
                            console.log(`    URL: ${channel.url}`);
                            console.log(`    Metadata:`, channel.metadata);
                        });
                        console.log("---------------------------------------------------");

                        return song;
                    });




                    ///// PUTTING THE NEW SONGS TOGETHER STARTS HERE /////

                // Collect all channels from original songs
                const allChannels = [];
                originalSongs.forEach(song => {
                    song.channels.forEach(channel => {
                        allChannels.push(channel);
                    });
                });

                // Function to get random channels
                function getRandomChannels(channelsArray, num) {
                    const shuffled = channelsArray.slice().sort(() => 0.5 - Math.random());
                    return shuffled.slice(0, num);
                }

                /**
                 * Generates random mixes with dynamic BPM selection and custom rules for specific songs.
                 * Includes checks to prevent overdriving and infinite loops.
                 * @param {number} numMixes - The number of mixes to generate.
                 * @returns {Array} - The array of generated song objects.
                 */
                function generateRandomMixes(numMixes) {
                    const newSongs = [];
                    const bpmOptions = [60, 120, 140, 160, 180, 240];

                    for (let songIndex = 0; songIndex < numMixes; songIndex++) {
                        // Randomly select a BPM for this song
                        const selectedBPM = bpmOptions[Math.floor(Math.random() * bpmOptions.length)];

                        // Select 28 random channels
                        const randomChannels = getRandomChannels(allChannels, 28);

                        // Define activation points for general channels
                        const activationPoints = [
                            { startSeq: 1, count: 16 },   // Channels 1-16 active from sequence 1
                            { startSeq: 5, count: 4 },   // Channels 17-20 activate at sequence 5
                            { startSeq: 17, count: 4 },  // Channels 21-24 activate at sequence 17
                            { startSeq: 25, count: 4 }   // Channels 25-28 activate at sequence 25
                        ];

                        // Assign activation sequences to channels
                        const channelsWithActivation = [];
                        let channelOffset = 0;
                        activationPoints.forEach(point => {
                            for (let i = 0; i < point.count; i++) {
                                if (channelOffset < randomChannels.length) {
                                    channelsWithActivation.push({
                                        channel: JSON.parse(JSON.stringify(randomChannels[channelOffset])), // Deep clone to prevent mutation
                                        activationSeq: point.startSeq
                                    });
                                    channelOffset++;
                                }
                            }
                        });

                        // Collect all sequences from the selected channels
                        const sequenceSet = new Set();
                        channelsWithActivation.forEach(({ channel }) => {
                            if (channel.metadata.channelSequence) {
                                channel.metadata.channelSequence.forEach(sequenceData => {
                                    sequenceSet.add(sequenceData.sequenceName);
                                });
                            }
                        });

                        // Convert sequenceSet to an array and sort numerically
                        const sequences = Array.from(sequenceSet).sort((a, b) => {
                            const numA = parseInt(a.replace('Sequence', ''), 10);
                            const numB = parseInt(b.replace('Sequence', ''), 10);
                            return numA - numB;
                        });

                        // Create new song with sequences
                        const newSong = {
                            id: `The Infinite Ordinal Remix #${songIndex + 1}`, // Unique ID for the remix
                            projectName: `The Infinite Ordinal`,
                            artist: `melophonic`,
                            bpm: selectedBPM, // Dynamically assign BPM
                            totalSequences: sequences.length,
                            totalChannels: channelsWithActivation.length,
                            channels: [],
                            projectSequences: {}
                        };

                        // Initialize projectSequences with the sequences
                        sequences.forEach(sequenceName => {
                            newSong.projectSequences[sequenceName] = {};
                        });

                        // Create an effects context to keep track of effects applied per song
                        const effectsContext = {
                            harmonyChannelsAdded: 0,
                            maxHarmonyChannels: window.EffectsModule.effectsConfig.harmonize.maxHarmonyChannels || 2,
                            totalGain: 0,
                            maxTotalGain: 10 // Arbitrary threshold for total gain
                        };

                        // Assign new channel IDs and replicate steps with activation logic
                        channelsWithActivation.forEach(({ channel, activationSeq }, index) => {
                            const chId = `ch${index}`;
                            const newChannel = {
                                id: chId,
                                url: channel.url,
                                metadata: {
                                    ...channel.metadata,
                                    originalBPM: newSong.bpm, // Update BPM in metadata
                                    activationSeq: activationSeq // Embed activation sequence
                                }
                            };

                            // Apply Effects
                            applyEffects(newChannel, index, newSong, activationSeq, newSong.bpm, effectsContext);

                            // Log if the channel is a loop sample
                            if (newChannel.metadata.isLoop) {
                                // **Enhanced Logging: Loop Sample Included in Remix**
                                console.log(`[effectsDebug] ID ${newChannel.url} is identified as a loop and has been included in remix ${newSong.id}`);
                            }

                            newSong.channels.push(newChannel);

                            // Check if the channel belongs to a special song
                            const isSpecialChannel = isChannelFromSpecialSong(channel);

                            if (channel.metadata.channelSequence) {
                                channel.metadata.channelSequence.forEach(sequenceData => {
                                    const sequenceName = sequenceData.sequenceName;
                                    const steps = sequenceData.steps;

                                    if (!newSong.projectSequences[sequenceName]) {
                                        newSong.projectSequences[sequenceName] = {};
                                    }

                                    newSong.projectSequences[sequenceName][chId] = { steps: steps };
                                });
                            }

                            // If it's a special channel, assign a custom activation rule
                            if (isSpecialChannel) {
                                const activationRule = getRandomActivationRule();
                                newChannel.metadata.activationRule = activationRule;
                                newChannel.metadata.customActivationEvents = generateActivationEvents(activationRule, newSong.totalSequences);
                            }
                        });

                        newSongs.push(newSong);

                        // **Logging the Remix Data**
                        console.log(`[Remix Generated] ${newSong.id}`);
                        console.log(`Artist: ${newSong.artist}`);
                        console.log(`BPM: ${newSong.bpm}`);
                        console.log(`Total Sequences: ${newSong.totalSequences}`);
                        console.log(`Total Channels: ${newSong.totalChannels}`);
                        console.log("Channels and Metadata:");
                        newSong.channels.forEach(channel => {
                            console.log(`  Channel ID: ${channel.id}`);
                            console.log(`    URL: ${channel.url}`);
                            console.log(`    Metadata:`, channel.metadata);
                        });
                        console.log("---------------------------------------------------");
                    }

                    return newSongs;
                }

                // Helper function to determine if a channel is from "Fiat Money" or "Did You Know"
                function isChannelFromSpecialSong(channel) {
                    const specialSongIds = [
                        "/content/5ee46b8f645a65b0ec8ae749a28f88e364347f89137bb79986355bf5fb94cbebi0", // Fiat Money
                        "/content/c41de57f1e062a440a9fc96d54baaccd7ec40049f48e9f3880559afc60b1b09ai0"  // Did You Know
                    ];
                    return specialSongIds.includes(channel.url);
                }

                // Helper function to randomly select one of the four activation rules
                function getRandomActivationRule() {
                    const rules = [1, 2, 3, 4];
                    return rules[Math.floor(Math.random() * rules.length)];
                }

                // Helper function to generate activation events based on the selected rule
                function generateActivationEvents(rule, totalSequences) {
                    const events = [];
                    switch (rule) {
                        case 1:
                            // Rule 1: Active in the first 2 sequences
                            events.push({ type: 'activate', seq: 1 });
                            events.push({ type: 'deactivate', seq: 3 });
                            break;
                        case 2:
                            // Rule 2: In for 2 sequences, out for 2 sequences throughout
                            for (let seq = 1; seq <= totalSequences; seq += 4) {
                                events.push({ type: 'activate', seq: seq });
                                if (seq + 2 <= totalSequences) {
                                    events.push({ type: 'deactivate', seq: seq + 2 });
                                }
                            }
                            break;
                        case 3:
                            // Rule 3: In at sequence 9, in for 2, out for 2 until 20, then back in at 41
                            // Activate at 9
                            events.push({ type: 'activate', seq: 9 });
                            // From 9 to 20: In for 2, out for 2
                            for (let seq = 9; seq <= 20; seq += 4) {
                                events.push({ type: 'activate', seq: seq });
                                if (seq + 2 <= 20) {
                                    events.push({ type: 'deactivate', seq: seq + 2 });
                                }
                            }
                            // Activate again at 41
                            events.push({ type: 'activate', seq: 41 });
                            break;
                        case 4:
                            // Rule 4: Randomly play for 2 sequences at sequence 1 or 5, 9, 16 etc.
                            const possibleStarts = [1, 5, 9, 16, 21, 25, 29, 33, 37, 41, 45];
                            const selectedStarts = getRandomSubset(possibleStarts, Math.floor(Math.random() * 3) + 1); // Select 1 to 3 starts

                            selectedStarts.forEach(startSeq => {
                                if (startSeq <= totalSequences) {
                                    events.push({ type: 'activate', seq: startSeq });
                                    if (startSeq + 2 <= totalSequences) {
                                        events.push({ type: 'deactivate', seq: startSeq + 2 });
                                    }
                                }
                            });
                            break;
                        default:
                            // Default to Rule 1 if an unknown rule is encountered
                            events.push({ type: 'activate', seq: 1 });
                            events.push({ type: 'deactivate', seq: 3 });
                            break;
                    }
                    return events;
                }

                // Helper function to get a random subset from an array
                function getRandomSubset(array, size) {
                    const shuffled = array.slice().sort(() => 0.5 - Math.random());
                    return shuffled.slice(0, size);
                }

                // **Generate initial 100 mixes**
                const generatedSongs = generateRandomMixes(100);

                // **Set globalData.songsArray to generated songs only**
                globalData.songsArray = generatedSongs;

                // Initialize current song and sequence indices
                globalData.currentSongIndex = 0;
                globalData.currentSequenceIndex = 0;

                // Prepare initial sample order for the first generated song
                if (globalData.songsArray.length > 0) {
                    globalData.initialSampleOrder = prepareInitialSampleOrder(globalData.songsArray[0]);
                }

                // Set artwork image if applicable
                if (globalData.isArtworkCover && artworkUrl.length) {
                    setArtworkImage(artworkUrl[0]);
                }

                // Update flags
                globalData.isSingleSong = globalData.songsArray.length === 1;
                globalData.isMultipleSongs = globalData.songsArray.length > 1;

                // Dispatch event indicating data loading is complete
                document.dispatchEvent(
                    new CustomEvent("dataLoadingComplete", {
                        detail: {
                            success: true,
                            totalSongs: globalData.songsArray.length,
                            songs: globalData.songsArray.map(({ id, totalSequences }) => ({ id, totalSequences }))
                        }
                    })
                );
                console.log("[Initialization] Data loading complete event dispatched.");

                // **Log the Original Songs Array with Names and BPMs**
                console.log("Original Songs Data:");
                originalSongs.forEach(song => {
                    console.log(`ID: ${song.id}`);
                    console.log(`Artist: ${song.artist}`);
                    console.log(`BPM: ${song.bpm}`);
                    console.log(`Total Sequences: ${song.totalSequences}`);
                    console.log(`Total Channels: ${song.totalChannels}`);
                    console.log("Channels and Metadata:");
                    song.channels.forEach(channel => {
                        console.log(`  Channel ID: ${channel.id}`);
                        console.log(`    URL: ${channel.url}`);
                        console.log(`    Metadata:`, channel.metadata);
                    });
                    console.log("---------------------------------------------------");
                });

            } else {
                console.log("[Initialization] No valid song data URLs to process.");
            }
        } catch (error) {
            console.error("[Initialization] Initialization error:", error);
        }
    })();
</script>



<!-- Load Player Scripts AFTER data loading is complete -->
<script>
    // Listen for the 'dataLoadingComplete' event before loading player scripts
    document.addEventListener("dataLoadingComplete", (event) => {
        console.log("[Script Loader] dataLoadingComplete event received. Loading player scripts...");

        const remainingScriptUrls = [
            "/content/5c03e882ab5a531271b2e93a80d8a9d72cb533c580bec1567020f5cd61595560i0", // projectArtistMapping
            "/content/016f153f011f6a23b8fccd0efcc7945913ee97f241c7a2df7c71c4fa7c9a5fb3i0", // unifiedMetadataManagement
            "/content/ef622be8aeeac45fdbdc291dd0db739d24c2c667c5c3ce7662f2b8c7f2c3de58i0", // GainNodeHelpers
            "/content/f4cc99813b43f71b3e781d3c99f24a6a7a5b1004ea0efce3b225011e347b8df0i0", // audioProcessingAndManagement
            "/content/7b305327f2951d219532ef0cb46b2039b23f2cfd0d8d0e827f3fe1b2b754b5a9i0", // DynamicGainBalancing
            "/content/7f1e3b45f22f943ddfb90a0b9811671185f720bb303f002215b9e0fd932f299ci0", // playbackEngine
            "/content/8b5b09cfedbc0c6a187816181f8d33f90c5bbd15fc10af47008176effb866a47i0"  // keyboardControlsAndEventListeners
            ];

        // Load scripts sequentially
        const loadScriptsSequentially = (urls) => {
            if (urls.length === 0) {
                console.log("[Script Loader] All player scripts loaded.");
                return;
            }
            const src = urls.shift();
            const script = document.createElement("script");
            script.src = src;
            script.async = false; // Ensure scripts are executed in order
            script.onload = () => {
                console.log(`[Script Loader] Loaded script: ${src}`);
                loadScriptsSequentially(urls);
            };
            script.onerror = (e) => {
                console.error(`[Script Loader] Error loading script: ${src}`, e);
                loadScriptsSequentially(urls);
            };
            document.body.appendChild(script);
        };

        loadScriptsSequentially([...remainingScriptUrls]);
    });
</script>


<!-- Keyboard Controls Extracted from previous script loading script -->
<script>
    // togglePlayButtonStyles.js

    globalData.togglePlayback = function() {
        if (!globalData.audioContext) {
            globalData.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        if (globalData.audioContext.state === 'suspended') {
            // Resume the AudioContext if it's suspended
            globalData.audioContext.resume().then(() => {
                proceedWithPlayback();
            });
        } else {
            // If already running, just proceed with playback toggle
            proceedWithPlayback();
        }
    };

    function proceedWithPlayback() {
        if (globalData.isPlaying) {
            // Stop the playback if it's currently playing
            stopPlayback();
        } else {
            // Start playback if it's not playing
            startPlayback();
        }
    }

    function startPlayback() {
        if (globalData.source) {
            globalData.source.stop(); // Stop any existing playback before starting
        }

        // Initialize current sequence index if not set
        if (globalData.currentSequenceIndex === undefined) {
            globalData.currentSequenceIndex = 0;
        }

        // Create a new AudioBufferSourceNode and start playback
        globalData.source = globalData.audioContext.createBufferSource();
        globalData.source.buffer = globalData.currentBuffer; // Assuming you have already loaded the buffer

        globalData.source.connect(globalData.audioContext.destination);
        globalData.source.start(0); // Start playback from the beginning
        globalData.isPlaying = true;
        console.log("Playback started");
    }

    function stopPlayback() {
        if (globalData.source) {
            globalData.source.stop(); // Stop playback
            globalData.isPlaying = false;
            console.log("Playback stopped");
        }
    }

// Add keyboard event listeners for sequence navigation with Shift + Arrow Keys
document.addEventListener('keydown', function(event) {
    // Check if the Shift key is pressed
    if (event.shiftKey) {
        // Detect Left Arrow Key with Shift
        if (event.code === 'ArrowLeft') {
            event.preventDefault(); // Prevent default behavior (optional)
            globalData.previousSequence();
        }
        // Detect Right Arrow Key with Shift
        else if (event.code === 'ArrowRight') {
            event.preventDefault(); // Prevent default behavior (optional)
            globalData.nextSequence();
        }
    }
});

// Implement the sequence navigation functions
globalData.previousSequence = function() {
    if (globalData.currentSequenceIndex > 0) {
        globalData.currentSequenceIndex--;
        globalData.updateSequence();
        console.log("Moved to previous sequence");
    } else {
        console.log("Already at the first sequence");
    }
};

globalData.nextSequence = function() {
    const currentSong = globalData.songsArray[globalData.currentSongIndex];
    if (globalData.currentSequenceIndex < currentSong.totalSequences - 1) {
        globalData.currentSequenceIndex++;
        globalData.updateSequence();
        console.log("Moved to next sequence");
    } else {
        console.log("Already at the last sequence");
    }
};

// Implement updateSequence function
globalData.updateSequence = function() {
    // Logic to update the playback to the new sequence
    // This function interacts with your playback engine to change the sequence
    console.log(`Sequence updated to index ${globalData.currentSequenceIndex}`);
    
    // Optionally, display the current sequence to the user
    displayCurrentSequence(globalData.currentSequenceIndex);

    // If playback is ongoing, stop the current playback and start the new sequence
    if (globalData.isPlaying) {
        stopPlayback();
        startPlayback();
    }
};

// Optional: Function to display the current sequence (for user feedback)
function displayCurrentSequence(index) {
    const currentSong = globalData.songsArray[globalData.currentSongIndex];
    const sequenceName = `Sequence${index + 1}`;
    const nowPlayingText = document.querySelector('.nowPlayingText .songTitle');
    if (nowPlayingText) {
        nowPlayingText.textContent = `${currentSong.id} - ${sequenceName}`;
    }
}

</script>

</body>
</html>



