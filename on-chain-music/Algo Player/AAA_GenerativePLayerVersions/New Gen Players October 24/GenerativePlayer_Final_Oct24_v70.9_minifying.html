<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Audionals - Web3 Music Player</title>
<link rel="stylesheet" href="/content/7a309a161e838ba93740684338b3d97f3c1226c046d8b1137afc2353b4bf16e1i0">
<style>
:root {--panel-bg-color: #333;--panel-text-color: #fff;--track-list-panel-bg-color: #444;--button-bg-color: #444;--button-hover-bg-color: #555;--button-active-bg-color: #777;--input-bg-color: #555;--border-radius: 8px;--padding: 10px;--box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);--transition-duration: 0.3s;--text-color: #fff;--bpm-bg-color: orange;--seed-bg-color: green;--font-size: 16px;}#seed-management-panel, #track-list-panel {position: fixed;background-color: var(--panel-bg-color);color: var(--panel-text-color);padding: var(--padding);border-radius: var(--border-radius);z-index: 10000;box-shadow: var(--box-shadow);transition: all var(--transition-duration) ease;}#seed-management-panel {top: 10px;right: 10px;width: 320px;}#track-list-panel {bottom: 10px;left: 10px;width: 300px;background-color: var(--track-list-panel-bg-color);}.hidden {display: none;}@media (max-width: 600px) {#seed-management-panel, #track-list-panel {width: 90%;left: 5%;right: 5%;}}#seed-mgmt-canvas {width: 100%;height: 100px;border: 1px solid #555;border-radius: 4px;background-color: #222;}#previous-seeds-container {margin-top: 15px;}#previous-seeds-container h3, #seed-input-section h3 {margin-bottom: 5px;}#previous-seeds-container ul {list-style: none;padding: 0;max-height: 150px;overflow-y: auto;border: 1px solid #555;border-radius: 4px;background-color: #444;}#previous-seeds-container li {display: flex;justify-content: space-between;align-items: center;padding: 5px 10px;border-bottom: 1px solid #555;}#previous-seeds-container li:last-child {border-bottom: none;}#previous-seeds-container button {background-color: #666;color: #fff;border: none;border-radius: 4px;padding: 2px 6px;cursor: pointer;transition: background-color var(--transition-duration) ease;margin-left: 10px;}#previous-seeds-container button:hover {background-color: #888;}#seed-input-section {margin-top: 15px;}#seed-input {width: 100%;padding: 8px;margin-bottom: 5px;border: 1px solid #555;border-radius: 4px;background-color: var(--input-bg-color);color: var(--panel-text-color);transition: border 0.2s ease;}#seed-input:focus {border: 2px solid #00f;outline: none;}#clear-seeds-section {margin-top: 15px;text-align: center;}#clear-seeds-button {width: 100%;padding: 8px;background-color: #b22222;color: #fff;border: none;border-radius: 4px;cursor: pointer;transition: background-color var(--transition-duration) ease;margin-top: 5px;}#clear-seeds-button:hover {background-color: #ff6347;}button {background-color: var(--button-bg-color);color: var(--panel-text-color);border: none;border-radius: 4px;cursor: pointer;transition: background-color var(--transition-duration) ease;padding: 10px 15px;margin: 5px;}button:hover {background-color: var(--button-hover-bg-color);}button:active {background-color: var(--button-active-bg-color);}button:focus {outline: 2px solid #00f;}#loadingSpinner {z-index: 1000;}#artworkCover img {max-width: 100%;height: auto;border-radius: 4px;}#nowPlayingContainer {position: fixed;bottom: 0;left: 50%;transform: translateX(-50%);background-color: rgba(20, 20, 20, 0.95);color: #fff;padding: 10px;display: flex;flex-direction: column;justify-content: center;align-items: center;box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.5);z-index: 10000;text-align: center;border-radius: 8px;width: 90%;max-width: 600px;transition: background-color 0.3s ease;}#nowPlayingContainer:hover {background-color: rgba(20, 20, 20, 1);}#nowPlayingText {display: flex;flex-direction: column;align-items: center;margin: 0;padding: 5px;text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);}#nowPlayingContainer .current-seed {display: block;font-size: 0.9em;color: #ccc;margin-bottom: 5px;}#nowPlayingContainer .title {display: block;font-size: 1.2em;font-weight: bold;color: #fff;}
</style>
</head>
<body>
<HTMLsection>
<span class="songTitle">The Infinite Ordinal Remix</span><h1>Audionals</h1><div id="seed-management-panel" class="hidden" role="dialog" aria-labelledby="seed-panel-title" aria-hidden="true"><h2 id="seed-panel-title">Seed Management</h2><canvas id="seed-mgmt-canvas" width="300" height="100" aria-label="Seed and BPM Information"></canvas><div id="previous-seeds-container"><h3>Previous Seeds</h3><ul></ul></div><div id="seed-input-section"><h3>Load a Specific Seed</h3><input type="text" id="seed-input" placeholder="Enter 16-digit Seed" aria-label="Enter Seed"><button id="load-seed-button" aria-label="Load Seed">Load Seed</button></div><div class="bpm-selection"><h3>Select BPM(s) to Filter</h3><div class="bpm-options, hidden"><div class="bpm-option"><input type="checkbox" id="bpm-60" value="60" checked="checked"><label for="bpm-60">60 BPM</label></div><div class="bpm-option"><input type="checkbox" id="bpm-120" value="120" checked="checked"><label for="bpm-120">120 BPM</label></div><div class="bpm-option"><input type="checkbox" id="bpm-140" value="140" checked="checked"><label for="bpm-140">140 BPM</label></div><div class="bpm-option"><input type="checkbox" id="bpm-160" value="160" checked="checked"><label for="bpm-160">160 BPM</label></div><div class="bpm-option"><input type="checkbox" id="bpm-180" value="180" checked="checked"><label for="bpm-180">180 BPM</label></div><div class="bpm-option"><input type="checkbox" id="bpm-240" value="240" checked="checked"><label for="bpm-240">240 BPM</label></div></div></div><div id="clear-seeds-section"><button id="clear-seeds-button" aria-label="Clear Previous Seeds">Clear Previous Seeds</button></div><div id="generate-mixes-section" style="margin-top:15px;text-align:center"><button id="generate-mixes-button" aria-label="Generate Mixes">Generate Mixes</button></div></div><div id="loadingSpinner"></div><div id="artworkCover"><img id="artworkImage" src="" alt="Artwork Cover"></div><div id="trackListingPanel"><h2>Track Listings:</h2><div id="metadataContent"></div></div><div id="nowPlayingContainer"><span class="current-seed">Seed: N/A</span><span class="title">The Infinite Ordinal Remix</span><span class="artistName">melophonic</span><span class="songBPM">BPM: N/A</span><span class="timeLeft">Time Left: N/A</span><span class="songTitle" style="display:none"></span></div><div id="buttonContainer"><button id="playButton" onclick="globalData.togglePlayback()" aria-label="Play or Stop Music">Play / Stop</button><button id="prevButton" onclick="handlePreviousSong()" aria-label="Previous Song">Previous</button><button id="nextButton" onclick="handleNextSong()" aria-label="Next Song">Next</button><button id="toggle-track-panel-button" onclick="toggleTrackListAndPopulate()" class="hidden" aria-label="Toggle Track List Panel">Track List</button><button id="toggle-seed-panel-button" onclick='togglePanel("seed-management-panel")' aria-label="Toggle Seed Management Panel">Seed Panel</button></div><div id="track-list-panel" class="hidden" role="dialog" aria-labelledby="track-list-title" aria-hidden="true"><h2 id="track-list-title" class="hidden">Track List</h2><div id="track-list-container"></div></div>
</HTMLsection>
<!-- Songs and Artwork -->
<script src="/content/616ef4c1bef02cb6c0f785ef76b98df4e379e8f01e2b31e2ae9e68449485f2bci0"></script>    
<!--Global Data -->
<script>
const globalData=window.globalData={isPlaying:!1,currentSongIndex:0,songsArray:[],audioBuffers:{},reverseAudioBuffers:{},audioContext:new(window.AudioContext||window.webkitAudioContext),masterGain:null,gainNodes:{},startPlayback:null,stopPlayback:null,togglePlayback:null,resetPlayback:null,isArtworkCover:!0,isVisualiserCover:!1};globalData.masterGain=globalData.audioContext.createGain(),globalData.masterGain.connect(globalData.audioContext.destination),globalData.nextSong=function(){this.currentSongIndex=(this.currentSongIndex+1)%this.songsArray.length,log(`Switched to next song: Index ${this.currentSongIndex}`)},globalData.previousSong=function(){this.currentSongIndex=(this.currentSongIndex-1+this.songsArray.length)%this.songsArray.length,log(`Switched to previous song: Index ${this.currentSongIndex}`)};
</script> 
<!-- Seed Management -->
<script>
(()=>{const e=e=>console.log(`[${(new Date).toISOString()}] ${e}`),t="hidden";window.togglePanel=e=>{const n=document.getElementById(e);if(n){n.classList.toggle(t);const e=n.classList.contains(t);n.setAttribute("aria-hidden",e)}else console.error(`${e.replace(/-/g," ")} not found.`)},window.populateTrackList=()=>{const e=document.getElementById("track-list-container");e.innerHTML="";const t=globalData?.songsArray;t?.length?t.forEach((({id:t,artist:n})=>{const o=document.createElement("div");o.className="track-item",o.innerHTML=`<div class="track-name">${t}</div><div class="track-artist">${n}</div>`,e.appendChild(o)})):e.textContent="No tracks available."},window.toggleTrackListAndPopulate=()=>{togglePanel("track-list-panel");const e=document.getElementById("track-list-panel");e&&!e.classList.contains(t)&&populateTrackList()};const n=()=>{let e="";for(;e=Array.from({length:16},(()=>Math.floor(10*Math.random()))).join(""),!(BigInt(e)<=BigInt(Number.MAX_SAFE_INTEGER)););return e},o=e=>new URLSearchParams(window.location.search).get(e),l=o("seed");let r=[];if(l){r=l.split(/[\s,]+/).map((e=>e.trim())).filter((e=>""!==e));for(let t=0;t<r.length;t++){const o=r[t];(!/^\d{16}$/.test(o)||BigInt(o)>BigInt(Number.MAX_SAFE_INTEGER))&&(e(`Invalid seed provided: "${o}". Generating a new seed.`),r[t]=n())}}else r=[n()];if(window.seedList=r,window.seed=r[0],e(`Using seed(s): ${window.seedList.join(", ")}`),o("seed")){const e=new URL(window.location);e.searchParams.delete("seed"),history.replaceState(null,"",e.toString())}const i=[80,100,120,140,160,180,240];window.globalData||(window.globalData={}),window.globalData.songsArray=r.map(((t,n)=>{const o=(t=>{const n=t.split("").reduce(((e,t)=>{const n=parseInt(t,10);return(10*e+(isNaN(n)?0:n))%1000000007}),0),o=i[n%i.length];return e(`Seed: ${t}, Hash: ${n}, Selected BPM: ${o}`),o})(t);return{seed:t,bpm:o,id:`Song ${n+1}`,artist:"Unknown Artist"}})),void 0===window.globalData.currentSongIndex&&(window.globalData.currentSongIndex=0);const a=()=>{const e=JSON.parse(localStorage.getItem("previousSeeds"))||[];return s(e),e},s=e=>{const t=document.getElementById("previous-seeds-container");if(!t)return;const n=t.querySelector("ul");n&&(n.innerHTML=e.length?e.map((e=>`\n                <li>\n                    <span>${e}</span>\n                    <button onclick="copyToClipboard('${e}')">Copy</button>\n                </li>`)).join(""):"<li>No previous seeds.</li>")};window.copyToClipboard=e=>{navigator.clipboard.writeText(e).then((()=>alert(`Seed copied to clipboard: ${e}`))).catch((e=>console.error("Could not copy text:",e)))};const d=()=>{confirm("Are you sure you want to clear all previous seeds?")&&(localStorage.removeItem("previousSeeds"),s([]),e("All previous seeds have been cleared."))},c=(t,n,o="The Infinite Ordinal Remix")=>{const l=document.getElementById("seed-mgmt-canvas");if(!l)return;const r=l.getContext("2d");r.clearRect(0,0,l.width,l.height),r.fillStyle=getComputedStyle(document.documentElement).getPropertyValue("--seed-bg-color")||"green",r.fillRect(0,0,l.width,l.height/2),r.fillStyle=getComputedStyle(document.documentElement).getPropertyValue("--bpm-bg-color")||"orange",r.fillRect(0,l.height/2,l.width,l.height/2),r.fillStyle=getComputedStyle(document.documentElement).getPropertyValue("--text-color")||"white",r.font=`${getComputedStyle(document.documentElement).getPropertyValue("--font-size")||"16px"} Arial`,r.textAlign="center",r.textBaseline="middle",r.fillText(`Seed: ${t}`,l.width/2,l.height/4),r.fillText(`BPM: ${n}`,l.width/2,3*l.height/4),(t=>{const n=a();n.includes(t)||(n.push(t),localStorage.setItem("previousSeeds",JSON.stringify(n)),s(n),e(`Seed saved: ${t}`))})(t);const i=document.querySelector("#nowPlayingContainer .current-seed");i&&(i.textContent=`Seed: ${t}`,e(`Updated current seed display: ${t}`));const d=document.querySelector("#nowPlayingContainer .title");d&&o&&(d.textContent=o,e(`Updated current song title: ${o}`))};window.displaySeedAndBPM=c;const g=e=>/^\d{16}$/.test(e)?!(BigInt(e)>BigInt(Number.MAX_SAFE_INTEGER))||(alert(`Seed must be a number up to ${Number.MAX_SAFE_INTEGER}.`),!1):(alert("Seed must be a 16-digit numeric string."),!1);(()=>{document.addEventListener("DOMContentLoaded",(()=>{if(globalData.songsArray.length>0){const e=globalData.songsArray[globalData.currentSongIndex];c(e.seed,e.bpm,e.id),globalData.currentSongIndex=0}else console.warn("No song mixes generated.");a()})),document.getElementById("clear-seeds-button")?.addEventListener("click",d),document.getElementById("load-seed-button")?.addEventListener("click",(()=>{const e=document.getElementById("seed-input").value.trim();if(!e)return void alert("Please enter a seed or seeds.");const t=e.split(/[\s,]+/).map((e=>e.trim())).filter((e=>""!==e));for(const e of t)if(!g(e))return;const n=new URL(window.location);n.searchParams.set("seed",t.join(",")),window.location.href=n.toString()}));const e=document.getElementById("seed-input");e&&e.addEventListener("keypress",(e=>{"Enter"===e.key&&(e.preventDefault(),document.getElementById("load-seed-button").click())}))})()})();
</script>


<!-- Seed Display -->
<script>

    window.updateSeedDisplay = function() {
          const currentSong = globalData.songsArray[globalData.currentSongIndex];
          if (currentSong) {
              const seed = currentSong.seed;
              const bpm = currentSong.bpm;
              const title = currentSong.id;
              displaySeedAndBPM(seed, bpm, title);
              globalData.currentSeed = seed; // Set the current seed
              // Additional logic to update the playback based on the new seed
              // For example, reload audio buffers if necessary
          } else {
              console.warn("Current song index is out of bounds.");
          }
      };
      window.updateSeedDisplay = updateSeedDisplay;

      /**
       * Handles transitioning to the next song in the playlist.
       */
      window.handleNextSong = function() {
          globalData.nextSong();
          updateSeedDisplay();
      };

      /**
       * Handles transitioning to the previous song in the playlist.
       */
      window.handlePreviousSong = function() {
          globalData.previousSong();
          updateSeedDisplay();
      };
      </script>


<!-- Combined Effects Configuration, Audio Effects Module, and GainNode Management -->
 <script>
(()=>{window.EffectsModule=window.EffectsModule||{},window.EffectsModule.effectsConfig={pitchShift:{enabled:!0,defaultProbability:.5,shifts:[.25,.5,1,2,4]},harmonize:{enabled:!0,defaultProbability:.0025,intervals:[.25,.5,1,1.5,2,4],maxHarmonyChannels:1},delay:{enabled:!0,defaultProbability:.5,noteValue:"sixteenth",maxDelayRepeats:8},reverse:{enabled:!0,defaultProbability:.3},pan:{enabled:!0,defaultProbability:1,positions:[-1,1]},reverb:{enabled:!0,defaultProbability:.5,decayTimeRange:[1,5],mixRange:[.2,.7]},filter:{enabled:!0,defaultProbability:.7,types:["lowpass","highpass","bandpass"],frequencyRange:[300,8e3],QRange:[1,8]},tremolo:{enabled:!0,defaultProbability:.6,rateRange:[4,12],depthRange:[.6,1]},distortion:{enabled:!1,defaultProbability:.3,amountRange:[1,10]},bitcrusher:{enabled:!0,defaultProbability:.3,bitDepthRange:[2,6],sampleRateRange:[8e3,22050]},chorus:{enabled:!0,defaultProbability:.3,rateRange:[.1,5],depthRange:[.1,1],feedbackRange:[0,.3],mixRange:[0,.8]},leslie:{enabled:!0,defaultProbability:.2,speedRange:[.5,1.5],depthRange:[.5,1],mixRange:[0,1]},delayBpmLinked:{enabled:!0,defaultProbability:.3,delayTimes:["quarter","eighth","sixteenth"],feedbackRange:[.3,.6],mixRange:[0,.7]}},window.EffectsModule.getEffectParams=function(e,a,t,n){const i=this.effectsConfig[e];if(!i||!i.enabled)return null;if(n()<i.defaultProbability){const a={};switch(e){case"pitchShift":a.shifts=i.shifts;break;case"harmonize":a.intervals=i.intervals,a.maxHarmonyChannels=i.maxHarmonyChannels;break;case"delay":a.noteValue=i.noteValue,a.maxDelayRepeats=i.maxDelayRepeats;break;case"chorus":a.rate=n()*(i.rateRange[1]-i.rateRange[0])+i.rateRange[0],a.depth=n()*(i.depthRange[1]-i.depthRange[0])+i.depthRange[0],a.feedback=n()*(i.feedbackRange[1]-i.feedbackRange[0])+i.feedbackRange[0],a.mix=n()*(i.mixRange[1]-i.mixRange[0])+i.mixRange[0];break;case"leslie":a.rotationSpeed=n()*(i.speedRange[1]-i.speedRange[0])+i.speedRange[0],a.depth=n()*(i.depthRange[1]-i.depthRange[0])+i.depthRange[0],a.mix=n()*(i.mixRange[1]-i.mixRange[0])+i.mixRange[0];break;case"delayBpmLinked":a.time=i.delayTimes[Math.floor(n()*i.delayTimes.length)],a.feedback=n()*(i.feedbackRange[1]-i.feedbackRange[0])+i.feedbackRange[0],a.mix=n()*(i.mixRange[1]-i.mixRange[0])+i.mixRange[0]}return{...i,...a}}return null};const e=(e,a,t)=>Math.min(Math.max(e,a),t);window.applyChorusEffect=(e,{rate:a,depth:t,feedback:n,mix:i},o)=>{e.metadata.chorus={rate:a,depth:t,feedback:n,mix:i}},window.applyRandomPitchShift=(e,{shifts:a},t)=>{const n=a[Math.floor(t()*a.length)];e.metadata.playbackSpeed*=n},window.addHarmony=(a,t,n,{intervals:i,maxHarmonyChannels:o},d,l)=>{d.harmonyChannelsAdded>=o||i.forEach((i=>{if(d.harmonyChannelsAdded>=o)return;const l=JSON.parse(JSON.stringify(a));l.id=`${a.id}_harmony_${t}_${i}`,l.metadata.playbackSpeed*=i,l.metadata.volume=e(.5*(l.metadata.volume||1),1),n.channels.push(l),d.harmonyChannelsAdded++,d.totalGain+=l.metadata.volume||1}))},window.applyIntermittentDelay=(e,{noteValue:a,maxDelayRepeats:t},n)=>{const i=6e4/n,o={quarter:i,eighth:i/2,sixteenth:i/4};e.metadata.delay={time:o[a]||i,repeats:t}},window.applyReverseEffect=e=>{e.metadata.requiresReversal=!0},window.applyVolumeChange=(a,{range:t},n)=>{const[i,o]=t,d=n()*(o-i)+i,l=e((a.metadata.volume||1)*d,.5,1);a.metadata.volume=parseFloat(l.toFixed(2))},window.applyPanEffect=(a,{positions:t},n)=>{if(!t||!Array.isArray(t)||0===t.length)return console.warn(`[PanEffect] Invalid or empty 'positions' array for Channel "${a.id}". Assigning default pan value 0.`),void(a.metadata.pan=0);const i=e(t[Math.floor(n()*t.length)],-1,1);a.metadata.pan=parseFloat(i.toFixed(2))},window.applyReverbEffect=(a,{decayTimeRange:t,mixRange:n},i)=>{let o=i()*(t[1]-t[0])+t[0];o=e(o,t[0],t[1]);let d=i()*(n[1]-n[0])+n[0];d=e(d,n[0],n[1]),a.metadata.reverb={decayTime:parseFloat(o.toFixed(2)),mix:parseFloat(d.toFixed(2))}},window.applyFilterEffect=(a,{types:t,frequencyRange:n,QRange:i},o)=>{const d=t[Math.floor(o()*t.length)];let l=o()*(n[1]-n[0])+n[0];l=e(l,n[0],n[1]);let r=o()*(i[1]-i[0])+i[0];r=e(r,i[0],i[1]),a.metadata.filter={type:d,frequency:parseFloat(l.toFixed(2)),Q:parseFloat(r.toFixed(2))}},window.applyTremoloEffect=(a,{rateRange:t,depthRange:n},i)=>{let o=i()*(t[1]-t[0])+t[0];o=e(o,t[0],t[1]);let d=i()*(n[1]-n[0])+n[0];d=e(d,n[0],n[1]),a.metadata.tremolo={rate:parseFloat(o.toFixed(2)),depth:parseFloat(d.toFixed(2))}},window.applyDistortionEffect=(a,{amountRange:t},n)=>{let i=n()*(t[1]-t[0])+t[0];i=e(i,t[0],t[1]),a.metadata.distortion={amount:parseFloat(i.toFixed(2))}},window.applyBitcrusherEffect=(a,{bitDepthRange:t,sampleRateRange:n},i)=>{let o=Math.floor(i()*(t[1]-t[0]+1))+t[0];o=e(o,t[0],t[1]);let d=i()*(n[1]-n[0])+n[0];d=e(d,n[0],n[1]),d=parseFloat(d.toFixed(0)),a.metadata.bitcrusher={bitDepth:o,sampleRate:d}},window.applyLeslieEffect=(e,{rotationSpeed:a,depth:t,mix:n},i)=>{e.metadata.leslie={rotationSpeed:a,depth:t,mix:n}},window.applyBpmLinkedDelay=(e,{time:a,feedback:t,mix:n},i)=>{e.metadata.delayBpmLinked={time:a,feedback:t,mix:n}},window.GainNodeHelper=(()=>{const e=window.globalData||(window.globalData={gainNodes:{},audioContext:new(window.AudioContext||window.webkitAudioContext),masterGain:null});e.masterGain||(e.masterGain=e.audioContext.createGain(),e.masterGain.connect(e.audioContext.destination));const a=a=>{const t=a.id;a.channels&&0!==a.channels.length?(e.gainNodes[t]=e.gainNodes[t]||{},a.channels.forEach((a=>{if(!e.gainNodes[t][a.id]){const n=e.audioContext.createGain();n.gain.value=a.metadata.volume||1,n.connect(e.masterGain),e.gainNodes[t][a.id]=n}}))):console.warn(`[GainNodeHelper] No channels found for Song "${t}".`)};return{createGainNodesForSong:a,prepareNextSongGainNodes:e=>{a(e)},cleanupGainNodesForSong:a=>{const t=e.gainNodes[a];t?(Object.values(t).forEach((e=>e.disconnect())),delete e.gainNodes[a]):console.warn(`[GainNodeHelper] No GainNodes found to clean up for Song "${a}".`)}}})(),document.dispatchEvent(new Event("effectsLoaded"))})();
</script>

<!-- GainNode Helpers (gainNodeHelpers.js) -->
<script>
window.GainNodeHelper = (() => {
  const n =
    window.globalData ||
    (window.globalData = {
      gainNodes: {},
      audioContext: new (window.AudioContext || window.webkitAudioContext)(),
      masterGain: null,
    });

  if (!n.masterGain) {
    n.masterGain = n.audioContext.createGain();
    n.masterGain.connect(n.audioContext.destination);
  }

  const e = {
    targetLoudness: 0.8,
    transientThreshold: 1.2,
    smoothingFactor: 0.7,
  };

  const o = (song, isNextSong = false) => {
    const i = song.id;

    // Initialize GainNodes for the song
    if (isNextSong) {
      // Preparing next song: i
    } else {
      // Setting current song: i
    }

    if (song.channels && song.channels.length > 0) {
      if (!n.gainNodes[i]) {
        n.gainNodes[i] = {};
      }

      // Create GainNodes for each channel if they don't exist
      song.channels.forEach((channel) => {
        if (!n.gainNodes[i][channel.id]) {
          const gainNode = n.audioContext.createGain();
          gainNode.gain.value = channel.metadata.volume || 1;
          gainNode.connect(n.masterGain);
          n.gainNodes[i][channel.id] = gainNode;
        }
      });

      // Normalize volumes across all channels
      if (!song.channels || song.channels.length === 0) {
        return;
      }

      const volumes = song.channels.map((ch) => ch.metadata.volume || 1);
      const maxVolume = Math.max(...volumes);
      song.channels.forEach((ch) => {
        const normalizedGain =
          ((ch.metadata.volume || 1) / maxVolume) * e.targetLoudness;
        a(song.id, ch.id, normalizedGain);
      });

      // Apply transient control to each channel
      if (song.channels && song.channels.length !== 0) {
        song.channels.forEach((channel) => {
          const gainNode = n.gainNodes?.[song.id]?.[channel.id];
          if (gainNode) {
            const adjustedGain = Math.min(
              gainNode.gain.value * e.transientThreshold,
              e.targetLoudness
            );
            gainNode.gain.setTargetAtTime(
              adjustedGain,
              n.audioContext.currentTime,
              e.smoothingFactor
            );
          }
        });
      }

      // All GainNodes initialized for Song ID: i
    } else {
      // No channels found for Song "i"
    }
  };

  const a = (songId, channelId, gainValue) => {
    const t = n.gainNodes?.[songId]?.[channelId];
    if (t) {
      t.gain.setValueAtTime(gainValue, n.audioContext.currentTime);
    } else {
      // No GainNode found for Channel "channelId" of Song "songId"
    }
  };

  return {
    /**
     * Creates GainNodes for a given song.
     * @param {Object} song - The song object containing channels.
     */
    createGainNodesForSong: (song) => o(song, false),

    /**
     * Prepares GainNodes for the next song.
     * @param {Object} song - The next song object containing channels.
     */
    prepareNextSongGainNodes: (song) => o(song, true),

    /**
     * Cleans up GainNodes for a given song.
     * @param {string} songId - The ID of the song to clean up.
     */
    cleanupGainNodesForSong: (songId) => {
      const gainNodesForSong = n.gainNodes[songId];
      if (gainNodesForSong) {
        Object.values(gainNodesForSong).forEach((gainNode) => {
          gainNode.disconnect();
        });
        delete n.gainNodes[songId];
      } else {
        // No GainNodes found to clean up for Song ID: songId
      }
    },

    /**
     * Sets the gain value for a specific channel of a song.
     * @param {string} songId - The ID of the song.
     * @param {string} channelId - The ID of the channel.
     * @param {number} gainValue - The gain value to set.
     */
    setChannelGain: (songId, channelId, gainValue) =>
      a(songId, channelId, gainValue),

    /**
     * Sets mastering controls by merging new settings.
     * @param {Object} newSettings - The new mastering settings.
     */
    setMasteringControls: (newSettings) =>
      Object.assign(e, newSettings),
  };
})();
</script>



<!-- Main Script (main.js) -->
<script>
    /* 
    #region Main Script
    **Purpose:**
    [Unchanged: Comprehensive documentation as provided by the user]
    #endregion
    */
    
    (async () => {
        const globalData = window.globalData; // Ensure consistent access
        const audioContext = globalData.audioContext; // Standardize AudioContext access

        // // Embed the seed list directly
        // window.seedList = [
        //         '1378012087872054',
        //         '8577097119065499',
        //         '8651019588475341',
        //         '8651019588475378'
        //     ];
            

        function waitForEffects() {
            return new Promise((resolve) => {
                if (window.EffectsModule && window.EffectsModule.effectsConfig) {
                    resolve();
                } else {
                    document.addEventListener('effectsLoaded', resolve, { once: true });
                }
            });
        }
        await waitForEffects();
    

        // Adjustable controls for gain reduction when layering
        const layeringControls = {
            gainReductionPerLayer: 0.7, // Gain multiplier per additional layer (e.g., 0.7 reduces gain by 30% per layer)
            maxLayers: 4 // Maximum number of layers per channel to prevent excessive gain reduction
        };

        /**
         * Applies a series of audio effects to a given channel, ensuring volume consistency and balance.
         *
         * @param {Object} channel - The audio channel to apply effects to.
         * @param {number} index - The index of the channel.
         * @param {Object} newSong - The song object containing channel and sequence information.
         * @param {number} currentSequence - The current sequence number.
         * @param {number} bpm - Beats per minute of the song.
         * @param {Object} effectsContext - Context object to manage total gain and harmony channels.
         * @param {Function} prng - Pseudo-random number generator function.
         */
        function applyEffects(channel, index, newSong, currentSequence, bpm, effectsContext, prng) {
            const MAX_EFFECTS_PER_CHANNEL = 3; // Define a reasonable limit

            const duplicationEffects = new Set(['harmonize', 'delay', 'delayBpmLinked']); // Effects that duplicate layers

            const effectsMap = [
                { name: 'pitchShift', applyFn: (ch, params) => applyRandomPitchShift(ch, params, prng) },
                { name: 'harmonize', applyFn: (ch, params) => addHarmony(ch, index, newSong, params, effectsContext, prng) },
                { name: 'delay', applyFn: (ch, params) => applyIntermittentDelay(ch, params, bpm) },
                { name: 'reverse', applyFn: (ch, params) => applyReverseEffect(ch) },
                { name: 'filter', applyFn: (ch, params) => applyFilterEffect(ch, params, prng) },
                { name: 'tremolo', applyFn: (ch, params) => applyTremoloEffect(ch, params, prng) },
                { name: 'distortion', applyFn: (ch, params) => applyDistortionEffect(ch, params, prng) },
                { name: 'bitcrusher', applyFn: (ch, params) => applyBitcrusherEffect(ch, params, prng) },
                { name: 'pan', applyFn: (ch, params) => applyPanEffect(ch, params, prng) },
                { name: 'reverb', applyFn: (ch, params) => applyReverbEffect(ch, params, prng) },
                { name: 'volumeChange', applyFn: (ch, params) => applyVolumeChange(ch, params, prng) },
                { name: 'chorus', applyFn: (ch, params) => applyChorusEffect(ch, params, prng) },
                { name: 'leslie', applyFn: (ch, params) => applyLeslieEffect(ch, params, bpm, prng) },
                { name: 'delayBpmLinked', applyFn: (ch, params) => applyBpmLinkedDelay(ch, params, bpm, prng) },
            ];

            // Shuffle the effectsMap to randomize effect application order
            const shuffledEffects = effectsMap.sort(() => 0.5 - Math.random());

            let appliedEffectsCount = 0;

            // Iterate through each effect in the shuffledEffectsMap
            for (const effect of shuffledEffects) {
                if (appliedEffectsCount >= MAX_EFFECTS_PER_CHANNEL) break; // Stop if max effects reached

                const effectParams = window.EffectsModule.getEffectParams(effect.name, currentSequence, bpm, prng);
                if (effectParams) {
                    // Apply the effect to the channel
                    effect.applyFn(channel, effectParams);
                    appliedEffectsCount++;

                    // If the effect is a duplication effect, adjust gain accordingly
                    if (duplicationEffects.has(effect.name)) {
                        // Initialize layer count if not present
                        if (!effectsContext.channelLayers[channel.id]) {
                            effectsContext.channelLayers[channel.id] = 1; // Original layer
                        }

                        // Increment layer count
                        if (effectsContext.channelLayers[channel.id] < layeringControls.maxLayers) {
                            effectsContext.channelLayers[channel.id]++;
                        }

                        // Calculate the new gain based on the number of layers
                        const layers = effectsContext.channelLayers[channel.id];
                        const newGain = (1 / layers) * layeringControls.gainReductionPerLayer ** (layers - 1);

                        // Update the channel's metadata volume
                        channel.metadata.volume = newGain;

                        // Apply the new gain using GainNodeHelper
                        GainNodeHelper.setChannelGain(newSong.id, channel.id, newGain);

                        console.log(`[Effects][Song: "${newSong.id}"] Applied duplication effect "${effect.name}" to Channel "${channel.id}". Layers: ${layers}, New Gain: ${newGain.toFixed(2)}`);
                    }

                    // Logging the application of the effect with song and channel information
                    // console.log(`[Effects][Song: "${newSong.id}"] Applied effect "${effect.name}" to Channel "${channel.id}" with parameters:`, effectParams);
                }
            }

            // Define volume clamping constants
            const MIN_CHANNEL_VOLUME = 0.5; // Minimum volume factor to prevent channels from being too quiet
            const MAX_CHANNEL_VOLUME = 1.5; // Maximum volume factor to prevent channels from being too loud
            const MAX_TOTAL_GAIN = 1;       // Maximum total gain across all channels to prevent overall mix from being too loud

            // After applying all effects, perform volume normalization and clamping

            // Ensure the total gain across all channels does not exceed MAX_TOTAL_GAIN
            if (effectsContext.totalGain > MAX_TOTAL_GAIN) {
                const reductionFactor = MAX_TOTAL_GAIN / effectsContext.totalGain;
                channel.metadata.volume = (channel.metadata.volume || 1) * reductionFactor;

                // Log the normalization action with song and channel information
                console.log(`[Normalization][Song: "${newSong.id}"] Normalized Channel "${channel.id}" volume by factor ${reductionFactor.toFixed(2)} to maintain total gain within ${MAX_TOTAL_GAIN}.`);
            }

            // Update the total gain in the effects context
            effectsContext.totalGain += channel.metadata.volume || 1;

            // Clamp the channel's volume within defined bounds to maintain balance
            if (channel.metadata.volume < MIN_CHANNEL_VOLUME) {
                channel.metadata.volume = MIN_CHANNEL_VOLUME;
                console.log(`[Clamping][Song: "${newSong.id}"] Clamped Channel "${channel.id}" volume to minimum ${MIN_CHANNEL_VOLUME}.`);
            } else if (channel.metadata.volume > MAX_CHANNEL_VOLUME) {
                channel.metadata.volume = MAX_CHANNEL_VOLUME;
                // console.log(`[Clamping][Song: "${newSong.id}"] Clamped Channel "${channel.id}" volume to maximum ${MAX_CHANNEL_VOLUME}.`);
            }

            // Update the GainNode's gain value using GainNodeHelper
            GainNodeHelper.setChannelGain(newSong.id, channel.id, channel.metadata.volume || 1);
        }
            
                
        const loopSampleIds = new Set([
            "7c42769c1763cc8f045aada7914e8158223e45e7a4f197b49f918b1c005d36fci0",
            "3364803cb3032ce95f4138a214c15a9b36dcb70f574a477f27615d448e1cdeb8i0",
        ]);
    
        const keyNames = [
            "projectName",
            "artistName",
            "projectBPM",
            "currentSequence",
            "channelURLs",
            "channelVolume",
            "channelPlaybackSpeed",
            "trimSettings",
            "projectChannelNames",
            "startSliderValue",
            "endSliderValue",
            "totalSampleDuration",
            "start",
            "end",
            "projectSequences",
            "steps"
        ];
    
        const keyMap = keyNames.reduce((map, key, index) => {
            map[key] = index;
            return map;
        }, {});
    
        const channelIds = Array.from({ length: 16 }, (_, index) => String.fromCharCode(65 + index)); // 'A' to 'P'
        const channelIdMap = channelIds.reduce((map, id, index) => {
            map[id] = index;
            return map;
        }, {});
    
        const fetchAndProcessSongData = async (url) => {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Network error for ${url}`);
                const compressedData = new Uint8Array(await response.arrayBuffer());
                const inflatedData = window.pako.inflate(compressedData);
                const jsonString = new TextDecoder("utf-8").decode(inflatedData);
                const parsedData = JSON.parse(jsonString);
                const processParsedData = (data) => {
                    const recurse = (obj) => {
                        if (Array.isArray(obj)) {
                            return obj.map(recurse);
                        } else if (obj && typeof obj === "object") {
                            return Object.entries(obj).reduce((accumulator, [key, value]) => {
                                const mappedKey = keyNames[key] || key;
                                accumulator[mappedKey] = mappedKey === "projectSequences"
                                    ? Object.fromEntries(
                                        Object.entries(value).map(([seqKey, seqValue]) => {
                                            const sequenceName = `Sequence${seqKey.replace(/^s/, "")}`;
                                            const channels = Object.fromEntries(
                                                Object.entries(seqValue).map(([channelKey, channelValue]) => {
                                                    const steps = channelValue[keyMap.steps] || [];
                                                    const processedSteps = steps.flatMap((step) => {
                                                        if (typeof step === "number") {
                                                            return step;
                                                        } else if (step?.r) {
                                                            const [start, end] = step.r;
                                                            return Array.from({ length: end - start + 1 }, (_, idx) => start + idx);
                                                        } else if (typeof step === "string" && step.endsWith("r")) {
                                                            return { index: parseInt(step.slice(0, -1), 10), reverse: true };
                                                        } else {
                                                            return [];
                                                        }
                                                    });
                                                    return [`ch${channelIdMap[channelKey]}`, { steps: processedSteps }];
                                                })
                                            );
                                            return [sequenceName, channels];
                                        })
                                    )
                                    : recurse(value);
                                return accumulator;
                            }, {});
                        } else {
                            return obj;
                        }
                    };
                    return recurse(data);
                };
                return processParsedData(parsedData);
            } catch (error) {
                console.error(`[Initialization] Error fetching/deserializing ${url}:`, error);
                throw error;
            }
        };
    
        const prepareInitialSampleOrder = ({ projectSequences }) => {
            const sampleSet = new Set();
            const sampleOrder = [];
            Object.keys(projectSequences)
                .sort((a, b) => +a.slice(9) - +b.slice(9))
                .forEach(seqK => {
                    Object.entries(projectSequences[seqK]).forEach(([chId, { steps }]) => {
                        steps.forEach(step => {
                            if (typeof step === "number" || step?.index !== undefined) {
                                const id = `${chId}_${step.reverse ? 'r' : 'f'}`;
                                if (!sampleSet.has(id)) {
                                    sampleSet.add(id);
                                    sampleOrder.push({ channelId: chId, reverse: step.reverse || false });
                                }
                            }
                        });
                    });
                });
            return sampleOrder;
        };
    
        const setArtworkImage = url => {
            const el = document.getElementById("artworkImage");
            if (el) {
                el.src = url;
                el.parentElement.style.display = "flex";
            }
        };
    
        const normalizeAudioBuffer = (audioBuffer) => {
            const numChannels = audioBuffer.numberOfChannels;
            let globalMaxAmplitude = 0;
    
            // First pass: Find the global maximum amplitude across all channels
            for (let i = 0; i < numChannels; i++) {
                const channelData = audioBuffer.getChannelData(i);
                const channelMax = Math.max(...channelData.map(sample => Math.abs(sample)));
                if (channelMax > globalMaxAmplitude) {
                    globalMaxAmplitude = channelMax;
                }
            }
    
            // Define target peak amplitude to prevent clipping
            const TARGET_PEAK = 0.95; // 0.95 to leave some headroom
    
            // Calculate normalization factor
            const normalizationFactor = globalMaxAmplitude > 0 ? TARGET_PEAK / globalMaxAmplitude : 1;
    
            // Apply normalization
            for (let i = 0; i < numChannels; i++) {
                const channelData = audioBuffer.getChannelData(i);
                for (let j = 0; j < channelData.length; j++) {
                    channelData[j] *= normalizationFactor;
                }
            }
    
            // console.log(`[Normalization] Applied normalization factor: ${normalizationFactor.toFixed(4)} to audio buffer.`);
            return audioBuffer;
        };
       
       
        // Define maximum cache size
        const MAX_CACHE_SIZE = 100; // Adjust based on available memory and application needs
    
        // Use a Map for sampleCache to maintain insertion order for LRU eviction
        const sampleCache = new Map();
    
        // Function to generate a unique key for each sample based on URL and processing parameters
        const generateSampleKey = (url, params = {}) => {
            let key = url;
            if (params.reversed) key += '_reversed';
            if (params.playbackSpeed && params.playbackSpeed !== 1) key += `_speed_${params.playbackSpeed}`;
            // Include other parameters as needed
            return key;
        };
    
        const loadAndProcessSample = async (url, params = {}) => {
            const key = generateSampleKey(url, params);
    
            if (sampleCache.has(key)) {
                // Move the used sample to the end to mark it as recently used
                const value = sampleCache.get(key);
                sampleCache.delete(key);
                sampleCache.set(key, value);
                console.log(`[Cache] Reusing cached sample: ${key}`);
                return value;
            }
    
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch sample from ${url}: ${response.statusText}`);
                }
    
                const arrayBuffer = await response.arrayBuffer();
    
                let audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
    
                // Normalize the audio buffer
                audioBuffer = normalizeAudioBuffer(audioBuffer);
    
                // Apply processing if needed
                if (params.reversed) {
                    for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
                        Array.prototype.reverse.call(audioBuffer.getChannelData(i));
                    }
                    // console.log(`[Processing] Reversed audio buffer for key: ${key}`);
                }
    
                if (params.playbackSpeed && params.playbackSpeed !== 1) {
                    // Implement time-stretching or pitch-shifting as needed
                    // Placeholder: Log that playbackSpeed is being applied
                    // console.log(`[Processing] Applying playback speed ${params.playbackSpeed} for key: ${key}`);
                    // Actual implementation would require more complex audio processing
                }
    
                // Add to cache
                sampleCache.set(key, audioBuffer);
                // console.log(`[Cache] Added sample to cache: ${key}`);
    
                // Evict least recently used samples if cache size exceeds limit
                if (sampleCache.size > MAX_CACHE_SIZE) {
                    const oldestKey = sampleCache.keys().next().value;
                    sampleCache.delete(oldestKey);
                    console.log(`[Cache] Evicted oldest sample from cache: ${oldestKey}`);
                }
    
                return audioBuffer;
            } catch (error) {
                console.error(`[LoadAndProcessSample] Error processing sample from ${url}:`, error);
                throw error; // Re-throw to allow higher-level handling
            }
        };
    
        // **New Function: generateMuteSchedule**
        const generateMuteSchedule = (prng, totalSequences) => {
            const muteSchedule = [];
            const evenSequences = [];
            for (let seq = 2; seq <= totalSequences; seq += 2) {
                evenSequences.push(seq);
            }
    
            evenSequences.forEach(seq => {
                // Decide whether to mute or unmute at this sequence
                const action = prng() < 0.5 ? 'mute' : 'unmute';
                // Decide number of channels to affect (1 to 4)
                const numChannels = Math.floor(prng() * 4) + 1;
                // Placeholder: actual channel selection will be handled during mix generation
                muteSchedule.push({ sequence: seq, action, numChannels });
            });
    
            return muteSchedule;
        };
    
        const validSongDataUrls = songDataUrls.filter((url) => url.trim() && !url.trim().startsWith("//"));
    
        if (validSongDataUrls.length) {
            if (!window.pako) {
                await (async function loadPako() {
                    try {
                        const response = await fetch("/content/2109694f44c973892fb8152cf5c68607fb19288c045af1abc1716c1c3b4d69e6i0");
                        const textContent = await response.text();
                        const scriptElement = new DOMParser().parseFromString(textContent, "text/html").querySelector("script");
                        if (!scriptElement || !scriptElement.textContent.includes("pako")) {
                            throw new Error("Pako library not found.");
                        }
                        document.head.append(
                            Object.assign(document.createElement("script"), { textContent: scriptElement.textContent })
                        );
                        console.log("[Initialization] Pako library loaded successfully.");
                    } catch (error) {
                        console.error("[Initialization] Error loading Pako:", error);
                    }
                })();
            }
            const songDataArray = await Promise.all(
                validSongDataUrls.map(async (url, index) => {
                    try {
                        const data = await fetchAndProcessSongData(url);
                        return { data, index };
                    } catch (error) {
                        console.error(`[Initialization] Failed to fetch/process ${url}:`, error);
                        return null;
                    }
                })
            ).then(dataArray => {
                const validDataArray = dataArray.filter(Boolean);
                if (!validDataArray.length) throw new Error("[Initialization] No valid data.");
                return validDataArray;
            });
    
            const originalSongs = songDataArray
                .sort((a, b) => a.index - b.index)
                .map(({ data, index }) => {
                    const {
                        projectName = "The Infinite Ordinal",
                        artistName = "melophonic",
                        projectBPM = 120,
                        projectSequences = {},
                        channelURLs = [],
                        channelVolume = [],
                        channelPlaybackSpeed = [],
                        trimSettings = {}
                    } = data;
    
                    const channels = channelIds.map((id, idx) => {
                        const channelSequence = Object.entries(projectSequences).reduce((acc, [sequenceName, sequenceData]) => {
                            const channelData = sequenceData[`ch${idx}`];
                            if (channelData) acc.push({ sequenceName, steps: channelData.steps });
                            return acc;
                        }, []);
                        const metadata = {
                            volume: channelVolume[idx] ?? 1,
                            playbackSpeed: channelPlaybackSpeed[idx] ?? 1,
                            trimStartTime_Percentage: trimSettings[idx]?.start || 0,
                            trimEndTime_Percentage: trimSettings[idx]?.end || 100,
                            requiresReversal: channelSequence.some(seq => seq.steps.some(step => typeof step === "object" && step.reverse)),
                            channelSequence,
                            originalBPM: projectBPM
                        };
                        const sampleId = channelURLs[idx];
                        if (loopSampleIds.has(sampleId)) {
                            metadata.isLoop = true;
                        }
                        return { id, url: sampleId || "URL_not_found", metadata };
                    });
                    return {
                        id: `Song ${index + 1}: ${projectName}`,
                        artist: artistName,
                        bpm: projectBPM,
                        totalSequences: Object.keys(projectSequences).length,
                        totalChannels: channels.length,
                        channels,
                        projectSequences
                    };
                });
    
            const allChannels = originalSongs.flatMap(song => song.channels);
    
            function lcg64(seed) {
                let state = seed;
                const a = 6364136223846793005n;
                const c = 1442695040888963407n;
                const m = 18446744073709551616n; // 2^64
                return function() {
                    state = (a * state + c) % m;
                    return Number(state) / Number(m);
                }
            }
    
            const getRandomChannels = (channelsArray, num, prng) => {
                const shuffled = [...channelsArray];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(prng() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled.slice(0, num);
            };
    
           
     /**
         * Generates a random 16-digit seed string.
         *
         * @returns {string} - A 16-digit random seed.
         */
         function generateRandomSeed() {
            let seed = '';
            for (let i = 0; i < 16; i++) {
                seed += Math.floor(Math.random() * 10).toString();
            }
            return seed;
        }

        /**
         * Generates a list of sequential seeds starting from the initial seed.
         *
         * @param {string} initialSeed - The starting 16-digit seed.
         * @param {number} count - Number of sequential seeds to generate.
         * @returns {string[]} - An array of 16-digit sequential seeds.
         */
        function generateSequentialSeeds(initialSeed, count = 100) {
            const seeds = [initialSeed];
            let seedNumber;
            try {
                seedNumber = BigInt(initialSeed);
            } catch (error) {
                console.error(`[Seed Generation] Invalid initial seed "${initialSeed}". Defaulting to 0n.`);
                seedNumber = 0n;
            }

            for (let i = 1; i < count; i++) {
                seedNumber += 1n;
                let newSeed = seedNumber.toString();
                if (newSeed.length < 16) {
                    newSeed = newSeed.padStart(16, '0');
                } else if (newSeed.length > 16) {
                    newSeed = newSeed.slice(-16); // Keep the last 16 digits
                }
                seeds.push(newSeed);
            }
            return seeds;
        }

        /**
         * Initializes the seedList based on user-provided seeds.
         * - If no seeds are provided, generate a random seed and create 100 sequential seeds.
         * - If one seed is provided, generate 99 additional sequential seeds from it.
         * - If multiple seeds are provided, use them as-is.
         */
        function initializeSeedList() {
            if (window.seedList && window.seedList.length > 1) {
                // Multiple seeds provided; use as-is.
                console.log(`[Seed Initialization] Using user-provided seedList with ${window.seedList.length} seeds.`);
            } else if (window.seedList && window.seedList.length === 1) {
                // Single seed provided; generate 99 additional sequential seeds.
                const initialSeed = window.seedList[0];
                const additionalSeeds = generateSequentialSeeds(initialSeed, 100).slice(1); // Exclude the initial seed
                window.seedList = window.seedList.concat(additionalSeeds);
                console.log(`[Seed Initialization] Single seed provided. Generated 99 additional sequential seeds from "${initialSeed}". Total seeds: ${window.seedList.length}.`);
            } else {
                // No seeds provided; generate a random seed and 99 additional sequential seeds.
                const randomSeed = generateRandomSeed();
                window.seedList = generateSequentialSeeds(randomSeed, 100);
                console.log(`[Seed Initialization] No user-provided seeds. Generated random seed "${randomSeed}" and created ${window.seedList.length} sequential seeds.`);
            }
        }

        // **Seed List Initialization (Moved Outside the 'if' Block)**
        initializeSeedList();

    // **Proceed with Mix Generation**
/**
 * Generates a single song mix based on a seed string and assigns a remix number.
 *
 * @param {string} seedString - The seed string used for PRNG.
 * @param {number} remixNumber - The sequential number assigned to the remix.
 * @returns {Promise<Array>} - A promise that resolves to an array containing the generated song.
 */
async function generateMixBySeed(seedString, remixNumber) {
    console.log(`[debugSeed][generateMixBySeed] Generating mix #${remixNumber} with seed "${seedString}"`);
    const bpmOptions = [60, 120, 140, 160, 180, 240];
    const newSongs = [];

    // Initialize base seed with error handling
    let baseSeed;
    try {
        baseSeed = BigInt(seedString);
    } catch (error) {
        console.error(`[seedDebug] Invalid seed string: "${seedString}". Using base seed 0.`);
        baseSeed = 0n;
    }

    const currentSeed = baseSeed || 1n;

    // Function to derive BPM from a seed using PRNG
    const getBPMFromSeed = (seed) => {
        const prng = lcg64(seed);
        return bpmOptions[Math.floor(prng() * bpmOptions.length)];
    };

    const prng = lcg64(currentSeed);
    const selectedBPM = getBPMFromSeed(currentSeed);

    // Select random channels for the mix
    const randomChannels = getRandomChannels(allChannels, 24, prng);

    // Activation points and sequences
    const activationPoints = [
        { startSeq: 1, count: 4 },
        { startSeq: 5, count: 8 },
        { startSeq: 9, count: 12 },
        { startSeq: 13, count: 16 }
    ];

    // Assign activation sequences to channels
    const channelsWithActivation = activationPoints.flatMap(({ startSeq, count }) =>
        Array.from({ length: count }, (_, i) => {
            const channel = randomChannels[i];
            return channel ? { channel: JSON.parse(JSON.stringify(channel)), activationSeq: startSeq } : null;
        }).filter(Boolean)
    );

    // Collect unique sequence names from channels
    const sequenceSet = new Set(
        channelsWithActivation.flatMap(({ channel }) =>
            channel.metadata.channelSequence?.map(seq => seq.sequenceName) || []
        )
    );

    // Sort sequences numerically based on their suffix
    let sequences = [...sequenceSet].sort((a, b) =>
        (parseInt(a.replace('Sequence', '')) || 0) - (parseInt(b.replace('Sequence', '')) || 0)
    );

    // Limit the number of sequences to 44
    sequences = sequences.slice(0, 44);

    // Initialize the new song object with remix numbering
    const newSong = {
        id: `Remix ${remixNumber}`, // Assigning Remix number as ID
        projectName: `Remix ${remixNumber}`, // Assigning Remix number as Project Name
        artist: `melophonic`,
        bpm: selectedBPM,
        totalSequences: sequences.length,
        totalChannels: channelsWithActivation.length,
        channels: [],
        projectSequences: Object.fromEntries(sequences.map(seq => [seq, {}])),
        seed: seedString,
        muteSchedule: [] // Retain for other dynamic muting purposes if needed
    };

    // Initialize effects context for the song
    const effectsContext = {
        harmonyChannelsAdded: 0,
        maxHarmonyChannels: window.EffectsModule?.effectsConfig?.harmonize?.maxHarmonyChannels || 2,
        totalGain: 0,
        maxTotalGain: 1,
        channelLayers: {} // Track layers per channel
    };

    // Assign activationSeq to channels and set isMuted=true
    await Promise.all(channelsWithActivation.map(async ({ channel, activationSeq }, index) => {
        const chId = `ch${index}`; // Ensure unique channel IDs within the song
        const newChannel = {
            id: chId,
            url: channel.url,
            metadata: {
                ...channel.metadata,
                originalBPM: newSong.bpm,
                activationSeq,
                isMuted: true // Initialize as muted
            }
        };
        await applyEffects(newChannel, index, newSong, activationSeq, newSong.bpm, effectsContext, prng);
        newSong.channels.push(newChannel);

        // Map sequences to the new channel
        channel.metadata.channelSequence?.forEach(seqData => {
            if (newSong.projectSequences[seqData.sequenceName]) {
                newSong.projectSequences[seqData.sequenceName] = {
                    ...newSong.projectSequences[seqData.sequenceName],
                    [chId]: { steps: seqData.steps }
                };
            }
        });
    }));

    // Add the new song to the songs list
    newSongs.push(newSong);

    return newSongs;
}

/**
 * Generates song mixes based on a list of seeds and assigns sequential remix numbers.
 *
 * @param {string[]} seedList - The list of seed strings for PRNG.
 * @returns {Promise<Array>} - A promise that resolves to an array of generated songs.
 */
async function generateMixesForSeedList(seedList) {
    const newSongs = [];

    for (let i = 0; i < seedList.length; i++) {
        const seedString = seedList[i];
        const remixNumber = i + 1; // Remix numbers start at 1
        const songs = await generateMixBySeed(seedString, remixNumber);
        newSongs.push(...songs);
    }

    return newSongs;
}

// **Proceed with Mix Generation**
const generatedSongs = await generateMixesForSeedList(window.seedList);
console.log(`[Mix Generation] Generated ${generatedSongs.length} songs based on seedList.`);

// Assign songs to globalData once
if (!globalData.initialized) {
    Object.assign(globalData, {
        songsArray: generatedSongs,
        songsByBPM: globalData.songsByBPM || {},
        currentSongIndex: 0,
        currentSequenceIndex: 0,
        initialSampleOrder: generatedSongs.length ? prepareInitialSampleOrder(generatedSongs[0]) : null,
        isSingleSong: generatedSongs.length === 1,
        isMultipleSongs: generatedSongs.length > 1,
        initialized: true
    });
}

// Initialize GainNodes for all generated songs once
globalData.songsArray.forEach(song => {
    GainNodeHelper.createGainNodesForSong(song);
});

// Set artwork image if applicable
if (globalData.isArtworkCover && artworkUrl.length) setArtworkImage(artworkUrl[0]);

// Dispatch data loading completion event
document.dispatchEvent(new CustomEvent("dataLoadingComplete", {
    detail: {
        success: true,
        totalSongs: globalData.songsArray.length,
        songs: globalData.songsArray.map(({ id, totalSequences }) => ({ id, totalSequences }))
    }
}));

// Expose generateMixBySeed to the global scope if needed
window.generateMixBySeed = generateMixBySeed;
        }
        
    
    })();
    

</script>

<!-- audioProcessingAndManagement -->
<script>
(async()=>{const e=window.globalData||(window.globalData={}),n=e.audioContext||(e.audioContext=new(window.AudioContext||window.webkitAudioContext)),o=e=>Uint8Array.from(atob(e),(e=>e.charCodeAt(0))).buffer,t=(e,n)=>{if("json"===n&&e.audioData){const n=e.audioData.match(/base64,([A-Za-z0-9+/=]+)/);return n?n[1]:null}if("html"===n)try{const n=new DOMParser,o=n.parseFromString(e,"text/html").querySelector('source[src^="data:audio/"]');if(o&&o.src){const e=o.src.match(/base64,([^"]+)/);return e?e[1]:null}return null}catch(e){return console.error(`[extractBase64][Error] Failed to parse HTML: ${e.message}`),null}return null},a=e=>{const n=e.replace(/\s+/g,"");return n.length%4==0&&/^[A-Za-z0-9+/]+={0,2}$/.test(n)},r=(e,n=.5)=>{let o=0;for(let n=0;n<e.numberOfChannels;n++){const t=e.getChannelData(n);for(const e of t){const n=Math.abs(e);n>o&&(o=n)}}const t=o>0?n/o:1;if(1!==t)for(let n=0;n<e.numberOfChannels;n++){const o=e.getChannelData(n);for(let e=0;e<o.length;e++)o[e]*=t}return e},s=async(o,t,a)=>{const{id:s,channels:c}=o,{id:d,url:u,metadata:{trimStartTime_Percentage:f,trimEndTime_Percentage:h,requiresReversal:g}}=t;try{const o=await fetch(u);if(!o.ok)return void console.error(`[ProcessChannel][Song: "${s}"] Fetch failed for URL: "${u}" - Status: ${o.status} ${o.statusText}. Skipping Channel ID: "${d}".`);const t=o.headers.get("Content-Type")||"",c=await i(o,t,u,s,d);if(!c)return void console.error(`[ProcessChannel][Song: "${s}"] Decoding failed for Channel ID: "${d}". Skipping.`);if(h<=f)return void console.error(`[ProcessChannel][Song: "${s}", Channel: "${d}"] Invalid trim percentages - Start: ${f}%, End: ${h}%. Skipping.`);const m=Math.floor(f/100*c.duration*c.sampleRate),$=Math.floor(h/100*c.duration*c.sampleRate),C=$-m;if(C<=0)return void console.error(`[ProcessChannel][Song: "${s}", Channel: "${d}"] Non-positive trimmed length: ${C} samples. Skipping.`);const w=n.createBuffer(c.numberOfChannels,C,c.sampleRate);for(let e=0;e<c.numberOfChannels;e++)w.getChannelData(e).set(c.getChannelData(e).subarray(m,$));const A=r(w,.5);if(e.audioBuffers=e.audioBuffers||{},e.reverseAudioBuffers=e.reverseAudioBuffers||{},e.audioBuffers[s]=e.audioBuffers[s]||{},e.reverseAudioBuffers[s]=e.reverseAudioBuffers[s]||{},e.audioBuffers[s][d]=A,g)try{const n=l(A);e.reverseAudioBuffers[s][d]=n}catch(e){console.error(`[ProcessChannel][Song: "${s}", Channel: "${d}"] Error reversing AudioBuffer: ${e.message}`)}a.push({"Song ID":s,"Channel ID":d,"Audio File":(p=u,p.split("/").pop()||"Unknown"),"Full Duration (s)":c.duration.toFixed(2),"Trimmed Duration (s)":w.duration.toFixed(2),"Requires Reversal":g})}catch(e){console.error(`[ProcessChannel][Song: "${s}", Channel: "${d}"] Unexpected error: ${e.message}`)}var p},i=async(r,s,i,l,c)=>{const d=e.audioFetchCache||(e.audioFetchCache=new Map);if(d.has(i))return d.get(i);try{let e;if(i.startsWith("data:audio/")){const t=i.split(",")[1];if(!a(t))return console.error(`[decodeAudioData][Song: "${l}", Channel: "${c}"] Invalid base64 data in data URI for URL: "${i}".`),null;const r=o(t);e=await n.decodeAudioData(r)}else if(/audio\/(wav|mpeg|mp4)|video\/mp4/.test(s)){const o=await r.arrayBuffer();e=await n.decodeAudioData(o)}else if(/application\/json/.test(s)){const s=await r.json(),i=t(s,"json");if(!i||!a(i))return null;const l=o(i);e=await n.decodeAudioData(l)}else if(/text\/html/.test(s)){const s=await r.text(),d=t(s,"html");if(!d||!a(d))return console.error(`[decodeAudioData][Song: "${l}", Channel: "${c}"] Invalid or missing base64 data in HTML for URL: "${i}".`),null;const u=o(d);e=await n.decodeAudioData(u)}else{if(!/audio\//.test(s))return console.error(`[decodeAudioData][Song: "${l}", Channel: "${c}"] Unsupported content type: "${s}" for URL: "${i}".`),null;const o=await r.arrayBuffer();e=await n.decodeAudioData(o)}return d.set(i,e),e}catch(e){return console.error(`[decodeAudioData][Song: "${l}", Channel: "${c}"] Decoding error for URL: "${i}" - ${e.message}`),null}},l=e=>{const o=n.createBuffer(e.numberOfChannels,e.length,e.sampleRate);for(let n=0;n<e.numberOfChannels;n++){const t=e.getChannelData(n),a=o.getChannelData(n);for(let e=0;e<t.length;e++)a[e]=t[t.length-e-1]}return r(o,.5)},c=e=>{e.length?console.table(e):console.warn("No audio samples processed.")},d=async()=>{try{"suspended"===n.state&&await n.resume(),await(async()=>{const{songsArray:o,initialSampleOrder:t}=e;if(!o.length)return void console.error("No songs to process.");const a=[],r=new Map;t.forEach((e=>{r.has(e.songId)||r.set(e.songId,[]),r.get(e.songId).push(e.channelId)}));for(const[e,n]of r.entries()){const t=o.find((n=>n.id===e));if(!t){console.warn(`Song with ID ${e} not found. Skipping.`);continue}const r=n.map((n=>{const o=t.channels.find((e=>e.id===n));return o?s(t,o):(console.warn(`Channel with ID ${n} not found in song ${e}. Skipping.`),null)})),i=(await Promise.all(r)).filter((e=>null!==e));a.push(...i),console.log(`Processed Song: "${t.id}" with ${i.length} channels.`)}c(a),console.log("Initial audio buffers ready.");const i=n.createGain();i.gain.value=.7,i.connect(n.destination),e.masterGain=i,console.log("Master Gain initialized with gain:",i.gain.value),document.dispatchEvent(new CustomEvent("initialAudioBuffersReady",{detail:{success:!0}}))})();try{const{songsArray:n,initialSampleOrder:o}=e;if(!n.length)return void console.error("No songs to process.");const t=[],a=n.flatMap((e=>e.channels.map((n=>({song:e,channel:n}))))),r=new Set(o.map((e=>`${e.songId}-${e.channelId}`))),i=a.filter((({song:e,channel:n})=>!r.has(`${e.id}-${n.id}`))),l=[];for(;i.length;)l.push(i.splice(0,4));for(const e of l)await Promise.all(e.map((({song:e,channel:n})=>s(e,n,t))));c(t),console.log("All background audio buffers processed."),document.dispatchEvent(new CustomEvent("allAudioBuffersReady",{detail:{success:!0}}))}catch(e){console.error("Background processing error:",e)}}catch(e){console.error("Audio processing initialization error:",e)}};document.addEventListener("dataLoadingComplete",d),e.songsArray?.length&&d(),document.addEventListener("initialAudioBuffersReady",(()=>{console.log("Initial buffers ready. Press 'P' to play.")}))})();
</script>
<!-- unifiedMetadataManagement -->
<script>
(()=>{const t=t=>{const a=t?.match(/Song\s+\d+:\s+(.+)/);return a?.[1]?.trim()||"UNKNOWN PROJECT NAME"},a=(t,a,n)=>a?.[t]||n||"Unknown Artist Name",n=t=>{if(!Array.isArray(t)||0===t.length)return void console.warn("No songs data available to process.");const a=e(t);o(a),r(a)},e=n=>{const e=window.globalData?.projectArtistMap||window.projectArtistMap||{};return n.map(((n,o)=>({trackNumber:o+1,projectName:t(n.id),artistName:a(t(n.id),e,n.artist)})))},o=t=>{const a=document.getElementById("metadataContent");if(!a)return void console.warn("Metadata content container (#metadataContent) not found.");const n=t.map((({trackNumber:t,projectName:a,artistName:n})=>`\n            <div class="metadataItem">\n                <h2>${t}. ${a}</h2>\n                <p>${n}</p>\n            </div>\n        `)).join("");a.innerHTML=n},r=t=>{t.forEach((({projectName:t,artistName:a})=>{}))},i=()=>{const t=document.getElementById("trackListingPanel");t?t.classList.toggle("visible"):console.warn("Metadata panel container (#trackListingPanel) not found.")};(()=>{try{window.globalData?.songsArray?.length?n(window.globalData.songsArray):(document.addEventListener("dataLoadingComplete",(({detail:{songs:t}={}})=>{n(t)})),document.addEventListener("keydown",(({key:t})=>{"t"===t.toLowerCase()&&i()})))}catch(t){console.error("Error initializing Metadata Management and Logging:",t)}})()})();
</script>
<!-- Load Player Scripts AFTER data loading is complete -->
<script>
document.addEventListener("dataLoadingComplete",(e=>{const c=e=>{if(0===e.length)return;const d=e.shift(),t=document.createElement("script");t.src=d,t.async=!1,t.onload=()=>c(e),t.onerror=t=>{console.error(`[Script Loader] Error loading script: ${d}`,t),c(e)},document.body.appendChild(t)};c(["/content/5c03e882ab5a531271b2e93a80d8a9d72cb533c580bec1567020f5cd61595560i0","/content/7b305327f2951d219532ef0cb46b2039b23f2cfd0d8d0e827f3fe1b2b754b5a9i0","/content/8b5b09cfedbc0c6a187816181f8d33f90c5bbd15fc10af47008176effb866a47i0"]),updateSeedDisplay()}));
</script>
<!-- Playback -->
<script>
    /*
    <details>
        <summary>🔍 How to Access Global Timing Information</summary>
        <p>The playback engine exposes global timing information through the <code>window.globalData</code> object. Other modules can access the following properties and events to monitor and interact with playback:</p>
        <ul>
            <li><strong>Playback Status:</strong> <code>window.globalData.isPlaying</code> - <em>Boolean</em> indicating if playback is active.</li>
            <li><strong>Current Song Index:</strong> <code>window.globalData.currentSongIndex</code> - <em>Number</em> representing the index of the currently playing song.</li>
            <li><strong>Current Sequence:</strong> <code>window.globalData.currentSequence</code> - <em>Number</em> indicating the currently active sequence.</li>
            <li><strong>Playback Events:</strong>
                <ul>
                    <li><code>'playbackStarted'</code> - Dispatched when playback starts.</li>
                    <li><code>'playbackStopped'</code> - Dispatched when playback stops.</li>
                </ul>
                <em>Use <code>document.addEventListener</code> to listen for these events.</em>
            </li>
            <li><strong>Audio Context Current Time:</strong> <code>window.globalData.audioContext.currentTime</code> - <em>Number</em> representing the current time of the AudioContext for precise timing.</li>
            <li><strong>Playback Control Methods:</strong>
                <ul>
                    <li><code>window.globalData.startPlayback()</code> - Starts playback.</li>
                    <li><code>window.globalData.stopPlayback()</code> - Stops playback.</li>
                    <li><code>window.globalData.togglePlayback()</code> - Toggles playback state.</li>
                    <li><code>window.globalData.resetPlayback()</code> - Resets and restarts playback.</li>
                </ul>
            </li>
        </ul>
        <p><strong>Example Usage:</strong></p>
        <pre><code>
// Check if playback is active
if (window.globalData.isPlaying) {
    console.log("Playback is currently active.");
}

// Listen for playback start
document.addEventListener("playbackStarted", (event) => {
    console.log("Playback has started.");
});

// Start playback
window.globalData.startPlayback();
        </code></pre>
    </details>
    */

 // playbackEngine.js
(() => {
    // Initialize global data or use existing globalData
    const globalData = window.globalData || (window.globalData = {
        isPlaying: false,
        currentSongIndex: 0,
        songsArray: [],
        audioBuffers: {},
        reverseAudioBuffers: {},
        audioContext: new (window.AudioContext || window.webkitAudioContext)(),
        masterGain: null,
        gainNodes: {},
        isArtworkCover: true,
        isVisualiserCover: false,
        compressor: null,      // Compressor Node
        lowShelfFilter: null,  // Low-Shelf Filter Node
        analyser: null,        // AnalyserNode
        isAudioProcessingInitialized: false, // Flag to prevent re-initialization
        currentSeed: 1n        // Initialize seed as BigInt
    });

    // Initialize the current sequence counter
    globalData.currentSequence = 0;

    const { audioContext } = globalData;
    const scheduleAheadTime = 0.1; // Time in seconds to schedule ahead
    const schedulerInterval = 25;   // Interval in milliseconds for the scheduler

    let playbackInterval = null;
    let sequenceStates = {};

    const missingAudioBuffers = new Set();
    const activeAudioSources = new Set();

    let countdownInterval = null;

    /**
     * Initializes the audio processing chain with Compressor, Low-Shelf Filter, and AnalyserNode.
     */
    function initializeAudioProcessingChain() {
        // Prevent re-initialization if already done
        if (globalData.isAudioProcessingInitialized) {
            console.log("[PlaybackEngine] Audio processing chain already initialized.");
            return;
        }

        // **Initialize Compressor**
        if (!globalData.compressor) {
            globalData.compressor = audioContext.createDynamicsCompressor();
            globalData.compressor.threshold.setValueAtTime(-24, audioContext.currentTime);
            globalData.compressor.knee.setValueAtTime(30, audioContext.currentTime);
            globalData.compressor.ratio.setValueAtTime(12, audioContext.currentTime);
            globalData.compressor.attack.setValueAtTime(0.003, audioContext.currentTime);
            globalData.compressor.release.setValueAtTime(0.25, audioContext.currentTime);

            console.log("[PlaybackEngine] Compressor node initialized.");
        }

        // **Initialize Master Gain**
        if (!globalData.masterGain) {
            globalData.masterGain = audioContext.createGain();
            globalData.masterGain.gain.setValueAtTime(1, audioContext.currentTime); // Set default gain

            // Connect masterGain to compressor
            globalData.masterGain.connect(globalData.compressor);
            console.log("[PlaybackEngine] Master Gain node created and connected to Compressor.");
        }

        // **Initialize Low-Shelf Filter**
        if (!globalData.lowShelfFilter) {
            globalData.lowShelfFilter = audioContext.createBiquadFilter();
            globalData.lowShelfFilter.type = "lowshelf";
            globalData.lowShelfFilter.frequency.setValueAtTime(50, audioContext.currentTime); // 50 Hz cutoff
            globalData.lowShelfFilter.gain.setValueAtTime(-6, audioContext.currentTime); // -6 dB attenuation

            // Connect compressor to lowShelfFilter
            globalData.compressor.connect(globalData.lowShelfFilter);
            console.log("[PlaybackEngine] Low-shelf filter initialized and connected to Compressor.");
        }

        // **Initialize AnalyserNode**
        if (!globalData.analyser) {
            globalData.analyser = audioContext.createAnalyser();
            globalData.analyser.fftSize = 2048;
            globalData.analyser.smoothingTimeConstant = 0.8;

            // Connect lowShelfFilter to AnalyserNode
            globalData.lowShelfFilter.connect(globalData.analyser);
            console.log("[PlaybackEngine] Analyser node initialized and connected to Low-Shelf Filter.");

            // Connect AnalyserNode to audio destination
            globalData.analyser.connect(audioContext.destination);
            console.log("[PlaybackEngine] Analyser node connected to AudioContext destination.");
        }

        // **Mark Audio Processing as Initialized**
        globalData.isAudioProcessingInitialized = true;
        console.log("[PlaybackEngine] Audio processing chain fully initialized.");

        // **Set Up Bass Monitoring Loop**
        setupBassMonitoring();
    }

    /**
     * Monitors low-frequency (bass) levels in real-time and adjusts the low-shelf filter accordingly.
     */
     function monitorLowFrequencies() {
         // Protective Checks
            if (!globalData.analyser) {
                console.error("[monitorLowFrequencies] AnalyserNode is not initialized in globalData.analyser.");
                return;
            }

            if (!globalData.lowShelfFilter) {
                console.error("[monitorLowFrequencies] lowShelfFilter is not initialized in globalData.lowShelfFilter.");
                return;
            }

            const bufferLength = globalData.analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            globalData.analyser.getByteFrequencyData(dataArray);

            // Calculate average bass level (e.g., frequencies below 250 Hz)
            const bassFrequency = 250;
            const nyquist = audioContext.sampleRate / 2;
            const bassBin = Math.floor(bassFrequency / nyquist * bufferLength);
            const bassLevels = dataArray.slice(0, bassBin);

            // Protective Check: Ensure there are bass levels to process
            if (bassLevels.length === 0) {
                console.warn("[monitorLowFrequencies] No bass levels found in the current frequency data.");
                return;
            }

            const averageBass = bassLevels.reduce((sum, value) => sum + value, 0) / bassLevels.length;

            // console.log(`[Monitoring] Average Bass Level: ${averageBass.toFixed(2)}`);

            // Define a threshold (e.g., 100 out of 255)
            const bassThreshold = 100;

            if (averageBass > bassThreshold) {
                // Attenuate the low-shelf filter further
                const currentGain = globalData.lowShelfFilter.gain.value;
                const newGain = currentGain - 0.5;
                globalData.lowShelfFilter.gain.setValueAtTime(newGain, audioContext.currentTime);
                // console.log(`[Monitoring] Attenuated low-shelf filter to reduce bass. New Gain: ${newGain}`);
            } else if (averageBass < bassThreshold - 20) {
                // Restore the low-shelf filter gain
                const currentGain = globalData.lowShelfFilter.gain.value;
                const newGain = currentGain + 0.5;
                globalData.lowShelfFilter.gain.setValueAtTime(newGain, audioContext.currentTime);
                // console.log(`[Monitoring] Restored low-shelf filter gain. New Gain: ${newGain}`);
            }
        }

    /**
     * Sets up the monitoring loop using requestAnimationFrame for smoother updates.
     */
    function setupBassMonitoring() {
        // Ensure AnalyserNode is initialized
        if (!globalData.analyser) {
            console.error("[setupBassMonitoring] AnalyserNode is not available. Cannot set up bass monitoring.");
            return;
        }

        // Recursive function to continuously monitor bass frequencies
        function monitoringLoop() {
            monitorLowFrequencies();
            requestAnimationFrame(monitoringLoop);
        }

        // Start the monitoring loop
        monitoringLoop();
        console.log("[setupBassMonitoring] Bass monitoring loop initiated using requestAnimationFrame.");
    }

    /**
     * Function to start playback
     */
    function startPlayback() {
        const { songsArray, currentSongIndex } = globalData;

        if (!songsArray.length) {
            console.error("No songs available for playback.");
            return;
        }

        // Get the current song and its sequences
        const song = songsArray[currentSongIndex % songsArray.length];
        const projectSequences = song.projectSequences || {};

        const stepDuration = 60 / song.bpm / 4;       // Duration of a single step
        const sequenceDuration = 64 * stepDuration;   // Total duration of a sequence

        // Reset states and logs
        globalData.currentSongIndex %= songsArray.length;
        sequenceStates = {};
        missingAudioBuffers.clear();

        console.log(`Starting playback for Song: ${song.id} (${globalData.currentSongIndex + 1}/${songsArray.length}) with ${Object.keys(projectSequences).length} sequences.`);
        console.log(`Song BPM: ${song.bpm}`);

        // **Update Synth's BPM Here**
        if (window.synth && typeof window.synth.updateBPM === 'function') {
            window.synth.updateBPM(song.bpm);
            console.log(`Synth BPM updated to ${song.bpm} BPM.`);
        } else {
            console.warn("Synth instance not found or updateBPM method unavailable.");
        }

        let sequenceStartTimeOffset = 0;
        let orderedSequenceNumber = 1; // Start from 1

        // Initialize sequence states with ordered sequence numbers
        for (const [sequenceId, sequenceData] of Object.entries(projectSequences)) {
            sequenceStates[sequenceId] = {
                sequenceNumber: orderedSequenceNumber, // Assign ordered number
                nextStepIndex: 0,
                nextStepTime: globalData.audioContext.currentTime + sequenceStartTimeOffset,
                stepDuration: stepDuration,
                endTime: globalData.audioContext.currentTime + sequenceStartTimeOffset + sequenceDuration,
                completed: false,
                loggedStart: false // Initialize the loggedStart flag
            };
            sequenceStartTimeOffset += sequenceDuration;
            orderedSequenceNumber++;
        }

        globalData.currentSongId = song.id;

        // **Initialize Compressor and Low-Shelf Filter if not already done**
        initializeAudioProcessingChain();

        // Prepare gain nodes for the song
        GainNodeHelper.createGainNodesForSong(song);
        GainNodeHelper.prepareNextSongGainNodes(songsArray[(globalData.currentSongIndex + 1) % songsArray.length]);
        globalData.isPlaying = true;

        // Reset currentSequence to 1 for the new song
        globalData.currentSequence = 1;

        // Start the playback scheduler
        playbackInterval = setInterval(() => scheduleSequences(song), schedulerInterval);

        console.log("Sequences scheduled and playback started.");
        document.dispatchEvent(new CustomEvent("playbackStarted", { detail: { success: true } }));

        // Update Now Playing information
        updateNowPlaying(song);
    }

    /**
     * Function to stop playback
     */
    function stopPlayback() {
        if (!globalData.isPlaying) {
            console.log("Playback is not in progress.");
            return;
        }

        resetPlayback();
        console.log("Playback stopped.");
        document.dispatchEvent(new CustomEvent("playbackStopped", { detail: { success: true } }));

        // Clear Now Playing information
        clearNowPlaying();

        // Clear countdown timer
        if (countdownInterval) {
            clearInterval(countdownInterval);
            countdownInterval = null;
        }
    }

    /**
     * Function to reset playback
     */
    function resetPlayback(options = {}) {
        clearInterval(playbackInterval);
        if (!options.preserveIsPlaying) {
            globalData.isPlaying = false;
        }

        sequenceStates = {};
        missingAudioBuffers.clear();

        // Stop and disconnect all active audio sources
        activeAudioSources.forEach(source => {
            try {
                source.stop();
                source.disconnect();
            } catch (error) {
                // console.error("Error stopping/disconnecting an audio source:", error);
            }
        });
        activeAudioSources.clear();

        // Clean up gain nodes
        if (globalData.currentSongId) {
            GainNodeHelper.cleanupGainNodesForSong(globalData.currentSongId);
            globalData.currentSongId = null;
        }

        // Clear countdown timer
        if (countdownInterval) {
            clearInterval(countdownInterval);
            countdownInterval = null;
        }

        // Execute callback if provided
        if (options.callback) {
            options.callback();
        }
    }

    /**
     * Toggle playback function
     */
    globalData.togglePlayback = () => globalData.isPlaying ? stopPlayback() : startPlayback();
    globalData.startPlayback = startPlayback;
    globalData.stopPlayback = stopPlayback;
    globalData.resetPlayback = () => resetPlayback({ callback: startPlayback });

    /**
     * Function to schedule sequences
     */
    function scheduleSequences(song) {
        const currentTime = audioContext.currentTime;
        let allSequencesCompleted = true;
        const totalSequences = Object.keys(song.projectSequences).length;

        for (const [sequenceId, sequenceData] of Object.entries(song.projectSequences || {})) {
            const sequenceState = sequenceStates[sequenceId];

            if (sequenceState && !sequenceState.completed) {
                if (currentTime >= sequenceState.endTime) {
                    sequenceState.completed = true;
                    console.log(`Sequence ${sequenceState.sequenceNumber} has completed.`);
                } else {
                    allSequencesCompleted = false;

                    // Check if a new sequence is starting
                    if (currentTime >= sequenceState.nextStepTime && !sequenceState.loggedStart) {
                        globalData.currentSequence = sequenceState.sequenceNumber;
                        // console.log(`Updating current sequence display: Sequence ${globalData.currentSequence} out of ${totalSequences}`);
                        sequenceState.loggedStart = true; // Prevent logging again
                    }

                    // Schedule steps ahead of time
                    while (sequenceState.nextStepTime < currentTime + scheduleAheadTime && globalData.isPlaying) {
                        const { nextStepIndex, nextStepTime, stepDuration } = sequenceState;

                        // **Log when a new sequence starts**
                        if (nextStepIndex === 0 && !sequenceState.loggedStart) {
                            console.log(`Starting Sequence ${sequenceState.sequenceNumber} at step ${nextStepIndex}.`);
                            sequenceState.loggedStart = true; // Prevent logging again
                        }

                        for (const [channelKey, noteData] of Object.entries(sequenceData)) {
                            const channelIndex = parseInt(channelKey.slice(2), 10);
                            const channel = song.channels[channelIndex];

                            if (!channel) {
                                // console.warn(`Channel index ${channelIndex} not found in song ${song.id}.`);
                                continue;
                            }

                            const step = noteData.steps?.find(step => 
                                typeof step === 'number' ? step === nextStepIndex : step.index === nextStepIndex
                            );

                            if (step !== undefined) {
                                const reverse = typeof step === 'object' && step.reverse;
                                playNote(song, channel, nextStepTime, reverse);
                            }
                        }

                        // Move to the next step
                        sequenceState.nextStepIndex++;
                        if (sequenceState.nextStepIndex >= 64) {
                            sequenceState.completed = true;
                            console.log(`Sequence ${sequenceState.sequenceNumber} has completed all steps.`);
                            break;
                        }
                        sequenceState.nextStepTime += stepDuration;
                    }
                }
            }
        }

        if (allSequencesCompleted) {
            console.log("All sequences have completed.");
            proceedToNextSong();
        }

        applyMuteSchedule(song, globalData.currentSequence);
    }

    /**
     * Function to play a note on a specific channel at a given time with fade-in and fade-out to prevent clicks.
     *
     * @param {Object} song - The song object.
     * @param {Object} channel - The channel object.
     * @param {number} time - The scheduled time to play the note.
     * @param {boolean} reverse - Whether to play the note in reverse.
     */
    function playNote(song, channel, time, reverse) {
        const bufferKey = `${song.id}_${channel.id}_${reverse ? "reverse" : "normal"}`;
        const buffer = reverse
            ? globalData.reverseAudioBuffers[song.id]?.[channel.id]
            : globalData.audioBuffers[song.id]?.[channel.id];

        if (!buffer) {
            if (!missingAudioBuffers.has(bufferKey)) {
                missingAudioBuffers.add(bufferKey);
                // console.warn(`Audio buffer missing for Song: ${song.id}, Channel: ${channel.id}${reverse ? " (Reverse)" : ""}`);
            }
            return;
        }

        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.playbackRate.value = channel.metadata.playbackSpeed || 1;

        // Create a GainNode for this source to handle fade-in and fade-out
        const sourceGain = audioContext.createGain();
        sourceGain.gain.setValueAtTime(0, time); // Start with gain at 0 for fade-in

        // Connect source -> sourceGain -> channel's GainNode
        source.connect(sourceGain);
        const channelGainNode = globalData.gainNodes?.[song.id]?.[channel.id] || globalData.masterGain;
        sourceGain.connect(channelGainNode);

        // Define fade durations in seconds
        const fadeInDuration = 0.01;  // 10 ms
        const fadeOutDuration = 0.01; // 10 ms

        // Schedule fade-in
        sourceGain.gain.linearRampToValueAtTime(channel.metadata.volume || 1, time + fadeInDuration);

        // Calculate the stop time considering fade-out
        const stopTime = time + buffer.duration / source.playbackRate.value;
        const adjustedStopTime = stopTime - fadeOutDuration;

        // Schedule fade-out
        sourceGain.gain.setValueAtTime(channel.metadata.volume || 1, adjustedStopTime);
        sourceGain.gain.linearRampToValueAtTime(0, stopTime);

        // Start the source
        source.start(time);

        // Schedule stop
        source.stop(stopTime);

        // Track active sources for cleanup
        activeAudioSources.add(source);
        source.onended = () => activeAudioSources.delete(source);
    }

   

    /**
     * Function to apply mute/unmute based on muteSchedule
     */
    function applyMuteSchedule(song, currentSequence) {
        const { muteSchedule } = song;
        if (!muteSchedule || !Array.isArray(muteSchedule)) return;

        // Find actions scheduled for the current sequence
        const actions = muteSchedule.filter(actionItem => actionItem.sequence === currentSequence);

        actions.forEach(actionItem => {
            const { action, channels } = actionItem;
            channels.forEach(channelId => {
                const channel = song.channels.find(ch => ch.id === channelId);
                if (channel) {
                    if (action === 'mute') {
                        muteChannel(channel);
                    } else if (action === 'unmute') {
                        if (getActiveChannelCount(song) < MAX_ACTIVE_CHANNELS) {
                            unmuteChannel(channel);
                        }
                    }
                }
            });
        });
    }


    function getActiveChannelCount(song) {
        return song.channels.filter(ch => !ch.metadata.isMuted).length;
    }

    function muteChannel(channel) {
        if (!channel.metadata.isMuted) {
            channel.metadata.isMuted = true;
            const gainNode = globalData.gainNodes[song.id]?.[channel.id];
            if (gainNode) {
                gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5); // 0.5 second fade-out
                // console.log(`Channel ${channel.id} muted with fade-out.`);
            }
        }
    }

    function unmuteChannel(channel) {
        if (channel.metadata.isMuted) {
            channel.metadata.isMuted = false;
            const gainNode = globalData.gainNodes[song.id]?.[channel.id];
            if (gainNode) {
                gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.5); // 0.5 second fade-in
                // console.log(`Channel ${channel.id} unmuted with fade-in.`);
            }
        }
    }

    /**
     * Function to update Now Playing information
     */
    function updateNowPlaying(song) {
        const nowPlayingContainer = document.getElementById("nowPlayingContainer");
        if (!nowPlayingContainer) {
            // console.warn("Now Playing Container not found.");
            return;
        }

        const { projectName, artistName } = getProjectAndArtist(song);
        nowPlayingContainer.querySelector(".songTitle").textContent = projectName;
        nowPlayingContainer.querySelector(".artistName").textContent = artistName;
        nowPlayingContainer.querySelector(".songBPM").textContent = `BPM: ${song.bpm}`;

        initializeCountdown(song);
    }

    /**
     * Function to clear Now Playing information
     */
    function clearNowPlaying() {
        const nowPlayingContainer = document.getElementById("nowPlayingContainer");
        if (!nowPlayingContainer) {
            // console.warn("Now Playing Container not found.");
            return;
        }
        nowPlayingContainer.querySelector(".songTitle").textContent = "No song playing";
        nowPlayingContainer.querySelector(".artistName").textContent = "";
        nowPlayingContainer.querySelector(".songBPM").textContent = "BPM: N/A";
        nowPlayingContainer.querySelector(".timeLeft").textContent = "Time Left: N/A";
    }

    /**
     * Function to initialize countdown timer
     */
    function initializeCountdown(song) {
        // Clear any existing interval
        if (countdownInterval) {
            clearInterval(countdownInterval);
        }

        const nowPlayingContainer = document.getElementById("nowPlayingContainer");
        if (!nowPlayingContainer) return;

        const timeLeftElement = nowPlayingContainer.querySelector(".timeLeft");
        if (!timeLeftElement) return;

        // Calculate total duration in seconds
        const stepDuration = 60 / song.bpm / 4;
        const stepsPerSequence = 64;
        const totalSequences = Object.keys(song.projectSequences).length;
        const totalDuration = stepDuration * stepsPerSequence * totalSequences;

        let timeLeft = totalDuration;

        // Update the display immediately
        updateTimeLeftDisplay(timeLeftElement, timeLeft);

        // Update every second
        countdownInterval = setInterval(() => {
            if (globalData.isPlaying) {
                timeLeft -= 1;
                if (timeLeft <= 0) {
                    timeLeft = 0;
                    clearInterval(countdownInterval);
                }
                updateTimeLeftDisplay(timeLeftElement, timeLeft);
            } else {
                clearInterval(countdownInterval);
            }
        }, 1000);
    }

    /**
     * Function to update the Time Left display
     */
    function updateTimeLeftDisplay(element, timeLeftInSeconds) {
        const minutes = Math.floor(timeLeftInSeconds / 60);
        const seconds = Math.floor(timeLeftInSeconds % 60);
        element.textContent = `Time Left: ${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    /**
     * Function to reset playback
     */
    function resetPlayback(options = {}) {
        clearInterval(playbackInterval);
        if (!options.preserveIsPlaying) {
            globalData.isPlaying = false;
        }

        sequenceStates = {};
        missingAudioBuffers.clear();

        // Stop and disconnect all active audio sources
        activeAudioSources.forEach(source => {
            try {
                source.stop();
                source.disconnect();
            } catch (error) {
                // console.error("Error stopping/disconnecting an audio source:", error);
            }
        });
        activeAudioSources.clear();

        // Clean up gain nodes
        if (globalData.currentSongId) {
            GainNodeHelper.cleanupGainNodesForSong(globalData.currentSongId);
            globalData.currentSongId = null;
        }

        // Clear countdown timer
        if (countdownInterval) {
            clearInterval(countdownInterval);
            countdownInterval = null;
        }

        // Execute callback if provided
        if (options.callback) {
            options.callback();
        }
    }

  /**
 * Function to proceed to the next song
 */
function proceedToNextSong() {
    if (!globalData.isPlaying) return;

    // Increment the seed here
    globalData.currentSeed = (globalData.currentSeed !== undefined ? BigInt(globalData.currentSeed) : 1n) + 1n;
    console.log(`Seed progressed to: ${globalData.currentSeed}`);

    // Update the song index
    globalData.currentSongIndex = (globalData.currentSongIndex + 1) % globalData.songsArray.length;

    setTimeout(() => {
        if (globalData.isPlaying) {
            // Retrieve the next song based on the updated index
            const nextSong = globalData.songsArray[globalData.currentSongIndex];
            if (nextSong) {
                // Assign the updated seed to the next song
                nextSong.seed = globalData.currentSeed.toString();
                // console.log(`Assigned new seed to song: ${nextSong.id} -> Seed: ${nextSong.seed}`);

                // Reset playback with callback to start playback
                resetPlayback({ preserveIsPlaying: true, callback: () => {
                    startPlayback();

                    // Dispatch 'songChanged' event with the new song's details
                    document.dispatchEvent(new CustomEvent("songChanged", { detail: { song: nextSong } }));
                }});
            } else {
                // console.warn("Next song not found in songsArray.");
            }
        }
    }, 200);
}

    /**
     * Function to play an AudioBuffer through the audio processing chain.
     *
     * @param {AudioBuffer} audioBuffer - The audio buffer to play.
     */
    function playAudioBuffer(audioBuffer) {
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(globalData.masterGain); // Connect to Master Gain
        source.start();
        // console.log("[PlaybackEngine] AudioBufferSourceNode started.");

        // Track active sources for cleanup
        activeAudioSources.add(source);
        source.onended = () => activeAudioSources.delete(source);
    }

    /**
     * Function to play a note on a specific channel at a given time with fade-in and fade-out to prevent clicks.
     *
     * @param {Object} song - The song object.
     * @param {Object} channel - The channel object.
     * @param {number} time - The scheduled time to play the note.
     * @param {boolean} reverse - Whether to play the note in reverse.
     */
    function playNote(song, channel, time, reverse) {
        const bufferKey = `${song.id}_${channel.id}_${reverse ? "reverse" : "normal"}`;
        const buffer = reverse
            ? globalData.reverseAudioBuffers[song.id]?.[channel.id]
            : globalData.audioBuffers[song.id]?.[channel.id];

        if (!buffer) {
            if (!missingAudioBuffers.has(bufferKey)) {
                missingAudioBuffers.add(bufferKey);
                // console.warn(`Audio buffer missing for Song: ${song.id}, Channel: ${channel.id}${reverse ? " (Reverse)" : ""}`);
            }
            return;
        }

        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.playbackRate.value = channel.metadata.playbackSpeed || 1;

        // Create a GainNode for this source to handle fade-in and fade-out
        const sourceGain = audioContext.createGain();
        sourceGain.gain.setValueAtTime(0, time); // Start with gain at 0 for fade-in

        // Connect source -> sourceGain -> channel's GainNode
        source.connect(sourceGain);
        const channelGainNode = globalData.gainNodes?.[song.id]?.[channel.id] || globalData.masterGain;
        sourceGain.connect(channelGainNode);

        // Define fade durations in seconds
        const fadeInDuration = 0.01;  // 10 ms
        const fadeOutDuration = 0.01; // 10 ms

        // Schedule fade-in
        sourceGain.gain.linearRampToValueAtTime(channel.metadata.volume || 1, time + fadeInDuration);

        // Calculate the stop time considering fade-out
        const stopTime = time + buffer.duration / source.playbackRate.value;
        const adjustedStopTime = stopTime - fadeOutDuration;

        // Schedule fade-out
        sourceGain.gain.setValueAtTime(channel.metadata.volume || 1, adjustedStopTime);
        sourceGain.gain.linearRampToValueAtTime(0, stopTime);

        // Start the source
        source.start(time);

        // Schedule stop
        source.stop(stopTime);

        // Track active sources for cleanup
        activeAudioSources.add(source);
        source.onended = () => activeAudioSources.delete(source);
    }

    /**
     * Function to get project name and artist name from song object
     */
    function getProjectAndArtist(song) {
        return {
            projectName: song.projectName || song.id || "Unknown Project",
            artistName: song.artist || "Unknown Artist"
        };
    }

   
    function getActiveChannelCount(song) {
        return song.channels.filter(ch => !ch.metadata.isMuted).length;
    }

    function muteChannel(channel) {
        if (!channel.metadata.isMuted) {
            channel.metadata.isMuted = true;
            const gainNode = globalData.gainNodes[song.id]?.[channel.id];
            if (gainNode) {
                gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5); // 0.5 second fade-out
                // console.log(`Channel ${channel.id} muted with fade-out.`);
            }
        }
    }

    function unmuteChannel(channel) {
        if (channel.metadata.isMuted) {
            channel.metadata.isMuted = false;
            const gainNode = globalData.gainNodes[song.id]?.[channel.id];
            if (gainNode) {
                gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.5); // 0.5 second fade-in
                // console.log(`Channel ${channel.id} unmuted with fade-in.`);
            }
        }
    }

    /**
     * Function to clean up gain nodes for a specific song
     */
    // Assuming GainNodeHelper has a cleanup function
    // If not, define it accordingly
    // Example:
    /*
    const GainNodeHelper = {
        createGainNodesForSong: function(song) { ... },
        prepareNextSong: function(song) { ... },
        cleanupGainNodesForSong: function(songId) { ... }
    };
    */

    // Function to initialize playback engine
    globalData.initializePlaybackEngine = () => {
        if (!globalData.songsArray.length) {
            // console.error("No songs available for playback.");
            return;
        }
        // console.log("Playback Engine Initialization Complete.");
    };

    /**
     * Set up artwork cover for playback toggle
     */
    function setupArtworkCover() {
        document.addEventListener("DOMContentLoaded", () => {
            const artworkCover = document.getElementById("artworkCover");
            const artworkImage = document.getElementById("artworkImage");
            const loadingSpinner = document.getElementById("loadingSpinner");

            if (globalData.isArtworkCover && globalData.songsArray.length) {
                // Assuming artworkUrl is part of the first song
                const firstSong = globalData.songsArray[0];
                const artworkUrl = firstSong.artworkUrl || [];

                if (artworkUrl.length) {
                    artworkImage.src = artworkUrl[0];
                    artworkCover.classList.remove("hidden");
                    loadingSpinner.style.display = "none";
                    artworkImage.addEventListener("click", globalData.togglePlayback);
                    // console.log("Artwork cover is set up for playback toggle.");
                } else {
                    // console.warn("No artwork URL provided for the first song.");
                }
            } else {
                // console.warn("Artwork cover is not enabled or no songs available.");
            }
        });
    }

    /**
     * Event listener for initial audio buffers ready
     */
    document.addEventListener("initialAudioBuffersReady", (event) => {
        if (event.detail.success) {
            globalData.initializePlaybackEngine();
            console.log("Initial audio buffers are ready.");
        }
    });

    /**
     * Event listeners for playback started and stopped
     */
    ["playbackStarted", "playbackStopped"].forEach((eventType) => {
        document.addEventListener(eventType, (event) => {
            if (event.detail.success) {
                console.log(`Playback has been successfully ${eventType === "playbackStarted" ? "started" : "stopped"}.`);
            }
        });
    });

    // Initialize artwork cover setup
    setupArtworkCover();

    // Initialize playback engine if audio buffers are already loaded
    if (Object.keys(globalData.audioBuffers).length) {
        globalData.initializePlaybackEngine();
    }

    /**
     * Function to initialize countdown timer
     */
    function initializeCountdown(song) {
        // Clear any existing interval
        if (countdownInterval) {
            clearInterval(countdownInterval);
        }

        const nowPlayingContainer = document.getElementById("nowPlayingContainer");
        if (!nowPlayingContainer) return;

        const timeLeftElement = nowPlayingContainer.querySelector(".timeLeft");
        if (!timeLeftElement) return;

        // Calculate total duration in seconds
        const stepDuration = 60 / song.bpm / 4;
        const stepsPerSequence = 64;
        const totalSequences = Object.keys(song.projectSequences).length;
        const totalDuration = stepDuration * stepsPerSequence * totalSequences;

        let timeLeft = totalDuration;

        // Update the display immediately
        updateTimeLeftDisplay(timeLeftElement, timeLeft);

        // Update every second
        countdownInterval = setInterval(() => {
            if (globalData.isPlaying) {
                timeLeft -= 1;
                if (timeLeft <= 0) {
                    timeLeft = 0;
                    clearInterval(countdownInterval);
                }
                updateTimeLeftDisplay(timeLeftElement, timeLeft);
            } else {
                clearInterval(countdownInterval);
            }
        }, 1000);
    }

    /**
     * Function to clean up gain nodes for a specific song
     */
    // Implement or ensure that GainNodeHelper has the necessary methods
    // For example:
    /*
    const GainNodeHelper = {
        createGainNodesForSong: function(song) {
            // Implementation here
        },
        prepareNextSong: function(song) {
            // Implementation here
        },
        cleanupGainNodesForSong: function(songId) {
            // Implementation here
            // Disconnect and delete gain nodes
        }
    };
    */

    // Function to handle UI artwork click
    // Already set up in setupArtworkCover

    // Additional helper functions (scheduleSequences, etc.) should be defined as needed
    // Ensure that all dependencies are properly implemented

})();
</script>
</body>
</html>