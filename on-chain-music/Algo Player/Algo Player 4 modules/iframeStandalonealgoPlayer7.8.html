<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Seed Input Page</title>


    <script>
        // ----------------------------
        // Initialization of Variables
        // ----------------------------

        // Define your songDataUrls directly
        const songDataUrls = [
            "/content/5527d0cc95ce5ce6eedf4e275234da8b1fe087512d0db618b6de1aaad437c96bi0", 
            "/content/b22f1c85371b58a9cdac19b2baa50b1f9025a28d44cdfaad539d0527aa7d894ei0", 
            "/content/8aec0a99a5617b9da98a5b63a11a5143f0cac3cfa662d9515c2285de03ef95d4i0",
            "/content/6d288c0c82653001bb32497889dd1486e8afec9b0671a95fa9e10f99c20737bbi0",
            "/content/07ff7bdc47e5272a3ff55cc46d2b189d510562a057a2c24112f3d0376950484di0", 
            "/content/119a3ccd1dfd7e987cca139f86d16717d845a22dd6afc59ad492527b95ae9a91i0",
            "/content/db9131cfe8e933e8e639f007dcd2b582a80bfd2be42b0eafa4d2e206332d6785i0", 
            "/content/fb0d2abcd1fa5bf2622579f0990435b48d41291f71626fc2e36a93e6ea6b3b85i0", 
            "/content/3359ce42359274ddbd2184d9f75a38b7e59b1d5f24512959e29c377fc8ca604ai0",
            "/content/633100d631767ddb9a309f5a2a66f5a66d5abd839f3b1c55642690d484189971i0",
            "/content/85436950f53c57aa0c510071d2d5f1c187e1d21e4e57210fcae152c4c7b6a768i0", 
            "/content/e3ca12dd7516b4e486af4e3fa7f4ebc535d825034ff3c9da4954f354572dcf61i0",
            "/content/d0496a8e1657ce470807c8d47dcb5f1018a32d8ec8e50d490ad49411ffee1457i0",
        ];

        // Compute the seed using the hashString function
        function hashString(str) {
            console.log(`hashString function called with input:`, str);
            let rotationCount = parseInt(str.split("i")[1]);
            console.log(`Rotation count parsed:`, rotationCount);
            
            let characters = str.split("");
            for (let i = 0; i < rotationCount; i++) {
                let char = characters.shift();
                characters.push(char);
            }
            str = characters.join("");
            console.log(`String after rotation:`, str);

            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = (31 * hash + str.charCodeAt(i)) % Number.MAX_SAFE_INTEGER;
            }
            const finalHash = hash % 1400000000;
            console.log(`Final hash calculated:`, finalHash);
            return finalHash;
        }

        const seedValue = hashString("4482324585393f1523e8c28a02605c0b1c95d2779510921da0f131a5e6da5843i0");
        console.log(`Hash string returned seed value:`, seedValue);

        // Initialize global variables
        window.seed = seedValue; // Set the seed based on hashString
        window.songDataUrls = songDataUrls; // Assign the songDataUrls array
        window.songIndex = 0;
        window.playbackStarted = false;

        // ----------------------------
        // Core Functionality
        // ----------------------------

        function initializeProgram(seed, songDataUrls) {
            console.log('[Initialization] Starting initialization with seed:', seed, 'and songDataUrls:', songDataUrls);
            try {
                // Validate songDataUrls
                if (!songDataUrls || songDataUrls.length === 0) {
                    throw new Error('Invalid or empty songDataUrls array.');
                }

                // Validate seed
                if (seed === null || seed === undefined || isNaN(seed)) {
                    throw new Error('Invalid seed value: ' + seed);
                }

                console.log(`[Initialization] Using seed: ${seed} and processing songDataUrls:`, songDataUrls);

                // Process the serialized song data
                processSerializedData(songDataUrls);
                console.log('[Initialization] processSerializedData completed successfully.');

                // Additional initialization steps can be added here

            } catch (error) {
                console.error('[Initialization Error] An error occurred during initialization:', error);
            }
        }

        // Example processSerializedData function
        async function processSerializedData(songDataUrls) {
            console.log('[processSerializedData] Processing the following songDataUrls:', songDataUrls);
            // Implement actual data fetching and processing here
            // For demonstration, we'll simulate data processing with a delay
            for (const [index, url] of songDataUrls.entries()) {
                console.log(`[processSerializedData] Processing song ${index + 1}: ${url}`);
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Failed to fetch ${url}`);
                    const arrayBuffer = await response.arrayBuffer();
                    const inflated = pako.inflate(new Uint8Array(arrayBuffer));
                    const jsonString = new TextDecoder("utf-8").decode(inflated);
                    const data = JSON.parse(jsonString);
                    console.log(`[processSerializedData] Successfully processed song ${index + 1}`);
                    // Implement your data handling logic here
                } catch (error) {
                    console.error(`[processSerializedData] Error processing song ${index + 1}:`, error);
                }
            }
        }

        // Reschedule Playback Functionality
        function reschedulePlayback(seed, songIndex) {
            try {
                // Update internal state
                window.seed = seed;
                window.songIndex = songIndex;

                // Reshuffle channels and adjust playback parameters
                shuffleChannels(seed);
                adjustPlaybackParameters(seed);

                // Restart or adjust playback as necessary
                restartPlayback();

                console.log(`Playback rescheduled with seed: ${seed} and songIndex: ${songIndex}`);
            } catch (error) {
                console.error('Error rescheduling playback:', error);
            }
        }

        function restartPlayback() {
            // Implement logic to restart playback based on updated seed and song index
            // For example, stop current playback and start the new one
            if (typeof stopPlayback === 'function') {
                stopPlayback();
            }
            if (typeof startPlayback === 'function') {
                startPlayback();
            }
            console.log("Playback restarted with new configuration.");
        }

        function shuffleChannels(seed) {
            // Implement channel shuffling logic based on seed
            console.log(`Shuffling channels with seed: ${seed}`);
            // Example: Shuffle logic here
        }

        function adjustPlaybackParameters(seed) {
            // Implement any parameter adjustments based on the new seed
            console.log(`Adjusting playback parameters with seed: ${seed}`);
            // Example: Adjust BPM, volume, etc.
        }

        // Reset Program Functionality
        function resetProgram() {
            try {
                console.log("Resetting program state...");
                window.seed = null;
                window.songDataUrls = [];
                window.songIndex = 0;
                window.playbackStarted = false;

                // Stop playback if necessary
                if (typeof stopPlayback === 'function') {
                    stopPlayback();
                    console.log("Playback stopped during reset.");
                }

                // Clear canvas or other UI elements
                const canvasContainer = document.getElementById('canvas-container');
                if (canvasContainer) {
                    canvasContainer.innerHTML = '';
                    console.log("Canvas container cleared.");
                }

                console.log("Program reset successfully.");
            } catch (error) {
                console.error("Error during program reset:", error);
            }
        }

        // Expose resetProgram globally
        window.resetProgram = resetProgram;

        // ----------------------------
        // Shuffle and Utility Functions
        // ----------------------------

        (function IIFE1() {
            console.log(`First IIFE [init] starting with seed:`, window.seed);

            function init() {
                console.log(`init function called.`);
                try {
                    console.log(`Calling setupStylesAndCanvas...`);
                    setupStylesAndCanvas();
                    console.log(`setupStylesAndCanvas completed successfully.`);
                    
                    if (window.songDataUrls && window.songDataUrls.length > 0) {
                        console.log(`window.songDataUrls array is defined and has ${window.songDataUrls.length} items. Proceeding with processing...`);
                        processSerializedData(window.songDataUrls);
                        console.log(`processSerializedData completed successfully.`);
                    } else {
                        console.warn(`window.songDataUrls array is either undefined or empty.`);
                    }
                } catch (error) {
                    console.error(`Error in init function:`, error);
                }
            }

            window.init = init;
            window.addEventListener('load', function() {
                console.log(`Window load event triggered.`);
                init();
                console.log(`init function execution completed.`);
            });

            console.log(`First IIFE [init] completed.`);
        })();

        (function IIFE_LoadPako() {

        const pakoUrl = ["localhost", "127.0.0.1"].includes(window.location.hostname)
            ? "http://localhost:3000/content/2109694f44c973892fb8152cf5c68607fb19288c045af1abc1716c1c3b4d69e6i0"
            : "/content/2109694f44c973892fb8152cf5c68607fb19288c045af1abc1716c1c3b4d69e6i0";
        
        let isLoaded = false;

        const loadPako = async () => {
            try {
                let pakoScript = localStorage.getItem("pakoScript");

                if (!pakoScript) {
                    const response = await fetchWithRetries(pakoUrl);
                    const scriptContent = await response.text();
                    pakoScript = (new DOMParser).parseFromString(scriptContent, "text/html").querySelector("script")?.textContent;
                    localStorage.setItem("pakoScript", pakoScript);
                }

                injectScript(pakoScript);
                console.log("Pako library loaded successfully.");

                await waitForPako();

                isLoaded = true;
                document.dispatchEvent(new Event("pakoLoaded"));
            } catch (error) {
                console.error("Error during Pako loading:", error);
                displayErrorMessage("Failed to load necessary libraries. Please try again later.");
            }
        };

        const fetchWithRetries = async (url, retries = 3, delay = 1000) => {
            for (let attempt = 0; attempt < retries; attempt++) {
                try {
                    const response = await fetch(url, { cache: "force-cache" });
                    if (response.ok) return response;
                    throw new Error(`Network error: ${response.statusText}`);
                } catch (error) {
                    if (attempt === retries - 1) throw error;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        };

        const injectScript = (scriptText) => {
            const script = document.createElement("script");
            script.textContent = scriptText;
            document.head.appendChild(script);
        };

        const waitForPako = () => {
            return new Promise((resolve, reject) => {
                let retries = 0;
                const maxWaitTime = 5000; // 5 seconds
                const checkInterval = 50;

                const intervalId = setInterval(() => {
                    if (typeof pako !== "undefined") {
                        clearInterval(intervalId);
                        resolve();
                    } else if ((retries += checkInterval) >= maxWaitTime) {
                        clearInterval(intervalId);
                        reject(new Error("Pako library failed to load within the timeout period."));
                    }
                }, checkInterval);
            });
        };

        const displayErrorMessage = (message) => {
            let errorMessageDiv = document.getElementById("errorMessage");
            if (!errorMessageDiv) {
                errorMessageDiv = document.createElement("div");
                errorMessageDiv.id = "errorMessage";
                errorMessageDiv.style.color = "red";
                document.body.prepend(errorMessageDiv);
            }
            errorMessageDiv.textContent = message;
            errorMessageDiv.style.display = "block";
        };

        if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", loadPako);
        } else {
            loadPako();
        }

        window.isPakoLoaded = () => isLoaded;
    })();

        (function IIFE2() {
            console.log(`Second IIFE [hashstring] starting with seed:`, window.seed);

            function seededRandom(localSeed) {
                console.log(`seededRandom function called with localSeed:`, localSeed);
                const x = Math.sin(localSeed) * 10000;
                const result = x - Math.floor(x);
                console.log(`seededRandom result:`, result);
                return result;
            }

            function setPlaybackStatus(status) {
                console.log(`setPlaybackStatus called with status:`, status);
                window.playbackStarted = status;
            }

            function initializePlayback() {
                console.log(`initializePlayback function called.`);
                if (window.playbackStarted === undefined) {
                    console.log(`playbackStarted is undefined, initializing to false.`);
                    window.playbackStarted = false;
                }

                document.addEventListener("playbackStarted", () => {
                    console.log(`playbackStarted event triggered.`);
                    window.psTime = Date.now();
                    setPlaybackStatus(true);
                    console.log(`Playback started at:`, window.psTime);
                });

                document.addEventListener("playbackStopped", () => {
                    console.log(`playbackStopped event triggered.`);
                    setPlaybackStatus(false);
                    console.log(`Playback stopped.`);
                });
            }

            function enforceDocumentTitle() {
                console.log(`enforceDocumentTitle function called.`);
                document.title = "? ? ?";
                const titleObserver = new MutationObserver(() => {
                    if (document.title !== "? ? ?") {
                        console.log(`Document title changed, resetting to ? ? ?`);
                        document.title = "? ? ?";
                    }
                });
                titleObserver.observe(document.querySelector("title"), { childList: true, subtree: true });
                console.log(`Title observer set up successfully.`);
            }

            window.addEventListener('load', function() {
                console.log(`window.onload triggered.`);
                enforceDocumentTitle();
                if (typeof displayPlayText === 'function') {
                    displayPlayText();  // Ensure this function is defined or remove if not needed
                }
                console.log(`onload functions executed successfully.`);
            });

            // Expose functions globally
            window.seededRandom = seededRandom;  // Make seededRandom globally available
            window.setPlaybackStatus = setPlaybackStatus;
            window.initializePlayback = initializePlayback;
            window.enforceDocumentTitle = enforceDocumentTitle;

            // Initialize the playback settings
            initializePlayback();

            console.log(`Second IIFE [hashstring] completed.`);
        })();

        (function IIFE3() {
            function setupStylesAndCanvas() {
                const styleElement = document.createElement("style");
                styleElement.textContent = `canvas { position: absolute; }`;
                document.head.appendChild(styleElement);
        
                const canvasContainer = document.createElement("div");
                canvasContainer.id = "canvas-container";
                const canvas = document.createElement("canvas");
                canvasContainer.appendChild(canvas);
                document.body.appendChild(canvasContainer);
            }
        
            window.setupStylesAndCanvas = setupStylesAndCanvas;
        })();

        (function IIFE4() {
            console.log(`Fourth IIFE [keymap] running with seed:`, window.seed);
        
            const keyMap = {
                0: "projectName", 1: "artistName", 2: "projectBPM", 3: "currentSequence", 
                4: "channelURLs", 5: "channelVolume", 6: "channelPlaybackSpeed", 
                7: "trimSettings", 8: "projectChannelNames", 9: "startSliderValue", 
                10: "endSliderValue", 11: "totalSampleDuration", 12: "start", 
                13: "end", 14: "projectSequences", 15: "steps"
            };
        
            const reverseKeyMap = Object.fromEntries(Object.entries(keyMap).map(([e, r]) => [r, +e]));
            const channelMap = Array.from({ length: 26 }, (e, r) => String.fromCharCode(65 + r));
            const reverseChannelMap = Object.fromEntries(channelMap.map((e, r) => [e, r]));
        
            function decompressSteps(e) {
                console.log(`decompressSteps function called.`);
                return e.flatMap(e => {
                    if (typeof e === "number") return e;
                    if (typeof e === "object" && "r" in e) {
                        const [r, t] = e.r;
                        return Array.from({ length: t - r + 1 }, (e, t) => r + t);
                    }
                    return typeof e === "string" && e.endsWith("r") ? { index: parseInt(e.slice(0, -1), 10), reverse: true } : void 0;
                });
            }
        
            function deserialize(e) {
                console.log(`deserialize function called.`);
                const r = e => Array.isArray(e) ? e.map(e => typeof e === "object" ? r(e) : e) : typeof e === "object" && e !== null ? Object.entries(e).reduce((e, [t, n]) => {
                    const a = keyMap[t] ?? t;
                    return e[a] = a === "projectSequences" ? Object.entries(n).reduce((e, [r, t]) => (e[r.replace("s", "Sequence")] = Object.entries(t).reduce((e, [r, t]) => {
                        var n;
                        return e[`ch${reverseChannelMap[r]}`] = { steps: (n = t[reverseKeyMap.steps] || [], n.flatMap(e => {
                            if (typeof e === "number") return e;
                            if (typeof e === "object" && "r" in e) {
                                const [r, t] = e.r;
                                return Array.from({ length: t - r + 1 }, (e, t) => r + t);
                            }
                            return typeof e === "string" && e.endsWith("r") ? { index: parseInt(e.slice(0, -1), 10), reverse: true } : void 0;
                        })) }, e;
                    }, {}), e), {}) : r(n), e;
                }, {}) : e;
                return r(e);
            }
        
            window.decompressSteps = decompressSteps;
            window.deserialize = deserialize;
        
            console.log(`Fourth IIFE [keymap] completed.`);
        })();

        // ----------------------------
        // IIFE #5: Load External Scripts
        // ----------------------------

        (function IIFE5() {
            // Since Pako is already loaded via CDN, we skip dynamic loading
            console.log("IIFE5 [pako loading] skipped as Pako is loaded via CDN.");
        })();

        // ----------------------------
        // IIFE #6: Fetching, Deserializing, Processing Data, and Shuffling Channels
        // ----------------------------

        (function IIFE6() {
            async function fetchAndDeserialize(url) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Network error: ${url}`);
                    const arrayBuffer = await response.arrayBuffer();
                    const inflated = pako.inflate(new Uint8Array(arrayBuffer));
                    const jsonString = new TextDecoder("utf-8").decode(inflated);
                    return deserialize(JSON.parse(jsonString));
                } catch (error) {
                    console.error(`[fetchAndDeserialize] Error fetching or deserializing ${url}:`, error);
                    return null;
                }
            }
        
            function seededRandom(seed) {
                const x = Math.sin(seed) * 10000;
                return x - Math.floor(x);
            }
        
            function shuffleArray(array, seed) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(seededRandom(seed) * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                    seed++;
                }
                return array;
            }
        
            function selectBPM(availableBPMs, seed) {
                return availableBPMs[Math.floor(seededRandom(seed) * availableBPMs.length)];
            }
        
            async function processSerializedData(urls) {
                // Since Pako is loaded via CDN, no need to wait for custom events
                if (typeof pako === "undefined") {
                    console.error("Pako library is not loaded.");
                    return;
                }
            
                const data = (await Promise.all(urls.map(fetchAndDeserialize))).filter(Boolean);
                if (data.length === 0) {
                    console.error("No valid data fetched.");
                    return;
                }
                const baseBPM = selectBPM([80, 100, 120, 140, 160, 180, 240], window.seed);
            
                data.forEach(dataset => {
                    const bpmRatio = baseBPM / dataset.projectBPM;
                    dataset.channelPlaybackSpeed = dataset.channelPlaybackSpeed.map(speed => speed * bpmRatio);
                });
            
                const allChannels = data.flatMap((dataset, idx) =>
                    dataset.channelURLs.map((url, i) => ({
                        url,
                        volume: dataset.channelVolume[i],
                        speed: dataset.channelPlaybackSpeed[i],
                        trim: dataset.trimSettings[i],
                        source: `data${idx + 1}`,
                        index: i
                    }))
                );
            
                const selectedChannels = shuffleArray(allChannels, window.seed).slice(0, 24);
                const combinedData = {
                    ...data[0],
                    projectBPM: baseBPM,
                    channelURLs: selectedChannels.map(ch => ch.url),
                    channelVolume: selectedChannels.map(ch => ch.volume),
                    channelPlaybackSpeed: selectedChannels.map(ch => ch.speed),
                    trimSettings: selectedChannels.map(ch => ch.trim),
                    projectSequences: {}
                };
            
                const projectSources = data.reduce((acc, dataset, i) => {
                    acc[`data${i + 1}`] = dataset;
                    return acc;
                }, {});
            
                Object.keys(data[0].projectSequences).forEach(seq => {
                    combinedData.projectSequences[seq] = {};
                    selectedChannels.forEach((ch, i) => {
                        combinedData.projectSequences[seq][`ch${i}`] = projectSources[ch.source]?.projectSequences[seq]?.[`ch${ch.index}`] || { steps: [] };
                    });
                });
            
                window.jsonDataUrl = URL.createObjectURL(new Blob([JSON.stringify(combinedData)], { type: "application/json" }));
            
                // Embedded scriptLoader_web3.js logic
                window.scriptsToLoad = [
                    "/content/61895db1f0d62d24cea96570e66b92435a8a4979e3d3fef8041680ed2afeddc8i0",
                    "/content/1b036f9d60a04f0612af8c53753273f66339e69d7843138007eb3573703b1218i0",
                    "/content/150e020d5e6ea8b53b7b3d2160f25f65c2e550d413f9c53d9e1cfb101d6914f2i0",
                    "/content/935828577e4762caaf32b76a0f74cb4f37bdcdbdae1d27a7c93d000d5cfe9d28i0",
                    "/content/bab2b37e0abcce41d784d65d94a5c3c266228c2d8bd3ecdee4fba7986f5a042ei0",
                    "/content/1a5cafb61e4a320434fc4087e203d2a5f695ba9112635b960fc9d7dcb961d9fci0",
                    "/content/a3d8a40fcde6935f16b49ad7c9e9aa185f01d1618f4e35828415f6cc27377a47i0",
                    "/content/17c6cb4f92d47043da52ce8334c41961c588b7955488e56f08264840ef63a4eei0",
                    "/content/4915e144695ab04171092a45e2d49cfa7b5e92c9a35ce612e7b749457acc92ddi0",
                    "/content/3ab9dda407f9c7f62b46401e2664bc1496247c8950620a11a36a8601267cb42fi0",
                    "/content/4a6164e05aee1d4ed77585bc85e4d4530801ef71e1c277c868ce374c4a7b9902i0",
                    "/content/0505ae5cebbe9513648fc8e4ecee22d9969764f3cdac9cd6ec33be083c77ae96i0",
                    "/content/87bb49f5617a241e29512850176e53169c3da4a76444d5d8fcd6c1e41489a4b3i0",
                    "/content/cea34b6ad754f3a4e992976125bbd1dd59213aab3de03c9fe2eb10ddbe387f76i0",
                    "/content/bcee9a2e880510772f0129c735a4ecea5bb45277f3b99ff640c1bd393dddd6dfi0",
                    "/content/90d910fe4088c53a16eb227ec2fe59802091dc4ea51564b2665090403c34f59ci0",
                    "/content/916fd1731cdecf82706a290d03448c6dc505c01d6ec44bbca20281a19723d617i0",
                    "/content/6a5e5c8b42793dd35512dfddd81dbbe211f052ac79839dd54b53461f5783a390i0",
                    "/content/c0ee69121238f6438be8398038301cf5b1d876cce30a0d45a3a5e0b927826940i0",
                    "/content/6f1def70a3290c50793773a8b1712c9a1b0561b3674ee50a06c13bc4e492f459i0",
                    "/content/c7c92a81d5279950be7d0bd3e755ad620551bc65e6e514d6f7c29b4c24465d0ai0",
                    "/content/99ecc0668e27f03cf202f9ebc49d0332ac8f594bc9b5483969108b83723a0e9di0",
                    "/content/305829e076d38130be65851c79241929983f16d679822015ff237029f67d5d9ei0",
                    "/content/0d8309856ec04e8ab5bd6aa4689429102378fb45368ad0e2787f0dfc72c66152i0",
                    "/content/287c837ecffc5b80d8e3c92c22b6dbf0447a3d916b95ee314c66909f6f2b2f3ci0",
                    "/content/214457a4f832847565746ecb0b9460ec7dc8ad93549a00a69f18b3d492c0e005i0"
                ];
        
                const mainLoaderScript = document.createElement("script");
                mainLoaderScript.src = "/content/0d81728a7d3eda3e4d9cdf6c8ca8f2c0701e1fdc183e77654440ba47760c7bc4i0";
                document.head.appendChild(mainLoaderScript);
        
                console.log("Deserialized Data URL:", window.jsonDataUrl);
            }
        
            window.fetchAndDeserialize = fetchAndDeserialize;
            window.processSerializedData = processSerializedData;
            window.seededRandom = seededRandom;
            window.shuffleArray = shuffleArray;
            window.selectBPM = selectBPM;
        })();
    </script>
</head>
<body>
    <div id="canvas-container">
        <canvas></canvas>
    </div>

    <!-- Optional: Add buttons or UI elements to interact with the program -->
    <button onclick="resetProgram()">Reset Program</button>
    <button onclick="reschedulePlayback(987654321, 1)">Reschedule Playback</button>

    <!-- Error Message Container -->
    <div id="errorMessage" style="color: red; display: none;"></div>
</body>
</html>
