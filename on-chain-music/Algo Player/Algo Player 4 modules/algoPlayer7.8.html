<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Parent HTML with Embedded iFrame</title>
    <script>
        // Define songDataUrls globally in the parent
        window.songDataUrls = [
            "/content/5527d0cc95ce5ce6eedf4e275234da8b1fe087512d0db618b6de1aaad437c96bi0", 
            "/content/b22f1c85371b58a9cdac19b2baa50b1f9025a28d44cdfaad539d0527aa7d894ei0", 
            "/content/8aec0a99a5617b9da98a5b63a11a5143f0cac3cfa662d9515c2285de03ef95d4i0",
            "/content/6d288c0c82653001bb32497889dd1486e8afec9b0671a95fa9e10f99c20737bbi0",
            "/content/07ff7bdc47e5272a3ff55cc46d2b189d510562a057a2c24112f3d0376950484di0", 
            "/content/119a3ccd1dfd7e987cca139f86d16717d845a22dd6afc59ad492527b95ae9a91i0",
            "/content/db9131cfe8e933e8e639f007dcd2b582a80bfd2be42b0eafa4d2e206332d6785i0", 
            "/content/fb0d2abcd1fa5bf2622579f0990435b48d41291f71626fc2e36a93e6ea6b3b85i0", 
            "/content/3359ce42359274ddbd2184d9f75a38b7e59b1d5f24512959e29c377fc8ca604ai0",
            "/content/633100d631767ddb9a309f5a2a66f5a66d5abd839f3b1c55642690d484189971i0",
            "/content/85436950f53c57aa0c510071d2d5f1c187e1d21e4e57210fcae152c4c7b6a768i0", 
            "/content/e3ca12dd7516b4e486af4e3fa7f4ebc535d825034ff3c9da4954f354572dcf61i0",
            "/content/d0496a8e1657ce470807c8d47dcb5f1018a32d8ec8e50d490ad49411ffee1457i0",
        ];

        window.seedQueue = [];
    const totalPreScheduledSeeds = 100;
    let currentSeedIndex = 0;
    let currentSeed = null;

    // Function to generate seeds (deterministic or random based on requirements)
    function generateSeed(index) {
        // Example: Simple deterministic seed based on index
        return 1000 + index; // Replace with a more robust seed generation logic as needed
    }

    // Initialize seedQueue
    function initializeSeedQueue() {
        for (let i = 0; i < totalPreScheduledSeeds; i++) {
            window.seedQueue.push(generateSeed(i));
        }
    }

    // Function to navigate to a specific seed
    function navigateToSeed(index) {
        if (index >= 0 && index < window.seedQueue.length) {
            currentSeed = window.seedQueue[index];
            currentSongIndex = index % window.songDataUrls.length;
            refreshIframe();
            updateSeedIndicator(index);
        }
    }

    // Function to update seedIndicator
    function updateSeedIndicator(index) {
        const indicator = document.getElementById('seedIndicator');
        indicator.textContent = `Seed ${index + 1} of ${window.seedQueue.length}`;
    }

    // Function to reset the application
    function resetApplication() {
        const iframe = document.getElementById('childFrame');
        if (iframe && iframe.contentWindow && typeof iframe.contentWindow.resetProgram === 'function') {
            iframe.contentWindow.resetProgram();
            currentSeedIndex = 0;
            currentSeed = window.seedQueue[currentSeedIndex];
            refreshIframe();
            updateSeedIndicator(currentSeedIndex);
            console.log("Application reset successfully.");
        } else {
            console.error("Reset function not available in iFrame.");
        }
    }

    // Initialize seedQueue on load and set up event listeners
    window.onload = () => {
        initializeSeedQueue();
        navigateToSeed(currentSeedIndex);

        document.getElementById('prevButton').addEventListener('click', () => {
            if (currentSeedIndex > 0) {
                currentSeedIndex--;
                navigateToSeed(currentSeedIndex);
            }
        });

        document.getElementById('nextButton').addEventListener('click', () => {
            if (currentSeedIndex < window.seedQueue.length - 1) {
                currentSeedIndex++;
                navigateToSeed(currentSeedIndex);
            }
        });

        document.getElementById('resetButton').addEventListener('click', () => {
            resetApplication();
        });
    };

    // Enhanced refreshIframe with command-based messaging
    function refreshIframe() {
        const iframe = document.getElementById('childFrame');
        iframe.contentWindow.postMessage({ 
            command: 'reschedulePlayback',
            payload: { 
                seed: currentSeed, 
                songIndex: currentSongIndex,
                songDataUrls: window.songDataUrls 
            }
        }, '*');
        console.log("Iframe refreshed with seed:", currentSeed, "song index:", currentSongIndex);
    }

</script>

    <style>
        /* Style to center the iframe */
        body, html {
            height: 100%;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f0f0f0;
            position: relative;
            transform: scale(0.7);
        }

        iframe {
            width: 1240px;
            height: 1240px;
            border: 1px solid #ccc;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        /* Style for the slider */
        #scaleControl {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 200px;
        }

        /* Style for the seed input and refresh button */
        #seedControl {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }

        #seedInput {
            width: 100px;
            padding: 5px;
            margin-left: 10px;
        }

        #playButton, #refreshButton, #nextButton {
            margin-left: 10px;
            padding: 5px;
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }

        #playButton:hover, #refreshButton:hover, #nextButton:hover {
            background-color: #0056b3;
        }

        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Hide overflow to prevent scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: black;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
    
        canvas {
            width: 100%; /* Make canvas fill its container */
            height: 100%; /* Maintain aspect ratio */
        }
    </style>
</head>
<body>
    <!-- Controls
    <div id="scaleControl">
        <label for="scaleSlider">Scale:</label>
        <input type="range" id="scaleSlider" min="0.5" max="2" step="0.1" value="1" oninput="updateScale(this.value)">
    </div>

    <div id="seedControl">
        <label for="seedInput">Seed:</label>
        <input type="number" id="seedInput" placeholder="Enter seed">
        <button id="playButton">Play</button>
        <button id="refreshButton" onclick="refreshIframe()">Refresh</button>
        <button id="nextButton">Next</button>
    </div> -->

<!-- Updated Controls with Reset and Seed Navigation -->
<div id="seedControl">
    <button id="prevButton">Previous</button>
    <span id="seedIndicator">Seed 1 of 100</span>
    <button id="nextButton">Next</button>
    <button id="resetButton">Reset</button>
</div>

<!-- Embedded iFrame -->
<iframe id="childFrame" srcdoc="

    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=yes&quot;&gt;
        &lt;title&gt;Seed Input Page&lt;/title&gt;

        &lt;script&gt;
            // iFrame Side
            window.addEventListener('message', function(event) {
                if (event.data.command === 'reschedulePlayback') {
                    const { seed, songIndex, songDataUrls } = event.data.payload;
                    window.seed = seed;
                    window.songIndex = songIndex;
                    window.songDataUrls = songDataUrls;
                    reschedulePlayback(seed, songIndex);
                }
            });

            function reschedulePlayback(seed, songIndex) {
                try {
                    // Update internal state
                    window.seed = seed;
                    window.songIndex = songIndex;

                    // Reshuffle channels and adjust playback parameters
                    shuffleChannels(seed);
                    adjustPlaybackParameters(seed);

                    // Restart or adjust playback as necessary
                    restartPlayback();

                    console.log(`Playback rescheduled with seed: ${seed} and songIndex: ${songIndex}`);
                } catch (error) {
                    console.error('Error rescheduling playback:', error);
                }
            }

            function restartPlayback() {
                // Implement logic to restart playback based on updated seed and song index
                // For example, stop current playback and start the new one
                if (typeof stopPlayback === 'function') {
                    stopPlayback();
                }
                if (typeof startPlayback === 'function') {
                    startPlayback();
                }
                console.log(&quot;Playback restarted with new configuration.&quot;);
            }

            function shuffleChannels(seed) {
                // Implement channel shuffling logic based on seed
                console.log(`Shuffling channels with seed: ${seed}`);
                // Example: Shuffle logic here
            }

            function adjustPlaybackParameters(seed) {
                // Implement any parameter adjustments based on the new seed
                console.log(`Adjusting playback parameters with seed: ${seed}`);
                // Example: Adjust BPM, volume, etc.
            }

            // Ensure resetProgram is defined and properly resets the application state
            function resetProgram() {
                try {
                    console.log(&quot;Resetting program state...&quot;);
                    window.seed = null;
                    window.songDataUrls = [];
                    window.songIndex = 0;
                    window.playbackStarted = false;

                    // Stop playback if necessary
                    if (typeof stopPlayback === 'function') {
                        stopPlayback();
                        console.log(&quot;Playback stopped during reset.&quot;);
                    }

                    // Clear canvas or other UI elements
                    const canvasContainer = document.getElementById('canvas-container');
                    if (canvasContainer) {
                        canvasContainer.innerHTML = '';
                        console.log(&quot;Canvas container cleared.&quot;);
                    }

                    console.log(&quot;Program reset successfully.&quot;);
                } catch (error) {
                    console.error(&quot;Error during program reset:&quot;, error);
                }
            }

            // Expose resetProgram globally
            window.resetProgram = resetProgram;

            // Existing initialization and other IIFEs...
        &lt;/script&gt;

        &lt;script&gt;
            // Initialize variables
            window.seed = null;
            window.songDataUrls = [];
            window.songIndex = 0;

            // Listen for messages from the parent
            window.addEventListener('message', function(event) {
                console.log('[Message Event] Received message from parent:', event.data);

                // Update songDataUrls if provided
                if (event.data.songDataUrls) {
                    window.songDataUrls = event.data.songDataUrls;
                    console.log('[Message Event] Updated songDataUrls:', window.songDataUrls);
                }

                // Update seed if provided
                if (event.data.seed !== undefined) {
                    window.seed = event.data.seed;
                    console.log('[Message Event] Updated seed:', window.seed);
                }

                // Update songIndex if provided
                if (event.data.songIndex !== undefined) {
                    window.songIndex = event.data.songIndex;
                    console.log('[Message Event] Updated songIndex:', window.songIndex);
                }

                // Update scale if provided
                if (event.data.scale !== undefined) {
                    const baseScale = 1;
                    const canvasContainer = document.getElementById('canvas-container');
                    if (canvasContainer) {
                        canvasContainer.style.transform = 'scale(' + (event.data.scale * baseScale) + ')';
                        console.log('[Message Event] Updated scale to:', event.data.scale);
                    } else {
                        console.warn('[Message Event] canvas-container not found.');
                    }
                }

                // Check if both seed and songDataUrls are available before initializing
                if (window.seed !== null && window.songDataUrls.length > 0) {
                    console.log('[Message Event] Ready to initialize program.');
                    initializeProgram(window.seed, window.songDataUrls);
                } else {
                    console.log('[Message Event] Seed or songDataUrls missing, cannot initialize yet.');
                }
            });

            // Request seed and songDataUrls from parent when the iframe loads
            window.parent.postMessage('requestSeed', '*');
            
            // Initialize the program
            function initializeProgram(seed, songDataUrls) {
                console.log('[Initialization] Starting initialization with seed:', seed, 'and songDataUrls:', songDataUrls);
                try {
                    // Validate songDataUrls
                    if (!songDataUrls || songDataUrls.length === 0) {
                        throw new Error('Invalid or empty songDataUrls array.');
                    }

                    // Validate seed
                    if (seed === null || seed === undefined || isNaN(seed)) {
                        throw new Error('Invalid seed value: ' + seed);
                    }

                    console.log(`[Initialization] Using seed: ${seed} and processing songDataUrls:`, songDataUrls);

                    // Process the serialized song data
                    processSerializedData(songDataUrls);
                    console.log('[Initialization] processSerializedData completed successfully.');

                    // Continue with initialization
                    // No need to call IIFE2() here as it's already invoked immediately

                } catch (error) {
                    console.error('[Initialization Error] An error occurred during initialization:', error);
                }
            }

            // Example processSerializedData function
            function processSerializedData(songDataUrls) {
                console.log('[processSerializedData] Processing the following songDataUrls:', songDataUrls);
                // Simulate processing
                songDataUrls.forEach((url, index) => {
                    console.log(`[processSerializedData] Processing song ${index + 1}: ${url}`);
                });
            }

            // Placeholder IIFEs
            function IIFE2() {
                console.log('[IIFE2] IIFE2 executed.');
            }
            
            function IIFE3() {
                console.log('[IIFE3] IIFE3 executed.');
            }
            
            function IIFE4() {
                console.log('[IIFE4] IIFE4 executed.');
            }
            
            function IIFE5() {
                console.log('[IIFE5] IIFE5 executed.');
            }

            function IIFE6() {
                console.log('[IIFE6] IIFE6 executed.');
            }

            // IIFE to reset and reinitialize the program
            (function IIFEReset() {
                function resetProgram() {
                    console.log(`[${new Date().toISOString()}] Resetting program...`);

                    // Reset global variables
                    window.seed = null;
                    window.songDataUrls = [];
                    window.songIndex = 0;
                    window.playbackStarted = false;
                    
                    // Reset any other program-specific states (if applicable)
                    // Clear canvas, reset audio contexts, stop any ongoing playback
                    if (typeof stopPlayback === &quot;function&quot;) {
                        stopPlayback();
                        console.log(`[${new Date().toISOString()}] Playback stopped during reset.`);
                    }

                    // Optionally clear any UI elements
                    const canvasContainer = document.getElementById('canvas-container');
                    if (canvasContainer) {
                        canvasContainer.innerHTML = ''; // Clear the canvas or any DOM elements
                    }
                }

                // Expose the reset function globally to allow external calls
                window.resetProgram = resetProgram;
            })();

            // IIFE #1
            (function IIFE1() {
                console.log(`[${new Date().toISOString()}] First IIFE [init] starting with seed:`, window.seed);

                function init() {
                    console.log(`[${new Date().toISOString()}] init function called.`);
                    try {
                        console.log(`[${new Date().toISOString()}] Calling setupStylesAndCanvas...`);
                        setupStylesAndCanvas();
                        console.log(`[${new Date().toISOString()}] setupStylesAndCanvas completed successfully.`);
                        
                        
                        if (window.songDataUrls && window.songDataUrls.length > 0) {
                            console.log(`[${new Date().toISOString()}] window.songDataUrls array is defined and has ${window.songDataUrls.length} items. Proceeding with processing...`);
                            processSerializedData(window.songDataUrls);
                            console.log(`[${new Date().toISOString()}] processSerializedData completed successfully.`);
                        } else {
                            console.warn(`[${new Date().toISOString()}] window.songDataUrls array is either undefined or empty.`);
                        }
                    } catch (error) {
                        console.error(`[${new Date().toISOString()}] Error in init function:`, error);
                    }
                }

                window.init = init;
                window.addEventListener('load', function() {
                    console.log(`[${new Date().toISOString()}] Window load event triggered.`);
                    init();
                    console.log(`[${new Date().toISOString()}] init function execution completed.`);
                });

                console.log(`[${new Date().toISOString()}] First IIFE [init] completed.`);
            })();

            // IIFE #2
            (function IIFE2() {
                console.log(`[${new Date().toISOString()}] Second IIFE [hashstring] starting with seed:`, window.seed);

                function hashString(str) {
                    console.log(`[${new Date().toISOString()}] hashString function called with input:`, str);
                    let rotationCount = parseInt(str.split(&quot;i&quot;)[1]);
                    console.log(`[${new Date().toISOString()}] Rotation count parsed:`, rotationCount);
                    
                    let characters = str.split(&quot;&quot;);
                    for (let i = 0; i < rotationCount; i++) {
                        let char = characters.shift();
                        characters.push(char);
                    }
                    str = characters.join(&quot;&quot;);
                    console.log(`[${new Date().toISOString()}] String after rotation:`, str);

                    let hash = 0;
                    for (let i = 0; i < str.length; i++) {
                        hash = (31 * hash + str.charCodeAt(i)) % Number.MAX_SAFE_INTEGER;
                    }
                    const finalHash = hash % 1400000000;
                    console.log(`[${new Date().toISOString()}] Final hash calculated:`, finalHash);
                    return finalHash;
                }

                const seedValue = hashString(&quot;4482324585393f1523e8c28a02605c0b1c95d2779510921da0f131a5e6da5843i0&quot;);
                console.log(`[${new Date().toISOString()}] Hash string returned seed value:`, seedValue);
                console.log(`[${new Date().toISOString()}] Using global seed:`, window.seed);

                function seededRandom(localSeed) {
                    console.log(`[${new Date().toISOString()}] seededRandom function called with localSeed:`, localSeed);
                    const x = Math.sin(localSeed) * 10000;
                    const result = x - Math.floor(x);
                    console.log(`[${new Date().toISOString()}] seededRandom result:`, result);
                    return result;
                }

                function setPlaybackStatus(status) {
                    console.log(`[${new Date().toISOString()}] setPlaybackStatus called with status:`, status);
                    window.playbackStarted = status;
                }

                function initializePlayback() {
                    console.log(`[${new Date().toISOString()}] initializePlayback function called.`);
                    if (window.playbackStarted === undefined) {
                        console.log(`[${new Date().toISOString()}] playbackStarted is undefined, initializing to false.`);
                        window.playbackStarted = false;
                    }

                    document.addEventListener(&quot;playbackStarted&quot;, () =&gt; {
                        console.log(`[${new Date().toISOString()}] playbackStarted event triggered.`);
                        window.psTime = Date.now();
                        setPlaybackStatus(true);
                        console.log(`[${new Date().toISOString()}] Playback started at:`, window.psTime);
                    });

                    document.addEventListener(&quot;playbackStopped&quot;, () =&gt; {
                        console.log(`[${new Date().toISOString()}] playbackStopped event triggered.`);
                        setPlaybackStatus(false);
                        console.log(`[${new Date().toISOString()}] Playback stopped.`);
                    });
                }

                function enforceDocumentTitle() {
                    console.log(`[${new Date().toISOString()}] enforceDocumentTitle function called.`);
                    document.title = &quot;? ? ?&quot;;
                    const titleObserver = new MutationObserver(() =&gt; {
                        if (document.title !== &quot;? ? ?&quot;) {
                            console.log(`[${new Date().toISOString()}] Document title changed, resetting to ? ? ?`);
                            document.title = &quot;? ? ?&quot;;
                        }
                    });
                    titleObserver.observe(document.querySelector(&quot;title&quot;), { childList: true, subtree: true });
                    console.log(`[${new Date().toISOString()}] Title observer set up successfully.`);
                }

                window.addEventListener('load', function() {
                    console.log(`[${new Date().toISOString()}] window.onload triggered.`);
                    enforceDocumentTitle();
                    displayPlayText();  // Assuming displayPlayText is another globally available function
                    console.log(`[${new Date().toISOString()}] onload functions executed successfully.`);
                });

                // Expose functions globally
                window.hashString = hashString;
                window.seededRandom = seededRandom;  // Make seededRandom globally available
                window.setPlaybackStatus = setPlaybackStatus;
                window.initializePlayback = initializePlayback;
                window.enforceDocumentTitle = enforceDocumentTitle;

                // Initialize the playback settings
                initializePlayback();

                console.log(`[${new Date().toISOString()}] Second IIFE [hashstring] completed.`);
            })();

            (function IIFE3() {
                function setupStylesAndCanvas() {
                    const styleElement = document.createElement(&quot;style&quot;);
                    styleElement.textContent = `canvas { position: absolute; }`;
                    document.head.appendChild(styleElement);
            
                    const canvasContainer = document.createElement(&quot;div&quot;);
                    canvasContainer.id = &quot;canvas-container&quot;;
                    const canvas = document.createElement(&quot;canvas&quot;);
                    canvasContainer.appendChild(canvas);
                    document.body.appendChild(canvasContainer);
                }
            
                window.setupStylesAndCanvas = setupStylesAndCanvas;
            })();
            

            // IIFE #4: Key and channel mappings, decompress, and deserialize utilities
            (function IIFE4() {
                console.log(`[${new Date().toISOString()}] Fourth IIFE [keymap] running with seed:`, window.seed);
            
                const keyMap = {
                    0: &quot;projectName&quot;, 1: &quot;artistName&quot;, 2: &quot;projectBPM&quot;, 3: &quot;currentSequence&quot;, 
                    4: &quot;channelURLs&quot;, 5: &quot;channelVolume&quot;, 6: &quot;channelPlaybackSpeed&quot;, 
                    7: &quot;trimSettings&quot;, 8: &quot;projectChannelNames&quot;, 9: &quot;startSliderValue&quot;, 
                    10: &quot;endSliderValue&quot;, 11: &quot;totalSampleDuration&quot;, 12: &quot;start&quot;, 
                    13: &quot;end&quot;, 14: &quot;projectSequences&quot;, 15: &quot;steps&quot;
                };
            
                const reverseKeyMap = Object.fromEntries(Object.entries(keyMap).map(([e, r]) => [r, +e]));
                const channelMap = Array.from({ length: 26 }, (e, r) => String.fromCharCode(65 + r));
                const reverseChannelMap = Object.fromEntries(channelMap.map((e, r) => [e, r]));
            
                function decompressSteps(e) {
                    console.log(`[${new Date().toISOString()}] decompressSteps function called.`);
                    return e.flatMap(e => {
                        if (typeof e === &quot;number&quot;) return e;
                        if (typeof e === &quot;object&quot; && &quot;r&quot; in e) {
                            const [r, t] = e.r;
                            return Array.from({ length: t - r + 1 }, (e, t) => r + t);
                        }
                        return typeof e === &quot;string&quot; && e.endsWith(&quot;r&quot;) ? { index: parseInt(e.slice(0, -1), 10), reverse: !0 } : void 0;
                    });
                }
            
                function deserialize(e) {
                    console.log(`[${new Date().toISOString()}] deserialize function called.`);
                    const r = e => Array.isArray(e) ? e.map(e => typeof e === &quot;object&quot; ? r(e) : e) : typeof e === &quot;object&quot; && e !== null ? Object.entries(e).reduce((e, [t, n]) => {
                        const a = keyMap[t] ?? t;
                        return e[a] = a === &quot;projectSequences&quot; ? Object.entries(n).reduce((e, [r, t]) => (e[r.replace(&quot;s&quot;, &quot;Sequence&quot;)] = Object.entries(t).reduce((e, [r, t]) => {
                            var n;
                            return e[`ch${reverseChannelMap[r]}`] = { steps: (n = t[reverseKeyMap.steps] || [], n.flatMap(e => {
                                if (typeof e === &quot;number&quot;) return e;
                                if (typeof e === &quot;object&quot; && &quot;r&quot; in e) {
                                    const [r, t] = e.r;
                                    return Array.from({ length: t - r + 1 }, (e, t) => r + t);
                                }
                                return typeof e === &quot;string&quot; && e.endsWith(&quot;r&quot;) ? { index: parseInt(e.slice(0, -1), 10), reverse: !0 } : void 0;
                            })) }, e;
                        }, {}), e), {}) : r(n), e;
                    }, {}) : e;
                    return r(e);
                }
            
                window.decompressSteps = decompressSteps;
                window.deserialize = deserialize;
            
                console.log(`[${new Date().toISOString()}] Fourth IIFE [keymap] completed.`);
            })();
            

            
            // IIFE #5: Load pako library from local storage or fetch it from the chain
(function IIFE5() {
    const pakoUrl = [&quot;localhost&quot;, &quot;127.0.0.1&quot;].includes(window.location.hostname)
        ? &quot;http://localhost:3000/content/2109694f44c973892fb8152cf5c68607fb19288c045af1abc1716c1c3b4d69e6i0&quot;
        : &quot;/content/2109694f44c973892fb8152cf5c68607fb19288c045af1abc1716c1c3b4d69e6i0&quot;;
    
    let isLoaded = false;

    const loadPako = async () => {
        try {
            let pakoScript = localStorage.getItem(&quot;pakoScript&quot;);

            if (!pakoScript) {
                const response = await fetchWithRetries(pakoUrl);
                const scriptContent = await response.text();
                pakoScript = (new DOMParser).parseFromString(scriptContent, &quot;text/html&quot;).querySelector(&quot;script&quot;)?.textContent;
                localStorage.setItem(&quot;pakoScript&quot;, pakoScript);
            }

            injectScript(pakoScript);
            console.log(&quot;Pako library loaded successfully.&quot;);

            await waitForPako();

            isLoaded = true;
            document.dispatchEvent(new Event(&quot;pakoLoaded&quot;));
        } catch (error) {
            console.error(&quot;Error during Pako loading:&quot;, error);
            displayErrorMessage(&quot;Failed to load necessary libraries. Please try again later.&quot;);
        }
    };

    const fetchWithRetries = async (url, retries = 3, delay = 1000) => {
        for (let attempt = 0; attempt < retries; attempt++) {
            try {
                const response = await fetch(url, { cache: &quot;force-cache&quot; });
                if (response.ok) return response;
                throw new Error(`Network error: ${response.statusText}`);
            } catch (error) {
                if (attempt === retries - 1) throw error;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    };

    const injectScript = (scriptText) => {
        const script = document.createElement(&quot;script&quot;);
        script.textContent = scriptText;
        document.head.appendChild(script);
    };

    const waitForPako = () => {
        return new Promise((resolve, reject) => {
            let retries = 0;
            const maxWaitTime = 5000; // 5 seconds
            const checkInterval = 50;

            const intervalId = setInterval(() => {
                if (typeof pako !== &quot;undefined&quot;) {
                    clearInterval(intervalId);
                    resolve();
                } else if ((retries += checkInterval) >= maxWaitTime) {
                    clearInterval(intervalId);
                    reject(new Error(&quot;Pako library failed to load within the timeout period.&quot;));
                }
            }, checkInterval);
        });
    };

    const displayErrorMessage = (message) => {
        let errorMessageDiv = document.getElementById(&quot;errorMessage&quot;);
        if (!errorMessageDiv) {
            errorMessageDiv = document.createElement(&quot;div&quot;);
            errorMessageDiv.id = &quot;errorMessage&quot;;
            errorMessageDiv.style.color = &quot;red&quot;;
            document.body.prepend(errorMessageDiv);
        }
        errorMessageDiv.textContent = message;
        errorMessageDiv.style.display = &quot;block&quot;;
    };

    if (document.readyState === &quot;loading&quot;) {
        document.addEventListener(&quot;DOMContentLoaded&quot;, loadPako);
    } else {
        loadPako();
    }

    window.isPakoLoaded = () => isLoaded;
})();


// IIFE #6: Fetching, deserializing, processing data, and shuffling channels
(function IIFE6() {
    async function fetchAndDeserialize(url) {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Network error: ${url}`);
        const arrayBuffer = await response.arrayBuffer();
        const inflated = pako.inflate(new Uint8Array(arrayBuffer));
        return deserialize(JSON.parse(new TextDecoder(&quot;utf-8&quot;).decode(inflated)));
    }

    function seededRandom(seed) {
        const x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
    }

    function shuffleArray(array, seed) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(seededRandom(seed) * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
            seed++;
        }
        return array;
    }

    function selectBPM(availableBPMs, seed) {
        return availableBPMs[Math.floor(seededRandom(seed) * availableBPMs.length)];
    }

    async function processSerializedData(urls) {
        await new Promise((resolve, reject) => {
            if (window.isPakoLoaded()) {
                resolve();
            } else {
                document.addEventListener(&quot;pakoLoaded&quot;, resolve);
            }
        });
    
        const data = (await Promise.all(urls.map(fetchAndDeserialize))).filter(Boolean);
        const baseBPM = selectBPM([80, 100, 120, 140, 160, 180, 240], window.seed);
    
        data.forEach(dataset =&gt; {
            const bpmRatio = baseBPM / dataset.projectBPM;
            dataset.channelPlaybackSpeed = dataset.channelPlaybackSpeed.map(speed =&gt; speed * bpmRatio);
        });
    
        const allChannels = data.flatMap((dataset, idx) =&gt;
            dataset.channelURLs.map((url, i) =&gt; ({
                url,
                volume: dataset.channelVolume[i],
                speed: dataset.channelPlaybackSpeed[i],
                trim: dataset.trimSettings[i],
                source: `data${idx + 1}`,
                index: i
            }))
        );
    
        const selectedChannels = shuffleArray(allChannels, window.seed).slice(0, 24);
        const combinedData = {
            ...data[0],
            projectBPM: baseBPM,
            channelURLs: selectedChannels.map(ch =&gt; ch.url),
            channelVolume: selectedChannels.map(ch =&gt; ch.volume),
            channelPlaybackSpeed: selectedChannels.map(ch =&gt; ch.speed),
            trimSettings: selectedChannels.map(ch =&gt; ch.trim),
            projectSequences: {}
        };
    
        const projectSources = data.reduce((acc, dataset, i) =&gt; {
            acc[`data${i + 1}`] = dataset;
            return acc;
        }, {});
    
        Object.keys(data[0].projectSequences).forEach(seq =&gt; {
            combinedData.projectSequences[seq] = {};
            selectedChannels.forEach((ch, i) =&gt; {
                combinedData.projectSequences[seq][`ch${i}`] = projectSources[ch.source]?.projectSequences[seq]?.[`ch${ch.index}`] || { steps: [] };
            });
        });
    
        window.jsonDataUrl = URL.createObjectURL(new Blob([JSON.stringify(combinedData)], { type: &quot;application/json&quot; }));
    
        // Embedded scriptLoader_web3.js logic
        window.scriptsToLoad = [
            &quot;/content/61895db1f0d62d24cea96570e66b92435a8a4979e3d3fef8041680ed2afeddc8i0&quot;,
            &quot;/content/1b036f9d60a04f0612af8c53753273f66339e69d7843138007eb3573703b1218i0&quot;,
            &quot;/content/150e020d5e6ea8b53b7b3d2160f25f65c2e550d413f9c53d9e1cfb101d6914f2i0&quot;,
            &quot;/content/935828577e4762caaf32b76a0f74cb4f37bdcdbdae1d27a7c93d000d5cfe9d28i0&quot;,
            &quot;/content/bab2b37e0abcce41d784d65d94a5c3c266228c2d8bd3ecdee4fba7986f5a042ei0&quot;,
            &quot;/content/1a5cafb61e4a320434fc4087e203d2a5f695ba9112635b960fc9d7dcb961d9fci0&quot;,
            &quot;/content/a3d8a40fcde6935f16b49ad7c9e9aa185f01d1618f4e35828415f6cc27377a47i0&quot;,
            &quot;/content/17c6cb4f92d47043da52ce8334c41961c588b7955488e56f08264840ef63a4eei0&quot;,
            &quot;/content/4915e144695ab04171092a45e2d49cfa7b5e92c9a35ce612e7b749457acc92ddi0&quot;,
            &quot;/content/3ab9dda407f9c7f62b46401e2664bc1496247c8950620a11a36a8601267cb42fi0&quot;,
            &quot;/content/4a6164e05aee1d4ed77585bc85e4d4530801ef71e1c277c868ce374c4a7b9902i0&quot;,
            &quot;/content/0505ae5cebbe9513648fc8e4ecee22d9969764f3cdac9cd6ec33be083c77ae96i0&quot;,
            &quot;/content/87bb49f5617a241e29512850176e53169c3da4a76444d5d8fcd6c1e41489a4b3i0&quot;,
            &quot;/content/cea34b6ad754f3a4e992976125bbd1dd59213aab3de03c9fe2eb10ddbe387f76i0&quot;,
            &quot;/content/bcee9a2e880510772f0129c735a4ecea5bb45277f3b99ff640c1bd393dddd6dfi0&quot;,
            &quot;/content/90d910fe4088c53a16eb227ec2fe59802091dc4ea51564b2665090403c34f59ci0&quot;,
            &quot;/content/916fd1731cdecf82706a290d03448c6dc505c01d6ec44bbca20281a19723d617i0&quot;,
            &quot;/content/6a5e5c8b42793dd35512dfddd81dbbe211f052ac79839dd54b53461f5783a390i0&quot;,
            &quot;/content/c0ee69121238f6438be8398038301cf5b1d876cce30a0d45a3a5e0b927826940i0&quot;,
            &quot;/content/6f1def70a3290c50793773a8b1712c9a1b0561b3674ee50a06c13bc4e492f459i0&quot;,
            &quot;/content/c7c92a81d5279950be7d0bd3e755ad620551bc65e6e514d6f7c29b4c24465d0ai0&quot;,
            &quot;/content/99ecc0668e27f03cf202f9ebc49d0332ac8f594bc9b5483969108b83723a0e9di0&quot;,
            &quot;/content/305829e076d38130be65851c79241929983f16d679822015ff237029f67d5d9ei0&quot;,
            &quot;/content/0d8309856ec04e8ab5bd6aa4689429102378fb45368ad0e2787f0dfc72c66152i0&quot;,
            &quot;/content/287c837ecffc5b80d8e3c92c22b6dbf0447a3d916b95ee314c66909f6f2b2f3ci0&quot;,
            &quot;/content/214457a4f832847565746ecb0b9460ec7dc8ad93549a00a69f18b3d492c0e005i0&quot;
        ];

        const mainLoaderScript = document.createElement(&quot;script&quot;);
        mainLoaderScript.src = &quot;/content/0d81728a7d3eda3e4d9cdf6c8ca8f2c0701e1fdc183e77654440ba47760c7bc4i0&quot;;
        document.head.appendChild(mainLoaderScript);

    
        console.log(&quot;Deserialized Data URL:&quot;, window.jsonDataUrl);
    }
    
    window.fetchAndDeserialize = fetchAndDeserialize;
    window.processSerializedData = processSerializedData;
    window.seededRandom = seededRandom;
    window.shuffleArray = shuffleArray;
    window.selectBPM = selectBPM;
    })();
    
    
    

            
</script>
</body>
</html>"
frameborder="0">
</iframe>

</body>
</html>
