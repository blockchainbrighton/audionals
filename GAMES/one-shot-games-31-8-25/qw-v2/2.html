<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pulse Swap</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #111;
      color: white;
      font-family: 'Arial', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      touch-action: manipulation;
    }
    #game {
      position: relative;
      width: 320px;
      height: 320px;
    }
    #ring {
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: #222;
      overflow: hidden;
      box-shadow: 0 0 20px rgba(255,255,255,0.1);
    }
    .tile {
      position: absolute;
      width: 150px; height: 150px;
      transform-origin: bottom right;
      border: 1px solid #333;
      display: flex;
      justify-content: center;
      align-items: center;
      clip-path: polygon(0 0, 100% 0, 100% 70%, 0 70%);
    }
    .entity {
      position: absolute;
      width: 30px; height: 30px;
      border-radius: 50%;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px 2px rgba(255,255,255,0.4);
      transition: background 0.1s;
    }
    #energy-bar {
      position: absolute;
      bottom: -10px;
      left: 0;
      height: 5px;
      width: 100%;
      background: #333;
    }
    #energy-fill {
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, #ff4e4e, #4e4eff);
      transition: width 0.1s ease;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 14px;
      z-index: 10;
    }
    #game-over {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-size: 24px;
    }
    button {
      margin-top: 10px;
      padding: 10px 20px;
      background: #4e4eff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="game">
    <div id="ui">Wave: <span id="wave">1</span></div>
    <div id="ring"></div>
    <div id="energy-bar"><div id="energy-fill"></div></div>
    <div id="game-over">
      <div>Game Over</div>
      <div>Wave: <span id="final-wave">1</span></div>
      <button onclick="restart()">Play Again</button>
    </div>
  </div>

  <script>
    const ring = document.getElementById('ring');
    const energyFill = document.getElementById('energy-fill');
    const waveDisplay = document.getElementById('wave');
    const gameOverScreen = document.getElementById('game-over');
    const finalWaveDisplay = document.getElementById('final-wave');

    const NUM_TILES = 12;
    const COLORS = ['red', 'blue', 'neutral'];
    const COLOR_CODES = { red: '#ff4e4e', blue: '#4e4eff', neutral: '#aaa' };

    let tiles = [];
    let redPos = 0, bluePos = 11;
    let redEntity, blueEntity;
    let energy = 100;
    let energyRegenRate = 2.5;
    let isSwapping = false;
    let wave = 1;
    let speed = 600; // ms per step
    let gameActive = true;
    let interval, pulseInterval;

    function createRing() {
      ring.innerHTML = '';
      tiles = [];
      for (let i = 0; i < NUM_TILES; i++) {
        const tile = document.createElement('div');
        tile.className = 'tile';
        const angle = (i * 30) - 90;
        tile.style.transform = `rotate(${angle}deg)`;
        
        // Procedural generation with increasing difficulty
        let type;
        const r = Math.random();
        if (wave === 1) {
          type = r < 0.45 ? 'red' : r < 0.9 ? 'blue' : 'neutral';
        } else if (wave < 3) {
          type = r < 0.4 ? 'red' : r < 0.8 ? 'blue' : 'neutral';
        } else {
          // Introduce pulse tiles in wave 3+
          if (wave >= 3 && r > 0.85) {
            type = 'pulse';
          } else {
            type = r < 0.38 ? 'red' : r < 0.76 ? 'blue' : 'neutral';
          }
        }

        tiles.push({ type, el: tile, pulsePhase: 0 });
        updateTileVisual(tile, type);
        ring.appendChild(tile);
      }

      // Entities
      redEntity = document.createElement('div');
      redEntity.className = 'entity';
      redEntity.style.background = COLOR_CODES.red;
      ring.appendChild(redEntity);

      blueEntity = document.createElement('div');
      blueEntity.className = 'entity';
      blueEntity.style.background = COLOR_CODES.blue;
      ring.appendChild(blueEntity);

      updatePositions();
    }

    function updateTileVisual(tileEl, type, phase = 0) {
      if (type === 'pulse') {
        const c = phase ? '#ff4e4e' : '#4e4eff';
        tileEl.style.background = c;
        tileEl.style.opacity = '0.8';
      } else {
        tileEl.style.background = COLOR_CODES[type];
        tileEl.style.opacity = type === 'neutral' ? '0.6' : '1';
      }
    }

    function updatePositions() {
      const angleR = (redPos * 30) - 90;
      const angleB = (bluePos * 30) - 90;
      redEntity.style.transform = `translate(-50%, -50%) rotate(${angleR}deg) translateY(-130px)`;
      blueEntity.style.transform = `translate(-50%, -50%) rotate(${angleB}deg) translateY(-130px)`;

      // Highlight active tiles
      [...ring.children].forEach((t, i) => {
        t.style.filter = (i === redPos || i === bluePos) ? 'brightness(1.3)' : 'brightness(1)';
      });
    }

    function moveEntities() {
      // Pulse tiles update
      tiles.forEach(t => {
        if (t.type === 'pulse') {
          t.pulsePhase = 1 - t.pulsePhase;
          updateTileVisual(t.el, 'pulse', t.pulsePhase);
        }
      });

      const redTile = tiles[redPos];
      const blueTile = tiles[bluePos];

      // Check if red can move forward
      let redCanMove = false;
      let nextRedPos = (redPos + 1) % NUM_TILES;
      let nextRedTile = tiles[nextRedPos];
      if (nextRedTile.type === 'red' || nextRedTile.type === 'neutral') {
        redCanMove = true;
      } else if (nextRedTile.type === 'pulse') {
        redCanMove = nextRedTile.pulsePhase === 1; // red phase
      }

      // Check if blue can move backward
      let blueCanMove = false;
      let nextBluePos = (bluePos - 1 + NUM_TILES) % NUM_TILES;
      let nextBlueTile = tiles[nextBluePos];
      if (nextBlueTile.type === 'blue' || nextBlueTile.type === 'neutral') {
        blueCanMove = true;
      } else if (nextBlueTile.type === 'pulse') {
        blueCanMove = nextBlueTile.pulsePhase === 0; // blue phase
      }

      // If both can move, move them
      if (redCanMove) redPos = nextRedPos;
      if (blueCanMove) bluePos = nextBluePos;

      // If one is blocked and not swapped in time, game over
      if ((!redCanMove && redPos !== bluePos) || (!blueCanMove && redPos !== bluePos)) {
        if (!isSwapping) {
          endGame();
        }
      }

      updatePositions();
    }

    function swap() {
      if (!gameActive || isSwapping) return;
      if (energy < 5) return;

      isSwapping = true;
      energy -= 15;
      energyFill.style.width = energy + '%';

      // Visual pop
      ring.style.transform = 'scale(0.95)';
      setTimeout(() => ring.style.transform = 'scale(1)', 100);

      // Flash pulse
      const flash = document.createElement('div');
      flash.style.cssText = `
        position: absolute; width: 100%; height: 100%;
        background: rgba(255,255,255,0.2);
        border-radius: 50%; animation: fadeOut 0.3s forwards;
      `;
      ring.appendChild(flash);
      setTimeout(() => ring.removeChild(flash), 300);

      // Swap positions
      [redPos, bluePos] = [bluePos, redPos];
      updatePositions();

      // Sound-like feedback via vibration (if supported)
      if (navigator.vibrate) navigator.vibrate(20);

      setTimeout(() => isSwapping = false, 100);
    }

    function startWave() {
      interval = setInterval(moveEntities, speed);
      const regen = setInterval(() => {
        if (!gameActive) return clearInterval(regen);
        if (energy < 100) energy += energyRegenRate / 10;
        energyFill.style.width = energy + '%';
      }, 100);
    }

    function nextWave() {
      wave++;
      waveDisplay.textContent = wave;
      speed = Math.max(300, 600 - (wave - 1) * 40); // Speed up
      clearInterval(interval);
      setTimeout(() => {
        createRing();
        startWave();
      }, 1000);
    }

    function endGame() {
      gameActive = false;
      clearInterval(interval);
      finalWaveDisplay.textContent = wave;
      gameOverScreen.style.display = 'flex';
    }

    function restart() {
      wave = 1;
      speed = 600;
      energy = 100;
      gameActive = true;
      isSwapping = false;
      energyFill.style.width = '100%';
      gameOverScreen.style.display = 'none';
      createRing();
      startWave();
    }

    // Touch/mouse input
    document.getElementById('game').addEventListener('click', () => {
      if (gameActive) swap();
    });

    // Start the game
    createRing();
    startWave();

    // Optional: keyboard support
    document.addEventListener('keydown', e => {
      if (e.code === 'Space') swap();
    });
  </script>
</body>
</html>