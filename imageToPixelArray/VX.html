<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Pixel Art Maker – Pro</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --sidebar-width: 240px; --radius: 10px; --color-border: #d0d5e0;
      --color-primary: #105fe0; --color-primary-light: #5d8cff; --color-accent: #36d3aa;
      --color-danger: #a23b4a; --font-family: "Inter", system-ui, sans-serif; --grid-max: 640px;
    }
    *,*::before,*::after{box-sizing:border-box;}
    html,body{height:100%;margin:0;}
    body{display:flex;flex-direction:column;min-width:900px;min-height:650px;
      font-family:var(--font-family);background:#f4f6fb;color:#333;}
    #mainLayout{flex:1;display:flex;}
    #leftColumn{flex:0 0 var(--sidebar-width);display:flex;flex-direction:column;gap:1rem;
      padding:1rem .75rem;background:#fff;border-right:1px solid var(--color-border);}
    #rightColumn{flex:1;display:flex;flex-direction:column;align-items:center;gap:1rem;
      padding:1rem 1.5rem;overflow:auto;}
    .btn{display:inline-flex;align-items:center;justify-content:center;
      padding:.5rem 1rem;font-weight:600;font-size:1rem;
      border-radius:var(--radius);border:1.8px solid transparent;
      background:#fff;cursor:pointer;transition:background .15s,box-shadow .15s;}
    .btn:active{transform:translateY(1px);}
    .btn-primary{background:var(--color-primary);color:#fff;}
    .btn-outline{border-color:var(--color-primary);color:var(--color-primary);background:#fafcfe;}
    .btn-danger{border-color:var(--color-danger);color:var(--color-danger);background:#fafcfe;}
    #latchToggle.on{background:var(--color-accent);border-color:#0c8b67;color:#fff;}
    #paletteRow{display:flex;flex-wrap:wrap;gap:.5rem;}
    .paletteColorBtn{width:34px;height:34px;border-radius:8px;border:2px solid #888;cursor:pointer;
      display:flex;align-items:center;justify-content:center;}
    .paletteColorBtn.selected{border-color:var(--color-primary);box-shadow:0 0 0 2px var(--color-primary-light);}
    .paletteColorBtn.transparent{background:repeating-linear-gradient(45deg,#ddd 0 8px,#fff 8px 16px);border-style:dashed;}
    .userColorRow{display:flex;align-items:center;gap:.25rem;font-size:.9rem;}
    #gridBox {
      width:min(var(--grid-max),60vmin);height:min(var(--grid-max),60vmin);
      position:relative; display:block;
    }
    .pixel-layer {
      position:absolute; left:0; top:0; width:100%; height:100%;
      display:grid; grid-template-columns:repeat(64,1fr); grid-template-rows:repeat(64,1fr);
      pointer-events:none;
    }
    #grid { z-index:3; pointer-events:auto; }
    #scrollLayer { z-index:2; }
    .cell,.scroll-cell {
      width:100%; height:100%; border:1px solid #f4f7fc; background-clip:padding-box;
      position:relative;
    }
    .scroll-cell { pointer-events:none; }
    [data-size].selected{background:var(--color-primary);color:#fff;}
    @media(max-width:1200px){:root{--sidebar-width:200px;}}
  </style>
</head>
<body>
  <div id="mainLayout">
    <aside id="leftColumn">
      <!-- ... Palette, Letter Color, Controls ... (unchanged, see earlier) -->
      <h2 style="margin:0 0 .5rem 0;font-size:1rem;">Palette</h2>
      <div id="paletteRow"></div>
      <section id="userColorsBlock"></section>
      <section id="letterColorBlock">
        <strong>Letter Colour:</strong>
        <div id="letterColorRow" style="display:flex;gap:.25rem;margin:.25rem 0;"></div>
      </section>
      <section id="letterBankBlock">
        <strong>Letter Bank:</strong>
        <div id="letterBankRow" style="display:flex;flex-wrap:wrap;gap:.25rem;margin-top:.25rem;"></div>
      </section>
      <section id="textControls">
        <div style="display:flex;align-items:center;gap:0.5rem;">
          <label>Size:</label>
          <button type="button" class="btn btn-outline" data-size="2">S</button>
          <button type="button" class="btn btn-outline selected" data-size="3">M</button>
          <button type="button" class="btn btn-outline" data-size="4">L</button>
          <input type="range" id="textSizeSlider" min="1" max="8" value="3" style="width:80px;" title="Text Size">
          <span id="textSizeValue" style="width:26px;display:inline-block;text-align:center;">3</span>
          <input type="text" id="textInput" maxlength="32" placeholder="Type text…" style="width:110px;">
          <button id="placeText" class="btn btn-primary">Place</button>
          <button id="scrollText" class="btn btn-outline">Scroll</button>
          <input type="range" id="scrollSpeed" min="40" max="400" value="120" style="width:65px;" title="Scroll Speed (ms)">
        </div>
      </section>
      <button id="latchToggle" class="btn btn-outline">Latch: Off</button>
      <button id="undoBtn" class="btn btn-danger">Undo</button>
    </aside>
    <main id="rightColumn">
      <div id="topRow" style="display:flex;align-items:center;flex-wrap:wrap;gap:.5rem;">
        <input type="file" id="imageUpload" accept="image/*">
        <button id="clearCanvas" class="btn btn-outline">Clear</button>
        <button id="saveProject" class="btn btn-outline">Save Project</button>
        <button id="loadProjectBtn" class="btn btn-outline">Load Project</button>
        <input type="file" id="projectLoader" accept=".pxproj,.json" hidden>
      </div>
      <div id="gridBox">
        <div id="scrollLayer" class="pixel-layer"></div>
        <div id="grid" class="pixel-layer"></div>
      </div>
      <section id="arrayDataBlock" style="width:100%;max-width:720px;display:flex;flex-direction:column;gap:.5rem;">
        <label for="arrayDataOutput" style="font-weight:600;">Pixel Array Data:</label>
        <textarea id="arrayDataOutput" readonly style="width:100%;height:130px;font-family:'JetBrains Mono','Menlo',monospace;border:1.2px solid #ccc;border-radius:5px;resize:none;"></textarea>
        <div style="display:flex;gap:.5rem;flex-wrap:wrap;">
          <button id="arrayCopyBtn"   class="btn btn-outline" style="min-width:130px;">Copy Array</button>
          <button id="downloadPNG"   class="btn btn-outline" style="min-width:130px;">Download PNG</button>
          <button id="downloadSVG" class="btn btn-outline" style="min-width:120px;">Download SVG</button>
        </div>
      </section>
    </main>
  </div>

  <script type="module">
    // Pixel font module (A-Z, 0-9, space, period, dash)
    export const pixelFont = {
      "A":["01110","10001","10001","11111","10001","10001","10001"],
      "B":["11110","10001","10001","11110","10001","10001","11110"],
      "C":["01110","10001","10000","10000","10000","10001","01110"],
      "D":["11110","10001","10001","10001","10001","10001","11110"],
      "E":["11111","10000","10000","11110","10000","10000","11111"],
      "F":["11111","10000","10000","11110","10000","10000","10000"],
      "G":["01110","10001","10000","10111","10001","10001","01111"],
      "H":["10001","10001","10001","11111","10001","10001","10001"],
      "I":["111","010","010","010","010","010","111"],
      "J":["00111","00010","00010","00010","10010","10010","01100"],
      "K":["10001","10010","10100","11000","10100","10010","10001"],
      "L":["10000","10000","10000","10000","10000","10000","11111"],
      "M":["10001","11011","10101","10101","10001","10001","10001"],
      "N":["10001","10001","11001","10101","10011","10001","10001"],
      "O":["01110","10001","10001","10001","10001","10001","01110"],
      "P":["11110","10001","10001","11110","10000","10000","10000"],
      "Q":["01110","10001","10001","10001","10101","10010","01101"],
      "R":["11110","10001","10001","11110","10100","10010","10001"],
      "S":["01111","10000","10000","01110","00001","00001","11110"],
      "T":["11111","00100","00100","00100","00100","00100","00100"],
      "U":["10001","10001","10001","10001","10001","10001","01110"],
      "V":["10001","10001","10001","10001","10001","01010","00100"],
      "W":["10001","10001","10001","10101","10101","11011","10001"],
      "X":["10001","10001","01010","00100","01010","10001","10001"],
      "Y":["10001","10001","10001","01010","00100","00100","00100"],
      "Z":["11111","00001","00010","00100","01000","10000","11111"],
      "0":["01110","10001","10011","10101","11001","10001","01110"],
      "1":["010","110","010","010","010","010","111"],
      "2":["01110","10001","00001","00010","00100","01000","11111"],
      "3":["11110","00001","00001","01110","00001","00001","11110"],
      "4":["00010","00110","01010","10010","11111","00010","00010"],
      "5":["11111","10000","10000","11110","00001","00001","11110"],
      "6":["01110","10000","10000","11110","10001","10001","01110"],
      "7":["11111","00001","00010","00100","01000","10000","10000"],
      "8":["01110","10001","10001","01110","10001","10001","01110"],
      "9":["01110","10001","10001","01111","00001","00001","01110"],
      " ":["00000","00000","00000","00000","00000","00000","00000"],
      ".":["00000","00000","00000","00000","00000","01100","01100"],
      "-":["00000","00000","00000","01110","00000","00000","00000"]
    };
    export const FONT_W = 5, FONT_H = 7;
    window.pixelFont = pixelFont;
    window.FONT_W = FONT_W;
    window.FONT_H = FONT_H;
  </script>
<script>
  const SIZE = 64, MAX_UNDO = 100, FONT_W = 5, FONT_H = 7;
  const visorTop = 19, visorBot = 46, visorLeft = 13, visorRight = 50;
  const $ = s => document.querySelector(s);
  const clone = g => g.map(r => [...r]);
  let palette = [[0,0,0,0]], userColors = Array(5).fill("#ffd700"),
    gridArray = Array(SIZE).fill().map(_=>Array(SIZE).fill(0)),
    originalArray = Array(SIZE).fill().map(_=>Array(SIZE).fill(0)),
    gridHistory = [], undoPointer = -1, mouseDown = false, latchMode = false, selectedColorIndex = 0,
    cellElems = Array(SIZE).fill().map(_=>Array(SIZE)),
    scrollCells = [], scrollInterval = null,
    LETTER_SCALE = 3, letterScale = 3, letterColorHex = "#105fe0";
  

   

  // --- Drop-in: Size Buttons + Slider + UI sync ---
  function updateTextSizeControls(val) {
    letterScale = +val;
    $('#textSizeValue').textContent = val;
    document.querySelectorAll('[data-size]').forEach(btn =>
      btn.classList.toggle('selected', +btn.dataset.size === +val)
    );
    $('#textSizeSlider').value = val;
  }

  // Size buttons:
  document.querySelectorAll('[data-size]').forEach(btn => {
    btn.onclick = () => updateTextSizeControls(btn.dataset.size);
  });

  // Size slider:
  $('#textSizeSlider').oninput = e => updateTextSizeControls(e.target.value);

  // Sync initial state:
  updateTextSizeControls(letterScale);

  $('#placeText').onclick = () => {
    stopScrollTextLayer();
    const text = $('#textInput').value.trim();
    if (text) insertLetter(text, letterScale);
  };

  $('#scrollText').onclick = function () {
    if (scrollInterval) { stopScrollTextLayer(); this.textContent = "Scroll"; }
    else {
      const text = $('#textInput').value.trim();
      if (!text) return;
      this.textContent = "Stop";
      startScrollTextLayer(text, letterScale, +$('#scrollSpeed').value, letterColorHex);
    }
  };




  const cellBg = (idx, col) => idx === 0 ? 'rgba(0,0,0,0)' : `rgb(${col[0]},${col[1]},${col[2]})`;
  const hexToRgbArr = h => [1,3,5].map(i=>parseInt(h.slice(i,i+2),16));
  const pushUndo = () => {
    if (gridHistory.length > MAX_UNDO) gridHistory.shift(), undoPointer--;
    gridHistory = gridHistory.slice(0, undoPointer+1);
    gridHistory.push(clone(gridArray));
    undoPointer = gridHistory.length-1;
  };
  const undo = () => { if (undoPointer<=0) return; undoPointer--; gridArray = clone(gridHistory[undoPointer]); drawGrid(); };
  const repaintCell = (r,c) => { const idx=gridArray[r][c],col=palette[idx]; cellElems[r][c].style.backgroundColor=cellBg(idx,col) };
  const drawGrid = () => { for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++)repaintCell(r,c); updateArrayDisplay(); };
  const setLatchUI = () => { $('#latchToggle').classList.toggle('on', latchMode); $('#latchToggle').textContent = latchMode ? 'Latch: On' : 'Latch: Off' };
  const createBtn = (cls,txt,fn) => Object.assign(document.createElement('button'),{className:cls,innerHTML:txt,onclick:fn});
  const clearArr = arr => arr.forEach(a=>a.fill(0));
  
  // --- Scroll Layer ---
  function initScrollLayer() {
    const sl = $('#scrollLayer'); sl.innerHTML = ''; scrollCells = [];
    for(let r=0;r<SIZE;r++) {
      let row = [];
      for(let c=0;c<SIZE;c++) {
        const div = document.createElement('div');
        div.className = 'scroll-cell'; sl.appendChild(div); row.push(div);
      }
      scrollCells.push(row);
    }
  }
  const clearScrollLayer = () => scrollCells.forEach(row=>row.forEach(cell=>cell.style.backgroundColor='rgba(0,0,0,0)'));
  function renderScrollToLayer(buf, frame=0) {
    clearScrollLayer();
    const h = visorBot-visorTop+1, w = visorRight-visorLeft+1;
    for(let r=0;r<h;r++) for(let c=0;c<w;c++)
      if(buf[r] && buf[r][frame+c]) scrollCells[visorTop+r][visorLeft+c].style.backgroundColor = buf[r][frame+c];
  }
  function makeTextColorBuffer(text, scale, hex) {
    const glyphs = [...text.toUpperCase()].map(ch=>window.pixelFont[ch]||window.pixelFont[' ']);
    const glyphW=5*scale, glyphH=7*scale, visorH=visorBot-visorTop+1, visorW=visorRight-visorLeft+1;
    const space=scale, fullW=glyphs.length*(glyphW+space)-space, bufferW=visorW+fullW+2*space;
    const buf=Array(visorH).fill().map(()=>Array(bufferW).fill(null));
    let x=visorW+space, y=Math.floor((visorH-glyphH)/2);
    glyphs.forEach(glyph=>{
      for(let r=0;r<7;r++)for(let c=0;c<5;c++)if(glyph[r][c]==='1')
        for(let dy=0;dy<scale;dy++)for(let dx=0;dx<scale;dx++) {
          let row=y+r*scale+dy, col=x+c*scale+dx;
          if(row>=0&&row<visorH&&col>=0&&col<bufferW) buf[row][col]=hex;
        }
      x+=glyphW+space;
    });
    return buf;
  }
  function startScrollTextLayer(text, scale, speed, hex) {
    if(scrollInterval) stopScrollTextLayer();
    const buf = makeTextColorBuffer(text, scale, hex);
    let frame = 0, maxFrame = buf[0].length - (visorRight-visorLeft+1);
    scrollInterval = setInterval(()=>{
      renderScrollToLayer(buf, frame);
      frame = (frame+1)%maxFrame;
    }, speed);
  }
  function stopScrollTextLayer() {
    if(scrollInterval) clearInterval(scrollInterval),scrollInterval=null;
    clearScrollLayer();
  }
  
  // --- Grid Logic & UI ---
  function buildGrid(){
    const grid=$('#grid'); grid.innerHTML='';
    for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){
      const div=document.createElement('div'); div.className='cell'; cellElems[r][c]=div;
      div.onmousedown = e => {
        mouseDown=true;
        gridArray[r][c]=e.button===2?originalArray[r][c]??0:selectedColorIndex;
        repaintCell(r,c); pushUndo(); e.preventDefault();
      };
      div.onmouseover = () => { if(mouseDown&&latchMode){gridArray[r][c]=selectedColorIndex;repaintCell(r,c);} };
      div.onmouseup = () => mouseDown=false;
      div.oncontextmenu = e => { gridArray[r][c]=originalArray[r][c]??0; repaintCell(r,c); pushUndo(); e.preventDefault(); };
      grid.appendChild(div);
    }
    document.addEventListener('mouseup',()=>mouseDown=false);
  }
  function createColorButtons(){
    const row=$('#paletteRow'); row.innerHTML='';
    palette.forEach((c,i)=>{
      const btn = createBtn(
        'paletteColorBtn'+(i===selectedColorIndex?' selected':'')+(i===0?' transparent':''),
        i===0?'<span style="font-size:1.2em;">⌀</span>':'',
        ()=>{selectedColorIndex=i;createColorButtons();}
      );
      btn.style.backgroundColor=cellBg(i,c);
      btn.title=i===0?'Transparent Pixel':`Palette ${i}`;
      row.appendChild(btn);
    });
  }
  function setupUserColorsUI(){
    const div=$('#userColorsBlock'); div.innerHTML='<strong>User Palette Colors:</strong>';
    userColors.forEach((hex,i)=>{
      const row=document.createElement('div'); row.className='userColorRow';
      row.innerHTML=`<label for=userColor${i}>Color ${i+1}: </label>`;
      const input=Object.assign(document.createElement('input'),{type:'color',value:hex,id:`userColor${i}`});
      const btn=createBtn('', 'Set', ()=>setUserColor(i,input.value));
      input.oninput=btn.onclick=()=>setUserColor(i,input.value);
      row.append(input,btn); div.appendChild(row);
    });
  }
  const setUserColor = (i,hex) => { userColors[i]=hex; palette[1+i]=hexToRgbArr(hex); createColorButtons(); drawGrid(); };
  
  // --- Project Save/Load ---
  const serialiseProject = () => JSON.stringify({version:1,palette,userColors,gridArray,originalArray,latchMode});
  const saveProject = () => {
    const blob=new Blob([serialiseProject()],{type:'application/json'}),
      a=document.createElement('a'),
      ts=new Date().toISOString().replace(/[:T]/g,'-').slice(0,19);
    a.href=URL.createObjectURL(blob); a.download=`pixelart-${ts}.pxproj`; a.click(); URL.revokeObjectURL(a.href);
  };
  const loadProject = json => {
    try {
      const d=JSON.parse(json);
      if(!d.gridArray||!d.palette) throw'Invalid project file';
      palette=d.palette; userColors=d.userColors; gridArray=d.gridArray;
      originalArray=d.originalArray||clone(gridArray); latchMode=!!d.latchMode;
      setLatchUI(); setupUserColorsUI(); createColorButtons(); drawGrid(); pushUndo();
    } catch(e) { alert('Could not load project: '+e); }
  };
  
  // --- Quantization & Palette ---
  function quantize(pixels, n=16) {
    let clusters=[], centroids=[]; for(let i=0;i<n;i++) centroids.push(pixels[Math.floor(Math.random()*pixels.length)]||[0,0,0]), clusters.push([]);
    let change=true; for(let iter=0;iter<8&&change;iter++){
      clusters.forEach(c=>c.length=0);
      for(let p of pixels){
        let min=1e9,idx=0;
        centroids.forEach((c,i)=>{let d=(p[0]-c[0])**2+(p[1]-c[1])**2+(p[2]-c[2])**2;if(d<min)min=d,idx=i;});
        clusters[idx].push(p);
      }
      change=false;
      centroids=clusters.map((cl,i)=>{
        if(!cl.length) return centroids[i];
        let avg=cl.reduce((a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]],[0,0,0]).map(x=>Math.round(x/cl.length));
        if(!centroids[i].every((v,d)=>v===avg[d])) change=true;
        return avg;
      });
    }
    return centroids;
  }
  const updatePaletteFromImage = pixels => {
    let imgCols=quantize(pixels,15);
    palette=[[0,0,0,0],...imgCols];
    userColors.forEach((hex,i)=>hex&&(palette[1+i]=hexToRgbArr(hex)));
    createColorButtons();
  };
  const rgbToPaletteIndex = (r,g,b,a=255) => {
    if(a<40)return 0;
    let min=1e9,idx=1;
    for(let i=1;i<palette.length;i++){
      let c=palette[i],d=(r-c[0])**2+(g-c[1])**2+(b-c[2])**2;
      if(d<min)min=d,idx=i;
    }
    return idx;
  };
  
  // --- Image Loading ---
  $('#imageUpload').onchange=evt=>{
    const file=evt.target.files[0]; if(!file)return;
    const r=new FileReader();
    r.onloadend=()=>{
      const img=new Image(); img.src=r.result; img.crossOrigin='Anonymous';
      img.onload=()=>{
        const canvas=document.createElement('canvas'); canvas.width=SIZE; canvas.height=SIZE;
        const ctx=canvas.getContext('2d'); ctx.clearRect(0,0,SIZE,SIZE);
        ctx.drawImage(img,0,0,SIZE,SIZE);
        const data=ctx.getImageData(0,0,SIZE,SIZE).data, pixels=[];
        for(let i=0;i<SIZE*SIZE;i++){const o=i*4;if(data[o+3]>40)pixels.push([data[o],data[o+1],data[o+2]]);}
        updatePaletteFromImage(pixels);
        for(let row=0;row<SIZE;row++)for(let col=0;col<SIZE;col++){
          const idx=(row*SIZE+col)*4,r=data[idx],g=data[idx+1],b=data[idx+2],a=data[idx+3],pi=rgbToPaletteIndex(r,g,b,a);
          gridArray[row][col]=pi; originalArray[row][col]=pi;
        }
        drawGrid(); pushUndo();
      };
    }; r.readAsDataURL(file);
  };
  
  // --- Array Display & Export ---
  const updateArrayDisplay = () => {
    const flat=gridArray.flat();
    const paletteString=palette.map(c=>c.length===4?"00":c.map(x=>x.toString(16).padStart(2,'0')).join('')).join(',');
    const rle=[],last=flat[0],count=1;
    let l=last,c=count;
    for(let i=1;i<flat.length;i++)flat[i]===l?c++:(rle.push([l.toString(16),c]),l=flat[i],c=1);
    rle.push([l.toString(16),c]);
    $('#arrayDataOutput').value=`${paletteString};${rle.map(([a,n])=>a+':'+n).join(',')};${SIZE}`;
  };
  $('#arrayCopyBtn').onclick=()=>{$('#arrayDataOutput').select();document.execCommand('copy');};
  $('#downloadPNG').onclick=()=>{
    const canvas=document.createElement('canvas');canvas.width=SIZE;canvas.height=SIZE;
    const ctx=canvas.getContext('2d'),imgData=ctx.createImageData(SIZE,SIZE);
    for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){
      const i=(r*SIZE+c)*4,idx=gridArray[r][c],col=palette[idx];
      if(idx===0)imgData.data[i+3]=0;
      else imgData.data[i]=col[0],imgData.data[i+1]=col[1],imgData.data[i+2]=col[2],imgData.data[i+3]=255;
    }
    ctx.putImageData(imgData,0,0);
    const link=document.createElement('a');
    link.download='pixelart.png'; link.href=canvas.toDataURL('image/png'); link.click();
  };
  $('#downloadSVG').onclick=()=>{
    let svg=`<svg xmlns="http://www.w3.org/2000/svg" width="${SIZE}" height="${SIZE}" shape-rendering="crispEdges" style="background:none">`;
    for(let y=0;y<SIZE;y++)for(let x=0;x<SIZE;x++){
      const idx=gridArray[y][x],c=palette[idx];
      if(idx)svg+=`<rect x="${x}" y="${y}" width="1" height="1" fill="rgb(${c[0]},${c[1]},${c[2]})"/>`;
    }
    svg+='</svg>';
    const blob=new Blob([svg],{type:'image/svg+xml'}),link=document.createElement('a');
    link.download='pixelart.svg';link.href=URL.createObjectURL(blob);link.click();URL.revokeObjectURL(link.href);
  };
  $('#clearCanvas').onclick=()=>{clearArr(gridArray); clearArr(originalArray); drawGrid(); pushUndo();};
  document.addEventListener('contextmenu',e=>e.preventDefault());
  
  // --- Letters & Bank ---
  function buildLetterColorSelector() {
    const row = document.getElementById('letterColorRow');
    row.innerHTML = '';
    const input = document.createElement('input');
    input.type = 'color'; input.value = letterColorHex;
    input.style.width = input.style.height = '36px'; input.style.border = '2.5px solid var(--color-primary)';
    input.style.borderRadius = '8px'; input.title = "Letter Colour";
    input.oninput = e => { letterColorHex = e.target.value; };
    row.appendChild(input);
  }
  // Center vertically in visor (block):
  function insertLetter(text, scale = letterScale) {
    if (!text || !window.pixelFont) return;
    const glyphs = [...text.toUpperCase()].map(ch => pixelFont[ch] || pixelFont[' ']);
    if (glyphs.some(g => !g)) return;
    const glyphW = FONT_W * scale, glyphH = FONT_H * scale;
    const wordW = glyphs.length * glyphW + (glyphs.length - 1) * scale;
    const visorW = visorRight - visorLeft + 1, visorH = visorBot - visorTop + 1;
    const startCol = visorLeft + Math.floor((visorW - wordW) / 2);
    // More perfect vertical centering (for even/odd glyphH, will look correct even at scale 1)
    const startRow = visorTop + Math.floor((visorH - glyphH) / 2);
    const rgb = hexToRgbArr(letterColorHex);
    let idx = palette.findIndex(c => c[0] === rgb[0] && c[1] === rgb[1] && c[2] === rgb[2]);
    if (idx === -1) { palette.push(rgb); idx = palette.length - 1; createColorButtons(); }
    glyphs.forEach((glyph, l) => {
      for (let r = 0; r < FONT_H; r++) for (let c = 0; c < FONT_W; c++)
        if (glyph[r][c] === '1')
          for (let dy = 0; dy < scale; dy++) for (let dx = 0; dx < scale; dx++) {
            const row = startRow + r * scale + dy, col = startCol + l * (glyphW + scale) + (c * scale) + dx;
            if (gridArray[row] && gridArray[row][col] !== undefined)
              gridArray[row][col] = idx;
          }
    });
    drawGrid(); pushUndo();
  }


  function buildLetterBank() {
    const row = document.getElementById('letterBankRow'); row.innerHTML = '';
    if (!window.pixelFont) return;
    Object.keys(pixelFont).forEach(ch => {
      const btn = document.createElement('button');
      btn.className = 'btn btn-outline'; btn.style.fontFamily = 'monospace'; btn.style.fontSize = '1.1em';
      btn.style.width = btn.style.height = '32px'; btn.textContent = ch; btn.title = `Insert "${ch}" (centered, large)`;
      btn.onclick = () => insertLetter(ch);
      row.appendChild(btn);
    });
    const input = document.createElement('input');
    input.type = 'text'; input.maxLength = 32; input.placeholder = 'Type...';
    input.style.width = '64px'; input.style.marginLeft = '4px';
    input.onchange = ()=>{ insertLetter(input.value); input.value=''; };
    row.appendChild(input);
  }
  
  // --- UI HANDLERS ---
  $('#latchToggle').onclick=()=>{latchMode=!latchMode;setLatchUI();};
  $('#undoBtn').onclick=undo;
  $('#saveProject').onclick=saveProject;
  $('#loadProjectBtn').onclick=()=>$('#projectLoader').click();
  $('#projectLoader').onchange=e=>{
    const f=e.target.files[0];if(!f)return;
    const r=new FileReader(); r.onload=evt=>loadProject(evt.target.result); r.readAsText(f); e.target.value='';
  };
  document.addEventListener("DOMContentLoaded",()=>{
    buildGrid(); setupUserColorsUI(); createColorButtons(); buildLetterBank(); buildLetterColorSelector(); drawGrid(); pushUndo(); initScrollLayer();
    document.querySelectorAll('[data-size]').forEach(btn=>{
      btn.onclick=()=>{
        letterScale=+btn.dataset.size;
        document.querySelectorAll('[data-size]').forEach(b=>b.classList.toggle('selected',b===btn));
      };
    });
    $('#placeText').onclick=()=>{
      stopScrollTextLayer();
      const text = $('#textInput').value.trim();
      if (text) insertLetter(text, letterScale);
    };
    $('#scrollText').onclick=function(){
      if(scrollInterval) { stopScrollTextLayer(); this.textContent="Scroll"; }
      else {
        const text = $('#textInput').value.trim();
        if(!text) return;
        this.textContent = "Stop";
        startScrollTextLayer(text, letterScale, +$('#scrollSpeed').value, letterColorHex);
      }
    };
    $('#scrollSpeed').oninput=function(){ if(scrollInterval){ stopScrollTextLayer(); $('#scrollText').textContent="Scroll"; } };
    document.getElementById('letterColorRow').addEventListener('input', e=>{ if(e.target.type==='color') letterColorHex = e.target.value; });
    window.addEventListener('beforeunload', stopScrollTextLayer);
  });
  
  window.insertLetter = insertLetter;
  </script>
  
  
</body>
</html>
