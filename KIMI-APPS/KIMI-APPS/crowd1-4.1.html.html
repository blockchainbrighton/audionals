<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>3D Crowd Game - Enhanced</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    html,body{
        margin:0;
        height:100%;
        background:#222;
        color:#eee;
        font-family:-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }
    #info{
        position:absolute;
        top:10px;
        left:10px;
        background:rgba(0,0,0,.5);
        padding:8px 12px;
        border-radius:4px;
        font-size:14px;
        pointer-events:none;
        max-width: 250px;
    }
    #game-ui {
        position:absolute;
        bottom:10px;
        left:10px;
        background:rgba(0,0,0,.5);
        padding:8px 12px;
        border-radius:4px;
        font-size:16px;
        font-weight: bold;
    }
    #win-message {
        display: none;
        color: #0f0;
    }
    #instructions {
        position: absolute;
        top: 80px; /* Positioned below the other info box */
        left: 10px;
        background: rgba(0,0,0,.5);
        padding: 0 15px 10px;
        border-radius: 4px;
        font-size: 13px;
        max-width: 250px;
        line-height: 1.5;
    }
    #instructions ul { padding-left: 20px; margin-top: 5px; }
    button{
        position:absolute;
        top:10px;
        right:10px;
        padding:8px 16px;
        border:none;
        border-radius:4px;
        background:#0af;
        color:#fff;
        cursor:pointer;
        font-size: 14px;
    }
  </style>
</head>
<body>
  <!-- INSTRUCTIONS PANEL -->
  <div id="instructions">
    <h3>Welcome to Tag!</h3>
    <p><b>Objective:</b> Catch all the other people in the park!</p>
    <ul>
        <li><b>Move Player:</b> Use <b>WASD</b> keys.</li>
        <li><b>Move Camera:</b>
            <ul>
                <li><b>Drag</b> to rotate.</li>
                <li><b>Scroll</b> to zoom.</li>
                <li><b>Right-Click + Drag</b> to pan.</li>
            </ul>
        </li>
    </ul>
    <p>The "Reset" button will start a new game.</p>
  </div>
  
  <div id="info">Camera follows player.</div>
  
  <!-- GAMEPLAY UI -->
  <div id="game-ui">
    <div id="score">Caught: 0 / 0</div>
    <div id="win-message">You Win!</div>
  </div>

  <button id="resetBtn">Reset Game</button>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    /* ---------- Globals ---------- */
    let scene, camera, renderer, controls;
    const sandboxSize = 25; // slightly larger for more space
    const clock = new THREE.Clock();
    
    // Game State
    let player;
    const crowd = [];
    const keys = { w:false, a:false, s:false, d:false };
    let gameActive = false;
    const score = { caught: 0, total: 0 };
    const scoreEl = document.getElementById('score');
    const winMsgEl = document.getElementById('win-message');
    const playerShirtColor = new THREE.Color(0x0088ff);


    /* ---------- Main ---------- */
    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x88ccee);
      scene.fog = new THREE.Fog(0x88ccee, 20, 50);

      camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 100);
      camera.position.set(0, 15, 20);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.minDistance = 5;
      controls.maxDistance = 40;
      controls.maxPolarAngle = Math.PI / 2.1; // Prevent camera going under ground
      controls.enablePan = true;
      
      /* Lighting */
      const sun = new THREE.DirectionalLight(0xffffff, 1.2);
      sun.position.set(10, 20, 10);
      sun.castShadow = true;
      sun.shadow.mapSize.set(2048, 2048);
      sun.shadow.camera.left = -sandboxSize/2;
      sun.shadow.camera.right = sandboxSize/2;
      sun.shadow.camera.top = sandboxSize/2;
      sun.shadow.camera.bottom = -sandboxSize/2;
      scene.add(sun, new THREE.AmbientLight(0x666666));

      /* Ground */
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(sandboxSize, sandboxSize),
        new THREE.MeshStandardMaterial({ color: 0xddbb77, roughness: 1 })
      );
      ground.rotation.x = -Math.PI/2;
      ground.receiveShadow = true;
      scene.add(ground);

      /* Walls */
      const wallMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.8 });
      const wallGeo = new THREE.BoxGeometry(sandboxSize, 2, 0.5);
      ['N','S','E','W'].forEach(side=>{
        const w = new THREE.Mesh(wallGeo, wallMat);
        w.castShadow = w.receiveShadow = true;
        if(side==='N'){ w.position.set(0,1,-sandboxSize/2); }
        if(side==='S'){ w.position.set(0,1, sandboxSize/2); }
        if(side==='E'){ w.rotation.y=Math.PI/2; w.position.set( sandboxSize/2,1,0); }
        if(side==='W'){ w.rotation.y=Math.PI/2; w.position.set(-sandboxSize/2,1,0); }
        scene.add(w);
      });

      /* Decorations */
      addBench( 8, -5); addBench( 8, 5);
      addBench(-8,  8); addBench(-5, -8);
      addTree( 7, 7); addTree( 7, -9);
      addTree(-9, -4); addTree(-4, 9);
      
      // Initialize player first, then crowd
      createPlayer();
      spawnNewGame();
      
      document.getElementById('resetBtn').addEventListener('click', spawnNewGame);
      window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
      window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
    }
    
    function createPlayer(){
        const playerMesh = createPerson(playerShirtColor);
        playerMesh.position.set(0,0,5);
        scene.add(playerMesh);
        player = {
            mesh: playerMesh,
            speed: 4,
            velocity: new THREE.Vector3()
        };
    }
    
    function spawnNewGame() {
      // Reset score and game state
      score.caught = 0;
      score.total = 10 + Math.floor(Math.random()*10);
      gameActive = true;
      winMsgEl.style.display = 'none';

      // Clear existing crowd
      crowd.forEach(agent => scene.remove(agent.mesh));
      crowd.length = 0;
      
      // Spawn new crowd
      for(let i = 0; i < score.total; i++){
        const personMesh = createPerson();
        personMesh.position.set(
          (Math.random()-0.5)*(sandboxSize-4),
          0,
          (Math.random()-0.5)*(sandboxSize-4)
        );
        scene.add(personMesh);
        crowd.push({
          mesh: personMesh,
          speed: 0.8 + Math.random()*0.6,
          dir: new THREE.Vector3(Math.random()-0.5,0,Math.random()-0.5).normalize(),
          nextAction: Math.random()*5,
          paused: false,
          idleTime: 0,
          isCaught: false
        });
      }
      
      // Reset player position
      player.mesh.position.set(0, 0, (sandboxSize/2) - 2);
      
      updateScoreboard();
    }
    
    function updateScoreboard() {
        scoreEl.textContent = `Caught: ${score.caught} / ${score.total}`;
        if(score.caught === score.total) {
            gameActive = false;
            winMsgEl.style.display = 'block';
        }
    }

    function createPerson(shirtColor) {
      const group = new THREE.Group();
      const skin = new THREE.Color().setHSL(Math.random(),0.6,0.55);
      const shirt = shirtColor || new THREE.Color().setHSL(Math.random(),0.8,0.6);
      const pants = new THREE.Color().setHSL(Math.random(),0.7,0.35);

      const body = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.25,1,4,8),
        new THREE.MeshStandardMaterial({ color: shirt })
      );
      body.name = "body"; // Give it a name to find it later
      body.position.y=0.9; body.castShadow=true;
      group.add(body);

      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.25,16,16),
        new THREE.MeshStandardMaterial({ color: skin })
      );
      head.position.y=1.7; head.castShadow=true;
      group.add(head);

      const legGeo = new THREE.CapsuleGeometry(0.1,0.7,4,8);
      const legL = new THREE.Mesh(legGeo, new THREE.MeshStandardMaterial({ color: pants }));
      legL.position.set(0.15,0.35,0); legL.castShadow=true; group.add(legL);
      const legR = legL.clone(); legR.position.x=-0.15; group.add(legR);
      
      return group;
    }

    function updatePlayer(delta) {
        if (!gameActive) {
            player.velocity.set(0,0,0);
            return;
        };

        const moveDirection = new THREE.Vector3();
        
        // Get camera-relative forward and right directions
        const cameraForward = new THREE.Vector3();
        camera.getWorldDirection(cameraForward);
        cameraForward.y = 0;
        cameraForward.normalize();
        const cameraRight = new THREE.Vector3().crossVectors(camera.up, cameraForward).negate();

        if (keys.w) moveDirection.add(cameraForward);
        if (keys.s) moveDirection.sub(cameraForward);
        if (keys.a) moveDirection.add(cameraRight);
        if (keys.d) moveDirection.sub(cameraRight);
        
        if (moveDirection.lengthSq() > 0) {
            moveDirection.normalize();
            player.mesh.lookAt(player.mesh.position.clone().add(moveDirection));
        }

        player.velocity.copy(moveDirection).multiplyScalar(player.speed);
        player.mesh.position.addScaledVector(player.velocity, delta);

        // Player wall collision
        const margin = 1;
        player.mesh.position.x = Math.max(-sandboxSize/2 + margin, Math.min(sandboxSize/2 - margin, player.mesh.position.x));
        player.mesh.position.z = Math.max(-sandboxSize/2 + margin, Math.min(sandboxSize/2 - margin, player.mesh.position.z));
        
        // --- Tagging Gameplay ---
        const tagRadius = 1.0;
        crowd.forEach(agent => {
            if (!agent.isCaught && player.mesh.position.distanceTo(agent.mesh.position) < tagRadius) {
                agent.isCaught = true;
                agent.paused = true;
                const body = agent.mesh.getObjectByName("body");
                if (body) body.material.color.copy(playerShirtColor);
                score.caught++;
                updateScoreboard();
            }
        });
    }

    function updateCrowd(delta) {
      const avoidanceRadius = 1.2;
      const slowDown = 0.02;

      crowd.forEach(agent=>{
        if (agent.isCaught) return; // Stop if caught by player

        if(agent.paused){
          agent.idleTime -= delta;
          if(agent.idleTime <= 0){ agent.paused=false; agent.dir=new THREE.Vector3(Math.random()-0.5,0,Math.random()-0.5).normalize(); }
          return;
        }

        agent.nextAction -= delta;
        if(agent.nextAction <= 0){
          agent.paused=true;
          agent.idleTime = 1 + Math.random()*2;
          agent.nextAction = 3 + Math.random()*5;
          return;
        }

        let avoidance = new THREE.Vector3();
        
        // Avoid other agents
        crowd.forEach(other=>{
          if(other===agent) return;
          const diff = new THREE.Vector3().subVectors(agent.mesh.position,other.mesh.position);
          if(diff.lengthSq() < avoidanceRadius*avoidanceRadius) avoidance.add(diff.normalize());
        });
        
        // Avoid player
        const diffToPlayer = new THREE.Vector3().subVectors(agent.mesh.position, player.mesh.position);
        if(diffToPlayer.lengthSq() < (avoidanceRadius * 2)**2) avoidance.add(diffToPlayer.normalize());


        const margin = 1;
        const pos = agent.mesh.position;
        if(pos.x > sandboxSize/2-margin) avoidance.x -=1;
        if(pos.x < -sandboxSize/2+margin) avoidance.x +=1;
        if(pos.z > sandboxSize/2-margin) avoidance.z -=1;
        if(pos.z < -sandboxSize/2+margin) avoidance.z +=1;

        if(avoidance.lengthSq() > 0) agent.dir.lerp(avoidance.normalize(),0.1);
        else agent.dir.lerp(new THREE.Vector3(Math.random()-0.5,0,Math.random()-0.5).normalize(),slowDown);
        agent.dir.normalize();

        agent.mesh.position.addScaledVector(agent.dir,agent.speed*delta);
        agent.mesh.lookAt(agent.mesh.position.clone().add(agent.dir));
      });
    }

    function addBench(x,z){ /* ... unchanged ... */
      const seat = new THREE.Mesh( new THREE.BoxGeometry(2.5,0.1,0.6), new THREE.MeshStandardMaterial({ color: 0x663300 }) );
      seat.position.set(x,0.3,z); seat.castShadow=seat.receiveShadow=true; scene.add(seat);
      const back = seat.clone(); back.position.y=0.7; back.scale.y=4; back.rotation.x=-Math.PI/12; scene.add(back);
    }
    function addTree(x,z){ /* ... unchanged ... */
      const trunk = new THREE.Mesh( new THREE.CylinderGeometry(0.2,0.3,2,8), new THREE.MeshStandardMaterial({ color: 0x663300 }) );
      trunk.position.set(x,1,z); trunk.castShadow=trunk.receiveShadow=true; scene.add(trunk);
      const foliage = new THREE.Mesh( new THREE.SphereGeometry(1.2,12,12), new THREE.MeshStandardMaterial({ color: 0x228833 }) );
      foliage.position.set(x,3,z); foliage.castShadow=foliage.receiveShadow=true; scene.add(foliage);
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      
      updatePlayer(delta);
      updateCrowd(delta);

      // Make camera smoothly follow the player
      if (player) controls.target.lerp(player.mesh.position, 0.1);

      controls.update();
      renderer.render(scene,camera);
    }

    window.addEventListener('resize',()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
    });
  </script>
</body>
</html>