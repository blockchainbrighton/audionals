<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Multi-Channel 64-Step Sequencer (Multi-Sequence)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg-main:#1a1c20;--bg-surface:#25282e;--bg-inset:#111214;
      --fg-main:#e1e3e8;--fg-muted:#8c919c;--border-color:#363a42;
      --primary-color:#5d87ff;--primary-color-light:#83a3ff;--primary-color-dark:#4d75e6;
      --cell-on-color:#5d87ff;--cell-note-color:#2ecf94;--cell-playhead-outline:#ffab40;
      --danger-color:#ff5d5d;--danger-color-dark:#e64d4d;
      --font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      --shadow-sm:0 2px 4px rgba(0,0,0,.1)
    }
    *,*::before,*::after{box-sizing:border-box}
    html,body{margin:0;background:var(--bg-main);color:var(--fg-main);font:14px/1.4 var(--font-family);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
    .container{max-width:1300px;margin:0 auto;padding:1.5rem;display:flex;flex-direction:column;gap:1.5rem}
    header{display:flex;flex-wrap:wrap;gap:1rem;align-items:center;justify-content:space-between;padding-bottom:1.25rem;border-bottom:1px solid var(--border-color)}
    .title{margin:0;font-size:1.25rem;font-weight:600}
    .panel{background:var(--bg-surface);border-radius:12px;border:1px solid var(--border-color);padding:1rem;box-shadow:var(--shadow-sm)}
    .panel-title{font-weight:600;margin:0 0 .75rem;border-bottom:1px solid var(--border-color);padding-bottom:.6rem;font-size:1rem}
    .row{display:flex;gap:1rem;align-items:center;padding:.4rem 0}
    .label{font-weight:500;color:var(--fg-muted);text-align:right;width:90px;flex-shrink:0}
    .controls{display:flex;flex-wrap:wrap;gap:.75rem;align-items:center;width:100%}
    button,.button-style{padding:8px 14px;border:1px solid var(--border-color);border-radius:8px;background:var(--bg-surface);color:var(--fg-main);font-weight:500;cursor:pointer;transition:background-color .2s,border-color .2s,transform .1s;box-shadow:0 1px 2px rgba(0,0,0,.1)}
    button:hover,.button-style:hover{background:#31343a;border-color:#4a4e57}
    button:active,.button-style:active{transform:translateY(1px)}
    button.danger{background:var(--danger-color);border-color:var(--danger-color-dark);color:#fff}
    button.danger:hover{background:#ff7a7a}
    button.active{outline:2px solid var(--primary-color);outline-offset:1px}
    #play{background:var(--primary-color);border-color:var(--primary-color-dark);color:#fff}
    #play:hover{background:var(--primary-color-light);border-color:var(--primary-color)}
    #stop{background:#363a42;border-color:#4a4e57}
    #stop:hover{background:#4a4e57}
    input[type="number"],input[type="text"]{padding:8px 12px;border:1px solid var(--border-color);border-radius:8px;background:var(--bg-inset);color:var(--fg-main);font-family:var(--font-family)}
    input[type="number"]:focus,input[type="text"]:focus{outline:2px solid var(--primary-color);outline-offset:2px;border-color:var(--primary-color)}
    input[type="file"]{display:none}
    .file-label{display:inline-block;padding:8px 14px;background:#363a42;border-radius:8px;cursor:pointer}
    .pill-group{display:flex;align-items:center;gap:.5rem}
    .pill{display:inline-flex;gap:.5rem;align-items:center;padding:8px 12px;border:1px solid var(--border-color);border-radius:999px;background:var(--bg-surface);font-size:13px}
    .pill input[type="checkbox"]{accent-color:var(--primary-color)}
    .grid-container{display:flex;flex-direction:column;gap:1rem;padding:0 .5rem}
    .grid{display:grid;grid-template-columns:repeat(64,1fr);gap:3px}
    .cell{aspect-ratio:1.5/1;border:1px solid var(--border-color);background:var(--bg-surface);border-radius:3px;cursor:pointer;position:relative;transition:background-color .1s,border-color .1s}
    .cell:hover{background:#31343a}
    .cell.on{background:var(--cell-on-color);border-color:var(--primary-color-light)}
    .cell.note{background:var(--cell-note-color);border-color:#57d9a9}
    .cell.playhead::after{content:"";position:absolute;inset:-3px;border:2px solid var(--cell-playhead-outline);border-radius:5px;pointer-events:none;animation:pulse 1s infinite alternate}
    @keyframes pulse{from{opacity:.7}to{opacity:1}}
    .barMarks{display:grid;grid-template-columns:120px repeat(16,1fr);margin-bottom:.5rem;padding:0 .5rem}
    .barMarks div{text-align:left;font-size:11px;color:var(--fg-muted);border-left:1px solid var(--border-color)}
    .barMarks div:first-child{border-left:none}
    .channel-strip{display:flex;gap:1rem;align-items:center;margin-bottom:1rem;padding-bottom:1rem;border-bottom:1px solid var(--border-color)}
    .channel-strip:last-child{border-bottom:none;margin-bottom:0}
    .channel-info{display:flex;flex-direction:column;gap:.5rem;width:105px;flex-shrink:0}
    .channel-grid-wrapper{flex-grow:1}
    #keyboard{--white-count:14;--white-w:calc(100%/var(--white-count));display:flex;width:100%;padding:1rem;background:var(--bg-inset);border-radius:8px;box-shadow:inset 0 2px 8px rgba(0,0,0,.3);margin-top:1rem;position:relative;overflow:hidden}
    .key{position:relative;border:1px solid #222;border-radius:5px;cursor:pointer;display:flex;align-items:flex-end;justify-content:center;padding-bottom:8px;font-size:11px;color:#333;user-select:none;box-shadow:inset 0 0 5px rgba(255,255,255,.1),0 2px 3px rgba(0,0,0,.4);transition:background-color .08s}
    .key.white{height:120px;width:var(--white-w);background:linear-gradient(to bottom,#f9f9f9,#d1d1d1);z-index:1}
    .key.black{height:75px;width:calc(var(--white-w)*.6);background:linear-gradient(to bottom,#444,#111);color:#eee;z-index:2;margin:0 calc(var(--white-w)*-.3);box-shadow:inset 0 -2px 5px rgba(255,255,255,.2),0 3px 5px rgba(0,0,0,.6)}
    .key.active{background:var(--primary-color-light)!important;border-color:var(--primary-color-dark);transform:scale(.985)}
    #status{padding:8px 12px;color:var(--fg-muted);font-size:13px;min-height:2em}
    .hint{font-size:12px;color:var(--fg-muted);opacity:.9;text-align:right}
    .dropzone{border:1px dashed var(--border-color);border-radius:10px;padding:.75rem;opacity:.85}
    .dropzone.drag{background:rgba(131,163,255,.08);border-color:var(--primary-color)}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1 class="title">Multi-Channel 64-Step Sequencer</h1>
      <div class="controls">
        <button id="play">▶︎ Play</button>
        <button id="stop">■ Stop</button>
        <div class="pill-group">
          <label class="pill"><input type="checkbox" id="record"> Record</label>
          <label class="pill">BPM <input id="bpm" type="number" value="120" min="40" max="240" style="width:64px;margin-left:6px"></label>
        </div>
      </div>
    </header>

    <!-- Sequences Panel -->
    <div class="panel">
      <h2 class="panel-title">Sequences</h2>
      <div class="row">
        <div class="label">Control</div>
        <div class="controls">
          <button id="addSequence">Add Sequence</button>
          <label class="pill">
            <input type="checkbox" id="seqChain" checked>
            Continuous play
          </label>
          <label class="pill">
            Quantize
            <select id="seqQuantize" style="margin-left:6px">
              <option value="bar" selected>bar</option>
              <option value="step">step</option>
            </select>
          </label>
        </div>
      </div>
      <div class="row">
        <div class="label">Sequences</div>
        <div class="controls" id="sequencesBar" style="flex-wrap:wrap;gap:.5rem"></div>
      </div>
    </div>

    <!-- Channels Panel -->
    <div class="panel">
      <h2 class="panel-title">Channels</h2>
      <div class="controls" style="padding-bottom:1rem">
        <button id="addSampler">Add Sampler</button>
        <button id="addSynth">Add Synth</button>
      </div>
      <div class="barMarks" aria-hidden="true"></div>
      <div id="channelsContainer" class="grid-container"></div>
    </div>

    <!-- Keyboard Panel -->
    <div class="panel">
      <h2 class="panel-title">Keyboard & MIDI</h2>
      <div class="hint" style="text-align:left;margin:-.5rem 0 1rem">MIDI: Connect a USB keyboard or use the on-screen keyboard. Click Play/Load to unlock audio.</div>
      <div id="keyboard"></div>
    </div>

    <!-- Session Panel -->
    <div class="panel dropzone" id="sessionPanel">
      <h2 class="panel-title">Session (Save / Load)</h2>
      <div class="row">
        <div class="label">Snapshot</div>
        <div class="controls">
          <button id="saveState">Save JSON</button>
          <label for="loadStateFile" class="button-style">Load JSON</label>
          <input id="loadStateFile" type="file" accept="application/json">
          <button id="copyState">Copy JSON</button>
          <button id="newSession">New Session</button>
        </div>
      </div>
      <div class="hint" style="text-align:left">Tip: You can also drag a previously saved JSON file onto this box to load it.</div>
    </div>

    <div id="status">Ready.</div>
  </div>

<script>
(() => {
  'use strict';

  /*** Helpers ***/
  const $  = sel => document.querySelector(sel);
  const el = (t,cls) => { const n = document.createElement(t); if (cls) n.className = cls; return n; };
  const clamp = (v,min,max)=> v<min?min:(v>max?max:v);
  const log = m => { $('#status').textContent = m; };

  /*** Constants & Central State ***/
  const STEPS = 64;
  const BARS  = 16;
  const LOOKAHEAD = 0.05;
  const STEP_DIV = 4;

  // Channels
  let channels = [];
  let channelCounter = 0;

  // Sequences
  let sequences = [];             // [{id, name}]
  let activeSequence = 0;
  let pendingSequence = null;     // queued seq index for quantized switching

  // UI refs
  const playBtn = $('#play'), stopBtn = $('#stop'), bpmEl = $('#bpm'), recEl = $('#record');
  const addSamplerBtn = $('#addSampler'), addSynthBtn = $('#addSynth');
  const channelsContainer = $('#channelsContainer');
  const saveStateBtn = $('#saveState'), loadStateFile = $('#loadStateFile');
  const copyStateBtn = $('#copyState'), newSessionBtn = $('#newSession');
  const sessionPanel = $('#sessionPanel');
  const addSequenceBtn = $('#addSequence');
  const sequencesBarEl = $('#sequencesBar');
  const seqChainEl = $('#seqChain');
  const seqQuantizeEl = $('#seqQuantize');

  /*** Audio ***/
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  let isPlaying = false, currentStep = 0, nextNoteTime = 0, rafId = 0;
  let bpm = +bpmEl.value || 120;

  const midiToHz = n => 440 * Math.pow(2, (n - 69) / 12);
  const stepDur = () => (60 / bpm) / STEP_DIV;

  function demoSynth(context){
    const master = context.createGain(); master.gain.value=0.9; master.connect(context.destination);
    return {
      noteOn(note,t,dur=0.22,vel=1){
        const o=context.createOscillator(),v=context.createGain(),l=context.createBiquadFilter();
        const f=midiToHz(note); o.type='sawtooth';o.frequency.setValueAtTime(f,t);l.type='lowpass';l.frequency.setValueAtTime(Math.min(12000,f*3),t);
        v.gain.setValueAtTime(0,t);const a=.005,d=.06,s=.2,r=.1,p=Math.max(.05,vel);v.gain.linearRampToValueAtTime(p,t+a);
        v.gain.linearRampToValueAtTime(s*p,t+a+d);const h=Math.max(dur,a+d);v.gain.setValueAtTime(s*p,t+h);v.gain.linearRampToValueAtTime(0,t+h+r);
        o.connect(l).connect(v).connect(master);o.start(t);o.stop(t+h+r+.01);
      }
    }
  }

  /*** Sequence Helpers ***/
  function makePatternForChannel(ch){
    return (ch.type === 'sampler') ? new Uint8Array(STEPS) : new Int16Array(STEPS).fill(-1);
  }
  function ensurePatternIndexForChannel(ch, idx){
    while (ch.patterns.length <= idx) ch.patterns.push(makePatternForChannel(ch));
  }
  function renderSequencesBar(){
    sequencesBarEl.innerHTML = '';
    const frag = document.createDocumentFragment();
    sequences.forEach((seq, i) => {
      const b = el('button');
      b.textContent = seq.name;
      if (i === activeSequence) b.classList.add('active');
      b.addEventListener('click', () => setActiveSequence(i, {quantized:true}));
      frag.appendChild(b);
    });
    sequencesBarEl.appendChild(frag);
  }
  function addSequence(){
    const id = Date.now() + Math.floor(Math.random()*1000);
    const name = `Seq ${sequences.length + 1}`;
    sequences.push({ id, name });
    const newIdx = sequences.length - 1;
    channels.forEach(ch => ensurePatternIndexForChannel(ch, newIdx));
    renderSequencesBar();
    if (sequences.length === 1) applySequenceImmediately(0);
  }
  function applySequenceImmediately(idx){
    activeSequence = idx;
    channels.forEach(ch => {
      ensurePatternIndexForChannel(ch, activeSequence);
      ch.steps = ch.patterns[activeSequence];
      renderChannel(ch);
    });
    renderSequencesBar();
  }
  function setActiveSequence(idx, {quantized = true} = {}){
    const maxIdx = sequences.length - 1;
    idx = clamp(idx, 0, maxIdx);
    if (quantized && isPlaying) {
      pendingSequence = idx; // will switch at boundary per quantize mode
    } else {
      applySequenceImmediately(idx);
    }
  }

  /*** Channel Management ***/
  function addChannel(type, initialData = {}){
    const id = initialData.id || Date.now() + (channelCounter++);
    const name = initialData.name || `${type} ${channelCounter}`;

    const channel = {
      id, type, name,
      steps: null,                 // pointer to active pattern
      patterns: [],                // array of 64-step patterns
      ui: { cells: new Array(STEPS) },
      sampleBuf: null,
      sampleSource: { type: 'none' },
      synth: type === 'synth' ? demoSynth(ctx) : null,
      synthModuleUrl: null,
    };

    // Ensure at least one sequence exists before building patterns
    const needed = Math.max(1, sequences.length || 1);
    for (let i = 0; i < needed; i++) channel.patterns.push(makePatternForChannel(channel));

    // Load full patterns if provided (modern snapshot)
    if (Array.isArray(initialData.patterns) && initialData.patterns.length) {
      while (channel.patterns.length < Math.max(initialData.patterns.length, sequences.length || 1)) {
        channel.patterns.push(makePatternForChannel(channel));
      }
      initialData.patterns.forEach((pArr, i)=> channel.patterns[i].set(pArr.slice(0, STEPS)));
    } else if (initialData.steps) {
      // Legacy snapshot: copy into first pattern
      channel.patterns[0].set(initialData.steps.slice(0, STEPS));
    }

    // Point visible steps to active sequence
    channel.steps = channel.patterns[activeSequence];

    channels.push(channel);
    buildChannelUI(channel);
    renderChannel(channel);

    // Async resource recovery from snapshot
    if(initialData.synthModule?.url) {
      const input = channel.ui.strip.querySelector('.synth-url-input');
      if (input) input.value = initialData.synthModule.url;
      loadSynthFromUrl(channel, initialData.synthModule.url);
    }
    if(initialData.sample) {
      loadSampleFromSource(channel, initialData.sample);
    }
  }

  function removeChannel(id) {
    const idx = channels.findIndex(c => c.id === id);
    if (idx > -1) {
      const channel = channels[idx];
      channel.ui.strip.remove();
      channels.splice(idx, 1);
      log('Channel removed.');
    }
  }

  function buildChannelUI(channel) {
    const strip = el('div', 'channel-strip'); strip.dataset.id = channel.id;

    const info = el('div', 'channel-info');
    const nameInput = el('input'); nameInput.type = 'text'; nameInput.value = channel.name; nameInput.title = 'Click to rename channel';
    nameInput.addEventListener('change', () => { channel.name = nameInput.value; });
    const removeBtn = el('button', 'danger'); removeBtn.textContent = 'Delete';
    removeBtn.addEventListener('click', () => removeChannel(channel.id));
    info.append(nameInput, removeBtn);

    const gridWrapper = el('div', 'channel-grid-wrapper');
    const controls = el('div', 'controls'); controls.style.padding = '0 0 0.5rem 0';

    if (channel.type === 'sampler') {
      const urlInput = el('input'); urlInput.type='text'; urlInput.placeholder='Sample URL'; urlInput.style.flex='1';
      const fileInputId = `sampleFile_${channel.id}`;
      const fileLabel = el('label', 'button-style file-label'); fileLabel.htmlFor=fileInputId; fileLabel.textContent='Choose File';
      const fileInput = el('input'); fileInput.id=fileInputId; fileInput.type='file'; fileInput.accept='audio/*';
      const loadBtn = el('button'); loadBtn.textContent='Load';
      controls.append(urlInput, fileLabel, fileInput, loadBtn);
      loadBtn.addEventListener('click', () => loadSampleFromUI(channel, fileInput, urlInput));
    } else {
      const urlInput = el('input','synth-url-input'); urlInput.type='text'; urlInput.placeholder='Headless synth module URL'; urlInput.style.flex='1';
      const loadBtn = el('button'); loadBtn.textContent='Load Synth';
      controls.append(urlInput, loadBtn);
      loadBtn.addEventListener('click', () => loadSynthFromUrl(channel, urlInput.value.trim()));
    }

    const grid = el('div', 'grid'); grid.role='grid'; grid.ariaLabel = `${channel.name} steps`;
    const frag = document.createDocumentFragment();
    for (let i=0; i<STEPS; i++) {
      const c = el('div', 'cell'); c.dataset.idx = i;
      frag.appendChild(c);
      channel.ui.cells[i] = c;
    }
    grid.appendChild(frag);
    grid.addEventListener('click', (e) => {
      const t = e.target; if (!t.classList.contains('cell')) return;
      const i = +t.dataset.idx;
      if (channel.type === 'sampler') {
        channel.steps[i] ^= 1;
      } else {
        if (channel.steps[i] !== -1) channel.steps[i] = -1; // clearing note (record to add)
      }
      renderStep(channel, i);
    });

    gridWrapper.append(controls, grid);
    strip.append(info, gridWrapper);
    channel.ui.strip = strip;
    channelsContainer.appendChild(strip);
  }

  addSamplerBtn.addEventListener('click', () => addChannel('sampler'));
  addSynthBtn.addEventListener('click', () => addChannel('synth'));

  /*** Audio Loading ***/
  async function loadSynthFromUrl(channel, url){
    await ctx.resume();
    if (!url){ channel.synth = demoSynth(ctx); channel.synthModuleUrl = null; log(`[${channel.name}] Using built-in synth.`); return; }
    try{
      const mod = await import(/* @vite-ignore */ url);
      const factory = mod.default || mod.createSynth || mod.synth || mod;
      const s = typeof factory === 'function' ? factory(ctx) : null;
      if (s && typeof s.noteOn === 'function'){ channel.synth = s; channel.synthModuleUrl = url; log(`[${channel.name}] Loaded synth module.`); }
      else { channel.synth = demoSynth(ctx); channel.synthModuleUrl = null; log(`[${channel.name}] Module invalid. Using demo synth.`); }
    }catch(e){ channel.synth = demoSynth(ctx); channel.synthModuleUrl = null; log(`[${channel.name}] Failed to load synth. Using demo synth.`); }
  }

  async function decodeSampleFromArrayBuffer(channel, ab) {
    try { channel.sampleBuf = await ctx.decodeAudioData(ab); return true; } catch(e) { return false; }
  }
  async function loadSampleFromUI(channel, fileInput, urlInput) {
    await ctx.resume();
    const f = fileInput.files[0];
    const url = urlInput.value.trim();
    try {
      if(f) {
        const dataUrl = await new Promise((res,rej)=>{ const r=new FileReader(); r.onerror=rej; r.onload=()=>res(r.result); r.readAsDataURL(f); });
        const ab = await f.arrayBuffer();
        if (!(await decodeSampleFromArrayBuffer(channel, ab))) throw new Error('decode failed');
        channel.sampleSource = { type: 'data', name: f.name, mime: f.type || 'audio/wav', dataUrl };
        log(`[${channel.name}] Sample loaded: ${f.name}`);
      } else if (url) {
        const res = await fetch(url);
        const ab = await res.arrayBuffer();
        if (!(await decodeSampleFromArrayBuffer(channel, ab))) throw new Error('decode failed');
        channel.sampleSource = { type: 'url', url };
        log(`[${channel.name}] Sample loaded: ${url}`);
      } else { log('Choose a file or paste a URL.'); }
    } catch(e) { log(`[${channel.name}] Could not load sample.`); }
  }
  async function loadSampleFromSource(channel, source) {
    channel.sampleBuf = null;
    channel.sampleSource = { type: 'none' };
    try {
      if (source.type === 'url' && source.url) {
        const res = await fetch(source.url);
        const ab = await res.arrayBuffer();
        if (await decodeSampleFromArrayBuffer(channel, ab)) {
          channel.sampleSource = { type: 'url', url: source.url };
        } else { throw new Error('decode fail'); }
      } else if (source.type === 'data' && source.dataUrl) {
        const resp = await fetch(source.dataUrl);
        const ab = await resp.arrayBuffer();
        if (await decodeSampleFromArrayBuffer(channel, ab)) {
          channel.sampleSource = { type: 'data', name: source.name||'sample', mime: source.mime||'audio/wav', dataUrl: source.dataUrl };
        } else { throw new Error('decode fail'); }
      }
    } catch (e) {
      log(`[${channel.name}] Failed to load saved sample.`);
    }
  }

  /*** Bar marks ***/
  (function buildBarMarks(){
    const bm = document.querySelector('.barMarks');
    const frag = document.createDocumentFragment();
    frag.appendChild(el('div','spacer'));
    for (let i=1;i<=BARS;i++){ const d = el('div'); d.textContent = i; frag.appendChild(d); }
    bm.appendChild(frag);
  })();

  /*** Render ***/
  function renderChannel(channel){ for (let i=0; i<STEPS; i++) renderStep(channel, i); }
  function renderStep(channel, i){
    const cell = channel.ui.cells[i];
    if (channel.type === 'sampler') cell.classList.toggle('on', !!channel.steps[i]);
    else cell.classList.toggle('note', channel.steps[i] !== -1);
  }
  function updatePlayhead(ph){
    channels.forEach(ch => {
      for(let i=0; i<STEPS; i++) {
        const on = (i === ph);
        if(ch.ui.cells[i]._ph !== on) {
          ch.ui.cells[i]._ph = on;
          ch.ui.cells[i].classList.toggle('playhead', on);
        }
      }
    });
  }

  /*** Scheduling ***/
  function scheduleStep(step, time){
    channels.forEach(ch => {
      if (ch.type === 'sampler') {
        if (ch.steps[step] && ch.sampleBuf) {
          const src = ctx.createBufferSource(); src.buffer = ch.sampleBuf; src.connect(ctx.destination); src.start(time);
        }
      } else {
        const note = ch.steps[step];
        if (note !== -1) ch.synth.noteOn(note, time, stepDur() * 0.95, 0.9);
      }
    });
  }
  function tick(){
    if (!isPlaying) return;
    const ahead = ctx.currentTime + LOOKAHEAD;
    while (nextNoteTime < ahead){
      scheduleStep(currentStep, nextNoteTime);
      nextNoteTime += stepDur();
      currentStep = (currentStep + 1) % STEPS;

      // Quantized sequence switch (bar or step)
      if (pendingSequence !== null) {
        const mode = seqQuantizeEl.value; // 'bar' or 'step'
        const atBarBoundary = (currentStep === 0);
        if (mode === 'step' || (mode === 'bar' && atBarBoundary)) {
          applySequenceImmediately(pendingSequence);
          pendingSequence = null;
        }
      }

      // Continuous play: chain to next sequence at bar boundary
      if (seqChainEl.checked && currentStep === 0 && sequences.length > 1) {
        const nextSeq = (activeSequence + 1) % sequences.length;
        applySequenceImmediately(nextSeq);
      }
    }
    const ph = (currentStep + STEPS - 1) % STEPS;
    updatePlayhead(ph);
    rafId = requestAnimationFrame(tick);
  }

  /*** Transport ***/
  function start(){
    if (isPlaying) return;
    ctx.resume(); isPlaying = true; currentStep = 0;
    nextNoteTime = ctx.currentTime + 0.06;
    log('Playing.'); playBtn.textContent = '❚❚ Pause';
    rafId = requestAnimationFrame(tick);
  }
  function stop(){
    if (!isPlaying) return;
    isPlaying = false; cancelAnimationFrame(rafId);
    updatePlayhead(-1);
    log('Stopped.'); playBtn.textContent = '▶︎ Play';
  }
  playBtn.addEventListener('click', ()=> isPlaying ? stop() : start());
  stopBtn.addEventListener('click', stop);
  bpmEl.addEventListener('input', e=>{ bpm = clamp(+e.target.value||120, 40, 240); e.target.value = bpm; });
  window.addEventListener('keydown', (e)=>{ if (e.code==='Space' && e.target.tagName !== 'INPUT'){ e.preventDefault(); isPlaying ? stop() : start(); }});

  /*** MIDI & On-Screen Keyboard ***/
  function triggerNote(note, vel){
    const t = ctx.currentTime;
    let notePlayed = false;
    channels.forEach(ch => {
      if (ch.type === 'synth') {
        ch.synth.noteOn(note, t, 0.25, vel);
        notePlayed = true;
        if (recEl.checked && isPlaying){
          const idx = (currentStep + STEPS - 1) % STEPS;
          ch.steps[idx] = note;
          renderStep(ch, idx);
        }
      }
    });
    if (!notePlayed) log('Add a synth channel to play notes.');
  }
  (async function initMIDI(){ /* MIDI hookup can be added here if needed */ })();
  (function createKeyboard(){
    const kbd=$('#keyboard');let w=0;for(let i=36;i<=84;i++)if(!([1,3,6,8,10].includes(i%12)))w++;kbd.style.setProperty('--white-count',String(w));
    const f=document.createDocumentFragment();
    for(let n=36;n<=84;n++){
      const b=[1,3,6,8,10].includes(n%12);
      const k=el('div','key '+(b?'black':'white')); k.dataset.note=n;
      if(!b&&(n%12)===0){k.textContent=`C${Math.floor(n/12)-1}`;}
      f.appendChild(k);
    }
    kbd.appendChild(f);
    const p=(e,a)=>{const t=e.target;if(!t.classList.contains('key'))return;e.preventDefault();ctx.resume();t.classList.toggle('active',a);if(a){t.setPointerCapture?.(e.pointerId);triggerNote(+t.dataset.note,1);}};
    kbd.addEventListener('pointerdown',e=>p(e,true)); kbd.addEventListener('pointerup',e=>p(e,false)); kbd.addEventListener('pointerleave',e=>p(e,false));
  })();

  /*** Save / Load ***/
  function makeSnapshot(){
    const plainChannels = channels.map(ch => ({
      id: ch.id,
      type: ch.type,
      name: ch.name,
      patterns: ch.patterns.map(p => Array.from(p)),                // all sequences
      sample: ch.type === 'sampler' ? ch.sampleSource : undefined,
      synthModule: ch.type === 'synth' ? { url: ch.synthModuleUrl } : undefined,
    }));
    return {
      version: 3,
      app: 'Multi-Channel Sequencer',
      savedAt: new Date().toISOString(),
      bpm,
      sequences,        // [{id,name}]
      activeSequence,
      channels: plainChannels,
    };
  }

  async function applySnapshot(snap){
    try{
      newSession(false); await new Promise(r=>setTimeout(r,50));

      if (typeof snap.bpm === 'number'){ bpm = clamp(snap.bpm, 40, 240); bpmEl.value = bpm; }

      // Restore sequences or create a default one
      sequences = Array.isArray(snap.sequences) && snap.sequences.length
        ? snap.sequences.map(s => ({ id: s.id, name: s.name || 'Seq' }))
        : [{ id: Date.now(), name: 'Seq 1' }];
      activeSequence = clamp(snap.activeSequence ?? 0, 0, sequences.length - 1);
      renderSequencesBar();

      if (Array.isArray(snap.channels)) {
        for(const chData of snap.channels) {
          // Back-compat: if no patterns, derive from steps
          if (!Array.isArray(chData.patterns) || !chData.patterns.length) {
            chData.patterns = [Array.isArray(chData.steps) ? chData.steps : []];
          }
          addChannel(chData.type, chData);
          const ch = channels[channels.length - 1];
          while (ch.patterns.length < Math.max(chData.patterns.length, sequences.length)) {
            ch.patterns.push(makePatternForChannel(ch));
          }
          chData.patterns.forEach((pArr, i) => ch.patterns[i].set(pArr.slice(0, STEPS)));
          ch.steps = ch.patterns[activeSequence];
          renderChannel(ch);

          if(chData.synthModule?.url){ const input = ch.ui.strip.querySelector('.synth-url-input'); if(input) input.value = chData.synthModule.url; loadSynthFromUrl(ch, chData.synthModule.url); }
          if(chData.sample) { loadSampleFromSource(ch, chData.sample); }
        }
      }
      renderSequencesBar();
      log('Session loaded.');
    }catch(err){
      console.error(err);
      log('Failed to load session JSON.');
    }
  }

  function downloadJSON(obj, filename){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'});
    const a = el('a'); a.href = URL.createObjectURL(blob); a.download = filename;
    document.body.appendChild(a); a.click();
    URL.revokeObjectURL(a.href); a.remove();
  }
  async function copyJSONToClipboard(obj){
    try { await navigator.clipboard.writeText(JSON.stringify(obj, null, 2)); log('Snapshot copied.'); }
    catch { log('Clipboard copy failed.'); }
  }
  function newSession(doLog = true){
    stop();
    channels.forEach(ch => ch.ui.strip.remove());
    channels = [];
    channelCounter = 0;
    bpm = 120; bpmEl.value = 120;

    // Reset sequences to a single default
    sequences = [{ id: Date.now(), name: 'Seq 1' }];
    activeSequence = 0;
    pendingSequence = null;
    renderSequencesBar();

    if(doLog) log('New blank session.');
  }

  saveStateBtn.addEventListener('click', ()=>{ downloadJSON(makeSnapshot(), `sequencer-snapshot.json`); log('Snapshot downloaded.'); });
  copyStateBtn.addEventListener('click', ()=> copyJSONToClipboard(makeSnapshot()));
  loadStateFile.addEventListener('change', async (e)=>{
    const f=e.target.files[0]; if(!f)return;
    try{ const snap = JSON.parse(await f.text()); await applySnapshot(snap); }
    catch{ log('Invalid JSON file.'); } finally{ e.target.value=''; }
  });
  newSessionBtn.addEventListener('click', () => newSession(true));

  // Drag & drop loading
  ;(() => {
    const dz = sessionPanel; const on=()=>dz.classList.add('drag'),off=()=>dz.classList.remove('drag');
    ['dragenter','dragover'].forEach(ev=>dz.addEventListener(ev,e=>{e.preventDefault();on();}));
    ['dragleave','drop'].forEach(ev=>dz.addEventListener(ev,e=>{e.preventDefault();off();}));
    dz.addEventListener('drop', async (e)=>{
      const file = [...(e.dataTransfer?.files||[])].find(f=>f.type==='application/json'||f.name.endsWith('.json'));
      if (!file){ log('Drop a JSON snapshot file.'); return; }
      try{ const snap=JSON.parse(await file.text()); await applySnapshot(snap); }
      catch{ log('Invalid JSON on drop.'); }
    });
  })();

  /*** Boot ***/
  sequences = [{ id: Date.now(), name: 'Seq 1' }];
  renderSequencesBar();

  addChannel('sampler');
  addChannel('synth');
  applySequenceImmediately(0);

  // Wire sequence controls
  addSequenceBtn.addEventListener('click', addSequence);
})();
</script>
</body>
</html>

