<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Web3 Oscilloscope Music</title>
  <meta name="viewport" content="width=600,initial-scale=1">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      color: #fff;
      font-family: 'Courier New', monospace;
      overflow: hidden;
    }
    body {
      display: grid;
      place-items: center;
      gap: 1rem;
    }
    #scope {
      border-radius: 12px;
      border: 1px solid #333;
      background: #000;
      box-shadow: 0 0 30px #0008;
    }
    #controls {
      display: flex;
      gap: 1rem;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
      padding: 0.5rem;
      background: #fff1;
      border-radius: 8px;
    }
    #controls button,
    #controls select {
      padding: 0.5rem 1rem;
      border-radius: 6px;
      border: 1px solid #555;
      background: #222;
      color: #fff;
      font-size: .9rem;
      cursor: pointer;
    }
    #controls button:hover {
      background: #444;
    }
    #loader {
      font-size: .9rem;
      color: #aaa;
      min-height: 1.4rem;
      text-align: center;
      font-style: italic;
    }

    /* Sequencer UI */
    #sequencer {
      display: none;
      flex-direction: column;
      gap: 1rem;
      align-items: center;
      max-width: 600px;
      padding: 1rem 0;
    }
    .seq-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
      max-width: 100%;
    }
    .step-slot {
      width: calc(100% / var(--step-count));
      min-width: 40px;
      height: 50px;
      border-radius: 8px;
      background: #111;
      border: 2px solid #444;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-weight: bold;
      font-size: 1.2rem;
      color: #666;
      transition: all 0.2s;
      flex: 1 1 auto;
    }
    .step-slot.filled {
      background: #0a0;
      color: #0f0;
      border-color: #0f0;
    }
    .step-slot.active {
      border-color: #0af;
      background: #023;
    }
    .step-slot.recording {
      animation: pulse 1s infinite;
    }
    .step-slot.clearing {
      opacity: 0.3;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(0, 255, 255, 0.7); }
      50% { box-shadow: 0 0 0 10px rgba(0, 255, 255, 0); }
      100% { box-shadow: 0 0 0 0 rgba(0, 255, 255, 0); }
    }

    .seq-controls {
      display: flex;
      gap: 1rem;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
      padding: 0.5rem;
      background: #222;
      border-radius: 8px;
    }
    .seq-controls label {
      font-size: .9rem;
      white-space: nowrap;
    }
    .bpm-slider {
      width: 120px;
      background: #444;
      accent-color: #0af;
      border-radius: 4px;
      height: 6px;
    }
    .bpm-display {
      font-family: monospace;
      font-size: 1.1rem;
      width: 40px;
      text-align: center;
      color: #0af;
    }
  </style>
</head>
<body>
  <canvas id="scope" width="600" height="600"></canvas>
  <section id="controls">
    <button id="startBtn">Start Audio + Draw</button>
    <button id="muteBtn">Mute</button>
    <select id="shapeSelect">
      <option value="circle">Circle</option>
      <option value="square">Square</option>
      <option value="butterfly">Butterfly</option>
      <option value="lissajous">Lissajous</option>
      <option value="spiro">Spirograph</option>
      <option value="harmonograph">Harmonograph</option>
    </select>
    <button id="seqBtn">Create Sequence</button>
  </section>
  <div id="loader">Initializing...</div>

  <!-- Sequencer UI -->
  <div id="sequencer">
    <div class="seq-row" id="stepSlots"></div>
    <div class="seq-controls">
      <label>Steps: <select id="stepCount">
        <option value="4">4</option>
        <option value="8" selected>8</option>
        <option value="16">16</option>
        <option value="32">32</option>
      </select></label>
      <label>BPM: 
        <input type="range" id="tempoSlider" class="bpm-slider" min="60" max="240" value="150">
        <span id="bpmDisplay" class="bpm-display">150</span>
      </label>
      <button id="playSeqBtn">Play Sequence</button>
    </div>
  </div>

  <script type="module">
    // --- State ---
    const state = {
      isPlaying: false,
      Tone: null,
      chains: {},
      current: null,
      seed: '5677',
      contextUnlocked: false,
      recording: false,
      seqPosition: 0,
      sequence: Array(8).fill(null),
      seqInterval: null,
      stepCount: 8,
      bpm: 150,
      get stepDuration() { return 60000 / this.bpm / 4; } // 16th-note timing
    };

    const canvas = scope, ctx = canvas.getContext('2d');
    const els = ['startBtn', 'muteBtn', 'shapeSelect', 'loader', 'seqBtn', 'sequencer', 'stepSlots', 'stepCount', 'tempoSlider', 'bpmDisplay', 'playSeqBtn'];
    const [startBtn, muteBtn, shapeSel, loader, seqBtn, sequencer, stepSlots, stepCount, tempoSlider, bpmDisplay, playSeqBtn] = els.map(id => document.getElementById(id));

    const SHAPES = ['circle', 'square', 'butterfly', 'lissajous', 'spiro', 'harmonograph'];

    // --- Deterministic PRNG ---
    function mulberry32(seed) {
      let a = 0x6d2b79f5 ^ seed.length;
      for (let i = 0; i < seed.length; ++i) a = Math.imul(a ^ seed.charCodeAt(i), 2654435761);
      return () => ((a = Math.imul(a ^ a >>> 15, 1 | a)), (a >>> 16) / 0x10000);
    }

    // --- Deterministic preset generator ---
    function deterministicPreset(seed, shape) {
      const rng = mulberry32(seed + "_" + shape);
      const types = ['sine', 'triangle', 'square', 'sawtooth'];
      const notes = ['C1', 'C2', 'E2', 'G2', 'A2', 'C3', 'E3', 'G3', 'B3', 'D4', 'F#4', 'A4', 'C5'];
      const modeRoll = rng();
      let mode = 1;
      if (modeRoll < 0.18) mode = 0;
      else if (modeRoll < 0.56) mode = 1;
      else if (modeRoll < 0.85) mode = 2;
      else mode = 3;

      let lfoRate;
      if (mode === 0) lfoRate = 0.07 + rng() * 0.3;
      else if (mode === 1) lfoRate = 0.25 + rng() * 8;
      else if (mode === 2) lfoRate = 6 + rng() * 20;
      else lfoRate = 24 + rng() * 36;

      let lfoMin, lfoMax;
      if (mode === 0) {
        lfoMin = 400 + rng() * 400;
        lfoMax = 900 + rng() * 600;
      } else if (mode === 1) {
        lfoMin = 120 + rng() * 700;
        lfoMax = 1200 + rng() * 1400;
      } else {
        lfoMin = 80 + rng() * 250;
        lfoMax = 1500 + rng() * 3500;
      }

      const oscCount = mode === 3 ? 2 + (rng() > 0.7 ? 1 : 0) : 1 + (rng() > 0.6 ? 1 : 0);
      const oscs = [];
      for (let i = 0; i < oscCount; ++i) {
        oscs.push([types[(rng() * types.length) | 0], notes[(rng() * notes.length) | 0]]);
      }

      const filterBase = mode === 0 ? 700 + rng() * 500 : 300 + rng() * 2400;
      const resonance = 0.6 + rng() * 0.7;

      let env = {};
      if (mode === 0) {
        env = { attack: 0.005 + rng() * 0.03, decay: 0.04 + rng() * 0.08, sustain: 0.1 + rng() * 0.2, release: 0.03 + rng() * 0.1 };
      } else if (mode === 3) {
        env = { attack: 2 + rng() * 8, decay: 4 + rng() * 20, sustain: 0.7 + rng() * 0.2, release: 8 + rng() * 24 };
      } else {
        env = { attack: 0.03 + rng() * 0.4, decay: 0.1 + rng() * 0.7, sustain: 0.2 + rng() * 0.5, release: 0.2 + rng() * 3 };
      }

      const reverbWet = (mode === 3 ? 0.4 + rng() * 0.5 : 0.1 + rng() * 0.5);
      const reverbRoom = (mode === 3 ? 0.85 + rng() * 0.12 : 0.6 + rng() * 0.38);
      const colorSpeed = 0.06 + rng() * 0.22;
      const shapeDrift = 0.0006 + rng() * 0.0032;

      return {
        osc1: oscs[0],
        osc2: oscs[1] || null,
        filter: filterBase,
        filterQ: resonance,
        lfo: [lfoRate, lfoMin, lfoMax],
        envelope: env,
        reverb: { wet: reverbWet, roomSize: reverbRoom },
        colorSpeed,
        shapeDrift
      };
    }

    // Generate presets
    let presets = {};
    for (const k of SHAPES) presets[k] = deterministicPreset(state.seed, k);

    // --- Drawing Functions (unchanged for brevity) ---
    const drawFuncs = { // ... (same as before, unchanged) ...
      circle(data, t, pr) { const S = .8 * canvas.width / 2, c = 300; ctx.beginPath();
        for (let i = 0; i < data.length; ++i) { let a = i / data.length * 2 * Math.PI + t * .001, amp = (data[i] + 1) / 2,
          r = S * amp, x = c + Math.cos(a) * r, y = c + Math.sin(a) * r; i ? ctx.lineTo(x, y) : ctx.moveTo(x, y); }
        ctx.closePath(); ctx.stroke();
      },
      square(data, t, pr) { const S = .8 * canvas.width / Math.SQRT2, c = 300, o = (600 - S) / 2; ctx.beginPath();
        for (let i = 0; i < data.length; ++i) { let p = i / data.length, amp = (data[i] + 1) / 2, x, y;
          if (p < .25) [x, y] = [o + S * (p / .25), o];
          else if (p < .5) [x, y] = [o + S, o + S * ((p - .25) / .25)];
          else if (p < .75) [x, y] = [o + S - S * ((p - .5) / .25), o + S];
          else [x, y] = [o, o + S - S * ((p - .75) / .25)];
          let dx = x - c, dy = y - c, fx = c + dx * (.8 + .2 * amp) + Math.sin(t * .0005) * 10, fy = c + dy * (.8 + .2 * amp) + Math.cos(t * .0006) * 10;
          i ? ctx.lineTo(fx, fy) : ctx.moveTo(x, y); }
        ctx.closePath(); ctx.stroke();
      },
      butterfly(data, t, pr) { const S = .4 * canvas.width, c = 300; ctx.beginPath();
        for (let i = 0; i < data.length; ++i) { let th = i / data.length * Math.PI * 24 + t * .0003, amp = (data[i] + 1) / 2,
          scale = Math.exp(Math.cos(th)) - 2 * Math.cos(4 * th) + Math.pow(Math.sin(th / 12), 5),
          x = Math.sin(th) * scale * S * (.5 + .5 * amp) + c, y = Math.cos(th) * scale * S * (.5 + .5 * amp) + c;
          i ? ctx.lineTo(x, y) : ctx.moveTo(x, y); }
        ctx.closePath(); ctx.stroke();
      },
      lissajous(data, t, pr) { const S = .8 * canvas.width / 3, c = 300, avg = data.reduce((a, b) => a + Math.abs(b), 0) / data.length,
        freqX = 3 + Math.sin(t * .0003) * 1.5, freqY = 2 + Math.cos(t * .0004) * 1.5, phase = t * .0005; ctx.beginPath();
        for (let i = 0; i < data.length; i++) { let theta = i / data.length * 2 * Math.PI, r = avg * (.5 + .5 * data[i]),
          x = c + Math.sin(freqX * theta + phase) * S * r, y = c + Math.sin(freqY * theta) * S * r;
          i ? ctx.lineTo(x, y) : ctx.moveTo(x, y); }
        ctx.stroke();
      },
      spiro(data, t, pr) { const S = .6 * canvas.width / 3, c = 300, inner = .3 + Math.sin(t * .0002) * .2, outer = .7, ratio = .21 + .02 * Math.sin(t * .0001); ctx.beginPath();
        for (let i = 0; i < data.length; i++) { let theta = i / data.length * 2 * Math.PI, waveAmp = (data[i] + 1) / 2,
          x = c + (S * (outer - inner) * Math.cos(theta) + S * inner * Math.cos((outer - inner) / inner * theta + t * ratio)) * (.8 + .2 * waveAmp),
          y = c + (S * (outer - inner) * Math.sin(theta) - S * inner * Math.sin((outer - inner) / inner * theta + t * ratio)) * (.8 + .2 * waveAmp);
          i ? ctx.lineTo(x, y) : ctx.moveTo(x, y); }
        ctx.stroke();
      },
      harmonograph(data, t, pr) { const S = .7 * canvas.width / 4, c = 300, decay = Math.exp(-t * .0002), avg = (data.reduce((a, b) => a + b, 0) / data.length + 1) * .5; ctx.beginPath();
        for (let i = 0; i < data.length; i++) { let theta = i / data.length * 2 * Math.PI,
          x = c + decay * S * (Math.sin(3 * theta + t * .0003) * .7 + Math.sin(5 * theta + t * .0004) * .3) * (.5 + .5 * data[i]),
          y = c + decay * S * (Math.sin(4 * theta + t * .00035) * .6 + Math.sin(6 * theta + t * .00025) * .4) * (.5 + .5 * data[i]);
          i ? ctx.lineTo(x, y) : ctx.moveTo(x, y); }
        ctx.stroke();
      }
    };

    // --- Dummy deterministic buffer for silent visual seed mode ---
    function makeSeedBuffer(shape, seed, len = 2048) {
      const rng = mulberry32(seed + "_" + shape), arr = new Float32Array(len);
      for (let i = 0; i < len; ++i) {
        const t = i / len, base = Math.sin(2 * Math.PI * t + rng() * 6.28);
        const harm2 = 0.5 * Math.sin(4 * Math.PI * t + rng() * 6.28);
        const harm3 = 0.25 * Math.sin(6 * Math.PI * t + rng() * 6.28);
        arr[i] = 0.6 * base + 0.3 * harm2 + 0.15 * harm3;
      }
      return arr;
    }

    // --- Visual Animation ---
    let animId = null, mode = "seed";
    function visualAnimate() {
      ctx.clearRect(0, 0, 600, 600);
      const pr = presets[shapeSel.value], t = performance.now();
      const avg = mode === "seed" ? 0.5 : 0.5, hue = (t * pr.colorSpeed) % 360, sat = 70 + avg * 30, light = 50 + avg * 20;
      ctx.strokeStyle = `hsl(${hue},${sat}%,${light}%)`;
      ctx.lineWidth = 2; ctx.lineJoin = ctx.lineCap = 'round';
      let buf;
      if (mode === "seed") {
        buf = makeSeedBuffer(shapeSel.value, state.seed);
      } else {
        const chain = state.chains[state.current];
        const analyser = chain?.analyser;
        buf = analyser ? new Float32Array(analyser.fftSize) : new Float32Array(2048);
        analyser?.getFloatTimeDomainData(buf);
      }
      (drawFuncs[shapeSel.value] || drawFuncs.circle)(buf, t, pr);
      animId = requestAnimationFrame(visualAnimate);
    }

    // --- Audio Chain Buffering ---
    function disposeAllChains() {
      Object.values(state.chains).forEach(chain => {
        Object.values(chain).forEach(n => { try { n?.stop?.() } catch {} try { n?.dispose?.() } catch {} });
      });
      state.chains = {};
      state.current = null;
    }

    function setActiveChain(shape) {
      for (const s in state.chains) state.chains[s]?.reverb?.disconnect();
      const chain = state.chains[shape];
      chain?.reverb?.toDestination();
      state.current = shape;
    }

    async function bufferShapeChain(shape) {
      if (!state.contextUnlocked || state.chains[shape]) return;
      const pr = presets[shape], T = state.Tone;
      const osc1 = new T.Oscillator(pr.osc1[1], pr.osc1[0]).start();
      let osc2 = null; if (pr.osc2) osc2 = new T.Oscillator(pr.osc2[1], pr.osc2[0]).start();
      const volume = new T.Volume(5),
        filter = new T.Filter(pr.filter, "lowpass"),
        lfo = new T.LFO(pr.lfo[0] + "n", pr.lfo[1], pr.lfo[2]).start();
      lfo.connect(filter.frequency);
      if (osc2) lfo.connect(osc2.detune);
      osc1.connect(volume); if (osc2) osc2.connect(volume);
      volume.connect(filter);
      const reverb = new T.Freeverb().set({ wet: .3, roomSize: .8 });
      filter.connect(reverb);
      const analyser = T.context.createAnalyser();
      analyser.fftSize = 2048; filter.connect(analyser);
      state.chains[shape] = { osc1, osc2, volume, filter, lfo, reverb, analyser };
    }

    async function unlockAudioAndBufferInitial() {
      if (state.contextUnlocked) return;
      loader.textContent = "Unlocking AudioContext...";
      await state.Tone.start();
      state.contextUnlocked = true;
      loader.textContent = "Buffering first synth chain...";
      await bufferShapeChain(shapeSel.value);
      setActiveChain(shapeSel.value);
      loader.textContent = "Ready. Shape: " + shapeSel.value;
      startBtn.textContent = "Stop Audio + Draw";
      muteBtn.disabled = false;
      mode = "live";
      state.isPlaying = true;
      setTimeout(async () => {
        for (const shape of SHAPES) if (shape !== shapeSel.value) await bufferShapeChain(shape);
      }, 50);
    }

    function stopAudioAndDraw() {
      if (!state.isPlaying) return;
      disposeAllChains();
      state.isPlaying = false;
      startBtn.textContent = "Start Audio + Draw";
      muteBtn.disabled = true; muteBtn.textContent = "Mute";
      if (state.Tone) state.Tone.Destination.mute = false;
      mode = "seed";
    }

    // --- Sequencer Logic ---
    function initSequencer() {
      sequencer.style.display = 'flex';
      buildStepSlots();
      playSeqBtn.textContent = 'Play Sequence';
      playSeqBtn.disabled = false;
      updatePlayButtonState();
    }

    function buildStepSlots() {
      stepSlots.innerHTML = '';
      const count = parseInt(stepCount.value);
      state.stepCount = count;
      state.sequence = Array(count).fill(null);
      state.seqPosition = 0;

      for (let i = 0; i < count; i++) {
        const slot = document.createElement('div');
        slot.className = 'step-slot';
        slot.dataset.index = i;
        slot.title = 'Click to record here, Right-click to clear';

        slot.addEventListener('click', () => {
          state.recording = true;
          state.seqPosition = i;
          updateSlotVisuals();
        });

        slot.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          state.sequence[i] = null;
          updateSlotVisuals();
        });

        let pressTimer;
        slot.addEventListener('mousedown', () => {
          pressTimer = setTimeout(() => {
            state.sequence[i] = null;
            updateSlotVisuals();
          }, 500);
        });
        slot.addEventListener('mouseup', () => clearTimeout(pressTimer));
        slot.addEventListener('mouseleave', () => clearTimeout(pressTimer));

        stepSlots.appendChild(slot);
      }
      updateSlotVisuals();
    }

    function updateSlotVisuals() {
      const slots = document.querySelectorAll('.step-slot');
      slots.forEach((slot, i) => {
        slot.className = 'step-slot';
        if (state.sequence[i] !== null) {
          slot.classList.add('filled');
          slot.textContent = String(state.sequence[i] + 1);
        } else {
          slot.textContent = '';
        }
        if (state.recording && state.seqPosition === i) {
          slot.classList.add('recording', 'active');
        }
        if (i === state.seqPosition && !state.sequence[i]) {
          slot.classList.add('active');
        }
      });
      updatePlayButtonState();
    }

    function updatePlayButtonState() {
      const isFull = state.sequence.every(s => s !== null);
      playSeqBtn.style.display = isFull ? 'inline-block' : 'none';
    }

    function toggleSequencePlayback() {
      if (state.seqInterval) {
        clearInterval(state.seqInterval);
        state.seqInterval = null;
        playSeqBtn.textContent = 'Play Sequence';
        state.recording = false;
        updateSlotVisuals();
      } else {
        playSeqBtn.textContent = 'Stop';
        state.recording = false;
        updateSlotVisuals();
        let pos = 0;
        state.seqInterval = setInterval(() => {
          const step = state.sequence[pos];
          if (step !== null) {
            triggerStep(step);
            const slots = document.querySelectorAll('.step-slot');
            slots.forEach((s, i) => s.classList.remove('active'));
            slots[pos].classList.add('active');
            setTimeout(() => slots[pos].classList.remove('active'), state.stepDuration * 0.9);
          }
          pos = (pos + 1) % state.stepCount;
        }, state.stepDuration);
      }
    }

    function triggerStep(index) {
      if (index < 0 || index >= SHAPES.length) return;
      const shape = SHAPES[index];
      if (state.isPlaying) {
        setActiveChain(shape);
      } else {
        shapeSel.value = shape;
        mode = "seed";
      }
    }

    // --- UI Events ---
    startBtn.onclick = async () => {
      if (!state.contextUnlocked) await unlockAudioAndBufferInitial();
      else if (state.isPlaying) stopAudioAndDraw();
      else await unlockAudioAndBufferInitial();
      updateSlotVisuals();
    };

    muteBtn.onclick = () => {
      if (!state.Tone) return;
      const m = state.Tone.Destination.mute = !state.Tone.Destination.mute;
      muteBtn.textContent = m ? "Unmute" : "Mute";
    };

    shapeSel.onchange = () => {
      if (state.isPlaying) setActiveChain(shapeSel.value);
      else mode = "seed";
    };

    seqBtn.onclick = () => {
      if (sequencer.style.display === 'flex') {
        sequencer.style.display = 'none';
        state.recording = false;
        if (state.seqInterval) toggleSequencePlayback();
      } else {
        initSequencer();
      }
    };

    stepCount.onchange = () => {
      buildStepSlots();
    };

    tempoSlider.oninput = () => {
      const bpm = parseInt(tempoSlider.value);
      bpmDisplay.textContent = bpm;
      state.bpm = bpm;
      if (state.seqInterval) {
        clearInterval(state.seqInterval);
        state.seqInterval = setInterval(() => {
          const step = state.sequence[state.seqPosition];
          if (step !== null) triggerStep(step);
          state.seqPosition = (state.seqPosition + 1) % state.stepCount;
        }, state.stepDuration);
      }
    };

    playSeqBtn.onclick = toggleSequencePlayback;

    document.addEventListener('keydown', e => {
      if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") return;
      const idx = e.key.charCodeAt(0) - 49;
      if (idx >= 0 && idx < SHAPES.length) {
        if (state.recording) {
          state.sequence[state.seqPosition] = idx;
          state.seqPosition = (state.seqPosition + 1) % state.stepCount;
          updateSlotVisuals();
          e.preventDefault();
          return;
        }
        if (shapeSel.selectedIndex !== idx) {
          shapeSel.selectedIndex = idx;
          shapeSel.onchange();
        }
        triggerStep(idx);
        e.preventDefault();
      }
    });

    // --- Tone Loader ---
    function loadToneJS({ url, onReady, onFail }) {
      loader.textContent = 'Loading Audio Engine...';
      import(url).then(mod => {
        state.Tone = window.Tone ?? mod?.default ?? mod;
        if (state.Tone) {
          onReady();
          loader.textContent = `Tone.js v${state.Tone.version ?? "?"} loaded.`;
        } else throw 'Tone.js not found';
      }).catch(e => {
        loader.textContent = 'Failed to load Tone.js.';
        onFail?.();
        console.error(e);
      });
    }

    // --- Init ---
    let rand = mulberry32(state.seed);
    let firstShape = SHAPES[(rand() * SHAPES.length) | 0];
    shapeSel.value = firstShape;
    mode = "seed";
    startBtn.disabled = false;
    muteBtn.disabled = true;
    visualAnimate();

    loadToneJS({
      url: 'https://cdn.jsdelivr.net/npm/tone@15.0.4/build/Tone.min.js',
      onReady: () => {
        loader.textContent = `Ready for Audio. Click to start! (Shape: ${shapeSel.value})`;
        startBtn.disabled = false;
      },
      onFail: () => { startBtn.disabled = true; muteBtn.disabled = true; }
    });
  </script>
</body>
</html>