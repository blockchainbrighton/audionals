<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Web3 Oscilloscope Music</title>
  <meta name="viewport" content="width=600,initial-scale=1">
  <style>
    html,body {margin:0;padding:0;height:100%;background:#000;color:#fff;font-family:'Courier New',monospace;overflow:hidden;}
    body {display:grid;place-items:center;gap:1rem;}
    #scope {border-radius:12px;border:1px solid #333;background:#000;box-shadow:0 0 30px #0008;}
    #controls{display:flex;gap:1rem;align-items:center;flex-wrap:wrap;justify-content:center;padding:.5rem;background:#fff1;border-radius:8px;flex-wrap:wrap;}
    #controls button,#controls select{padding:.5rem 1rem;border-radius:6px;border:1px solid #555;background:#222;color:#fff;font-size:.9rem;cursor:pointer;}
    #controls button:hover{background:#444;}
    #loader{font-size:.9rem;color:#aaa;min-height:1.4rem;text-align:center;font-style:italic;}
    #sequencer {width:100%;max-width:600px;padding:1rem;box-sizing:border-box;}
    .step-container {display:flex;gap:.5rem;margin:.5rem 0;justify-content:center;flex-wrap:wrap;}
    .step-slot {width:60px;height:60px;border-radius:8px;background:#111;border:2px solid #333;display:flex;align-items:center;justify-content:center;cursor:pointer;font-weight:bold;font-size:1.2rem;color:#666;transition:all .2s;}
    .step-slot.active {background:#0f0;border-color:#0f0;color:#000;}
    .step-slot.playing {background:#f0f;border-color:#f0f;color:#000;}
    .step-controls {display:flex;gap:1rem;justify-content:center;margin-top:1rem;flex-wrap:wrap;}
    .step-controls button {padding:0.5rem 1.5rem;font-size:1rem;}
    .step-settings {display:flex;gap:1rem;justify-content:center;margin:.5rem 0;align-items:center;flex-wrap:wrap;}
    .tempo-control {display:flex;align-items:center;gap:.5rem;}
    .tempo-control label {min-width:60px;}
    input[type="range"] {width:120px;height:8px;background:#333;border-radius:4px;outline:none;cursor:pointer;}
    input[type="range"]::-webkit-slider-thumb {width:16px;height:16px;border-radius:50%;background:#0f0;border:2px solid #000;cursor:pointer;}
    input[type="range"]::-moz-range-thumb {width:16px;height:16px;border-radius:50%;background:#0f0;border:2px solid #000;cursor:pointer;}
  </style>
</head>
<body>
  <canvas id="scope" width="600" height="600"></canvas>
  <section id="controls">
    <button id="startBtn">Start Audio + Draw</button>
    <button id="muteBtn">Mute</button>
    <select id="shapeSelect">
      <option value="circle">Circle</option>
      <option value="square">Square</option>
      <option value="butterfly">Butterfly</option>
      <option value="lissajous">Lissajous</option>
      <option value="spiro">Spirograph</option>
      <option value="harmonograph">Harmonograph</option>
    </select>
    <button id="seqBtn">Create Sequence</button>
  </section>
  <div id="loader">Initializing...</div>
  
  <div id="sequencer" style="display:none">
    <div class="step-settings">
      <div class="tempo-control">
        <label for="tempoSlider">Tempo:</label>
        <input type="range" id="tempoSlider" min="50" max="240" value="150" step="5">
        <span id="tempoValue">150 BPM</span>
      </div>
      <div class="step-count-control">
        <label for="stepCount">Steps:</label>
        <select id="stepCount">
          <option value="4">4</option>
          <option value="8" selected>8</option>
          <option value="16">16</option>
          <option value="32">32</option>
        </select>
      </div>
    </div>
    <div class="step-container" id="stepSlots"></div>
    <div class="step-controls">
      <button id="playSeqBtn" style="display:none">Play Sequence</button>
      <button id="stopSeqBtn" style="display:none">Stop</button>
    </div>
  </div>
  
  <script type="module">
    // --- State ---
    const state = {
      isPlaying: false,
      Tone: null,
      chains: {}, // All audio chains, shape => { ...nodes }
      current: null, // Currently connected shape
      seed: '567',
      ready: false,
      contextUnlocked: false,
      sequencer: {
        active: false,
        recording: false,
        slots: Array(8).fill(null),
        currentStep: 0,
        interval: null,
        baseStepTime: 400, // ms per step at 150 BPM
        currentBPM: 150
      }
    };
    
    const canvas = scope, ctx = canvas.getContext('2d');
    const [startBtn, muteBtn, shapeSel, loader, seqBtn] = 
      ['startBtn','muteBtn','shapeSelect','loader','seqBtn'].map(id=>document.getElementById(id));
    const stepSlots = document.getElementById('stepSlots');
    const playSeqBtn = document.getElementById('playSeqBtn');
    const stopSeqBtn = document.getElementById('stopSeqBtn');
    const sequencerEl = document.getElementById('sequencer');
    const tempoSlider = document.getElementById('tempoSlider');
    const tempoValue = document.getElementById('tempoValue');
    const stepCountSelect = document.getElementById('stepCount');
    
    // --- Deterministic PRNG ---
    function mulberry32(seed) {
      let a = 0x6d2b79f5 ^ seed.length;
      for (let i = 0; i < seed.length; ++i) a = Math.imul(a ^ seed.charCodeAt(i), 2654435761);
      return () => ((a = Math.imul(a ^ a >>> 15, 1 | a)), (a >>> 16) / 0x10000);
    }
    
    // --- Deterministic preset generator ---
    function deterministicPreset(seed, shape) {
      const rng = mulberry32(seed + "_" + shape);
      const types = ['sine','triangle','square','sawtooth'];
      const notes = ['C1','C2','E2','G2','A2','C3','E3','G3','B3','D4','F#4','A4','C5'];
      const modeRoll = rng();
      let mode = 1;
      if (modeRoll < 0.18) mode = 0;
      else if (modeRoll < 0.56) mode = 1;
      else if (modeRoll < 0.85) mode = 2;
      else mode = 3;
      let lfoRate;
      if (mode === 0)      lfoRate = 0.07 + rng()*0.3;
      else if (mode === 1) lfoRate = 0.25 + rng()*8;
      else if (mode === 2) lfoRate = 6 + rng()*20;
      else                 lfoRate = 24 + rng()*36;
      let lfoMin, lfoMax;
      if (mode === 0) {
          lfoMin = 400 + rng()*400;
          lfoMax = 900 + rng()*600;
      } else if (mode === 1) {
          lfoMin = 120 + rng()*700;
          lfoMax = 1200 + rng()*1400;
      } else {
          lfoMin = 80 + rng()*250;
          lfoMax = 1500 + rng()*3500;
      }
      const oscCount = mode === 3 ? 2 + (rng() > 0.7 ? 1 : 0) : 1 + (rng() > 0.6 ? 1 : 0);
      const oscs = [];
      for (let i = 0; i < oscCount; ++i) {
          oscs.push([types[(rng()*types.length)|0], notes[(rng()*notes.length)|0]]);
      }
      const filterBase = mode === 0 ? 700 + rng()*500 : 300 + rng()*2400;
      const resonance = 0.6 + rng()*0.7;
      let env = {};
      if (mode === 0) {
          env = { attack: 0.005 + rng()*0.03, decay: 0.04 + rng()*0.08, sustain: 0.1 + rng()*0.2, release: 0.03 + rng()*0.1 };
      } else if (mode === 3) {
          env = { attack: 2 + rng()*8, decay: 4 + rng()*20, sustain: 0.7 + rng()*0.2, release: 8 + rng()*24 };
      } else {
          env = { attack: 0.03 + rng()*0.4, decay: 0.1 + rng()*0.7, sustain: 0.2 + rng()*0.5, release: 0.2 + rng()*3 };
      }
      const reverbWet = (mode === 3 ? 0.4 + rng()*0.5 : 0.1 + rng()*0.5);
      const reverbRoom = (mode === 3 ? 0.85 + rng()*0.12 : 0.6 + rng()*0.38);
      const colorSpeed = 0.06 + rng()*0.22;
      const shapeDrift = 0.0006 + rng()*0.0032;
      return {
          osc1: oscs[0],
          osc2: oscs[1] || null,
          filter: filterBase,
          filterQ: resonance,
          lfo: [lfoRate, lfoMin, lfoMax],
          envelope: env,
          reverb: { wet: reverbWet, roomSize: reverbRoom },
          colorSpeed,
          shapeDrift
      };
    }
    
    // Generate deterministic presets for all shapes at load time
    const SHAPES = ['circle','square','butterfly','lissajous','spiro','harmonograph'];
    let presets = {};
    for(const k of SHAPES) presets[k] = deterministicPreset(state.seed, k);
    
    // --- Drawing Functions ---
    const drawFuncs = {
      circle(data,t,pr){const S=.8*canvas.width/2,c=300;ctx.beginPath();
        for(let i=0;i<data.length;++i){let a=i/data.length*2*Math.PI+t*.001,amp=(data[i]+1)/2,
        r=S*amp,x=c+Math.cos(a)*r,y=c+Math.sin(a)*r;i?ctx.lineTo(x,y):ctx.moveTo(x,y);}
        ctx.closePath();ctx.stroke();
      },
      square(data,t,pr){const S=.8*canvas.width/Math.SQRT2,c=300,o=(600-S)/2;ctx.beginPath();
        for(let i=0;i<data.length;++i){let p=i/data.length,amp=(data[i]+1)/2,x,y;
        if(p<.25)[x,y]=[o+S*(p/.25),o];
        else if(p<.5)[x,y]=[o+S,o+S*((p-.25)/.25)];
        else if(p<.75)[x,y]=[o+S-S*((p-.5)/.25),o+S];
        else [x,y]=[o,o+S-S*((p-.75)/.25)];
        let dx=x-c,dy=y-c,fx=c+dx*(.8+.2*amp)+Math.sin(t*.0005)*10,fy=c+dy*(.8+.2*amp)+Math.cos(t*.0006)*10;
        i?ctx.lineTo(fx,fy):ctx.moveTo(x,y);}
        ctx.closePath();ctx.stroke();
      },
      butterfly(data,t,pr){const S=.4*canvas.width,c=300;ctx.beginPath();
        for(let i=0;i<data.length;++i){let th=i/data.length*Math.PI*24+t*.0003,amp=(data[i]+1)/2,
        scale=Math.exp(Math.cos(th))-2*Math.cos(4*th)+Math.pow(Math.sin(th/12),5),
        x=Math.sin(th)*scale*S*(.5+.5*amp)+c,y=Math.cos(th)*scale*S*(.5+.5*amp)+c;
        i?ctx.lineTo(x,y):ctx.moveTo(x,y);}
        ctx.closePath();ctx.stroke();
      },
      lissajous(data,t,pr){const S=.8*canvas.width/3,c=300,avg=data.reduce((a,b)=>a+Math.abs(b),0)/data.length,
        freqX=3+Math.sin(t*.0003)*1.5,freqY=2+Math.cos(t*.0004)*1.5,phase=t*.0005;ctx.beginPath();
        for(let i=0;i<data.length;i++){let theta=i/data.length*2*Math.PI,r=avg*(.5+.5*data[i]),
        x=c+Math.sin(freqX*theta+phase)*S*r,y=c+Math.sin(freqY*theta)*S*r;
        i?ctx.lineTo(x,y):ctx.moveTo(x,y);}
        ctx.stroke();
      },
      spiro(data,t,pr){const S=.6*canvas.width/3,c=300,inner=.3+Math.sin(t*.0002)*.2,outer=.7,ratio=.21+.02*Math.sin(t*.0001);ctx.beginPath();
        for(let i=0;i<data.length;i++){let theta=i/data.length*2*Math.PI,waveAmp=(data[i]+1)/2,
        x=c+(S*(outer-inner)*Math.cos(theta)+S*inner*Math.cos((outer-inner)/inner*theta+t*ratio))*(.8+.2*waveAmp),
        y=c+(S*(outer-inner)*Math.sin(theta)-S*inner*Math.sin((outer-inner)/inner*theta+t*ratio))*(.8+.2*waveAmp);
        i?ctx.lineTo(x,y):ctx.moveTo(x,y);}
        ctx.stroke();
      },
      harmonograph(data,t,pr){const S=.7*canvas.width/4,c=300,decay=Math.exp(-t*.0002),avg=(data.reduce((a,b)=>a+b,0)/data.length+1)*.5;ctx.beginPath();
        for(let i=0;i<data.length;i++){let theta=i/data.length*2*Math.PI,
        x=c+decay*S*(Math.sin(3*theta+t*.0003)*.7+Math.sin(5*theta+t*.0004)*.3)*(.5+.5*data[i]),
        y=c+decay*S*(Math.sin(4*theta+t*.00035)*.6+Math.sin(6*theta+t*.00025)*.4)*(.5+.5*data[i]);
        i?ctx.lineTo(x,y):ctx.moveTo(x,y);}
        ctx.stroke();
      }
    };
    
    // --- Dummy deterministic buffer for silent visual seed mode ---
    function makeSeedBuffer(shape, seed, len=2048) {
      const rng = mulberry32(seed+"_"+shape), arr = new Float32Array(len);
      for(let i=0;i<len;++i) {
        const t = i/len, base = Math.sin(2*Math.PI*t + rng()*6.28);
        const harm2 = 0.5*Math.sin(4*Math.PI*t + rng()*6.28);
        const harm3 = 0.25*Math.sin(6*Math.PI*t + rng()*6.28);
        arr[i] = 0.6*base + 0.3*harm2 + 0.15*harm3;
      }
      return arr;
    }
    
    // --- Visual Animation ---
    let animId = null, mode = "seed";
    function visualAnimate() {
      ctx.clearRect(0,0,600,600);
      const pr = presets[shapeSel.value], t = performance.now();
      const avg = mode==="seed"?0.5:0.5, hue = (t*pr.colorSpeed)%360, sat = 70+avg*30, light = 50+avg*20;
      ctx.strokeStyle = `hsl(${hue},${sat}%,${light}%)`;
      ctx.lineWidth = 2; ctx.lineJoin = ctx.lineCap = 'round';
      let buf;
      if(mode==="seed") {
        buf = makeSeedBuffer(shapeSel.value, state.seed);
      } else {
        const chain = state.chains[state.current];
        const analyser = chain?.analyser;
        buf = analyser ? new Float32Array(analyser.fftSize) : new Float32Array(2048);
        analyser?.getFloatTimeDomainData(buf);
      }
      (drawFuncs[shapeSel.value]||drawFuncs.circle)(buf, t, pr);
      animId = requestAnimationFrame(visualAnimate);
    }
    
    // --- Audio Chain Buffering ---
    function disposeAllChains() {
      Object.values(state.chains).forEach(chain=>{
        Object.values(chain).forEach(n=>{try{n?.stop?.()}catch{}try{n?.dispose?.()}catch{}});
      });
      state.chains = {};
      state.current = null;
    }
    
    function setActiveChain(shape) {
      // Disconnect all chains from destination
      for(const s in state.chains) {
        state.chains[s]?.reverb?.disconnect();
      }
      // Connect selected
      const chain = state.chains[shape];
      chain?.reverb?.toDestination();
      state.current = shape;
    }
    
    // --- Immediate First Shape Buffering, Other Chains Lazy ---
    async function bufferShapeChain(shape) {
      if (!state.contextUnlocked) return; // Robust: only run if context is running
      if (state.chains[shape]) return;    // Already buffered
      const pr = presets[shape], T = state.Tone;
      const osc1 = new T.Oscillator(pr.osc1[1],pr.osc1[0]).start();
      let osc2 = null; if(pr.osc2)osc2 = new T.Oscillator(pr.osc2[1],pr.osc2[0]).start();
      const volume = new T.Volume(5),
            filter = new T.Filter(pr.filter,"lowpass"),
            lfo = new T.LFO(pr.lfo[0]+"n",pr.lfo[1],pr.lfo[2]).start();
      lfo.connect(filter.frequency);
      if(osc2)lfo.connect(osc2.detune);
      osc1.connect(volume); if(osc2)osc2.connect(volume);
      volume.connect(filter);
      const reverb = new T.Freeverb().set({wet:.3,roomSize:.8});
      filter.connect(reverb);
      const analyser = T.context.createAnalyser();
      analyser.fftSize=2048; filter.connect(analyser);
      state.chains[shape] = {osc1, osc2, volume, filter, lfo, reverb, analyser};
    }
    
    async function unlockAudioAndBufferInitial() {
      if (state.contextUnlocked) return;
      loader.textContent = "Unlocking AudioContext...";
      await state.Tone.start();
      state.contextUnlocked = true;
      loader.textContent = "Buffering first synth chain...";
      await bufferShapeChain(shapeSel.value);
      setActiveChain(shapeSel.value);
      loader.textContent = "Ready. Shape: " + shapeSel.value;
      startBtn.textContent = "Stop Audio + Draw";
      muteBtn.disabled = false;
      mode = "live";
      state.isPlaying = true;
      // Now background buffer others:
      setTimeout(async ()=>{
        for(const shape of SHAPES) {
          if(shape !== shapeSel.value) await bufferShapeChain(shape);
        }
      },30);
    }
    
    function stopAudioAndDraw() {
      if(!state.isPlaying)return;
      disposeAllChains();
      state.isPlaying=false;
      startBtn.textContent="Start Audio + Draw";
      muteBtn.disabled=true; muteBtn.textContent="Mute";
      if(state.Tone) state.Tone.Destination.mute=false;
      mode = "seed";
    }
    
    // --- Sequencer Functions ---
    function initSequencer() {
      // Set initial step count
      updateStepCount(parseInt(stepCountSelect.value));
      
      // Show the sequencer
      sequencerEl.style.display = 'block';
      loader.textContent = 'Sequencer ready. Click a slot to start recording.';
    }
    
    function updateStepCount(count) {
      // Update state
      state.sequencer.slots = Array(count).fill(null);
      
      // Create new slots
      stepSlots.innerHTML = '';
      for (let i = 0; i < count; i++) {
        const slot = document.createElement('div');
        slot.className = 'step-slot';
        slot.dataset.index = i;
        slot.textContent = state.sequencer.slots[i] ? state.sequencer.slots[i] : '';
        
        // Click to enter record mode
        slot.addEventListener('click', (e) => {
          if (!state.sequencer.recording) {
            // Start recording at this slot
            state.sequencer.recording = true;
            state.sequencer.currentStep = parseInt(e.target.dataset.index);
            highlightActiveSlot();
            loader.textContent = `Recording at step ${state.sequencer.currentStep + 1}. Press 1-6 to assign.`;
          }
        });
        
        // Right-click to clear
        slot.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          const index = parseInt(e.target.dataset.index);
          state.sequencer.slots[index] = null;
          e.target.textContent = '';
          e.target.classList.remove('active');
          
          // Check if any slots are filled
          const hasFilledSlots = state.sequencer.slots.some(slot => slot !== null);
          playSeqBtn.style.display = hasFilledSlots ? 'inline-block' : 'none';
        });
        
        // Long press to clear (alternative to right-click)
        let pressTimer;
        slot.addEventListener('mousedown', () => {
          pressTimer = setTimeout(() => {
            const index = parseInt(slot.dataset.index);
            state.sequencer.slots[index] = null;
            slot.textContent = '';
            slot.classList.remove('active');
            
            const hasFilledSlots = state.sequencer.slots.some(slot => slot !== null);
            playSeqBtn.style.display = hasFilledSlots ? 'inline-block' : 'none';
          }, 500);
        });
        
        slot.addEventListener('mouseup', () => clearTimeout(pressTimer));
        slot.addEventListener('mouseleave', () => clearTimeout(pressTimer));
        
        stepSlots.appendChild(slot);
      }
      
      // Reset recording if current step is beyond new count
      if (state.sequencer.recording && state.sequencer.currentStep >= count) {
        state.sequencer.currentStep = 0;
        highlightActiveSlot();
      }
      
      // Update play button visibility
      const hasFilledSlots = state.sequencer.slots.some(slot => slot !== null);
      playSeqBtn.style.display = hasFilledSlots ? 'inline-block' : 'none';
    }
    
    function highlightActiveSlot() {
      document.querySelectorAll('.step-slot').forEach((slot, i) => {
        if (i === state.sequencer.currentStep) {
          slot.classList.add('active');
        } else {
          slot.classList.remove('active');
        }
      });
    }
    
    function highlightPlayingSlot(step) {
      document.querySelectorAll('.step-slot').forEach((slot, i) => {
        if (i === step) {
          slot.classList.add('playing');
        } else {
          slot.classList.remove('playing');
        }
      });
    }
    
    function updateSlotDisplay() {
      document.querySelectorAll('.step-slot').forEach((slot, i) => {
        slot.textContent = state.sequencer.slots[i] ? state.sequencer.slots[i] : '';
        if (state.sequencer.slots[i]) {
          slot.classList.add('active');
        } else {
          slot.classList.remove('active');
        }
      });
      
      // Show/hide play button based on whether we have any filled slots
      const hasFilledSlots = state.sequencer.slots.some(slot => slot !== null);
      playSeqBtn.style.display = hasFilledSlots ? 'inline-block' : 'none';
    }
    
    function calculateStepTime() {
      // Base step time is 400ms at 150 BPM (quarter note)
      // Formula: (60000ms/min) / (BPM) / (4) * (150/150) = 150/BPM * 400
      return (150 / state.sequencer.currentBPM) * 400;
    }
    
    function startSequencer() {
      if (state.sequencer.interval) return;
      
      let currentStep = 0;
      const stepTime = calculateStepTime();
      
      state.sequencer.interval = setInterval(() => {
        // Clear previous playing highlight
        document.querySelectorAll('.step-slot').forEach(slot => {
          slot.classList.remove('playing');
        });
        
        // Trigger the sound for current step
        const stepValue = state.sequencer.slots[currentStep];
        if (stepValue !== null) {
          const shapeIndex = parseInt(stepValue) - 1;
          if (shapeIndex >= 0 && shapeIndex < SHAPES.length) {
            const shape = SHAPES[shapeIndex];
            shapeSel.value = shape;
            shapeSel.onchange();
            highlightPlayingSlot(currentStep);
          }
        }
        
        currentStep = (currentStep + 1) % state.sequencer.slots.length;
      }, stepTime);
      
      playSeqBtn.style.display = 'none';
      stopSeqBtn.style.display = 'inline-block';
      loader.textContent = `Sequence playing at ${state.sequencer.currentBPM} BPM...`;
    }
    
    function stopSequencer() {
      if (state.sequencer.interval) {
        clearInterval(state.sequencer.interval);
        state.sequencer.interval = null;
      }
      
      // Clear playing highlights
      document.querySelectorAll('.step-slot').forEach(slot => {
        slot.classList.remove('playing');
      });
      
      stopSeqBtn.style.display = 'none';
      playSeqBtn.style.display = 'inline-block';
      loader.textContent = 'Sequence stopped.';
    }
    
    // --- UI Events ---
    startBtn.onclick = async ()=>{
      if (!state.contextUnlocked) await unlockAudioAndBufferInitial();
      else if (state.isPlaying) stopAudioAndDraw();
      else { // restart
        await unlockAudioAndBufferInitial();
      }
    };
    
    muteBtn.onclick = ()=>{
      if(!state.Tone)return;
      const m = state.Tone.Destination.mute = !state.Tone.Destination.mute;
      muteBtn.textContent = m ? "Unmute" : "Mute";
    };
    
    shapeSel.onchange = ()=>{
      if(state.isPlaying) setActiveChain(shapeSel.value), mode="live";
      else mode="seed";
    };
    
    seqBtn.onclick = () => {
      if (sequencerEl.style.display === 'none') {
        initSequencer();
        seqBtn.textContent = 'Hide Sequencer';
      } else {
        sequencerEl.style.display = 'none';
        seqBtn.textContent = 'Create Sequence';
        // Exit any recording mode
        state.sequencer.recording = false;
        document.querySelectorAll('.step-slot').forEach(slot => {
          slot.classList.remove('active');
        });
        loader.textContent = 'Sequencer hidden.';
      }
    };
    
    playSeqBtn.onclick = () => {
      startSequencer();
    };
    
    stopSeqBtn.onclick = () => {
      stopSequencer();
    };
    
    // Tempo slider events
    tempoSlider.addEventListener('input', () => {
      state.sequencer.currentBPM = parseInt(tempoSlider.value);
      tempoValue.textContent = `${state.sequencer.currentBPM} BPM`;
      
      // Update display if playing
      if (state.sequencer.interval) {
        loader.textContent = `Sequence playing at ${state.sequencer.currentBPM} BPM...`;
      }
    });
    
    // Step count change
    stepCountSelect.addEventListener('change', () => {
      const newCount = parseInt(stepCountSelect.value);
      updateStepCount(newCount);
      loader.textContent = `Step count changed to ${newCount}. Click a slot to start recording.`;
    });
    
    // --- Number Key Shape/Sound Selection ---
    document.addEventListener('keydown', e => {
      if(e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") return;
      
      // Handle 1-6 keys for shape selection
      const keyNum = parseInt(e.key);
      if(keyNum >= 1 && keyNum <= 6) {
        const shapeIndex = keyNum - 1;
        if(shapeSel.selectedIndex !== shapeIndex) {
          shapeSel.selectedIndex = shapeIndex;
          shapeSel.onchange();
        }
        
        // If in sequencer record mode, fill the current slot
        if (state.sequencer.recording) {
          state.sequencer.slots[state.sequencer.currentStep] = keyNum;
          updateSlotDisplay();
          
          // Auto-advance to next slot
          state.sequencer.currentStep = (state.sequencer.currentStep + 1) % state.sequencer.slots.length;
          highlightActiveSlot();
          
          // Check if all slots are filled
          const allFilled = state.sequencer.slots.every(slot => slot !== null);
          if (allFilled) {
            state.sequencer.recording = false;
            loader.textContent = `All ${state.sequencer.slots.length} slots filled! Press Play to start sequence.`;
          } else {
            loader.textContent = `Slot ${state.sequencer.currentStep + 1} ready. Press 1-6 to assign.`;
          }
        }
        
        e.preventDefault();
      }
    });
    
    // --- Tone Loader ---
    function loadToneJS({url,onReady,onFail}) {
      loader.textContent = 'Loading Audio Engine...';
      import(url).then(mod=>{
        state.Tone = window.Tone ?? mod?.default ?? mod;
        if(state.Tone){onReady();loader.textContent=`Tone.js v${state.Tone.version??"?"} loaded.`;}
        else throw 'Tone.js not found';
      }).catch(e=>{
        loader.textContent='Failed to load Tone.js.';onFail?.();console.error(e);
      });
    }
    
    // --- Init: show seed-visual by default, UI disables, wait for interaction to unlock audio ---
    let rand = mulberry32(state.seed);
    let firstShape = SHAPES[(rand()*SHAPES.length)|0];
    shapeSel.value = firstShape;
    mode = "seed";
    startBtn.disabled = false; // user must click!
    muteBtn.disabled = true;
    visualAnimate();
    
    // Load Tone, but synth chains only after user starts
    loadToneJS({
      url:'https://cdn.jsdelivr.net/npm/tone@15.0.4/build/Tone.min.js',
      onReady:()=>{
        loader.textContent=`Ready for Audio. Click to start! (Shape: ${shapeSel.value})`;
        startBtn.disabled = false;
      },
      onFail:()=>{startBtn.disabled=true;muteBtn.disabled=true;}
    });
  </script>
</body>
</html>