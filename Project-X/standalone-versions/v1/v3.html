<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minimal Web3 Oscilloscope Music</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background-color: #121212;
      color: #ffffff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      overflow: hidden;
    }
    body {
      display: grid;
      place-items: center;
      gap: 2rem;
    }
    #scope {
      border-radius: 8px;
      border: 1px solid #333;
      background-color: #000;
    }
    #controls {
      display: flex;
      gap: 1rem;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }
    #controls button, #controls select {
      padding: 0.5rem 1rem;
      border-radius: 4px;
      border: 1px solid #555;
      background-color: #222;
      color: #fff;
      font-size: 1rem;
    }
    #controls button:hover {
      background-color: #333;
    }
    #loader {
      text-align: center;
      font-size: 0.9rem;
      color: #aaa;
      min-height: 1.2rem;
    }
  </style>
</head>
<body>
  <canvas id="scope" width="600" height="600"></canvas>
  <section id="controls">
    <button id="startBtn">Start Audio + Draw</button>
    <button id="muteBtn">Mute</button> <!-- New Mute Button -->
    <select id="shapeSelect">
      <option value="circle">Circle</option>
      <option value="square">Square</option>
      <option value="butterfly">Butterfly</option>
    </select>
  </section>
  <div id="loader">Initializing...</div>
  <script type="module">
    // toneLoader.js (embedded)
    export function loadToneJSAndBoot({
        toneUrl = 'https://ordinals.com/content/04813d7748d918bd8a3069cb1823ebc9586f0ce16cd6a97a784581ec38d13062i0',
        setLoaderStatus = () => { },
        runtimeState = {},
        boot = () => { }
    } = {}) {
        setLoaderStatus('Loading Audio Engine...');
        import(/* @vite-ignore */ toneUrl)
            .then(mod => {
                // Tone.js might be attached to window or available as a module export
                runtimeState.Tone = window.Tone ?? mod?.default ?? mod;
                if (runtimeState.Tone) {
                    setLoaderStatus(`Tone.js v${runtimeState.Tone?.version ?? '?'} ready.`);
                    boot();
                } else {
                    throw new Error('Tone.js loaded but namespace not found.');
                }
            })
            .catch(err => {
                setLoaderStatus('Failed to load Tone.js. App cannot start.', true);
                console.error(err);
            });
    }
    // main.js (separate file content below, but loaded as module)
    // import { loadToneJSAndBoot } from './toneLoader.js'; // This will resolve to the function above in this single-file setup
    // --- 1. State & DOM Elements ---
    const state = {
        isPlaying: false,
        analyser: null,
        animationId: null,
        currentShape: 'circle', // default shape
        Tone: null, // Will be populated by the loader
        // Store references to Tone nodes for proper disposal for the *current* sound
        oscillator1: null,
        oscillator2: null, // Added second oscillator
        filter: null,
        lfo: null,
        volume: null // Add volume node for consistent loudness
    };

    // --- Sound Definitions ---
    // Define unique sounds for each shape in C Major
    // C3: 130.81 Hz, E3: 164.81 Hz, G3: 196.00 Hz
    const soundPresets = {
        circle: {
            osc1Type: "sine",
            osc1Freq: "C3", // 130.81 Hz
            osc2Type: null, // No second oscillator
            filterFreq: 1500,
            lfoFreq: "4n",
            lfoMin: 500,
            lfoMax: 3000
        },
        square: {
            osc1Type: "square",
            osc1Freq: "E3", // 164.81 Hz
            osc2Type: null, // No second oscillator
            filterFreq: 1200,
            lfoFreq: "8n",
            lfoMin: 300,
            lfoMax: 2500
        },
        butterfly: {
            osc1Type: "sawtooth",
            osc1Freq: "G3", // 196.00 Hz
            osc2Type: "sine", // Add a second sine wave
            osc2Freq: "G4", // One octave higher (392.00 Hz)
            filterFreq: 2000,
            lfoFreq: "2n.", // Dotted half note for slower modulation
            lfoMin: 200,
            lfoMax: 4000
        }
    };

    const canvas = document.getElementById('scope');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const muteBtn = document.getElementById('muteBtn'); // New Mute Button
    const shapeSelect = document.getElementById('shapeSelect');
    const loaderDiv = document.getElementById('loader');
    // --- 2. Drawing Functions ---
    const drawFunctions = {
        circle: (data, time) => {
            const size = Math.min(canvas.width, canvas.height) * 0.8;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            ctx.beginPath();
            for (let i = 0; i < data.length; i++) {
                const angle = (i / data.length) * Math.PI * 2;
                const amplitude = (data[i] + 1) / 2; // Map from [-1, 1] to [0, 1]
                const radius = (size / 2) * amplitude;
                const x = centerX + Math.cos(angle + time) * radius;
                const y = centerY + Math.sin(angle + time) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
        },
        square: (data, time) => {
            const size = Math.min(canvas.width, canvas.height) * 0.8;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const side = size / Math.sqrt(2);
            const offsetX = (canvas.width - side) / 2;
            const offsetY = (canvas.height - side) / 2;
            ctx.beginPath();
            for (let i = 0; i < data.length; i++) {
                const progress = i / data.length;
                let x, y;
                if (progress < 0.25) {
                    // Top side
                    x = offsetX + (progress / 0.25) * side;
                    y = offsetY;
                } else if (progress < 0.5) {
                    // Right side
                    x = offsetX + side;
                    y = offsetY + ((progress - 0.25) / 0.25) * side;
                } else if (progress < 0.75) {
                    // Bottom side
                    x = offsetX + side - ((progress - 0.5) / 0.25) * side;
                    y = offsetY + side;
                } else {
                    // Left side
                    x = offsetX;
                    y = offsetY + side - ((progress - 0.75) / 0.25) * side;
                }
                const amplitude = (data[i] + 1) / 2;
                const distX = x - centerX;
                const distY = y - centerY;
                const finalX = centerX + distX * (0.8 + 0.2 * amplitude);
                const finalY = centerY + distY * (0.8 + 0.2 * amplitude);
                if (i === 0) ctx.moveTo(finalX, finalY);
                else ctx.lineTo(finalX, finalY);
            }
            ctx.closePath();
            ctx.stroke();
        },
        butterfly: (data, time) => {
            const size = Math.min(canvas.width, canvas.height) * 0.4;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            ctx.beginPath();
            for (let i = 0; i < data.length; i++) {
                const t = (i / data.length) * Math.PI * 24; // 12 "wings"
                // Butterfly parametric equations
                const scale = Math.pow(Math.E, Math.cos(t)) - 2 * Math.cos(4 * t) + Math.pow(Math.sin(t / 12), 5);
                let x = Math.sin(t) * scale;
                let y = Math.cos(t) * scale;
                // Use audio data to modulate the shape
                const amplitude = (data[i] + 1) / 2;
                x *= size * (0.5 + 0.5 * amplitude);
                y *= size * (0.5 + 0.5 * amplitude);
                x += centerX;
                y += centerY;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
        }
    };
    // --- 3. Animation Loop ---
    function animate() {
        if (!state.analyser || !state.isPlaying) return;
        const bufferLength = state.analyser.fftSize;
        const dataArray = new Float32Array(bufferLength);
        state.analyser.getFloatTimeDomainData(dataArray);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Styling
        ctx.strokeStyle = `hsl(${(performance.now() / 50) % 360}, 100%, 70%)`;
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        const currentTime = performance.now() / 1000;
        const drawFunc = drawFunctions[state.currentShape] || drawFunctions.circle;
        drawFunc(dataArray, currentTime);
        state.animationId = requestAnimationFrame(animate);
    }

    // --- Helper: Stop Current Sound Nodes ---
    function stopCurrentSound() {
        // --- Dispose of Tone.js nodes for the current sound ---
        if (state.oscillator1) {
            state.oscillator1.stop();
            state.oscillator1.dispose();
            state.oscillator1 = null;
        }
        if (state.oscillator2) { // Dispose second oscillator if it exists
            state.oscillator2.stop();
            state.oscillator2.dispose();
            state.oscillator2 = null;
        }
        if (state.filter) {
            state.filter.dispose();
            state.filter = null;
        }
        if (state.lfo) {
            state.lfo.stop();
            state.lfo.dispose();
            state.lfo = null;
        }
        if (state.volume) {
            state.volume.dispose();
            state.volume = null;
        }
        state.analyser = null; // Analyser is native node, no dispose, just dereference
    }

    // --- 4. Start/Stop Logic ---
    async function startAudioAndDraw() {
        if (state.isPlaying) return;
        if (!state.Tone) {
            loaderDiv.textContent = 'Error: Tone.js not loaded.';
            return;
        }
        try {
            // Resume Audio Context
            if (state.Tone.context.state !== 'running') {
                await state.Tone.context.resume();
            }

            // Get the preset for the current shape
            const preset = soundPresets[state.currentShape];

            // --- Create audio nodes based on the preset ---
            state.oscillator1 = new state.Tone.Oscillator(preset.osc1Freq, preset.osc1Type).start();
            if (preset.osc2Type && preset.osc2Freq) {
                state.oscillator2 = new state.Tone.Oscillator(preset.osc2Freq, preset.osc2Type).start();
            } else {
                state.oscillator2 = null; // Ensure it's null if not used
            }

            // Create a volume node to control overall loudness
            state.volume = new state.Tone.Volume(5).toDestination(); // Boost volume slightly

            // Create filter and LFO
            state.filter = new state.Tone.Filter(preset.filterFreq, "lowpass");
            state.lfo = new state.Tone.LFO(preset.lfoFreq, preset.lfoMin, preset.lfoMax).start();

            // Connect the audio graph
            // Oscillator(s) -> Volume -> Filter -> LFO (modulates Filter) -> Destination
            state.oscillator1.connect(state.volume);
            if (state.oscillator2) {
                state.oscillator2.connect(state.volume);
            }
            state.volume.connect(state.filter);
            state.lfo.connect(state.filter.frequency);
            state.filter.toDestination(); // Connect filter output to final destination

            // Create analyser (connect it to the graph before the destination)
            state.analyser = state.Tone.context.createAnalyser();
            state.analyser.fftSize = 2048;
            // Connect the analyser to monitor the signal *after* filtering but before final output
            state.filter.connect(state.analyser);

            state.isPlaying = true;
            startBtn.textContent = 'Stop Audio + Draw';
            muteBtn.disabled = false; // Enable mute button when playing
            animate();
        } catch (err) {
            console.error('Error starting audio:', err);
            loaderDiv.textContent = 'Failed to start audio.';
        }
    }

    function stopAudioAndDraw() {
        if (!state.isPlaying) return;

        // Cancel animation frame
        if (state.animationId) {
            cancelAnimationFrame(state.animationId);
            state.animationId = null;
        }

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        stopCurrentSound(); // Use helper to dispose nodes

        state.isPlaying = false;
        startBtn.textContent = 'Start Audio + Draw';
        muteBtn.disabled = true; // Disable mute button when stopped
        muteBtn.textContent = 'Mute'; // Reset mute button text
        state.Tone.Destination.mute = false; // Ensure unmuted on stop
    }


    // --- 5. Event Listeners ---
    startBtn.addEventListener('click', () => {
        if (state.isPlaying) {
            stopAudioAndDraw();
        } else {
            startAudioAndDraw();
        }
    });

    // --- Mute Button Event Listener ---
    muteBtn.addEventListener('click', () => {
        if (state.Tone) {
             const isMuted = state.Tone.Destination.mute;
             state.Tone.Destination.mute = !isMuted;
             muteBtn.textContent = isMuted ? 'Mute' : 'Unmute';
        }
    });

    // --- Shape Change Listener ---
    shapeSelect.addEventListener('change', () => {
        const newShape = shapeSelect.value;
        if (state.currentShape !== newShape) {
            state.currentShape = newShape;
            // If audio is playing, restart it with the new sound
            if (state.isPlaying) {
                stopAudioAndDraw();
                startAudioAndDraw();
            }
        }
    });

    // --- 6. Initialize Loader ---
    loadToneJSAndBoot({
        setLoaderStatus: (message, isError = false) => {
            loaderDiv.textContent = message;
            loaderDiv.style.color = isError ? 'red' : '#aaa';
            if (isError) {
                 startBtn.disabled = true;
                 muteBtn.disabled = true;
            }
        },
        runtimeState: state, // Pass our state object to be populated
        boot: () => {
            // This is called after Tone.js is successfully loaded
            console.log('Tone.js is ready, demo can now be started.');
            loaderDiv.textContent = 'Audio engine ready. Click Start.';
            startBtn.disabled = false;
            muteBtn.disabled = true; // Mute button disabled until audio starts
        }
    });

    // Initial state for buttons
    startBtn.disabled = true;
    muteBtn.disabled = true;
  </script>
</body>
</html>