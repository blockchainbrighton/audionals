<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Web3 Oscilloscope Music - Optimized</title>
  <meta name="viewport" content="width=600,initial-scale=1">
  <style>
    html,body {margin:0;padding:0;height:100%;background:#000;color:#fff;font-family:sans-serif;}
    body {display:grid;place-items:center;gap:1.2rem;padding:1rem;}
    #scope {border-radius:8px;border:1px solid #444;background:#000;box-shadow:0 0 15px rgba(100,100,255,0.2);cursor:pointer;}
    #controls {display:flex;gap:0.8rem;align-items:center;flex-wrap:wrap;justify-content:center;}
    #controls button,#controls select{padding:0.5rem 1rem;border-radius:5px;border:1px solid #666;background:#2a2a2a;color:#eee;transition:background 0.2s,transform 0.1s;font-size:0.9rem;}
    #controls button:hover{background:#3a3a3a;transform:translateY(-1px);}
    #controls button:active{transform:translateY(1px);}
    #loader{font-size:0.95rem;color:#aaa;min-height:1.3rem;text-align:center;font-style:italic;}
    #info{font-size:0.8rem;color:#888;text-align:center;max-width:600px;}
    .visual-indicator{position:absolute;top:10px;right:10px;padding:4px 8px;border-radius:3px;font-size:0.75rem;font-weight:bold;z-index:10;}
    .indicator-silent{background:#555;color:#ccc;}
    .indicator-audio{background:#4a86e8;color:#fff;box-shadow:0 0 8px rgba(74,134,232,0.7);}
    #modeToggle{background:#444;border-color:#777;}
    #modeToggle.seed-mode{background:#2c5a2c;border-color:#5cb85c;color:#dff0d8;}
    #modeToggle.random-mode{background:#5a3c2c;border-color:#b85c5c;color:#f0d8d8;}
    .keyboard-note {position:absolute;bottom:10px;right:10px;padding:4px 8px;border-radius:3px;font-size:0.75rem;z-index:10;opacity:0.9;}
    .keyboard-note {background:#8b4513;color:#fff;box-shadow:0 0 8px rgba(139,69,19,0.7);}
  </style>
</head>
<body>
  <div id="visualIndicator" class="visual-indicator indicator-silent">Silent Mode</div>
  <div id="keyboardIndicator" class="keyboard-note" style="display:none;">Keyboard Ready</div>
  <canvas id="scope" width="600" height="600"></canvas>
  <section id="controls">
    <button id="startBtn">Start Audio</button>
    <button id="muteBtn">Mute</button>
    <select id="shapeSelect"></select>
    <button id="randomizeBtn">Randomize</button>
    <button id="modeToggle" class="random-mode">Mode: Random</button>
  </section>
  <div id="loader">Initializing...</div>
  <div id="info">Visuals start automatically. Click 'Start Audio' OR the image to hear sound. Use 'Mode' to switch generation method.</div>
  <script type="module">
    // --- Utilities: Seeded RNG (mulberry32) ---
    function mulberry32(seed) {
      let a = 0x6d2b79f5 ^ seed.length;
      for (let i = 0; i < seed.length; ++i) a = Math.imul(a ^ seed.charCodeAt(i), 2654435761);
      return () => ((a = Math.imul(a ^ a >>> 15, 1 | a)), (a >>> 16) / 0x10000);
    }
    // --- State and DOM refs ---
    const state = {
      isPlaying: false, isAudioStarted: false, Tone: null, nodes: {}, currentParams: {}, dummyData: null,
      isSeedMode: false, seedGenerator: null, predefinedSets: {}, keyboardOscillators: {}, keyboardNotes: {},
      keyboardActive: false
    };
    const $ = id => document.getElementById(id);
    const canvas = $("scope"), ctx = canvas.getContext("2d"),
      startBtn = $("startBtn"), muteBtn = $("muteBtn"), shapeSel = $("shapeSelect"),
      randomizeBtn = $("randomizeBtn"), loader = $("loader"),
      visualIndicator = $("visualIndicator"), modeToggleBtn = $("modeToggle"),
      keyboardIndicator = $("keyboardIndicator");
    // --- Shapes ---
    const baseShapes = {
      circle:    {name: "Circle",    draw: drawCircle},
      square:    {name: "Square",    draw: drawSquare},
      butterfly: {name: "Butterfly", draw: drawButterfly},
      lissajous: {name: "Lissajous", draw: drawLissajous},
      spiral:    {name: "Spiral",    draw: drawSpiral},
      rose:      {name: "Rose",      draw: drawRose}
    };
    Object.entries(baseShapes).forEach(([key, {name}])=>{
      const o = document.createElement("option"); o.value = key; o.textContent = name; shapeSel.appendChild(o);
    });
    // --- Drawing Functions (unchanged) ---
    function drawCircle(data, t, p) {
      const S=p.size*canvas.width/2, c=300;
      ctx.beginPath();
      for(let i=0;i<data.length;++i){
        const a=i/data.length*2*Math.PI,amp=(data[i]+1)/2,r=S*amp,modA=a+t*(p.rotationSpeed??.05);
        const x=c+Math.cos(modA)*r,y=c+Math.sin(modA)*r;
        i?ctx.lineTo(x,y):ctx.moveTo(x,y);
      } ctx.closePath(); ctx.stroke();
    }
    function drawSquare(data,t,p){const S=p.size*canvas.width/Math.SQRT2,c=300,o=(600-S)/2;ctx.beginPath();
      for(let i=0;i<data.length;++i){const q=i/data.length,amp=(data[i]+1)/2;
        let x,y;if(q<.25)[x,y]=[o+S*(q/.25),o];else if(q<.5)[x,y]=[o+S,o+S*((q-.25)/.25)];
        else if(q<.75)[x,y]=[o+S-S*((q-.5)/.25),o+S];else[x,y]=[o,o+S-S*((q-.75)/.25)];
        const dx=x-c,dy=y-c,scale=.8+.2*amp+.1*Math.sin(t*(p.pulseSpeed??.2)),fx=c+dx*scale,fy=c+dy*scale;
        i?ctx.lineTo(fx,fy):ctx.moveTo(fx,fy);}ctx.closePath();ctx.stroke();}
    function drawButterfly(data,t,p){const S=p.size*.4*canvas.width,c=300;ctx.beginPath();
      for(let i=0;i<data.length;++i){const th=i/data.length*Math.PI*24,amp=(data[i]+1)/2,scale=Math.exp(Math.cos(th))-2*Math.cos(4*th)+Math.pow(Math.sin(th/12),5);
        let x=Math.sin(th)*scale*S*(.5+.5*amp),y=Math.cos(th)*scale*S*(.5+.5*amp);
        const a=t*(p.rotationSpeed??.05),nx=x*Math.cos(a)-y*Math.sin(a),ny=x*Math.sin(a)+y*Math.cos(a);
        i?ctx.lineTo(nx+c,ny+c):ctx.moveTo(nx+c,ny+c);}ctx.closePath();ctx.stroke();}
    function drawLissajous(data,t,p){const S=p.size*.45*canvas.width,c=300,a=p.lissaA||3,b=p.lissaB||2,d=p.lissaDelta||0;ctx.beginPath();
      for(let i=0;i<data.length;++i){const prog=i/data.length,amp=(data[i]+1)/2,modT=t*(p.rotationSpeed??.05);
        const x=S*Math.sin(a*modT+prog*2*Math.PI+d)*amp,y=S*Math.sin(b*modT+prog*2*Math.PI)*amp;
        i?ctx.lineTo(x+c,y+c):ctx.moveTo(x+c,y+c);}ctx.stroke();}
    function drawSpiral(data,t,p){const S=p.size*.45*canvas.width,c=300,turns=p.spiralTurns||5;ctx.beginPath();
      for(let i=0;i<data.length;++i){const prog=i/data.length,amp=(data[i]+1)/2,a=prog*2*Math.PI*turns+t*(p.rotationSpeed??.05),r=S*prog*amp;
        const x=c+Math.cos(a)*r,y=c+Math.sin(a)*r;i?ctx.lineTo(x,y):ctx.moveTo(x,y);}ctx.stroke();}
    function drawRose(data,t,p){const S=p.size*.45*canvas.width,c=300,k=p.roseK||3;ctx.beginPath();
      for(let i=0;i<data.length;++i){const prog=i/data.length,amp=(data[i]+1)/2,a=prog*2*Math.PI+t*(p.rotationSpeed??.05),r=S*Math.cos(k*a)*amp;
        const x=c+Math.cos(a)*r,y=c+Math.sin(a)*r;i?ctx.lineTo(x,y):ctx.moveTo(x,y);}ctx.closePath();ctx.stroke();}
    // --- Dummy Data ---
    function generateDummyData(){
      const d = new Float32Array(2048);
      for(let i=0;i<2048;i++){
        const t=i/2048;d[i]=.4*Math.sin(t*6*Math.PI)+.3*Math.sin(t*14*Math.PI+Math.PI/3)+.2*Math.sin(t*22*Math.PI+Math.PI/6)+.1*Math.sin(t*34*Math.PI);}
      return d;
    }
    // --- Audio: param/gen helpers ---
    const noteNames = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'], octaves=[2,3,4,5], waveforms=['sine','square','sawtooth','triangle'], filterTypes=['lowpass','highpass','bandpass'];
    const rand = (arr, rng=Math.random) => arr[Math.floor(rng()*arr.length)];
    function getRandomNote(rng=Math.random){return rand(noteNames,rng)+rand(octaves,rng);}
    function generateRandomParams(shapeKey=null,rng=Math.random){
      const sKey=shapeKey||rand(Object.keys(baseShapes),rng),osc1Type=rand(waveforms,rng),osc1Note=getRandomNote(rng),useOsc2=rng()>.3,osc2Type=useOsc2?rand(waveforms,rng):null,osc2Note=useOsc2?getRandomNote(rng):null;
      let interaction='mix';if(useOsc2){const r=rng();if(r<.4)interaction='am';else if(r<.7)interaction='fm';}
      const filterFreq=500+rng()*4000,filterType=rand(filterTypes,rng),lfoFreq=.1+rng()*5,lfoMin=200+rng()*1e3,lfoMax=lfoMin+500+rng()*4e3,
        hueBase=Math.floor(rng()*360),hueRange=50+Math.floor(rng()*100),lineWidth=1.5+rng()*3,rotationSpeed=(rng()-.5)*.3,pulseSpeed=.05+rng()*.3,size=.65+rng()*.4,useGlow=rng()>.5;
      let lissaA,lissaB,lissaDelta,spiralTurns,roseK;
      switch(sKey){
        case 'lissajous':lissaA=1+Math.floor(rng()*5);lissaB=1+Math.floor(rng()*5);lissaDelta=rng()*Math.PI;break;
        case 'spiral':spiralTurns=2+Math.floor(rng()*6);break;
        case 'rose':roseK=.5+rng()*5;break;
        default:lissaA=1+Math.floor(rng()*5);lissaB=1+Math.floor(rng()*5);lissaDelta=rng()*Math.PI;spiralTurns=2+Math.floor(rng()*6);roseK=.5+rng()*5;
      }
      return {shapeKey:sKey,osc1:{type:osc1Type,note:osc1Note},osc2:useOsc2?{type:osc2Type,note:osc2Note}:null,interaction,
        filter:{frequency:filterFreq,type:filterType},lfo:{frequency:lfoFreq,min:lfoMin,max:lfoMax},
        visual:{hueBase,hueRange,lineWidth,rotationSpeed,pulseSpeed,size,useGlow,lissaA,lissaB,lissaDelta,spiralTurns,roseK}};
    }
    function generatePredefinedSets(seedString="defaultSeed123"){
      const rng=mulberry32(seedString),sets={};Object.keys(baseShapes).forEach(k=>sets[k]=generateRandomParams(k,rng));
      state.predefinedSets=sets;
    }
    
    // --- Keyboard Piano Implementation ---
    function setupKeyboardInterface() {
      // Piano key mapping: 88 keys from A0 (21) to C8 (108)
      // Map keyboard keys to piano notes
      const keyMap = {
        'a': 21, 'w': 22, 's': 23, 'e': 24, 'd': 25, 'f': 26, 't': 27, 'g': 28, 
        'y': 29, 'h': 30, 'u': 31, 'j': 32, 'k': 33, 'o': 34, 'l': 35, 'p': 36, 
        ';': 37, "'": 38, 'z': 39, 'x': 40, 'c': 41, 'v': 42, 'b': 43, 'n': 44, 
        ',': 45, 'm': 46, '.': 47, '/': 48,
        // Second octave set
        'q': 49, '1': 50, '2': 51, '3': 52, '4': 53, '5': 54, '6': 55, '7': 56, 
        '8': 57, '9': 58, '0': 59, '-': 60, '=': 61, 'r': 62, 'i': 63, '[': 64, 
        ']': 65, '\\': 66
      };
      
      // Function to convert MIDI note number to note name
      function midiToNoteName(midi) {
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const octave = Math.floor(midi / 12) - 1;
        const note = noteNames[midi % 12];
        return note + octave;
      }
      
      // Function to convert MIDI note to frequency
      function midiToFreq(midi) {
        return 440 * Math.pow(2, (midi - 69) / 12);
      }
      
      // Track active keyboard oscillators
      state.keyboardOscillators = {};
      
      // Keyboard event handlers
      window.addEventListener('keydown', (e) => {
        // Only respond if audio is initialized
        if (!state.Tone || !state.isAudioStarted) return;
        
        // Prevent multiple triggers from holding key
        if (e.repeat) return;
        
        const key = e.key.toLowerCase();
        if (keyMap[key]) {
          // Mark keyboard as active
          if (!state.keyboardActive) {
            state.keyboardActive = true;
            keyboardIndicator.style.display = 'block';
            keyboardIndicator.textContent = 'Keyboard Ready';
            setTimeout(() => {
              keyboardIndicator.textContent = 'Play any key!';
            }, 1500);
          }
          
          const midiNote = keyMap[key];
          const noteName = midiToNoteName(midiNote);
          const freq = midiToFreq(midiNote);
          
          // Use current audio parameters for the oscillator
          const params = state.currentParams;
          const oscType = params.osc1?.type || 'sine';
          
          // Create oscillator with current visual parameters for feedback
          const osc = new state.Tone.Oscillator(freq, oscType).start();
          
          // Apply current filter settings if available
          if (params.filter) {
            const filter = new state.Tone.Filter(params.filter.frequency, params.filter.type);
            osc.connect(filter);
            filter.connect(state.Tone.Destination);
          } else {
            osc.connect(state.Tone.Destination);
          }
          
          // Store oscillator to allow stopping it
          state.keyboardOscillators[key] = osc;
          
          // Visual feedback on canvas
          keyboardIndicator.textContent = `Playing: ${noteName}`;
          
          // Update the loader text
          loader.textContent = `Playing note: ${noteName}`;
        }
      });
      
      window.addEventListener('keyup', (e) => {
        const key = e.key.toLowerCase();
        if (state.keyboardOscillators[key]) {
          // Stop the oscillator with a short release for natural sound
          state.keyboardOscillators[key].stop('+0.05');
          delete state.keyboardOscillators[key];
        }
      });
      
      // Mark that keyboard is ready
      keyboardIndicator.style.display = 'block';
      setTimeout(() => {
        keyboardIndicator.textContent = 'Keyboard Ready - Play any mapped key';
      }, 500);
      
      console.log('Keyboard interface initialized for 88-key piano');
    }
    
    // --- Audio Graph ---
    function disposeNodes(){Object.values(state.nodes).forEach(n=>{try{n?.stop?.()}catch{}try{n?.dispose?.()}catch{}});state.nodes={};}
    async function setupAudioGraph(params){
      if(!state.Tone)return loader.textContent='Tone.js not loaded.';
      if(!state.isAudioStarted){try{await state.Tone.start();state.isAudioStarted=true;}catch(e){loader.textContent="Failed to start audio.";return false;}}
      disposeNodes();
      const T=state.Tone,osc1=state.nodes.osc1=new T.Oscillator(params.osc1.note,params.osc1.type).start();
      let osc2=null;if(params.osc2)osc2=state.nodes.osc2=new T.Oscillator(params.osc2.note,params.osc2.type).start();
      const filter=state.nodes.filter=new T.Filter(params.filter.frequency,params.filter.type),
        lfo=state.nodes.lfo=new T.LFO(params.lfo.frequency,params.lfo.min,params.lfo.max).start(),
        modulatedGain=state.nodes.modulatedGain=new T.Gain(1),volume=state.nodes.volume=new T.Volume(-10);
      lfo.connect(filter.frequency);
      if(params.interaction==='am'&&osc2){osc1.connect(modulatedGain);osc2.connect(modulatedGain.gain);modulatedGain.connect(volume);}
      else if(params.interaction==='fm'&&osc2){osc2.connect(osc1.frequency);osc1.connect(volume);}
      else{osc1.connect(volume);if(osc2)osc2.connect(volume);}
      volume.connect(filter);filter.toDestination();
      state.Tone.Destination.mute=true;muteBtn.textContent="Unmute";
      const ana=state.nodes.analyser=T.context.createAnalyser();ana.fftSize=2048;filter.connect(ana);
      return true;
    }
    // --- Animation ---
    const defaultVis = {hueBase:200,hueRange:100,lineWidth:2,rotationSpeed:.05,pulseSpeed:.2,size:.8,useGlow:true};
    (function animate(){
      const time=performance.now()/1e3,ana=state.nodes.analyser;
      let data=(state.isAudioStarted&&state.isPlaying&&ana)?(ana.getFloatTimeDomainData(state.liveDataBuffer=state.liveDataBuffer||new Float32Array(ana.fftSize)),state.liveDataBuffer):(state.dummyData=state.dummyData||generateDummyData());
      visualIndicator.textContent=(state.isAudioStarted&&state.isPlaying&&ana)?"Audio Live":(state.isAudioStarted?"Muted":"Silent Mode");
      visualIndicator.className="visual-indicator "+((state.isAudioStarted&&state.isPlaying&&ana)?"indicator-audio":"indicator-silent");
      const p=state.currentParams.visual||defaultVis,shapeKey=state.currentParams.shapeKey||"circle",shapeFunc=baseShapes[shapeKey]?.draw||drawCircle;
      ctx.clearRect(0,0,600,600);
      const hue=(p.hueBase+time*15)%360,sat=80+15*Math.sin(time*.4),light=50+25*Math.sin(time*.25);
      ctx.strokeStyle=`hsl(${hue},${sat}%,${light}%)`;ctx.lineWidth=p.lineWidth;ctx.lineJoin=ctx.lineCap='round';ctx.shadowBlur=p.useGlow?12:0;ctx.shadowColor=ctx.strokeStyle;
      shapeFunc(data,time,p); state.nodes.animId=requestAnimationFrame(animate);
    })();
    // --- Core Audio Toggle ---
    async function toggleAudio(){
      if(!state.isAudioStarted){if(await setupAudioGraph(state.currentParams)){state.isPlaying=true;state.Tone.Destination.mute=false;startBtn.textContent="Stop Audio";muteBtn.disabled=false;loader.textContent="Audio is now playing.";}
      }else if(state.isPlaying){state.Tone.Destination.mute=true;state.isPlaying=false;startBtn.textContent="Start Audio";loader.textContent="Audio muted.";}
      else{state.Tone.Destination.mute=false;state.isPlaying=true;startBtn.textContent="Stop Audio";loader.textContent="Audio unmuted.";}
    }
    // --- UI Events ---
    startBtn.onclick = canvas.onclick = toggleAudio;
    muteBtn.onclick = ()=>{if(!state.Tone||!state.isAudioStarted)return;const m=state.Tone.Destination.mute=!state.Tone.Destination.mute;muteBtn.textContent=m?"Unmute":"Mute";loader.textContent=m?"Audio muted.":"Audio unmuted.";}
    shapeSel.onchange=()=>{
      if(state.currentParams){
        let np=state.isSeedMode&&state.predefinedSets[shapeSel.value]?state.predefinedSets[shapeSel.value]:{...state.currentParams,shapeKey:shapeSel.value};
        if(np.visual){delete np.visual.lissaA;delete np.visual.lissaB;delete np.visual.lissaDelta;delete np.visual.spiralTurns;delete np.visual.roseK;}
        state.currentParams=np;
      }
    };
    randomizeBtn.onclick=async()=>{
      let np=state.isSeedMode?generateRandomParams(null,state.seedGenerator):generateRandomParams();
      state.currentParams=np;shapeSel.value=np.shapeKey;state.dummyData=null;
      if(state.isAudioStarted)await setupAudioGraph(np);
      loader.textContent=state.isAudioStarted?"Audio randomized and playing.":"New visual pattern generated. Click 'Start Audio' to hear.";
    };
    modeToggleBtn.onclick=()=>{
      state.isSeedMode=!state.isSeedMode;
      if(state.isSeedMode){
        modeToggleBtn.textContent="Mode: Seed";modeToggleBtn.className="seed-mode";
        const seed="MyUniqueSeed_v1";state.seedGenerator=mulberry32(seed);generatePredefinedSets(seed);
        const k=Object.keys(state.predefinedSets)[0];state.currentParams=state.predefinedSets[k];shapeSel.value=k;
        loader.textContent=`Seed Mode (${seed}) loaded. Showing '${baseShapes[k].name}'.`;
      }else{
        modeToggleBtn.textContent="Mode: Random";modeToggleBtn.className="random-mode";state.seedGenerator=null;
        loader.textContent="Random Mode. New randomizations will use Math.random.";
      }
    };
    // --- Tone.js Loader ---
    function loadToneJSAndBoot({toneUrl,setLoaderStatus,state,boot}){
      setLoaderStatus('Loading Audio Engine...');
      import(toneUrl).then(mod=>{
        state.Tone=window.Tone??mod?.default??mod;
        if(state.Tone){setLoaderStatus(`Tone.js v${state.Tone.version??"?"} ready.`);boot();}
        else throw new Error('Tone.js not found.');
      }).catch(e=>{
        setLoaderStatus('Failed to load Tone.js. App cannot start.',1);console.error(e);
      });
    }
    // --- Boot ---
    loadToneJSAndBoot({
      toneUrl: 'https://ordinals.com/content/04813d7748d918bd8a3069cb1823ebc9586f0ce16cd6a97a784581ec38d13062i0',
      setLoaderStatus:(msg,err)=>{loader.textContent=msg;loader.style.color=err?"red":"#aaa";startBtn.disabled=!!err;muteBtn.disabled=true;randomizeBtn.disabled=!!err;modeToggleBtn.disabled=!!err;},
      state,
      boot:()=>{
        loader.textContent="Audio engine ready. Generating initial pattern...";
        startBtn.disabled=false;muteBtn.disabled=true;randomizeBtn.disabled=false;modeToggleBtn.disabled=false;
        generatePredefinedSets("InitialSeed_v1");
        const initial="circle";
        state.currentParams=state.predefinedSets[initial]||generateRandomParams(initial);
        state.dummyData=generateDummyData();
        shapeSel.value=state.currentParams.shapeKey;
        loader.textContent="Pattern generated (Seed Mode ready). Click 'Start Audio' OR the image to hear sound.";
        
        // Initialize keyboard interface after boot
        setupKeyboardInterface();
      }
    });
    startBtn.disabled=true;muteBtn.disabled=true;randomizeBtn.disabled=true;modeToggleBtn.disabled=true;
  </script>
</body>
</html>