<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Oscilloscope Visualizer</title>
  <script type="module">
    // --- Pseudorandom Number Generator (Seed-based) ---
    class PRNG {
      constructor(seed = 1) {
        this.seed = seed;
      }
      next() {
        this.seed = (this.seed * 9301 + 49297) % 233280;
        return this.seed / 233280;
      }
      nextInRange(min, max) {
        return min + (max - min) * this.next();
      }
    }

    // --- Dynamically Load Tone.js ---
    class ToneLoader extends HTMLElement {
      connectedCallback() {
        if (window.Tone) {
          this.onLoad();
          return;
        }
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/tone@14.8.49/build/Tone.js';
        script.onload = () => {
          console.log('Tone.js loaded');
          this.onLoad();
        };
        document.head.appendChild(script);
      }

      onLoad() {
        this.dispatchEvent(new CustomEvent('tone-ready'));
      }
    }
    customElements.define('tone-loader', ToneLoader);

    // --- Oscilloscope Canvas ---
    class ScopeCanvas extends HTMLElement {
      constructor() {
        super();
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.audioData = new Float32Array(2048);
        this.shape = 'circle';
        this.params = {};
        this.prng = new PRNG(1);
        this.attachShadow({ mode: 'open' }).appendChild(this.canvas);
      }

      connectedCallback() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.draw();
      }

      resize() {
        const rect = this.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
      }

      setAudioData(data) {
        this.audioData = data;
      }

      setShape(shape, params = {}) {
        this.shape = shape;
        this.params = params;
        this.prng = new PRNG(params.seed || 1);
      }

      draw() {
        const { ctx, canvas } = this;
        const w = canvas.width;
        const h = canvas.height;
        const cx = w / 2;
        const cy = h / 2;
        const time = performance.now() / 1000;

        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, w, h);

        // Draw waveform
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(0, 255, 200, 0.7)';
        ctx.lineWidth = 1.5;
        const slice = w / this.audioData.length;
        for (let i = 0; i < this.audioData.length; i++) {
          const x = i * slice;
          const y = cy + this.audioData[i] * h * 0.3;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Draw shape
        ctx.save();
        ctx.translate(cx, cy);

        const scale = Math.min(w, h) * 0.3;
        const amp = 1 + Math.sin(time * 4) * 0.2;

        switch (this.shape) {
          case 'circle':
            this.drawCircle(ctx, scale, time);
            break;
          case 'square':
            this.drawSquare(ctx, scale, time);
            break;
          case 'butterfly':
            this.drawButterfly(ctx, scale, time);
            break;
          case 'lissajous':
            this.drawLissajous(ctx, scale, time);
            break;
          case 'spirograph':
            this.drawSpirograph(ctx, scale, time);
            break;
          case 'harmonograph':
            this.drawHarmonograph(ctx, scale, time);
            break;
        }
        ctx.restore();

        requestAnimationFrame(() => this.draw());
      }

      drawCircle(ctx, scale, t) {
        const freq = this.params.freq || 0.5;
        const r = scale * (0.8 + 0.2 * Math.sin(t * freq * 6));
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.strokeStyle = `hsl(${(t * 30) % 360}, 80%, 60%)`;
        ctx.lineWidth = 3;
        ctx.stroke();
      }

      drawSquare(ctx, scale, t) {
        const rot = t * (this.params.freq || 0.5) * 2;
        ctx.rotate(rot);
        const s = scale * (1 + 0.2 * Math.sin(t * 3));
        ctx.strokeStyle = '#ff6b6b';
        ctx.lineWidth = 4;
        ctx.strokeRect(-s, -s, s * 2, s * 2);
      }

      drawButterfly(ctx, scale, t) {
        ctx.beginPath();
        const N = 2000;
        for (let i = 0; i < N; i++) {
          const theta = (i / N) * Math.PI * 20;
          const r = Math.exp(Math.sin(theta)) - 2 * Math.cos(4 * theta) - Math.pow(Math.sin(theta / 12), 5);
          const x = r * Math.sin(theta) * scale * 0.4;
          const y = r * Math.cos(theta) * scale * 0.4;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = '#c792ea';
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }

      drawLissajous(ctx, scale, t) {
        const a = this.prng.nextInRange(1, 5);
        const b = this.prng.nextInRange(1, 5);
        const delta = this.prng.next() * Math.PI;
        ctx.beginPath();
        const N = 1000;
        for (let i = 0; i <= N; i++) {
          const theta = (i / N) * Math.PI * 12;
          const x = Math.sin(a * theta + delta) * scale;
          const y = Math.sin(b * theta) * scale;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = '#80deea';
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      drawSpirograph(ctx, scale, t) {
        const R = 1.5;
        const r = 0.6;
        const d = 0.5;
        ctx.beginPath();
        const N = 2000;
        for (let i = 0; i < N; i++) {
          const theta = (i / N) * Math.PI * 10;
          const x = (R - r) * Math.sin(theta) + d * Math.sin(((R - r) / r) * theta);
          const y = (R - r) * Math.cos(theta) - d * Math.cos(((R - r) / r) * theta);
          if (i === 0) ctx.moveTo(x * scale, y * scale);
          else ctx.lineTo(x * scale, y * scale);
        }
        ctx.strokeStyle = '#ffeb3b';
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }

      drawHarmonograph(ctx, scale, t) {
        const decay = 0.999;
        const x =
          Math.sin(t * 2 + 0.3) * 0.8 * scale * decay +
          Math.sin(t * 1.9) * 0.5 * scale * decay;
        const y =
          Math.sin(t * 2.1 + 0.7) * 0.7 * scale * decay +
          Math.sin(t * 2.3) * 0.4 * scale * decay;

        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI * 2);
        ctx.fillStyle = '#f44336';
        ctx.fill();

        const trail = 50;
        for (let i = 1; i < trail; i++) {
          const dt = t - i * 0.05;
          const tx =
            Math.sin(dt * 2 + 0.3) * 0.8 * scale * Math.pow(decay, i) +
            Math.sin(dt * 1.9) * 0.5 * scale * Math.pow(decay, i);
          const ty =
            Math.sin(dt * 2.1 + 0.7) * 0.7 * scale * Math.pow(decay, i) +
            Math.sin(dt * 2.3) * 0.4 * scale * Math.pow(decay, i);
          ctx.beginPath();
          ctx.arc(tx, ty, 1, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(244, 67, 54, ${0.8 - i / trail})`;
          ctx.fill();
        }
      }
    }
    customElements.define('scope-canvas', ScopeCanvas);

    // --- Audio & Sequencer Controls ---
    class OscControls extends HTMLElement {
      constructor() {
        super();
        this.audioStarted = false;
        this.muted = false;
        this.sequencerActive = false;
        this.sequence = Array(8).fill(null);
        this.seqIndex = 0;
        this.stepTime = 500; // ms
        this.synth = null;
        this.analyser = null;
        this.audioData = new Float32Array(2048);
        this.recording = false;
        this.seqInterval = null;
        this.seed = 1;
        this.shapes = ['circle', 'square', 'butterfly', 'lissajous', 'spirograph', 'harmonograph'];
        this.attachShadow({ mode: 'open' });
      }

      connectedCallback() {
        this.render();
        this.bindEvents();
      }

      render() {
        this.shadowRoot.innerHTML = `
          <style>
            :host { 
              display: block; 
              background: #1e1e1e; 
              color: #eee; 
              padding: 15px; 
              font-family: 'Courier New', monospace;
              border-bottom: 1px solid #333;
            }
            button { 
              background: #333; 
              color: white; 
              border: none; 
              padding: 8px 12px; 
              margin: 5px; 
              cursor: pointer; 
              border-radius: 4px;
            }
            button:hover { background: #555; }
            select, input { 
              padding: 8px; 
              margin: 5px; 
              background: #333; 
              color: white; 
              border: 1px solid #555; 
              border-radius: 4px;
            }
            .row { display: flex; flex-wrap: wrap; align-items: center; margin: 10px 0; }
            .seq-step { 
              width: 30px; height: 30px; 
              margin: 2px; 
              background: #222; 
              display: flex; 
              align-items: center; 
              justify-content: center; 
              font-size: 12px; 
              cursor: pointer;
              border: 1px solid #444;
            }
            .seq-step.active { background: #00c853; }
            .seq-controls { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
            .seq-grid { display: flex; flex-wrap: wrap; width: 250px; margin: 10px 0; }
            .slider { width: 100px; }
          </style>

          <div class="row">
            <button id="startBtn">Start Audio + Draw</button>
            <button id="muteBtn">Unmute</button>
            <select id="shapeSelect">
              ${this.shapes.map(s => `<option value="${s}">${s.charAt(0).toUpperCase() + s.slice(1)}</option>`).join('')}
            </select>
            <div>
              <input type="number" id="seedInput" value="1" min="1" max="99999" style="width: 80px"/>
              <button id="setSeed">Set Seed</button>
            </div>
          </div>

          <div class="row">
            <button id="seqToggle">Create Sequence</button>
          </div>

          <div id="sequencer" style="display:none;">
            <div class="seq-grid" id="seqGrid">
              ${Array(8).fill().map((_, i) => `<div class="seq-step" data-index="${i}">${i+1}</div>`).join('')}
            </div>
            <div class="seq-controls">
              <button id="seqPlay">Play</button>
              <button id="seqStop">Stop</button>
              <input type="range" class="slider" id="stepTime" min="100" max="1000" value="500" step="50"/>
              <span id="timeLabel">500ms</span>
            </div>
            <div>Use keys 1-6 to record steps</div>
          </div>
        `;
      }

      bindEvents() {
        const $ = sel => this.shadowRoot.querySelector(sel);

        // Audio & shape control
        $('button#startBtn').addEventListener('click', () => this.startAudio());
        $('button#muteBtn').addEventListener('click', () => this.toggleMute());
        $('select#shapeSelect').addEventListener('change', (e) => this.changeShape(e.target.value));
        $('button#setSeed').addEventListener('click', () => this.setSeed());

        // Sequencer
        $('button#seqToggle').addEventListener('click', () => {
          const seq = $('#sequencer');
          seq.style.display = seq.style.display === 'none' ? 'block' : 'none';
        });

        // Step time
        const stepTimeSlider = $('#stepTime');
        stepTimeSlider.addEventListener('input', () => {
          this.stepTime = stepTimeSlider.value;
          $('#timeLabel').textContent = this.stepTime + 'ms';
        });

        // Play/Stop sequence
        $('#seqPlay').addEventListener('click', () => this.playSequence());
        $('#seqStop').addEventListener('click', () => this.stopSequence());

        // Step recording
        this.shadowRoot.querySelectorAll('.seq-step').forEach(el => {
          el.addEventListener('click', (e) => {
            const index = e.target.dataset.index;
            this.promptStep(index);
          });
        });

        // Keyboard input for recording
        document.addEventListener('keydown', (e) => {
          if (!this.sequencerActive) return;
          if (e.key >= '1' && e.key <= '6') {
            const shapeIndex = parseInt(e.key) - 1;
            const shape = this.shapes[shapeIndex];
            const step = this.seqIndex;
            this.sequence[step] = { shape, seed: this.seed };
            this.updateSequenceUI();
            this.changeShape(shape);
          }
        });
      }

      async startAudio() {
        if (this.audioStarted) return;
        await window.Tone.start();
        this.synth = new Tone.PolySynth(Tone.Synth).toDestination();
        this.analyser = new Tone.Analyser('waveform', 2048);
        this.synth.connect(this.analyser);
        this.audioStarted = true;
        this.changeShape('circle');
        this.updateStatus();
      }

      toggleMute() {
        this.muted = !this.muted;
        Tone.Destination.mute = this.muted;
        this.shadowRoot.querySelector('#muteBtn').textContent = this.muted ? 'Unmute' : 'Mute';
      }

      changeShape(shape) {
        if (!this.audioStarted) return;
        const params = { seed: this.seed };
        this.dispatchEvent(new CustomEvent('shape-change', {
          detail: { shape, params }
        }));
        this.playTone(shape);
      }

      playTone(shape) {
        if (this.muted) return;
        const baseNotes = { circle: 'C4', square: 'D4', butterfly: 'E4', lissajous: 'F4', spirograph: 'G4', harmonograph: 'A4' };
        const note = baseNotes[shape];
        this.synth.triggerAttackRelease(note, 0.1);
      }

      setSeed() {
        const seed = parseInt(this.shadowRoot.querySelector('#seedInput').value) || 1;
        this.seed = seed;
        this.changeShape(this.currentShape || 'circle');
      }

      promptStep(index) {
        const shape = prompt(`Enter shape (1-6) for step ${parseInt(index)+1}:`);
        const n = parseInt(shape);
        if (n >= 1 && n <= 6) {
          const selectedShape = this.shapes[n - 1];
          this.sequence[index] = { shape: selectedShape, seed: this.seed };
          this.updateSequenceUI();
        }
      }

      updateSequenceUI() {
        this.shadowRoot.querySelectorAll('.seq-step').forEach((el, i) => {
          el.classList.toggle('active', !!this.sequence[i]);
          el.textContent = this.sequence[i] ? (i+1) : '?';
        });
      }

      playSequence() {
        if (this.seqInterval) return;
        if (!this.sequence.some(s => s)) {
          alert("Record at least one step!");
          return;
        }
        this.sequencerActive = true;
        this.seqIndex = 0;
        this.seqInterval = setInterval(() => {
          const step = this.sequence[this.seqIndex];
          if (step) {
            this.changeShape(step.shape);
            this.dispatchEvent(new CustomEvent('shape-change', {
              detail: step
            }));
          }
          this.seqIndex = (this.seqIndex + 1) % 8;
        }, this.stepTime);
      }

      stopSequence() {
        if (this.seqInterval) {
          clearInterval(this.seqInterval);
          this.seqInterval = null;
        }
        this.sequencerActive = false;
      }

      getAudioData() {
        return this.analyser ? this.analyser.getValue() : new Float32Array(2048);
      }
    }
    customElements.define('osc-controls', OscControls);

    // --- Main App ---
    class OscApp extends HTMLElement {
      constructor() {
        super();
        this.attachShadow({ mode: 'open' });
      }

      connectedCallback() {
        this.render();
        this.bindEvents();
      }

      render() {
        this.shadowRoot.innerHTML = `
          <style>
            :host {
              display: block;
              height: 100vh;
              font-family: 'Arial', sans-serif;
              background: #121212;
              color: #eee;
            }
            .container {
              display: flex;
              flex-direction: column;
              height: 100%;
            }
            scope-canvas {
              flex: 1;
              display: block;
              background: #000;
            }
            osc-controls {
              flex-shrink: 0;
            }
          </style>
          <div class="container">
            <tone-loader id="toneLoader"></tone-loader>
            <osc-controls id="controls"></osc-controls>
            <scope-canvas id="canvas"></scope-canvas>
          </div>
        `;

        this.toneLoader = this.shadowRoot.getElementById('toneLoader');
        this.controls = this.shadowRoot.getElementById('controls');
        this.canvas = this.shadowRoot.getElementById('canvas');
      }

      bindEvents() {
        this.toneLoader.addEventListener('tone-ready', () => {
          console.log('App ready');
        });

        this.controls.addEventListener('shape-change', (e) => {
          this.canvas.setShape(e.detail.shape, e.detail);
        });

        // Update canvas with audio data
        this.rafLoop();
      }

      rafLoop() {
        if (this.controls.getAudioData) {
          const data = this.controls.getAudioData();
          this.canvas.setAudioData(data);
        }
        requestAnimationFrame(() => this.rafLoop());
      }
    }
    customElements.define('osc-app', OscApp);
  </script>

  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <osc-app></osc-app>
</body>
</html>