<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Oscilloscope Visualizer</title>
  <script type="module">
    // --- PSEUDORANDOM NUMBER GENERATOR (Seed-based) ---
    class PRNG {
      constructor(seed = 1) {
        this.seed = seed;
      }
      next() {
        this.seed = (this.seed * 9301 + 49297) % 233280;
        return this.seed / 233280;
      }
      nextInRange(min, max) {
        return min + (max - min) * this.next();
      }
      nextInt(min, max) {
        return Math.floor(this.nextInRange(min, max + 1));
      }
    }

    // --- DYNAMIC TONE.JS LOADER WEB COMPONENT ---
    class ToneLoader extends HTMLElement {
      connectedCallback() {
        if (window.Tone) {
          this.onLoad();
          return;
        }
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/tone@14.8.49/build/Tone.min.js';
        script.onload = () => this.onLoad();
        document.head.appendChild(script);
      }

      onLoad() {
        this.dispatchEvent(new CustomEvent('tone-ready'));
      }
    }
    customElements.define('tone-loader', ToneLoader);

    // --- SCOPE CANVAS WEB COMPONENT ---
    class ScopeCanvas extends HTMLElement {
      constructor() {
        super();
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.audioData = new Float32Array(2048);
        this.shape = 'circle';
        this.params = {};
        this.prng = new PRNG(1);
        this.attachShadow({ mode: 'open' }).appendChild(this.canvas);
      }

      connectedCallback() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.draw();
      }

      resize() {
        const rect = this.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
      }

      setAudioData(data) {
        this.audioData = data;
        this.draw();
      }

      setShape(shape, params = {}) {
        this.shape = shape;
        this.params = params;
        this.prng = new PRNG(params.seed || 1);
      }

      draw() {
        const { ctx, canvas } = this;
        const w = canvas.width;
        const h = canvas.height;
        const cx = w / 2;
        const cy = h / 2;
        const time = performance.now() / 1000;
        const scale = Math.min(w, h) * 0.4;

        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, w, h);

        // Draw waveform
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(0, 255, 200, 0.6)';
        ctx.lineWidth = 2;
        const slice = w / this.audioData.length;
        for (let i = 0; i < this.audioData.length; i++) {
          const x = i * slice;
          const y = h / 2 + this.audioData[i] * h * 0.3;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Draw shape
        ctx.save();
        ctx.translate(cx, cy);

        switch (this.shape) {
          case 'circle':
            this.drawCircle(ctx, time, scale);
            break;
          case 'square':
            this.drawSquare(ctx, time, scale);
            break;
          case 'butterfly':
            this.drawButterfly(ctx, time, scale);
            break;
          case 'lissajous':
            this.drawLissajous(ctx, time, scale);
            break;
          case 'spirograph':
            this.drawSpirograph(ctx, time, scale);
            break;
          case 'harmonograph':
            this.drawHarmonograph(ctx, time, scale);
            break;
        }
        ctx.restore();

        requestAnimationFrame(() => this.draw());
      }

      drawCircle(ctx, t, scale) {
        const freq = this.params.freq || 1;
        const r = scale * (0.5 + 0.5 * Math.sin(t * freq * 2));
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.strokeStyle = `hsl(${(t * 30) % 360}, 80%, 60%)`;
        ctx.lineWidth = 4;
        ctx.stroke();
      }

      drawSquare(ctx, t, scale) {
        const s = scale * (0.6 + 0.4 * Math.sin(t * 1.5));
        const rot = t * 0.5;
        ctx.rotate(rot);
        ctx.strokeStyle = `hsl(${(t * 20 + 120) % 360}, 80%, 60%)`;
        ctx.lineWidth = 4;
        ctx.strokeRect(-s, -s, s * 2, s * 2);
      }

      drawButterfly(ctx, t, scale) {
        const n = 2000;
        const dt = Math.PI * 2 / n;
        ctx.beginPath();
        for (let i = 0; i < n; i++) {
          const theta = i * dt;
          const r = Math.exp(Math.sin(theta)) - 2 * Math.cos(4 * theta) + Math.sin((2 * theta - Math.PI) / 24) ** 5;
          const x = r * Math.cos(theta) * scale * 0.3;
          const y = r * Math.sin(theta) * scale * 0.3;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = `hsl(${(t * 10 + 240) % 360}, 90%, 60%)`;
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      drawLissajous(ctx, t, scale) {
        const a = this.prng.nextInRange(1, 5);
        const b = this.prng.nextInRange(1, 5);
        const delta = this.prng.next() * Math.PI * 2;
        const n = 500;
        ctx.beginPath();
        for (let i = 0; i <= n; i++) {
          const theta = (i / n) * Math.PI * 2;
          const x = Math.sin(a * theta + delta) * scale;
          const y = Math.sin(b * theta) * scale * 0.8;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = `hsl(${(t * 15 + 60) % 360}, 85%, 60%)`;
        ctx.lineWidth = 3;
        ctx.stroke();
      }

      drawSpirograph(ctx, t, scale) {
        const R = 1.5;
        const r = 0.5;
        const d = 0.5;
        const n = 1000;
        ctx.beginPath();
        for (let i = 0; i < n; i++) {
          const theta = (i / n) * Math.PI * 10;
          const x = (R - r) * Math.cos(theta) + d * Math.cos((R - r) * theta / r);
          const y = (R - r) * Math.sin(theta) - d * Math.sin((R - r) * theta / r);
          const sx = x * scale * 0.4;
          const sy = y * scale * 0.4;
          if (i === 0) ctx.moveTo(sx, sy);
          else ctx.lineTo(sx, sy);
        }
        ctx.strokeStyle = `hsl(${(t * 25 + 300) % 360}, 90%, 60%)`;
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      drawHarmonograph(ctx, t, scale) {
        const decay = 0.05;
        const x1 = Math.sin(t * 3 + 0.3) * Math.cos(t * 0.7) * Math.exp(-decay * t);
        const y1 = Math.sin(t * 2) * Math.exp(-decay * t);
        const x2 = Math.cos(t * 2.3) * Math.sin(t * 0.5) * Math.exp(-decay * t);
        const y2 = Math.cos(t * 1.7 + 0.2) * Math.exp(-decay * t);
        const x = (x1 + x2) * scale;
        const y = (y1 + y2) * scale;
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI * 2);
        ctx.fillStyle = 'hotpink';
        ctx.fill();
      }
    }
    customElements.define('scope-canvas', ScopeCanvas);

    // --- AUDIO CONTROLS & SEQUENCER WEB COMPONENT ---
    class OscControls extends HTMLElement {
      constructor() {
        super();
        this.isAudioStarted = false;
        this.isMuted = false;
        this.isPlaying = false;
        this.sequencerOpen = false;
        this.sequence = Array(8).fill(null);
        this.currentStep = 0;
        this.stepTime = 0.25; // seconds
        this.toneContext = null;
        this.analyser = null;
        this.synths = {};
        this.currentSynth = null;
        this.sequencerInterval = null;
        this.shapes = ['circle', 'square', 'butterfly', 'lissajous', 'spirograph', 'harmonograph'];
        this.prng = new PRNG(1);

        this.shadow = this.attachShadow({ mode: 'open' });
        this.render();
        this.bindEvents();
      }

      render() {
        this.shadow.innerHTML = `
          <style>
            :host { display: block; padding: 10px; font-family: 'Courier New', monospace; color: #eee; background: #222; }
            button, select, input { margin: 5px; padding: 8px; font-size: 14px; border: none; border-radius: 4px; }
            button { background: #006; color: white; cursor: pointer; }
            button:hover { background: #008; }
            button:disabled { background: #444; cursor: not-allowed; }
            select, input { background: #333; color: #eee; }
            .controls { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
            .sequencer { margin-top: 15px; padding: 10px; background: #333; border-radius: 6px; }
            .steps { display: flex; gap: 5px; margin: 10px 0; }
            .step { width: 40px; height: 40px; background: #444; display: flex; align-items: center; justify-content: center; font-size: 18px; cursor: pointer; }
            .step.active { background: #00f; color: white; }
            .step.recording { background: #f00; color: white; }
            .seed { display: flex; gap: 5px; align-items: center; }
          </style>
          <div class="controls">
            <button id="startBtn">Start Audio + Draw</button>
            <button id="muteBtn">Unmute</button>
            <select id="shapeSelect">${this.shapes.map(s => `<option value="${s}">${s.charAt(0).toUpperCase() + s.slice(1)}</option>`).join('')}</select>
            <button id="seqBtn">Create Sequence</button>
            <div class="seed">
              <input type="number" id="seedInput" value="1" min="1" max="99999" style="width: 80px;">
              <button id="setSeedBtn">Set Seed</button>
            </div>
          </div>
          <div id="sequencer" class="sequencer" style="display:none;">
            <h4>Step Sequencer (Press 1-6 to record)</h4>
            <div class="steps"></div>
            <div>
              <button id="playSeqBtn">Play</button>
              <button id="stopSeqBtn">Stop</button>
              <input type="range" id="speedInput" min="0.1" max="1" step="0.05" value="0.25" style="width:100px;">
              <span>${this.stepTime}s</span>
            </div>
          </div>
        `;
        this.updateSteps();
      }

      bindEvents() {
        const $ = id => this.shadow.getElementById(id);

        $('startBtn').onclick = () => this.startAudio();
        $('muteBtn').onclick = () => this.toggleMute();
        $('shapeSelect').onchange = () => this.changeShape();
        $('seqBtn').onclick = () => this.toggleSequencer();
        $('setSeedBtn').onclick = () => this.setSeed();
        $('playSeqBtn').onclick = () => this.playSequence();
        $('stopSeqBtn').onclick = () => this.stopSequence();
        $('speedInput').oninput = () => {
          this.stepTime = parseFloat($('speedInput').value);
          $('speedInput').nextElementSibling.textContent = `${this.stepTime}s`;
          if (this.isPlaying) this.restartSequencer();
        };

        document.addEventListener('keydown', e => {
          if (!this.sequencerOpen) return;
          const key = parseInt(e.key);
          if (key >= 1 && key <= 6) {
            e.preventDefault();
            this.recordStep(key - 1);
          }
        });
      }

      startAudio() {
        if (this.isAudioStarted) return;
        this.isAudioStarted = true;
        $('startBtn').disabled = true;
        $('startBtn').textContent = "Audio Started";

        // Initialize Tone.js
        this.toneContext = new Tone.Context();
        Tone.setContext(this.toneContext);
        this.analyser = new Tone.Analyser("waveform", 2048);
        this.analyser.connect(Tone.Destination);

        // Create synths
        this.shapes.forEach(shape => {
          const synth = new Tone.Synth({
            oscillator: { type: this.getOscType(shape) },
            envelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 0.1 }
          }).connect(this.analyser).connect(Tone.Destination);
          this.synths[shape] = synth;
        });

        this.changeShape();
        this.emit('audio-started');
      }

      getOscType(shape) {
        const types = {
          circle: 'sine',
          square: 'square',
          butterfly: 'triangle',
          lissajous: 'sawtooth',
          spirograph: 'pulse',
          harmonograph: 'fmsine'
        };
        return types[shape] || 'sine';
      }

      toggleMute() {
        this.isMuted = !this.isMuted;
        Tone.Destination.mute = this.isMuted;
        this.shadow.getElementById('muteBtn').textContent = this.isMuted ? 'Unmute' : 'Mute';
      }

      changeShape() {
        if (!this.isAudioStarted) return;
        const shape = this.shadow.getElementById('shapeSelect').value;
        this.currentSynth = this.synths[shape];
        const seed = parseInt(this.shadow.getElementById('seedInput').value);
        this.prng = new PRNG(seed);
        const freq = this.prng.nextInRange(200, 800);
        const params = { seed, freq };
        this.currentSynth.triggerAttack(freq);
        this.emit('shape-changed', { shape, params });
      }

      setSeed() {
        const seed = parseInt(this.shadow.getElementById('seedInput').value);
        if (isNaN(seed) || seed <= 0) return;
        this.prng = new PRNG(seed);
        this.changeShape();
      }

      toggleSequencer() {
        this.sequencerOpen = !this.sequencerOpen;
        this.shadow.getElementById('sequencer').style.display = this.sequencerOpen ? 'block' : 'none';
        this.shadow.getElementById('seqBtn').textContent = this.sequencerOpen ? 'Close Sequencer' : 'Create Sequence';
      }

      recordStep(index) {
        const shapeIndex = index;
        const stepEls = this.shadow.querySelectorAll('.step');
        stepEls[this.currentStep].classList.remove('recording');
        this.sequence[this.currentStep] = this.shapes[shapeIndex];
        stepEls[this.currentStep].textContent = shapeIndex + 1;
        this.currentStep = (this.currentStep + 1) % 8;
        stepEls[this.currentStep].classList.add('recording');
      }

      updateSteps() {
        const container = this.shadow.querySelector('.steps');
        container.innerHTML = '';
        this.sequence.forEach((s, i) => {
          const el = document.createElement('div');
          el.className = 'step';
          el.textContent = s ? this.shapes.indexOf(s) + 1 : '?';
          if (i === this.currentStep) el.classList.add('recording');
          container.appendChild(el);
        });
      }

      playSequence() {
        if (this.isPlaying) return;
        this.isPlaying = true;
        this.currentStep = 0;
        this.updateSteps();
        this.shadow.querySelector('.step').classList.add('recording');
        this.sequencerInterval = setInterval(() => {
          const shape = this.sequence[this.currentStep];
          if (shape && this.synths[shape]) {
            this.synths[shape].triggerAttackRelease('C4', 0.2);
            this.emit('shape-changed', { 
              shape, 
              params: { seed: parseInt(this.shadow.getElementById('seedInput').value), freq: 440 }
            });
          }
          this.currentStep = (this.currentStep + 1) % 8;
          this.updateSteps();
        }, this.stepTime * 1000);
      }

      stopSequence() {
        if (!this.isPlaying) return;
        clearInterval(this.sequencerInterval);
        this.isPlaying = false;
        this.shadow.querySelectorAll('.step').forEach(el => el.classList.remove('recording'));
      }

      restartSequencer() {
        this.stopSequence();
        this.playSequence();
      }

      emit(event, detail = null) {
        this.dispatchEvent(new CustomEvent(event, { detail }));
      }
    }
    customElements.define('osc-controls', OscControls);

    // --- MAIN APP COMPONENT ---
    class OscApp extends HTMLElement {
      constructor() {
        super();
        this.audioData = new Float32Array(2048).fill(0);
        this.attachShadow({ mode: 'open' });
      }

      connectedCallback() {
        this.shadow.innerHTML = `
          <style>
            :host { display: block; height: 100vh; display: flex; flex-direction: column; font-family: Arial, sans-serif; }
            scope-canvas { flex: 1; background: #000; display: block; }
            osc-controls { flex-shrink: 0; }
          </style>
          <tone-loader id="toneLoader"></tone-loader>
          <scope-canvas id="scope"></scope-canvas>
          <osc-controls id="controls"></osc-controls>
        `;

        this.scope = this.shadow.getElementById('scope');
        this.controls = this.shadow.getElementById('controls');
        this.toneLoader = this.shadow.getElementById('toneLoader');

        this.toneLoader.addEventListener('tone-ready', () => {
          console.log('Tone.js loaded');
        });

        this.controls.addEventListener('audio-started', () => {
          this.startAudioAnalysis();
        });

        this.controls.addEventListener('shape-changed', (e) => {
          this.scope.setShape(e.detail.shape, e.detail.params);
        });
      }

      startAudioAnalysis() {
        const analyser = Tone.getDestination().chain(new Tone.Analyser("waveform", 2048))[0];
        const tick = () => {
          this.audioData = analyser.getValue();
          this.scope.setAudioData(this.audioData);
          requestAnimationFrame(tick);
        };
        tick();
      }
    }
    customElements.define('osc-app', OscApp);
  </script>
  <style>
    body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; }
    osc-app { width: 100%; height: 100%; }
  </style>
</head>
<body>
  <osc-app></osc-app>
</body>
</html>