// osc-synth.js
export class OscSynth {
    /**
     * Create a new OscSynth instance.  This class is responsible for
     * constructing a polyphonic synth voice with optional drone and
     * scheduling a deterministic sequence of notes based on the
     * supplied parameters.  Effects such as filters, phasers,
     * distortion, chorus and reverb are inserted into the signal path
     * according to the preset.  An analyser node is exposed to
     * visualise the outgoing audio.  The Tone.Transport will be
     * configured with the preset's tempo and started when connect() is
     * called.
     *
     * @param {typeof Tone} Tone - Tone.js reference (must be loaded)
     * @param {object} params - Sound preset generated by OscControls
     */
    constructor(Tone, params) {
      if (!params) throw new Error('OscSynth requires fully defined params!');
      this.Tone = Tone;
      this.params = params;
      this.nodes = {};
      this._buildChain();
    }

    /**
     * Clamp a value between min and max.
     * @param {number} val
     * @param {number} min
     * @param {number} max
     */
    _clamp(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }

    /**
     * Build the audio graph for this preset.  This method
     * initialises the filter, optional effects, synths and LFO.  It
     * does not start the Tone.Transport or schedule any notes – that
     * occurs in connect().
     */
    _buildChain() {
      const T = this.Tone;
      const p = this.params;
      // Master volume provides a single point of gain control.  We set
      // the initial gain conservatively – individual voices can boost
      // via velocity.
      const master = new T.Volume(-8);
      // Primary filter – all voices route through here.  Values are
      // clamped to musically sensible ranges to avoid subsonic rumble
      // or ultrasonic content.
      const filterFreq = this._clamp(p.filter?.frequency ?? 2000, 200, 8000);
      const filterQ    = this._clamp(p.filter?.Q ?? 1, 0.2, 10);
      const filterType = p.filter?.type || 'lowpass';
      const filterRolloff = [-12,-24,-48].includes(p.filter?.rolloff) ? p.filter.rolloff : -24;
      const filter = new T.Filter({
        frequency: filterFreq,
        type: filterType,
        Q: filterQ,
        rolloff: filterRolloff
      });
      // Optional phaser.  Parameters are clamped as with the filter.
      let phaser = null;
      if (p.phaser) {
        phaser = new T.Phaser({
          frequency: this._clamp(p.phaser.frequency ?? 0.5, 0.05, 8),
          octaves: this._clamp(p.phaser.octaves ?? 3, 1, 8),
          baseFrequency: this._clamp(p.phaser.baseFrequency ?? 350, 40, 1000)
        });
      }
      // Optional distortion
      let distortion = null;
      if (p.distortion) {
        distortion = new T.Distortion(this._clamp(p.distortion, 0.01, 1.0));
      }
      // Optional bitcrusher
      let bitcrusher = null;
      if (p.bitcrusher) {
        bitcrusher = new T.BitCrusher(p.bitcrusher);
      }
      // Optional chorus
      let chorus = null;
      if (p.chorus) {
        chorus = new T.Chorus({ frequency: 1.5, delayTime: 2.5, depth: this._clamp(p.chorus, 0.5, 4.0) }).start();
      }
      // Optional reverb
      let reverb = null;
      if (p.reverb) {
        reverb = new T.Reverb({ decay: 3, preDelay: 0.2 });
      }
      // LFO to modulate the filter frequency slowly over time.  The
      // depth property controls the amplitude of the modulation.  We
      // connect the LFO to the filter's frequency parameter.  Min and
      // max values are derived from the current filter frequency and
      // depth.  If no LFO is defined the variable remains null.
      let lfo = null;
      if (p.lfo) {
        const lfoFreq = this._clamp(p.lfo.frequency ?? 0.1, 0.01, 1.0);
        const depth = this._clamp(p.lfo.depth ?? 0.1, 0.01, 1.0);
        const min = filterFreq * (1 - depth);
        const max = filterFreq * (1 + depth);
        lfo = new T.LFO({ frequency: lfoFreq, min, max, type: p.lfo.type || 'sine' }).start();
        lfo.connect(filter.frequency);
      }
      // Create the polyphonic synth used for note playback.  We use a
      // single Synth instance; attacks overlap since we call
      // triggerAttackRelease for each note.  The oscillator type and
      // envelope are taken from the preset.  Velocity values from the
      // notes array are applied at trigger time.
      const synth = new T.Synth({
        oscillator: { type: p.oscillator?.type || 'sine' },
        envelope: {
          attack: this._clamp(p.envelope?.attack ?? 0.1, 0.005, 1.0),
          decay: this._clamp(p.envelope?.decay ?? 0.3, 0.05, 1.0),
          sustain: this._clamp(p.envelope?.sustain ?? 0.6, 0.1, 1.0),
          release: this._clamp(p.envelope?.release ?? 0.8, 0.05, 4.0)
        }
      });
      // Optional drone oscillator.  When enabled it plays a continuous
      // tone at low volume to anchor the harmony.  We route it through
      // the same filter and effects as the synth.
      let droneOsc = null;
      if (p.drone) {
        droneOsc = new T.Oscillator({
          type: p.drone.type || 'sine',
          frequency: p.drone.note || p.notes?.[0]?.note || 'C3',
          volume: p.drone.volume ?? -18
        }).start();
      }
      // Assemble the signal chain: synth/drone -> filter -> phaser ->
      // distortion -> bitcrusher -> chorus -> reverb -> master -> out
      let last = filter;
      if (phaser) {
        last.connect(phaser);
        last = phaser;
      }
      if (distortion) {
        last.connect(distortion);
        last = distortion;
      }
      if (bitcrusher) {
        last.connect(bitcrusher);
        last = bitcrusher;
      }
      if (chorus) {
        last.connect(chorus);
        last = chorus;
      }
      if (reverb) {
        last.connect(reverb);
        last = reverb;
      }
      last.connect(master);
      // Store nodes for disposal later
      this.nodes = { master, filter, phaser, distortion, bitcrusher, chorus, reverb, lfo, synth, droneOsc };
    }

    /**
     * Connect the synth to the given destination and schedule the
     * deterministic pattern.  The Tone.Transport will be configured
     * with the preset tempo and started.  An analyser node is created
     * after the master volume for visualisation.
     * @param {AudioNode} destination - Typically Tone.Destination
     * @returns {AnalyserNode}
     */
    connect(destination) {
      const T = this.Tone;
      const p = this.params;
      const { master, filter, phaser, distortion, bitcrusher, chorus, reverb, lfo, synth, droneOsc } = this.nodes;
      // Connect synth and drone to the start of the signal chain
      if (synth) synth.connect(filter);
      if (droneOsc) droneOsc.connect(filter);
      // Connect master to destination
      master.connect(destination);
      // Create an analyser node after the master for visuals
      const ana = T.context.createAnalyser();
      ana.fftSize = 2048;
      master.connect(ana);
      this.analyser = ana;
      // Configure transport tempo and loop length.  Cancel any prior
      // scheduled events and stop the transport so that loops from
      // previous instances do not continue playing.
      T.Transport.stop();
      T.Transport.cancel(0);
      T.Transport.bpm.value = p.tempo || 90;
      // Build the sequencing loop.  The loop iterates over the
      // sequence array and triggers notes from the notes list.  Each
      // callback receives the scheduled time.  We advance an internal
      // index on each invocation.  The interval of the loop is
      // specified by p.stepInterval (e.g. '8n').
      let stepIndex = 0;
      const sequence = Array.isArray(p.sequence) && p.sequence.length > 0 ? p.sequence : [0];
      const notes = Array.isArray(p.notes) && p.notes.length > 0 ? p.notes : [{ note: 'C3', duration: '4n', velocity: 0.8 }];
      this.loop = new T.Loop((time) => {
        const seqIdx = sequence[stepIndex % sequence.length];
        const noteObj = notes[seqIdx % notes.length];
        // Trigger a note with the specified duration and velocity.  If
        // durations are long relative to the loop interval the release
        // portion of the envelope will overlap with subsequent notes,
        // creating sustained textures.
        synth.triggerAttackRelease(noteObj.note, noteObj.duration || '8n', time, noteObj.velocity ?? 0.7);
        stepIndex++;
      }, p.stepInterval || '8n');
      this.loop.start(0);
      // Start LFO if defined
      if (lfo) lfo.start();
      // Start the transport
      T.Transport.start();
      return ana;
    }

    /**
     * Dispose of all Tone.js objects created by this instance and stop
     * any scheduled loops.  Cleans up the transport so that no
     * lingering events remain.  After disposal the instance should
     * not be used again.
     */
    dispose() {
      const T = this.Tone;
      // Stop the loop and transport
      if (this.loop) {
        try { this.loop.stop(); this.loop.dispose(); } catch {}
        this.loop = null;
      }
      T.Transport.stop();
      T.Transport.cancel(0);
      // Dispose of all stored nodes
      if (this.nodes) {
        const { master, filter, phaser, distortion, bitcrusher, chorus, reverb, lfo, synth, droneOsc } = this.nodes;
        [synth, droneOsc, phaser, distortion, bitcrusher, chorus, reverb, lfo, filter, master].forEach(node => {
          if (!node) return;
          try { node.stop?.(); } catch {}
          try { node.dispose?.(); } catch {}
        });
      }
      // Disconnect the analyser
      if (this.analyser) {
        try { this.analyser.disconnect(); } catch {}
        this.analyser = null;
      }
      this.nodes = {};
    }
  }
  