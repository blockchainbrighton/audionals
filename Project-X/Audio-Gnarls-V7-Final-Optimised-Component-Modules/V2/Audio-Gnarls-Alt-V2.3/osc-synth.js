// osc-synth.js
export class OscSynth {
    /**
     * Create a new OscSynth instance.  This class is responsible for
     * constructing a polyphonic synth voice with optional drone and
     * scheduling a deterministic sequence of notes based on the
     * supplied parameters.  Effects such as filters, phasers,
     * distortion, chorus and reverb are inserted into the signal path
     * according to the preset.  An analyser node is exposed to
     * visualise the outgoing audio.  The Tone.Transport will be
     * configured with the preset's tempo and started when connect() is
     * called.
     *
     * @param {typeof Tone} Tone - Tone.js reference (must be loaded)
     * @param {object} params - Sound preset generated by OscControls
     */
    constructor(Tone, params) {
      if (!params) throw new Error('OscSynth requires fully defined params!');
      this.Tone = Tone;
      this.params = params;
      this.nodes = {};
      this._buildChain();
    }

    /**
     * Clamp a value between min and max.
     * @param {number} val
     * @param {number} min
     * @param {number} max
     */
    _clamp(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }

    /**
     * Build the audio graph for this preset.  This method
     * initialises the filter, optional effects, synths and LFO.  It
     * does not start the Tone.Transport or schedule any notes – that
     * occurs in connect().
     */
    _buildChain() {
      const T = this.Tone;
      const p = this.params;
      // Master volume sits at the end of the chain.  The value here
      // provides headroom; individual voices define their own volumes.
      const master = new T.Volume(-6);
      // Shared filter for all voices and drone
      const filterFreq = this._clamp(p.filter?.frequency ?? 2000, 200, 8000);
      const filterQ    = this._clamp(p.filter?.Q ?? 1, 0.2, 10);
      const filterType = p.filter?.type || 'lowpass';
      const filterRolloff = [-12,-24,-48].includes(p.filter?.rolloff) ? p.filter.rolloff : -24;
      const filter = new T.Filter({
        frequency: filterFreq,
        type: filterType,
        Q: filterQ,
        rolloff: filterRolloff
      });
      // Optional phaser
      let phaser = null;
      if (p.phaser) {
        phaser = new T.Phaser({
          frequency: this._clamp(p.phaser.frequency ?? 0.5, 0.05, 8),
          octaves: this._clamp(p.phaser.octaves ?? 3, 1, 8),
          baseFrequency: this._clamp(p.phaser.baseFrequency ?? 350, 40, 1000)
        });
      }
      // Optional distortion
      let distortion = null;
      if (p.distortion) {
        distortion = new T.Distortion(this._clamp(p.distortion, 0.01, 1.0));
      }
      // Optional bitcrusher
      let bitcrusher = null;
      if (p.bitcrusher) {
        bitcrusher = new T.BitCrusher(p.bitcrusher);
      }
      // Optional chorus
      let chorus = null;
      if (p.chorus) {
        chorus = new T.Chorus({ frequency: 1.5, delayTime: 2.5, depth: this._clamp(p.chorus, 0.5, 4.0) }).start();
      }
      // Optional reverb
      let reverb = null;
      if (p.reverb) {
        reverb = new T.Reverb({ decay: 3, preDelay: 0.2 });
      }
      // Global LFO to modulate filter frequency
      let lfo = null;
      if (p.lfo) {
        const lfoFreq = this._clamp(p.lfo.frequency ?? 0.1, 0.01, 1.0);
        const depth = this._clamp(p.lfo.depth ?? 0.1, 0.01, 1.0);
        const min = filterFreq * (1 - depth);
        const max = filterFreq * (1 + depth);
        lfo = new T.LFO({ frequency: lfoFreq, min, max, type: p.lfo.type || 'sine' }).start();
        lfo.connect(filter.frequency);
      }
      // Build voices from the preset's bank.  Each entry specifies
      // instrument type, pitch, envelope, oscillator type and volume.
      const voices = [];
      if (Array.isArray(p.bank)) {
        p.bank.forEach((voiceDesc) => {
          let voice;
          const env = voiceDesc.envelope || {};
          const vol = voiceDesc.volume ?? -10;
          try {
            switch (voiceDesc.inst) {
              case 'MonoSynth':
                voice = new T.MonoSynth({
                  oscillator: { type: voiceDesc.oscType || 'sine' },
                  envelope: { attack: env.attack, decay: env.decay, sustain: env.sustain, release: env.release },
                  volume: vol
                });
                break;
              case 'FMSynth':
                voice = new T.FMSynth({
                  harmonicity: 2,
                  modulationIndex: 1.5,
                  oscillator: { type: voiceDesc.oscType || 'sine' },
                  envelope: { attack: env.attack, decay: env.decay, sustain: env.sustain, release: env.release },
                  volume: vol
                });
                break;
              case 'AMSynth':
                voice = new T.AMSynth({
                  harmonicity: 1.5,
                  oscillator: { type: voiceDesc.oscType || 'sine' },
                  envelope: { attack: env.attack, decay: env.decay, sustain: env.sustain, release: env.release },
                  volume: vol
                });
                break;
              case 'MembraneSynth':
                voice = new T.MembraneSynth({
                  pitchDecay: 0.05,
                  octaves: 4,
                  envelope: { attack: env.attack, decay: env.decay, sustain: env.sustain, release: env.release },
                  volume: vol
                });
                break;
              case 'MetalSynth':
                voice = new T.MetalSynth({
                  harmonicity: 5.1,
                  resonance: 700,
                  modulationIndex: 32,
                  envelope: { attack: env.attack, decay: env.decay, sustain: env.sustain, release: env.release },
                  volume: vol
                });
                break;
              case 'PluckSynth':
                voice = new T.PluckSynth({
                  attackNoise: 1.2,
                  dampening: 4000,
                  resonance: 0.7,
                  volume: vol
                });
                break;
              case 'Synth':
              default:
                voice = new T.Synth({
                  oscillator: { type: voiceDesc.oscType || 'sine' },
                  envelope: { attack: env.attack, decay: env.decay, sustain: env.sustain, release: env.release },
                  volume: vol
                });
                break;
            }
          } catch (err) {
            console.warn('[OscSynth] Failed to create voice', voiceDesc.inst, err);
            voice = new T.Synth({
              oscillator: { type: 'sine' },
              envelope: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.3 },
              volume: -12
            });
          }
          voices.push(voice);
        });
      }
      // Optional drone oscillator
      let droneOsc = null;
      if (p.drone) {
        droneOsc = new T.Oscillator({
          type: p.drone.type || 'sine',
          frequency: p.drone.note || 'C3',
          volume: p.drone.volume ?? -18
        }).start();
      }
      // Assemble the static signal chain: filter -> phaser ->
      // distortion -> bitcrusher -> chorus -> reverb -> master
      let last = filter;
      if (phaser) { last.connect(phaser); last = phaser; }
      if (distortion) { last.connect(distortion); last = distortion; }
      if (bitcrusher) { last.connect(bitcrusher); last = bitcrusher; }
      if (chorus) { last.connect(chorus); last = chorus; }
      if (reverb) { last.connect(reverb); last = reverb; }
      last.connect(master);
      // Store nodes for disposal later and voices for triggering
      this.nodes = { master, filter, phaser, distortion, bitcrusher, chorus, reverb, lfo, droneOsc };
      this.voices = voices;
    }

    /**
     * Connect the synth to the given destination and schedule the
     * deterministic pattern.  The Tone.Transport will be configured
     * with the preset tempo and started.  An analyser node is created
     * after the master volume for visualisation.
     * @param {AudioNode} destination - Typically Tone.Destination
     * @returns {AnalyserNode}
     */
    connect(destination) {
      const T = this.Tone;
      const { master, filter, droneOsc } = this.nodes;
      // Connect each voice to the shared filter
      if (Array.isArray(this.voices)) {
        this.voices.forEach(v => {
          try { v.connect(filter); } catch {}
        });
      }
      // Connect drone if present
      if (droneOsc) droneOsc.connect(filter);
      // Connect master to destination
      master.connect(destination);
      // Create analyser for visuals
      const ana = T.context.createAnalyser();
      ana.fftSize = 2048;
      master.connect(ana);
      this.analyser = ana;
      return ana;
    }

    /**
     * Dispose of all Tone.js objects created by this instance and stop
     * any scheduled loops.  Cleans up the transport so that no
     * lingering events remain.  After disposal the instance should
     * not be used again.
     */
    dispose() {
      const T = this.Tone;
      // Stop and dispose voices
      if (Array.isArray(this.voices)) {
        this.voices.forEach(v => {
          try { v.releaseAll?.(); } catch {}
          try { v.dispose?.(); } catch {}
        });
      }
      this.voices = [];
      // Dispose of stored nodes
      if (this.nodes) {
        const { master, filter, phaser, distortion, bitcrusher, chorus, reverb, lfo, droneOsc } = this.nodes;
        [droneOsc, phaser, distortion, bitcrusher, chorus, reverb, lfo, filter, master].forEach(node => {
          if (!node) return;
          try { node.stop?.(); } catch {}
          try { node.dispose?.(); } catch {}
        });
      }
      // Disconnect analyser
      if (this.analyser) {
        try { this.analyser.disconnect(); } catch {}
        this.analyser = null;
      }
      this.nodes = {};
    }

    /**
     * Trigger a single voice from the bank.  This can be used by
     * external sequencers (e.g. the step‑sequencer component) to
     * construct melodies and rhythms.  If the index is out of range
     * it will wrap around the available voices.  The duration and
     * velocity parameters are optional and default to sensible values.
     *
     * @param {number} index - Index of the voice in the preset's bank
     * @param {string} [duration='8n'] - Length of the note (Tone.js time)
     * @param {number} [velocity=0.8] - 0–1 loudness multiplier
     */
    triggerVoice(index, duration = '8n', velocity = 0.8) {
      if (!Array.isArray(this.voices) || this.voices.length === 0) return;
      const i = index % this.voices.length;
      const voice = this.voices[i];
      const bankEntry = Array.isArray(this.params.bank) && this.params.bank[i] ? this.params.bank[i] : { note: 'C3' };
      const note = bankEntry.note || 'C3';
      try {
        voice.triggerAttackRelease(note, duration, undefined, velocity);
      } catch (err) {
        // Some instruments (e.g. PluckSynth) may not support velocity; fallback
        try { voice.triggerAttackRelease(note, duration); } catch {}
      }
    }
  }
  