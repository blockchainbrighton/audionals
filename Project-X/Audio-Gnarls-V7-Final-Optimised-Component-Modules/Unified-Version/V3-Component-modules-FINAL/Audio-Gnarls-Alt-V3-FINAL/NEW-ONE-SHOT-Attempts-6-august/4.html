<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Oscilloscope Visualizer</title>
  <script type="module">
    // --- Pseudorandom Number Generator (Deterministic by Seed) ---
    class PRNG {
      constructor(seed = 1) {
        this.seed = seed;
      }
      next() {
        this.seed = (this.seed * 9301 + 49297) % 233280;
        return this.seed / 233280;
      }
      nextInRange(min, max) {
        return min + this.next() * (max - min);
      }
    }

    // --- Dynamic Tone.js Loader Web Component ---
    class ToneLoader extends HTMLElement {
      async connectedCallback() {
        if (!window.Tone) {
          const script = document.createElement('script');
          script.src = 'https://cdn.jsdelivr.net/npm/tone@14.8.42/build/Tone.js';
          script.onload = () => this.dispatchEvent(new Event('tone-ready'));
          document.head.appendChild(script);
        } else {
          this.dispatchEvent(new Event('tone-ready'));
        }
      }
    }
    customElements.define('tone-loader', ToneLoader);

    // --- Canvas Oscilloscope Web Component ---
    class ScopeCanvas extends HTMLElement {
      constructor() {
        super();
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.audioData = new Float32Array(2048);
        this.currentShape = 'circle';
        this.prng = new PRNG(1);
        this.animFrame = null;
        this.time = 0;

        const shadow = this.attachShadow({ mode: 'open' });
        shadow.appendChild(this.canvas);
        this.resize();
        window.addEventListener('resize', () => this.resize());
      }

      resize() {
        const rect = this.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
      }

      setAudioData(data) {
        this.audioData = data;
        this.time += 0.02;
      }

      setShape(shape, params = {}) {
        this.currentShape = shape;
        this.shapeParams = params;
      }

      setSeed(seed) {
        this.prng = new PRNG(seed);
        this.time = 0;
      }

      draw() {
        const { ctx, canvas } = this;
        const w = canvas.width, h = canvas.height;
        const cx = w / 2, cy = h / 2;
        const scale = Math.min(w, h) * 0.4;

        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, w, h);

        // Waveform
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(0, 255, 200, 0.6)';
        ctx.lineWidth = 1.5;
        for (let i = 0; i < this.audioData.length; i++) {
          const x = (i / this.audioData.length) * w;
          const y = cy + this.audioData[i] * h * 0.3;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Shape
        ctx.save();
        this[`draw${this.capitalize(this.currentShape)}`]?.(cx, cy, scale);
        ctx.restore();

        this.animFrame = requestAnimationFrame(() => this.draw());
      }

      capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }

      drawCircle(cx, cy, scale) {
        const t = this.time * this.shapeParams.speed;
        const r = scale * (0.5 + 0.5 * Math.sin(t));
        const color = this.hsvToRgb(t * 0.1, 0.8, 1);
        this.ctx.strokeStyle = `rgb(${color.r},${color.g},${color.b})`;
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        this.ctx.arc(cx, cy, r, 0, Math.PI * 2);
        this.ctx.stroke();
      }

      drawSquare(cx, cy, scale) {
        const t = this.time * this.shapeParams.speed;
        const s = scale * (0.6 + 0.4 * Math.sin(t));
        const rot = t * 0.3;
        const color = this.hsvToRgb(t * 0.2, 0.7, 1);
        this.ctx.strokeStyle = `rgb(${color.r},${color.g},${color.b})`;
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        this.ctx.save();
        this.ctx.translate(cx, cy);
        this.ctx.rotate(rot);
        this.ctx.strokeRect(-s, -s, s * 2, s * 2);
        this.ctx.restore();
      }

      drawButterfly(cx, cy, scale) {
        const t = this.time * this.shapeParams.speed;
        const n = 2000;
        const color = this.hsvToRgb(t * 0.05, 0.9, 1);
        this.ctx.strokeStyle = `rgba(${color.r},${color.g},${color.b},0.8)`;
        this.ctx.lineWidth = 1.5;
        this.ctx.beginPath();
        for (let i = 0; i < n; i++) {
          const theta = (i / n) * Math.PI * 20;
          const r = Math.exp(Math.sin(theta)) - 2 * Math.cos(4 * theta) - Math.pow(Math.sin(theta / 12), 5);
          const x = cx + r * Math.cos(theta + t) * scale * 0.25;
          const y = cy + r * Math.sin(theta + t) * scale * 0.25;
          if (i === 0) this.ctx.moveTo(x, y);
          else this.ctx.lineTo(x, y);
        }
        this.ctx.stroke();
      }

      drawLissajous(cx, cy, scale) {
        const t = this.time * this.shapeParams.speed;
        const a = this.shapeParams.a, b = this.shapeParams.b;
        const δ = this.shapeParams.delta;
        const n = 500;
        const color = this.hsvToRgb(t * 0.1, 0.8, 1);
        this.ctx.strokeStyle = `rgb(${color.r},${color.g},${color.b})`;
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        for (let i = 0; i < n; i++) {
          const θ = (i / n) * Math.PI * 2;
          const x = cx + scale * 0.8 * Math.sin(a * θ + δ) * Math.cos(t);
          const y = cy + scale * 0.8 * Math.sin(b * θ) * Math.cos(t * 0.7);
          if (i === 0) this.ctx.moveTo(x, y);
          else this.ctx.lineTo(x, y);
        }
        this.ctx.stroke();
      }

      drawSpirograph(cx, cy, scale) {
        const t = this.time * this.shapeParams.speed;
        const R = 100, r = 38, d = 50;
        const k = r / R, l = d / r;
        const n = 1000;
        const color = this.hsvToRgb(t * 0.05, 0.8, 1);
        this.ctx.strokeStyle = `rgb(${color.r},${color.g},${color.b})`;
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        for (let i = 0; i < n; i++) {
          const θ = (i / n) * Math.PI * 12;
          const x = cx + scale * 0.003 * ((R - r) * Math.cos(θ) + l * r * Math.cos(((R - r) / r) * θ + t));
          const y = cy + scale * 0.003 * ((R - r) * Math.sin(θ) - l * r * Math.sin(((R - r) / r) * θ + t));
          if (i === 0) this.ctx.moveTo(x, y);
          else this.ctx.lineTo(x, y);
        }
        this.ctx.stroke();
      }

      drawHarmonograph(cx, cy, scale) {
        const t = this.time * this.shapeParams.speed;
        const decay = Math.exp(-t * 0.05);
        const x =
          scale * 0.35 * decay *
          (Math.sin(t * this.shapeParams.f1 + this.shapeParams.p1) * this.shapeParams.a1 +
           Math.sin(t * this.shapeParams.f2 + this.shapeParams.p2) * this.shapeParams.a2);
        const y =
          scale * 0.35 * decay *
          (Math.sin(t * this.shapeParams.f3 + this.shapeParams.p3) * this.shapeParams.a3 +
           Math.sin(t * this.shapeParams.f4 + this.shapeParams.p4) * this.shapeParams.a4);

        const trail = 50;
        this.ctx.strokeStyle = 'rgba(255, 100, 255, 0.3)';
        this.ctx.lineWidth = 1.5;
        this.ctx.beginPath();
        for (let i = 0; i < trail; i++) {
          const dt = i / 10;
          const α = (trail - i) / trail;
          const xt =
            scale * 0.35 * Math.exp(-(t - dt) * 0.05) *
            (Math.sin((t - dt) * this.shapeParams.f1 + this.shapeParams.p1) * this.shapeParams.a1 +
             Math.sin((t - dt) * this.shapeParams.f2 + this.shapeParams.p2) * this.shapeParams.a2);
          const yt =
            scale * 0.35 * Math.exp(-(t - dt) * 0.05) *
            (Math.sin((t - dt) * this.shapeParams.f3 + this.shapeParams.p3) * this.shapeParams.a3 +
             Math.sin((t - dt) * this.shapeParams.f4 + this.shapeParams.p4) * this.shapeParams.a4);
          if (i === 0) this.ctx.moveTo(cx + xt, cy + yt);
          else this.ctx.lineTo(cx + xt, cy + yt);
        }
        this.ctx.stroke();
      }

      hsvToRgb(h, s, v) {
        let r, g, b;
        const i = Math.floor(h * 6);
        const f = h * 6 - i;
        const p = v * (1 - s);
        const q = v * (1 - f * s);
        const t = v * (1 - (1 - f) * s);
        switch (i % 6) {
          case 0: r = v; g = t; b = p; break;
          case 1: r = q; g = v; b = p; break;
          case 2: r = p; g = v; b = t; break;
          case 3: r = p; g = q; b = v; break;
          case 4: r = t; g = p; b = v; break;
          case 5: r = v; g = p; b = q; break;
        }
        return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
      }

      start() {
        if (this.animFrame) return;
        this.draw();
      }

      stop() {
        if (this.animFrame) {
          cancelAnimationFrame(this.animFrame);
          this.animFrame = null;
        }
      }
    }
    customElements.define('scope-canvas', ScopeCanvas);

    // --- Audio & Sequencer Controls Web Component ---
    class OscControls extends HTMLElement {
      constructor() {
        super();
        this.shapes = ['circle', 'square', 'butterfly', 'lissajous', 'spirograph', 'harmonograph'];
        this.shapeParams = {};
        this.isAudioStarted = false;
        this.isMuted = false;
        this.sequence = Array(8).fill(null);
        this.seqIndex = 0;
        this.seqPlaying = false;
        this.seqInterval = null;
        this.stepTime = 500; // ms
        this.recording = false;
        this.currentStep = 0;

        const shadow = this.attachShadow({ mode: 'open' });
        shadow.innerHTML = `
          <style>
            :host { display: block; background: #222; color: #eee; padding: 10px; font-family: sans-serif; }
            button, select, input { margin: 5px; padding: 8px; border: none; border-radius: 4px; }
            button { background: #0af; color: white; cursor: pointer; }
            button:disabled { background: #555; cursor: not-allowed; }
            button.active { background: #0f0; }
            .seq { margin: 10px 0; display: flex; flex-wrap: wrap; gap: 5px; }
            .step { width: 40px; height: 40px; background: #333; display: flex; align-items: center; justify-content: center; cursor: pointer; }
            .step.active { background: #0af; color: white; }
            .step.current { border: 2px solid yellow; }
            .controls { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
            .seed { display: flex; gap: 5px; }
          </style>
          <div class="controls">
            <button id="startBtn">Start Audio + Draw</button>
            <button id="muteBtn">Unmute</button>
            <select id="shapeSelect">${this.shapes.map(s => `<option value="${s}">${s.charAt(0).toUpperCase() + s.slice(1)}</option>`).join('')}</select>
            <button id="seqBtn">Create Sequence</button>
            <div class="seed">
              <input type="number" id="seedInput" value="1" min="1" max="9999" style="width: 80px"/>
              <button id="setSeed">Set Seed</button>
            </div>
          </div>
          <div class="seq" id="seqContainer"></div>
          <div id="seqControls" style="display:none; margin-top:10px;">
            <button id="playSeq">Play Seq</button>
            <button id="stopSeq">Stop Seq</button>
            <input type="range" id="stepTime" min="100" max="1000" value="500" step="50"/>
            <span id="timeLabel">500ms</span>
          </div>
        `;
        this.setupEventListeners();
        this.updateSequenceUI();
      }

      setupEventListeners() {
        const $ = id => this.shadowRoot.getElementById(id);
        $('startBtn').onclick = () => this.startAudio();
        $('muteBtn').onclick = () => this.toggleMute();
        $('shapeSelect').onchange = () => this.changeShape();
        $('setSeed').onclick = () => this.setSeed();
        $('seqBtn').onclick = () => this.toggleSequencer();
        $('playSeq').onclick = () => this.playSequence();
        $('stopSeq').onclick = () => this.stopSequence();
        $('stepTime').oninput = () => {
          this.stepTime = parseInt($('stepTime').value);
          $('timeLabel').textContent = this.stepTime + 'ms';
        };

        // Keyboard recording
        document.addEventListener('keydown', e => {
          if (!this.recording) return;
          const key = e.key;
          if (key >= '1' && key <= '6') {
            const idx = parseInt(key) - 1;
            this.sequence[this.currentStep] = this.shapes[idx];
            this.currentStep = (this.currentStep + 1) % 8;
            this.updateSequenceUI();
          }
        });

        // Click to edit sequence
        this.shadowRoot.getElementById('seqContainer').addEventListener('click', e => {
          if (!this.recording) return;
          const stepEls = this.shadowRoot.querySelectorAll('.step');
          stepEls.forEach((el, i) => {
            if (e.target === el) {
              const nextIdx = (this.shapes.indexOf(this.sequence[i]) + 1) % this.shapes.length;
              this.sequence[i] = this.shapes[nextIdx];
              this.updateSequenceUI();
            }
          });
        });
      }

      setApp(app) {
        this.app = app;
      }

      startAudio() {
        if (this.isAudioStarted) return;
        this.isAudioStarted = true;
        this.app.startAudio();
        this.shadowRoot.getElementById('startBtn').disabled = true;
      }

      toggleMute() {
        this.isMuted = !this.isMuted;
        this.app.toggleMute(this.isMuted);
        this.shadowRoot.getElementById('muteBtn').textContent = this.isMuted ? 'Unmute' : 'Mute';
      }

      changeShape() {
        const shape = this.shadowRoot.getElementById('shapeSelect').value;
        this.app.changeShape(shape);
      }

      setSeed() {
        const seed = parseInt(this.shadowRoot.getElementById('seedInput').value) || 1;
        this.app.setSeed(seed);
      }

      toggleSequencer() {
        const seqEl = this.shadowRoot.getElementById('seqControls');
        this.recording = !this.recording;
        seqEl.style.display = this.recording ? 'block' : 'none';
        this.shadowRoot.getElementById('seqBtn').textContent = this.recording ? 'Exit Seq' : 'Create Sequence';
        if (!this.recording) this.stopSequence();
        this.updateSequenceUI();
      }

      updateSequenceUI() {
        const container = this.shadowRoot.getElementById('seqContainer');
        container.innerHTML = '';
        this.sequence.forEach((shape, i) => {
          const step = document.createElement('div');
          step.className = `step ${shape ? 'active' : ''} ${i === this.currentStep && this.seqPlaying ? 'current' : ''}`;
          step.textContent = shape ? shape[0].toUpperCase() : '';
          container.appendChild(step);
        });
      }

      playSequence() {
        if (this.seqPlaying) return;
        this.seqPlaying = true;
        this.seqIndex = 0;
        this.updateSequenceUI();
        this.seqInterval = setInterval(() => {
          const shape = this.sequence[this.seqIndex];
          if (shape) this.app.changeShape(shape);
          this.seqIndex = (this.seqIndex + 1) % 8;
          this.updateSequenceUI();
        }, this.stepTime);
      }

      stopSequence() {
        if (!this.seqPlaying) return;
        clearInterval(this.seqInterval);
        this.seqPlaying = false;
        this.updateSequenceUI();
      }
    }
    customElements.define('osc-controls', OscControls);

    // --- Main App Component ---
    class OscApp extends HTMLElement {
      constructor() {
        super();
        this.audioContext = null;
        this.synth = null;
        this.analyser = null;
        this.waveformData = new Float32Array(2048);
        this.currentShape = 'circle';
        this.prng = new PRNG(1);
        this.shapeParams = {};

        const shadow = this.attachShadow({ mode: 'open' });
        shadow.innerHTML = `
          <style>
            :host { display: block; height: 100vh; display: flex; flex-direction: column; font-family: 'Arial', sans-serif; }
            tone-loader { display: none; }
            scope-canvas { flex: 1; background: #000; }
            osc-controls { border-top: 1px solid #444; }
          </style>
          <tone-loader></tone-loader>
          <scope-canvas></scope-canvas>
          <osc-controls></osc-controls>
        `;

        this.canvas = this.shadowRoot.querySelector('scope-canvas');
        this.controls = this.shadowRoot.querySelector('osc-controls');
        this.loader = this.shadowRoot.querySelector('tone-loader');

        this.loader.addEventListener('tone-ready', () => {
          this.initAudio();
          this.controls.setApp(this);
          this.canvas.start();
        });

        // Start animation loop
        this.animate();
      }

      initAudio() {
        this.audioContext = Tone.context;
        this.analyser = new Tone.Analyser('waveform', 2048);
        this.synth = new Tone.PolySynth(Tone.Synth).connect(this.analyser).toDestination();
        this.synth.volume.value = -10;
        this.changeShape('circle');
      }

      startAudio() {
        Tone.start();
        console.log('Audio started');
      }

      toggleMute(muted) {
        this.synth.volume.value = muted ? -Infinity : -10;
      }

      setSeed(seed) {
        this.prng = new PRNG(seed);
        this.controls.shadowRoot.getElementById('seedInput').value = seed;
        this.changeShape(this.currentShape);
      }

      generateParams(shape) {
        const p = this.prng;
        const base = {
          speed: p.nextInRange(0.5, 2.0),
        };

        switch (shape) {
          case 'lissajous':
            return { ...base, a: 3 + Math.round(p.next() * 4), b: 2 + Math.round(p.next() * 4), delta: p.next() * Math.PI };
          case 'harmonograph':
            return {
              ...base,
              a1: p.next(), a2: p.next(), a3: p.next(), a4: p.next(),
              f1: p.nextInRange(1, 5), f2: p.nextInRange(1, 5), f3: p.nextInRange(1, 5), f4: p.nextInRange(1, 5),
              p1: p.next() * Math.PI, p2: p.next() * Math.PI, p3: p.next() * Math.PI, p4: p.next() * Math.PI
            };
          default:
            return base;
        }
      }

      changeShape(shape) {
        this.currentShape = shape;
        this.shapeParams = this.generateParams(shape);
        this.canvas.setShape(shape, this.shapeParams);

        // Trigger sound
        if (this.synth) {
          const note = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4'][this.prng.next() * 6 | 0];
          this.synth.triggerAttackRelease(note, '8n');
        }

        // Update UI
        const select = this.controls.shadowRoot.getElementById('shapeSelect');
        select.value = shape;
      }

      animate() {
        if (this.analyser) {
          this.waveformData = this.analyser.getValue();
          this.canvas.setAudioData(this.waveformData);
        }
        requestAnimationFrame(() => this.animate());
      }
    }
    customElements.define('osc-app', OscApp);
  </script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; color: white; }
    osc-app { width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <osc-app></osc-app>
</body>
</html>