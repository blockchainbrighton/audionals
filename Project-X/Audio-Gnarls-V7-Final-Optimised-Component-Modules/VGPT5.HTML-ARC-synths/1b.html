<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARC Analog Synth Workstation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #0f0;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            color: #0f0;
            font-size: 12px;
            pointer-events: none;
        }
        .hud-panel {
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #0f0;
            padding: 8px;
            margin-bottom: 10px;
            border-radius: 4px;
        }
        .hud-title {
            font-weight: bold;
            margin-bottom: 4px;
            color: #0f8;
        }
        .hud-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }
        #patch-info {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #0f0;
            padding: 8px;
            border-radius: 4px;
            font-size: 14px;
        }
        #keyboard {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            z-index: 100;
        }
        .key {
            width: 30px;
            height: 100px;
            background: #fff;
            border: 1px solid #000;
            border-radius: 0 0 4px 4px;
            margin: 0 1px;
            cursor: pointer;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 5px;
            font-size: 10px;
            color: #000;
        }
        .key.black {
            width: 20px;
            height: 60px;
            background: #000;
            color: #fff;
            margin: 0 -10px;
            z-index: 1;
        }
        #instructions {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #0f0;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            text-align: center;
            max-width: 500px;
        }
        #patch-selector {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #0f0;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        button {
            background: #002200;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 4px 8px;
            margin: 2px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        button:hover {
            background: #004400;
        }
        input[type="range"] {
            width: 100px;
        }
        #export-import {
            position: absolute;
            top: 60px;
            right: 10px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="hud">
        <div class="hud-panel">
            <div class="hud-title">OSCILLOSCOPE</div>
            <div id="scope-container"></div>
        </div>
        <div class="hud-panel">
            <div class="hud-title">SYNTH STATUS</div>
            <div class="hud-row"><span>BPM:</span><span id="bpm-value">120</span></div>
            <div class="hud-row"><span>Scale:</span><span id="scale-value">A Minor</span></div>
            <div class="hud-row"><span>Swing:</span><span id="swing-value">0.02</span></div>
        </div>
    </div>
    <div id="patch-info">
        <div>Patch: <span id="patch-name">Tight Mono Bass</span></div>
        <div>Seed: <span id="patch-seed">default</span></div>
    </div>
    <div id="keyboard">
        <!-- Keyboard will be generated by JavaScript -->
    </div>
    <div id="instructions">
        Click and drag to connect modules. Press keys 1-0 to load patches. Click keys to play notes.
    </div>
    <div id="patch-selector">
        <button id="patch-1">1</button>
        <button id="patch-2">2</button>
        <button id="patch-3">3</button>
        <button id="patch-4">4</button>
        <button id="patch-5">5</button>
        <button id="patch-6">6</button>
        <button id="patch-7">7</button>
        <button id="patch-8">8</button>
        <button id="patch-9">9</button>
        <button id="patch-0">0</button>
    </div>
    <div id="export-import">
        <button id="export-btn">Export Patch</button>
        <button id="import-btn">Import Patch</button>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer;
        let modules = [];
        let cables = [];
        let selectedModule = null;
        let draggingCable = null;
        let currentPatch = 0;
        let seed = 'default';
        let synth, sequencer;
        let scopeCanvas, scopeContext;
        let isPlaying = false;

        // Initialize everything
        function init() {
            // Parse URL hash for seed
            const urlParams = new URLSearchParams(window.location.hash.substring(1));
            seed = urlParams.get('seed') || 'default';
            document.getElementById('patch-seed').textContent = seed;
            
            // Set up THREE.js scene
            setupScene();
            
            // Set up p5.js HUD
            setupHUD();
            
            // Set up keyboard
            setupKeyboard();
            
            // Set up synth
            setupSynth();
            
            // Set up patch selector
            setupPatchSelector();
            
            // Set up export/import
            setupExportImport();
            
            // Load initial patch
            loadPatch(currentPatch);
            
            // Start animation loop
            animate();
        }

        // Set up THREE.js scene
        function setupScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Create modules
            createModules();
            
            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
        }

        // Set up p5.js HUD
        function setupHUD() {
            // Create scope canvas
            scopeCanvas = document.createElement('canvas');
            scopeCanvas.width = 200;
            scopeCanvas.height = 100;
            scopeContext = scopeCanvas.getContext('2d');
            document.getElementById('scope-container').appendChild(scopeCanvas);
            
            // Draw initial scope
            drawScope();
        }

        // Set up keyboard
        function setupKeyboard() {
            const keyboard = document.getElementById('keyboard');
            const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const octaves = [3, 4];
            
            for (let octave of octaves) {
                for (let i = 0; i < 12; i++) {
                    const note = notes[i];
                    const isBlack = note.includes('#');
                    const key = document.createElement('div');
                    key.className = `key ${isBlack ? 'black' : ''}`;
                    key.textContent = note + octave;
                    key.dataset.note = note + octave;
                    
                    if (!isBlack) {
                        key.addEventListener('mousedown', () => playNote(note + octave));
                        key.addEventListener('mouseup', stopNote);
                        key.addEventListener('mouseleave', stopNote);
                    }
                    
                    keyboard.appendChild(key);
                }
            }
        }

        // Set up synth
        function setupSynth() {
            // Create a polyphonic synth with 8 voices
            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: {
                    type: "sawtooth"
                },
                envelope: {
                    attack: 0.002,
                    decay: 0.1,
                    sustain: 0.3,
                    release: 0.2
                }
            }).toDestination();
            
            // Create sequencer
            sequencer = new Tone.Sequence((time, note) => {
                synth.triggerAttackRelease(note, "8n", time);
            }, ["C3", "D3", "E3", "F3", "G3", "A3", "B3", "C4"], "8n");
            
            // Set up transport
            Tone.Transport.bpm.value = 120;
            Tone.Transport.swing = 0.02;
            Tone.Transport.start();
        }

        // Set up patch selector
        function setupPatchSelector() {
            for (let i = 0; i < 10; i++) {
                document.getElementById(`patch-${i === 9 ? 0 : i+1}`).addEventListener('click', () => {
                    loadPatch(i);
                });
            }
        }

        // Set up export/import
        function setupExportImport() {
            document.getElementById('export-btn').addEventListener('click', exportPatch);
            document.getElementById('import-btn').addEventListener('click', importPatch);
        }

        // Create modules
        function createModules() {
            // Define module positions
            const positions = [
                { x: -8, y: 4, name: "VCO1" },
                { x: -8, y: 2, name: "VCO2" },
                { x: -8, y: 0, name: "VCO3" },
                { x: -8, y: -2, name: "Noise" },
                { x: -4, y: 3, name: "Mixer" },
                { x: 0, y: 2, name: "VCF" },
                { x: 4, y: 2, name: "VCA" },
                { x: -4, y: -1, name: "ADSR1" },
                { x: 0, y: -1, name: "ADSR2" },
                { x: 4, y: -1, name: "LFO1" },
                { x: 8, y: -1, name: "LFO2" },
                { x: -4, y: -4, name: "S&H" },
                { x: 0, y: -4, name: "Glide" },
                { x: 4, y: -4, name: "RingMod" },
                { x: 8, y: 2, name: "FX Rack" },
                { x: 8, y: 4, name: "Mod Matrix" },
                { x: 8, y: 0, name: "Sequencer" }
            ];
            
            // Create modules
            positions.forEach(pos => {
                const geometry = new THREE.BoxGeometry(2, 1, 0.5);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x008800,
                    transparent: true,
                    opacity: 0.7
                });
                const module = new THREE.Mesh(geometry, material);
                module.position.set(pos.x, pos.y, 0);
                module.userData = { name: pos.name };
                scene.add(module);
                
                // Add label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = '#00ff00';
                context.font = '24px Courier New';
                context.textAlign = 'center';
                context.fillText(pos.name, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const labelMaterial = new THREE.MeshBasicMaterial({ 
                    map: texture,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                const labelGeometry = new THREE.PlaneGeometry(2, 0.5);
                const label = new THREE.Mesh(labelGeometry, labelMaterial);
                label.position.set(pos.x, pos.y + 0.8, 0.3);
                scene.add(label);
                
                modules.push(module);
            });
            
            // Add input/output jacks
            modules.forEach(module => {
                // Input jack
                const inputGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 16);
                const inputMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const inputJack = new THREE.Mesh(inputGeometry, inputMaterial);
                inputJack.position.set(module.position.x - 0.8, module.position.y, 0.3);
                inputJack.userData = { type: 'input' };
                scene.add(inputJack);
                
                // Output jack
                const outputGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 16);
                const outputMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
                const outputJack = new THREE.Mesh(outputGeometry, outputMaterial);
                outputJack.position.set(module.position.x + 0.8, module.position.y, 0.3);
                outputJack.userData = { type: 'output' };
                scene.add(outputJack);
                
                module.userData.input = inputJack;
                module.userData.output = outputJack;
            });
        }

        // Play a note
        function playNote(note) {
            synth.triggerAttack(note);
        }

        // Stop playing note
        function stopNote() {
            synth.triggerRelease();
        }

        // Load a patch
        function loadPatch(index) {
            currentPatch = index;
            document.getElementById('patch-name').textContent = getPatchName(index);
            
            // Apply patch settings
            switch(index) {
                case 0: // Tight Mono Bass
                    // Detuned saws + sub sine
                    synth.set({
                        oscillator: {
                            type: "sawtooth"
                        },
                        envelope: {
                            attack: 0.002,
                            decay: 0.09,
                            sustain: 0.4,
                            release: 0.12
                        }
                    });
                    Tone.Transport.bpm.value = 120;
                    document.getElementById('bpm-value').textContent = '120';
                    document.getElementById('scale-value').textContent = 'A Minor';
                    document.getElementById('swing-value').textContent = '0.02';
                    break;
                case 1: // Lead Synth
                    synth.set({
                        oscillator: {
                            type: "square"
                        },
                        envelope: {
                            attack: 0.01,
                            decay: 0.2,
                            sustain: 0.7,
                            release: 0.3
                        }
                    });
                    Tone.Transport.bpm.value = 130;
                    document.getElementById('bpm-value').textContent = '130';
                    document.getElementById('scale-value').textContent = 'C Major';
                    document.getElementById('swing-value').textContent = '0.0';
                    break;
                case 2: // Pad
                    synth.set({
                        oscillator: {
                            type: "sine"
                        },
                        envelope: {
                            attack: 0.5,
                            decay: 0.5,
                            sustain: 0.8,
                            release: 1.0
                        }
                    });
                    Tone.Transport.bpm.value = 80;
                    document.getElementById('bpm-value').textContent = '80';
                    document.getElementById('scale-value').textContent = 'D Minor';
                    document.getElementById('swing-value').textContent = '0.0';
                    break;
                // Add more patches as needed
                default:
                    synth.set({
                        oscillator: {
                            type: "sawtooth"
                        },
                        envelope: {
                            attack: 0.01,
                            decay: 0.1,
                            sustain: 0.5,
                            release: 0.2
                        }
                    });
            }
        }

        // Get patch name
        function getPatchName(index) {
            const names = [
                "Tight Mono Bass",
                "Lead Synth",
                "Pad",
                "Bassline",
                "Arp Sequence",
                "Chord Stab",
                "Pluck",
                "Sweep Pad",
                "Noise Hit",
                "Drone"
            ];
            return names[index] || "Patch " + (index + 1);
        }

        // Export patch
        function exportPatch() {
            const patchData = {
                patch: currentPatch,
                seed: seed,
                bpm: Tone.Transport.bpm.value,
                scale: document.getElementById('scale-value').textContent,
                swing: parseFloat(document.getElementById('swing-value').textContent),
                synth: synth.get()
            };
            
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(patchData, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "patch.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        // Import patch
        function importPatch() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = e => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.readAsText(file, 'UTF-8');
                
                reader.onload = readerEvent => {
                    try {
                        const content = readerEvent.target.result;
                        const patchData = JSON.parse(content);
                        
                        // Apply patch data
                        loadPatch(patchData.patch);
                        Tone.Transport.bpm.value = patchData.bpm;
                        document.getElementById('bpm-value').textContent = patchData.bpm;
                        document.getElementById('scale-value').textContent = patchData.scale;
                        document.getElementById('swing-value').textContent = patchData.swing;
                        synth.set(patchData.synth);
                        
                        alert('Patch imported successfully!');
                    } catch (error) {
                        alert('Error importing patch: ' + error.message);
                    }
                };
            };
            
            input.click();
        }

        // Draw oscilloscope
        function drawScope() {
            if (!scopeContext) return;
            
            scopeContext.fillStyle = 'rgba(0, 20, 0, 0.1)';
            scopeContext.fillRect(0, 0, scopeCanvas.width, scopeCanvas.height);
            
            scopeContext.strokeStyle = '#0f0';
            scopeContext.lineWidth = 1;
            scopeContext.beginPath();
            
            // Draw a simple waveform
            const now = Date.now();
            for (let i = 0; i < scopeCanvas.width; i++) {
                const x = i;
                const y = scopeCanvas.height / 2 + Math.sin((i + now/10) * 0.1) * 30;
                if (i === 0) {
                    scopeContext.moveTo(x, y);
                } else {
                    scopeContext.lineTo(x, y);
                }
            }
            
            scopeContext.stroke();
            
            // Draw Lissajous figure
            scopeContext.beginPath();
            for (let i = 0; i < 360; i++) {
                const rad = i * Math.PI / 180;
                const x = scopeCanvas.width * 0.75 + Math.sin(rad * 2 + now/100) * 20;
                const y = scopeCanvas.height / 2 + Math.sin(rad * 3 + now/100) * 20;
                if (i === 0) {
                    scopeContext.moveTo(x, y);
                } else {
                    scopeContext.lineTo(x, y);
                }
            }
            scopeContext.stroke();
        }

        // Mouse event handlers
        function onMouseDown(event) {
            event.preventDefault();
            
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(modules);
            
            if (intersects.length > 0) {
                selectedModule = intersects[0].object;
                
                // Check if we clicked on an output jack
                const jackIntersects = raycaster.intersectObjects([selectedModule.userData.output]);
                if (jackIntersects.length > 0) {
                    draggingCable = {
                        start: selectedModule.userData.output.position.clone(),
                        end: selectedModule.userData.output.position.clone()
                    };
                }
            }
        }

        function onMouseMove(event) {
            if (draggingCable) {
                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                const intersection = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersection);
                
                draggingCable.end.copy(intersection);
                
                // Update cable visualization
                updateDraggingCable();
            }
        }

        function onMouseUp(event) {
            if (draggingCable) {
                // Check if we released over an input jack
                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                const intersects = raycaster.intersectObjects(modules.map(m => m.userData.input));
                
                if (intersects.length > 0) {
                    const targetJack = intersects[0].object;
                    const sourceModule = selectedModule;
                    const targetModule = modules.find(m => m.userData.input === targetJack);
                    
                    // Create cable connection
                    createCable(sourceModule, targetModule);
                }
                
                // Clean up
                draggingCable = null;
                selectedModule = null;
                
                // Remove dragging cable visualization
                if (draggingCableLine) {
                    scene.remove(draggingCableLine);
                    draggingCableLine = null;
                }
            }
        }

        // Update dragging cable visualization
        let draggingCableLine = null;
        function updateDraggingCable() {
            if (draggingCableLine) {
                scene.remove(draggingCableLine);
            }
            
            const points = [];
            points.push(draggingCable.start);
            points.push(draggingCable.end);
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
            draggingCableLine = new THREE.Line(geometry, material);
            scene.add(draggingCableLine);
        }

        // Create cable between modules
        function createCable(source, target) {
            const cableGeometry = new THREE.CatmullRomCurve3([
                source.userData.output.position,
                new THREE.Vector3(
                    (source.userData.output.position.x + target.userData.input.position.x) / 2,
                    (source.userData.output.position.y + target.userData.input.position.y) / 2 + 1,
                    0
                ),
                target.userData.input.position
            ]);
            
            const tubeGeometry = new THREE.TubeGeometry(cableGeometry, 32, 0.05, 8, false);
            const material = new THREE.MeshBasicMaterial({ 
                color: Math.random() * 0xffffff,
                transparent: true,
                opacity: 0.7
            });
            const cable = new THREE.Mesh(tubeGeometry, material);
            scene.add(cable);
            
            cables.push({
                source: source,
                target: target,
                mesh: cable
            });
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate modules slightly
            modules.forEach(module => {
                module.rotation.y += 0.005;
            });
            
            // Update scope
            drawScope();
            
            // Render scene
            renderer.render(scene, camera);
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>