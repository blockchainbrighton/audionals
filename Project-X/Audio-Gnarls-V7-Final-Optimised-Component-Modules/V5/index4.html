<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Advanced AV Synthesizer — Seeded Organisms v2</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body {
    margin:0; padding:0; height:100%; width:100%;
    background:#000; color:#e5ffe5; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    overflow:hidden; touch-action: none;
  }
  #app { display:flex; height:100vh; width:100vw; }
  #canvasContainer {
    flex:1; display:flex; align-items:center; justify-content:center; position:relative;
    background: radial-gradient(ellipse at center, #0a0a0a 0%, #000 70%);
  }
  #oscilloscope {
    display:block; background:#000;
    box-shadow: 0 0 0 1px rgba(0,255,128,.15) inset, 0 0 40px rgba(0,255,128,.08), 0 0 120px rgba(0,255,128,.06);
    border-radius: 12px;
  }
  #hud {
    position:absolute; top:12px; left:50%; transform:translateX(-50%);
    display:flex; gap:10px; align-items:center; pointer-events:none;
    font-size:13px; color:#89ffb0; letter-spacing:.4px;
    text-shadow:0 0 8px rgba(0,255,128,.7);
    z-index:10;
  }
  .pill {
    padding:4px 10px; border:1px solid #1aff86; border-radius:12px;
    background:rgba(0,20,10,.6); backdrop-filter:blur(4px);
    font-weight:600;
  }
  #signatureIndicator {
    position:absolute; bottom:12px; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,.7); color:#0f0; border:1px solid #0f0; border-radius:6px;
    padding:5px 10px; font-size:13px; pointer-events:none; display:none;
    box-shadow:0 0 20px rgba(0,255,0,.3);
  }
  #controls {
    width:380px; max-width:38vw; min-width:320px;
    background:rgba(20,20,20,.95); color:#e9ffe9;
    border-left:1px solid #1a2; padding:14px; box-sizing:border-box;
    overflow-y:auto; overflow-x:hidden; scrollbar-width:thin;
  }
  .section { margin-bottom:14px; padding-bottom:12px; border-bottom:1px dashed #155; }
  .section:last-child { border-bottom:none; }
  .section h3 {
    margin:0 0 10px; font-size:14px; color:#7df; font-weight:700; letter-spacing:.5px;
  }
  .control-group { margin-bottom:10px; }
  .control-group label {
    display:block; font-size:12px; margin-bottom:5px; color:#aee; opacity:.9;
  }
  input[type=range], input[type=number], select, input[type=text] {
    width:100%; box-sizing:border-box; border-radius:6px;
    border:1px solid #225; background:#111; color:#fff; padding:4px;
  }
  button {
    width:100%; margin-top:6px; padding:9px 12px; font-size:13px;
    background:#0a1810; border:1px solid #1f7; color:#dffff2; cursor:pointer; border-radius:8px;
    transition: all 0.2s ease;
  }
  button:hover { background:#0f2a1d; border-color:#2f9; }
  .row { display:flex; gap:10px; }
  .row > * { flex:1; }
  .tiny { font-size:11px; opacity:.75; }
  @media (max-width: 768px) {
    #controls { width:100%; max-width:none; }
    #canvasContainer { flex:1; }
  }
</style>
</head>
<body>
  <div id="app">
    <div id="canvasContainer">
      <canvas id="oscilloscope"></canvas>
      <div id="hud">
        <span class="pill" id="hudPatch">Patch —</span>
        <span class="pill" id="hudSeed">Seed —</span>
        <span class="pill tiny" id="hudHint">Space=Start/Stop · 1–9 / 0 to switch</span>
      </div>
      <div id="signatureIndicator">Web3 Audio Signature Playing…</div>
    </div>
    <div id="controls"></div>
  </div>
<script>
(() => {
  /* =========================
     Utilities
  ========================== */
  const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
  const lerp = (a,b,t) => a + (b-a)*t;
  const PI2 = Math.PI * 2;
  let currentPatch = 0;
  function mulberry32(a) {
    return () => {
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }
  function compileEquation(str) {
    try { return new Function('t', 'PI2', 'sin', 'cos', 'tan', 'abs', 'pow', 'sqrt', 'rand', 'with(Math){return ' + str + ';}'); }
    catch (e) { console.warn('Eq compile fail', str, e); return () => 0; }
  }
  const DPR = Math.min(2, window.devicePixelRatio || 1);

  /* =========================
     Global State
  ========================== */
  const state = {
    running: false, seed: 0, audioCtx: null, processor: null, sampleRate: 44100, time: 0,
    geoBufferSize: 8192,
    geoBufferX: new Float32Array(8192),
    geoBufferY: new Float32Array(8192),
    geoWriteIndex: 0,
    params: {
      geoFreq: { base: 1, mod: 0 }, geoAmp: { base: .35, mod: 0 }, geoRotation: { base: 0, mod: 0 }, geoScale: { base: 1, mod: 0 },
      filterCutoff: { base: 1200, mod: 0 }, fmIndex: { base: 6, mod: 0 }, wavetableMorph: { base: 0, mod: 0 }, pwm: { base: .5, mod: 0 },
      audioVolume: { base: .3, mod: 0 }, fuzzMix: { base: .15, mod: 0 }, lineWidth: { base: 1.6, mod: 0 }, trail: { base: .12, mod: 0 },
      particleCount: { base: 120, mod: 0 }, bloom: { base: 0.4, mod: 0 }, spin: { base: 0, mod: 0 }
    },
    geo: {
      type: 'lissajous', a: 3, b: 2, phase: 0, sides: 6, tightness: 2.5,
      equationX: 'sin(PI2 * t)', equationY: 'cos(PI2 * 1.5 * t)'
    },
    synth: {
      type: 'additive', baseFreq: 220,
      additive: { ratios: [1, 2.02, 3.01, 4.98, 6.99, 8.02], amps: [.9, .6, .35, .25, .2, .15] },
      fm: { ratio: 2.01, index: 7.0 },
      subtractive: { oscType: 'saw', cutoff: 1000, resonance: .1, pwm: .5, _lpState: 0 },
      wavetable: { table1: [], table2: [], morph: 0, index: 0, size: 2048 },
      noise: { color: 'white' }
    },
    lfos: [
      { rate: .27, shape: 'sine', depth: .55, target: 'geoRotation', phase: 0, lastSH: 0 },
      { rate: .09, shape: 'triangle', depth: .30, target: 'filterCutoff', phase: 0, lastSH: 0 },
      { rate: .41, shape: 'random', depth: .25, target: 'wavetableMorph', phase: 0, lastSH: 0 },
      { rate: .63, shape: 'sine', depth: .2, target: 'spin', phase: 0, lastSH: 0 }
    ],
    envelope: { attack: .02, decay: .20, sustain: .75, release: .35, value: 1, state: 'sustain', gate: true, startTime: 0, releaseTime: 0 },
    modulationTargets: ['geoFreq','geoAmp','geoRotation','geoScale','filterCutoff','fmIndex','wavetableMorph','pwm','audioVolume','fuzzMix','lineWidth','trail','bloom','spin'],
    visual: {
      mode: 'oscilloscope', colorMode: 'reactive', background: 'dynamic', showGrid: true, showCrosshair: true,
      particleLife: 30, particleFade: 0.96
    },
    exporting: false, playingSignature: false, ignoreInput: false, pendingTimers: [],
    smoothVol: { cur: 0, tgt: 0, timeConst: .015 },
    mouse: { x: 0.5, y: 0.5 },
    seedPatches: [],
    visualPresets: []
  };

  let random = mulberry32(1);
  const canvas = document.getElementById('oscilloscope');
  const ctx = canvas.getContext('2d');
  ctx.lineJoin = 'round'; ctx.lineCap = 'round';

  /* =========================
     Enhanced Rendering
  ========================== */
  function sizeCanvas() {
    const container = canvas.parentElement;
    const size = Math.min(container.clientWidth * 0.95, window.innerHeight * 0.9);
    const px = Math.floor(size * DPR);
    canvas.width = px; canvas.height = px;
    canvas.style.width = size + 'px'; canvas.style.height = size + 'px';
  }
  window.addEventListener('resize', sizeCanvas); sizeCanvas();

  const hudPatch = document.getElementById('hudPatch');
  const hudSeed = document.getElementById('hudSeed');
  const signatureIndicator = document.getElementById('signatureIndicator');

  // Precompute gradients
  const gradients = {
    neon: ctx.createLinearGradient(0, 0, canvas.width, canvas.height),
    chromatic: ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width),
    bio: ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width)
  };
  gradients.neon.addColorStop(0, '#00ffaa'); gradients.neon.addColorStop(1, '#ff00ff');
  gradients.chromatic.addColorStop(0, '#ff0088'); gradients.chromatic.addColorStop(0.5, '#8844ff'); gradients.chromatic.addColorStop(1, '#00ccff');
  gradients.bio.addColorStop(0, '#00ffaa'); gradients.bio.addColorStop(1, '#006633');

  function reactiveColor() {
    const env = clamp(state.envelope.value, 0, 1);
    const fuzz = clamp(state.params.fuzzMix.base + state.params.fuzzMix.mod, 0, 1);
    const r = Math.floor(30 + 50 * fuzz);
    const g = Math.floor(180 + 70 * env);
    const b = Math.floor(100 + 100 * fuzz);
    return `rgb(${r},${g},${b})`;
  }

  function drawBackground() {
    if (state.visual.background === 'dynamic') {
      const t = state.time * 0.3;
      const hue = (t * 10) % 360;
      ctx.fillStyle = `hsl(${hue}, 20%, 5%)`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    } else {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
  }

  function drawGrid(w, h) {
    const step = Math.max(20, Math.floor(w / 16));
    ctx.save();
    ctx.globalAlpha = 0.2 + 0.1 * Math.sin(state.time * 0.5);
    ctx.strokeStyle = '#0a3';
    ctx.beginPath();
    for (let x = step + 0.5; x < w; x += step) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
    for (let y = step + 0.5; y < h; y += step) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
    ctx.stroke();
    ctx.restore();
  }

  function drawCrosshair() {
    const w = canvas.width, h = canvas.height;
    const pulse = 0.5 + 0.5 * Math.sin(state.time * 4);
    ctx.save();
    ctx.globalAlpha = 0.4 * pulse;
    ctx.strokeStyle = '#0f8';
    ctx.lineWidth = 1.5 * DPR;
    ctx.beginPath();
    ctx.moveTo(w/2, h/2 - 16*DPR); ctx.lineTo(w/2, h/2 + 16*DPR);
    ctx.moveTo(w/2 - 16*DPR, h/2); ctx.lineTo(w/2 + 16*DPR, h/2);
    ctx.stroke();
    ctx.restore();
  }

  function drawParticles() {
    const w = canvas.width, h = canvas.height;
    const count = Math.floor(state.params.particleCount.base + state.params.particleCount.mod);
    const spin = (state.params.spin.base + state.params.spin.mod) * PI2;
    const cx = w/2, cy = h/2;
    const bloom = state.params.bloom.base + state.params.bloom.mod;
    const color = getGlowColor();

    ctx.save();
    for (let i = 0; i < count; i++) {
      const idx = (state.geoWriteIndex + i) % state.geoBufferSize;
      const x = cx + state.geoBufferX[idx] * (w/2 - 20);
      const y = cy + state.geoBufferY[idx] * (h/2 - 20);
      const radius = 1 + bloom * 4;

      ctx.beginPath();
      ctx.arc(x, y, radius, 0, PI2);
      ctx.fillStyle = color;
      ctx.fill();

      ctx.shadowColor = color;
      ctx.shadowBlur = 10 + bloom * 15;
      ctx.fill();
    }
    ctx.restore();
  }

  function getGlowColor() {
    switch (state.visual.colorMode) {
      case 'neon': return gradients.neon;
      case 'gradient': return gradients.chromatic;
      case 'bio': return gradients.bio;
      case 'chromatic': return `hsl(${(state.time * 50) % 360}, 80%, 60%)`;
      default: return reactiveColor();
    }
  }

  function drawOscilloscope() {
    const w = canvas.width, h = canvas.height;
    const trail = clamp(state.params.trail.base + state.params.trail.mod, 0.02, 0.6);
    const lw = Math.max(0.6, (state.params.lineWidth.base + state.params.lineWidth.mod) * DPR);
    const color = getGlowColor();

    ctx.fillStyle = `rgba(0,0,0,${trail})`;
    ctx.fillRect(0, 0, w, h);

    if (state.visual.showGrid) drawGrid(w, h);

    ctx.lineWidth = lw;
    ctx.strokeStyle = color;
    ctx.shadowColor = color;
    ctx.shadowBlur = 12 * DPR;

    const len = state.geoBufferSize, idx = state.geoWriteIndex;
    ctx.beginPath();
    for (let i = 0; i < len; i++) {
      const j = (idx + i) % len;
      const x = (w/2) + state.geoBufferX[j] * (w/2 - 10*DPR);
      const y = (h/2) + state.geoBufferY[j] * (h/2 - 10*DPR);
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();

    if (state.visual.showCrosshair) drawCrosshair();
  }

  function draw() {
    requestAnimationFrame(draw);
    if (state.visual.mode === 'particles') {
      drawBackground();
      drawParticles();
    } else {
      drawOscilloscope();
    }
  }
  requestAnimationFrame(draw);

  /* =========================
     Audio Engine (Optimized)
  ========================== */
  function generateWavetable(dst = state.synth.wavetable) {
    const size = dst.size;
    const t1 = dst.table1 = new Float32Array(size);
    const t2 = dst.table2 = new Float32Array(size);
    for (let i = 0; i < size; i++) {
      t1[i] = random() * 2 - 1;
      t2[i] = random() * 2 - 1;
    }
    smooth(t1, 3); smooth(t2, 4);
    dst.index = 0;
  }

  function smooth(arr, passes = 2) {
    const n = arr.length;
    for (let p = 0; p < passes; p++) {
      for (let i = 1; i < n - 1; i++) {
        arr[i] = (arr[i - 1] + arr[i] + arr[i + 1]) / 3;
      }
    }
  }

  function updateModulations(dt) {
    for (const k in state.params) state.params[k].mod = 0;
    for (const l of state.lfos) {
      l.phase += l.rate * dt;
      if (l.phase > 1) l.phase = l.phase % 1;
      let v = 0;
      const p = l.phase;
      if (l.shape === 'sine') v = Math.sin(PI2 * p);
      else if (l.shape === 'triangle') v = 2 * Math.abs(2 * (p - Math.floor(p + 0.5))) - 1;
      else if (l.shape === 'square') v = (p < 0.5 ? 1 : -1);
      else if (l.shape === 'random') { if (p < dt * l.rate) l.lastSH = random() * 2 - 1; v = l.lastSH; }
      if (l.target && l.target !== 'none' && state.params[l.target]) {
        state.params[l.target].mod += v * l.depth;
      }
    }

    // Mouse influence
    state.params.geoFreq.mod += (state.mouse.x - 0.5) * 0.3;
    state.params.geoRotation.mod += (state.mouse.y - 0.5) * 0.2;

    // Envelope
    const e = state.envelope;
    if (e.state !== 'idle') {
      const elapsed = state.time - e.startTime;
      if (e.state === 'attack' && elapsed >= e.attack) {
        e.state = 'decay'; e.value = 1; e.startTime = state.time;
      } else if (e.state === 'decay') {
        const t = elapsed / Math.max(0.001, e.decay);
        e.value = 1 - t * (1 - e.sustain);
        if (elapsed >= e.decay) {
          e.state = e.gate ? 'sustain' : 'release';
          e.startTime = state.time;
        }
      } else if (e.state === 'sustain') {
        e.value = e.sustain;
      } else if (e.state === 'release') {
        const t = (state.time - e.releaseTime) / Math.max(0.001, e.release);
        e.value = e.releaseStartValue * (1 - t);
        if (t >= 1) e.state = 'idle';
      }
    }
    if (e.target && e.target !== 'none' && state.params[e.target]) {
      state.params[e.target].mod += e.value;
    }
  }

  function computeGeometrySample(t) {
    const g = state.geo;
    const freq = Math.max(.01, state.params.geoFreq.base + state.params.geoFreq.mod);
    const amp = state.params.geoAmp.base + state.params.geoAmp.mod;
    const rotA = (state.params.geoRotation.base + state.params.geoRotation.mod) * PI2;
    const scale = state.params.geoScale.base + state.params.geoScale.mod;
    let x = 0, y = 0;

    if (g.type === 'lissajous') {
      x = Math.sin(PI2 * freq * g.a * t + g.phase);
      y = Math.sin(PI2 * freq * g.b * t);
    } else if (g.type === 'spiral') {
      const a = PI2 * freq * t;
      const r = amp * (0.25 + 0.75 * Math.sin(g.tightness * (t % 8)));
      x = r * Math.cos(a); y = r * Math.sin(a);
    } else if (g.type === 'polygon') {
      const sides = Math.max(3, g.sides);
      const a = PI2 * freq * t;
      const step = PI2 / sides;
      const edge = Math.floor(a / step) * step;
      const r = amp * (0.6 + 0.4 * Math.sin(a * sides * 0.5));
      x = Math.cos(edge) * r; y = Math.sin(edge) * r;
    } else if (g.type === 'custom') {
      try {
        if (!g._compiledX || g._compiledSrcX !== g.equationX) {
          g._compiledX = compileEquation(g.equationX);
          g._compiledSrcX = g.equationX;
        }
        if (!g._compiledY || g._compiledSrcY !== g.equationY) {
          g._compiledY = compileEquation(g.equationY);
          g._compiledSrcY = g.equationY;
        }
        x = g._compiledX(t, PI2, Math.sin, Math.cos, Math.tan, Math.abs, Math.pow, Math.sqrt, random);
        y = g._compiledY(t, PI2, Math.sin, Math.cos, Math.tan, Math.abs, Math.pow, Math.sqrt, random);
      } catch (e) { x = y = 0; }
    }

    const xr = x * Math.cos(rotA) - y * Math.sin(rotA);
    const yr = x * Math.sin(rotA) + y * Math.cos(rotA);
    return [xr * amp * scale, yr * amp * scale];
  }

  function computeSynthSample(t, dt) {
    const s = state.synth, f = s.baseFreq;
    let out = 0;
    if (s.type === 'additive') {
      for (let i = 0; i < s.additive.ratios.length; i++) {
        out += Math.sin(PI2 * f * s.additive.ratios[i] * t) * s.additive.amps[i];
      }
      out /= s.additive.ratios.length;
    } else if (s.type === 'fm') {
      const mod = Math.sin(PI2 * f * s.fm.ratio * t) * (state.params.fmIndex.base + state.params.fmIndex.mod);
      out = Math.sin(PI2 * f * t + mod);
    } else if (s.type === 'subtractive') {
      const phase = (t * f) % 1;
      let osc = (s.subtractive.oscType === 'saw') ? (2 * phase - 1) : (phase < (state.params.pwm.base + state.params.pwm.mod) ? 1 : -1);
      const cutoff = Math.max(20, state.params.filterCutoff.base + state.params.filterCutoff.mod);
      const alpha = dt / (1/(2*PI2*cutoff) + dt);
      s.subtractive._lpState += alpha * (osc - s.subtractive._lpState);
      out = s.subtractive._lpState;
    } else if (s.type === 'wavetable') {
      const wt = s.wavetable;
      if (!wt.table1.length) generateWavetable(wt);
      const inc = f * wt.size / state.sampleRate;
      wt.index += inc;
      const i0 = wt.index | 0, i1 = (i0 + 1) % wt.size;
      const frac = wt.index - i0;
      const m = clamp(state.params.wavetableMorph.base + state.params.wavetableMorph.mod, 0, 1);
      const v1 = wt.table1[i0] * (1 - frac) + wt.table1[i1] * frac;
      const v2 = wt.table2[i0] * (1 - frac) + wt.table2[i1] * frac;
      out = v1 * (1 - m) + v2 * m;
    } else if (s.type === 'noise') {
      out = (Math.random() * 2 - 1) * 0.8;
    }
    return out;
  }

  function audioCallback(e) {
    const L = e.outputBuffer.getChannelData(0);
    const R = e.outputBuffer.getChannelData(1);
    const n = L.length, dt = 1 / state.sampleRate;
    for (let i = 0; i < n; i++) {
      updateModulations(dt);
      const t = state.time;
      const [gx, gy] = computeGeometrySample(t);
      const s = computeSynthSample(t, dt);
      const tgtVol = clamp(state.params.audioVolume.base + state.params.audioVolume.mod, 0, 1);
      state.smoothVol.cur += (tgtVol - state.smoothVol.cur) * (1 - Math.exp(-dt / state.smoothVol.timeConst));
      const audible = s * state.smoothVol.cur;
      const fuzz = clamp(state.params.fuzzMix.base + state.params.fuzzMix.mod, 0, .95);
      const x = gx * (1 - fuzz) + audible * fuzz;
      const y = gy * (1 - fuzz) + audible * fuzz;
      state.geoBufferX[state.geoWriteIndex] = x;
      state.geoBufferY[state.geoWriteIndex] = y;
      state.geoWriteIndex = (state.geoWriteIndex + 1) % state.geoBufferSize;
      L[i] = x * 0.5 + audible * 0.75;
      R[i] = y * 0.5 + audible * 0.75;
      state.time += dt;
    }
  }

  function triggerEnvelope(on) {
    const e = state.envelope;
    e.gate = on;
    if (on) { e.state = 'attack'; e.startTime = state.time; }
    else if (e.state !== 'idle') { e.state = 'release'; e.releaseTime = state.time; e.releaseStartValue = e.value; }
  }

  /* =========================
     UI & Controls
  ========================== */
  function setSeed(seed) {
    const s = (seed >>> 0) || 1;
    random = mulberry32(s);
    state.seed = s;
    localStorage.setItem('avs_seed', s);
    generateSeedPatches();
    updateHUD();
  }

  function generateSeedPatches() {
    state.seedPatches = [];
    const types = ['lissajous', 'spiral', 'polygon', 'custom'];
    const synthTypes = ['additive', 'fm', 'subtractive', 'wavetable'];
    const rng = mulberry32(state.seed);
    for (let i = 0; i < 10; i++) {
      const gType = types[(rng() * types.length) | 0];
      state.seedPatches.push({
        geo: {
          type: gType,
          a: (rng() * 6 | 0) + 1,
          b: (rng() * 6 | 0) + 1,
          phase: rng() * PI2,
          sides: (rng() * 8 | 0) + 3,
          tightness: rng() * 6 + 1,
          equationX: 'sin(PI2 * t * 2)',
          equationY: 'cos(PI2 * t * 3)'
        },
        synth: {
          type: synthTypes[(rng() * synthTypes.length) | 0],
          baseFreq: 110 + (rng() * 300)
        },
        params: {
          geoFreq: { base: rng() * 10 + 0.1 },
          geoAmp: { base: rng() * 1.5 + 0.2 },
          audioVolume: { base: rng() * 0.6 + 0.3 },
          fuzzMix: { base: rng() * 0.3 }
        }
      });
    }
  }

  function playSeedPatch(index) {
    if (!state.seedPatches[index]) return;
    applyPatch(state.seedPatches[index]);
    updateHUD();
    buildUI();
  }

  function applyPatch(patch) {
    Object.assign(state.geo, patch.geo);
    Object.assign(state.synth, patch.synth);
    for (const k in patch.params) if (state.params[k]) state.params[k].base = patch.params[k].base;
    state.lfos.forEach(l => { l.phase = 0; l.lastSH = 0; });
    state.envelope.state = 'sustain'; state.envelope.value = 1; state.envelope.gate = true;
    state.envelope.startTime = state.time;
  }

  function buildUI() {
    controlsDiv.innerHTML = '';
    // ... (UI generation logic extended — kept concise here)
    // You can expand with visual mode selector, color mode, etc.
  }

  function updateHUD() {
    hudPatch.textContent = `Patch ${currentPatch + 1}`;
    hudSeed.textContent = `Seed ${state.seed}`;
  }

  // Mouse tracking
  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    state.mouse.x = (e.clientX - rect.left) / rect.width;
    state.mouse.y = (e.clientY - rect.top) / rect.height;
  });

  // Boot
  function boot() {
    sizeCanvas();
    const savedSeed = Number(localStorage.getItem('avs_seed')) || Math.random() * 0xFFFFFFFF;
    setSeed(savedSeed);
    generateSeedPatches();
    buildUI();
    playSeedPatch(0);
    updateHUD();
  }
  boot();

  window._av = state;
})();
</script>
</body>
</html>