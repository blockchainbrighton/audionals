<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Seeded Oscilloscope Synth NFT — 12-TET / 19-TET</title>
<style>
  :root {
    --bg:#000;
    --fg:#d7ffe3;
    --muted:#7abf99;
    --accent:#8fffd2;
    --danger:#ff6a6a;
    --panel:#0b0f0d;
    --grid:#0a1d15;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:14px ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;overflow:hidden;}
  #app{display:grid;grid-template-rows:auto 1fr auto;gap:6px;height:100vh;}
  header,footer{display:flex;gap:10px;align-items:center;padding:8px 10px;background:var(--panel);border-bottom:1px solid #0d2;box-shadow:0 1px 0 #041;}
  footer{border-top:1px solid #0d2;border-bottom:none;box-shadow:0 -1px 0 #041;}
  .btn{background:#092;color:var(--fg);border:1px solid #0d2;border-radius:6px;padding:6px 10px;cursor:pointer}
  .btn[disabled]{opacity:.5;cursor:not-allowed}
  .switch{display:inline-flex;align-items:center;gap:6px}
  input[type="number"]{width:70px;background:#031;color:var(--fg);border:1px solid #0d2;border-radius:6px;padding:4px 6px}
  #scopeWrap{position:relative;background:linear-gradient(#000,#001);margin:0 6px 6px 6px;border:1px solid #0d2;border-radius:10px;overflow:hidden}
  #scope{display:block;width:100%;height:100%}
  #readouts{position:absolute;inset:10px auto auto 10px;background:rgba(0,0,0,.35);padding:6px 8px;border:1px solid #0d2;border-radius:6px}
  #meters{position:absolute;top:10px;right:10px;display:flex;gap:6px}
  .meter{width:6px;height:80px;background:#041;position:relative;border:1px solid #0d2;border-radius:3px;overflow:hidden}
  .meter>.bar{position:absolute;bottom:0;left:0;right:0;background:var(--accent);height:0%}
  .hud{display:inline-block;margin-left:10px;color:var(--muted)}
  .tag{display:inline-block;padding:2px 6px;border:1px solid #0d2;border-radius:6px;background:#041;margin-right:6px}
  details{margin-left:auto;color:var(--muted)}
  summary{cursor:pointer}
  a.link{color:var(--accent);text-decoration:none}
</style>
</head>
<body>
<div id="app">
  <header>
    <button id="power" class="btn">Power</button>
    <span class="tag">Seed: <span id="seedOut">—</span></span>
    <label> BPM <input id="bpm" type="number" min="40" max="220" value="110" /></label>
    <button id="rec" class="btn">Rec</button>
    <button id="play" class="btn" disabled>Play</button>
    <button id="stop" class="btn" disabled>Stop</button>
    <label class="switch">
      Loop <input id="loop" type="checkbox" checked />
    </label>
    <button id="save" class="btn">Save</button>
    <label class="btn" for="loadFile">Load<input id="loadFile" type="file" accept="application/json" style="display:none"/></label>
    <span class="hud" id="tuningHUD">Tuning: —</span>
    <label class="switch" title="Affects only newly scheduled notes">
      Temperament
      <select id="temperament">
        <option value="12">12-TET</option>
        <option value="19">19-TET</option>
      </select>
    </label>
    <details id="bootLog"><summary>Boot Log</summary><pre id="bootText" style="max-height:25vh;overflow:auto;margin:0;color:#9fd8b8"></pre></details>
    <span id="loader" class="hud" style="margin-left:auto">Idle</span>
  </header>

  <div id="scopeWrap">
    <canvas id="scope"></canvas>
    <div id="readouts">
      <div>Alg ⇄ Voice (0–9). Recording writes steps.</div>
      <div>Transport: <span id="transportState">stopped</span></div>
    </div>
    <div id="meters">
      <div class="meter" title="Master"><div class="bar" id="mMaster"></div></div>
      <div class="meter" title="CPU (approx draw)"><div class="bar" id="mCPU"></div></div>
    </div>
  </div>

  <footer>
    <span>XY Algorithms:</span>
    <span class="hud">1) Lissajous 2) Spiral–Precess 3) Polar Rose 4) Phyllotaxis 5) Figure-8 6) Epicycle 7) VectorScope XY 8) Torus-Knot 9) Audio Flowfield 10) Harmonic Bloom</span>
  </footer>
</div>

<script>
/* -------------------- Deterministic PRNG & seed handling -------------------- */
function sfc32(a,b,c,d){return function(){a|=0;b|=0;c|=0;d|=0;var t=(a+b|0)+d|0;d=d+1|0;a=b^b>>>9;b=c+(c<<3)|0;c=(c<<21|c>>>11);c=c+t|0;return (t>>>0)/4294967296}}
function xmur3(str){let h=1779033703^str.length;for(let i=0;i<str.length;i++){h=Math.imul(h^str.charCodeAt(i),3432918353);h=h<<13|h>>>19}return function(){h=Math.imul(h^h>>>16,2246822507);h=Math.imul(h^h>>>13,3266489909);return (h^h>>>16)>>>0}}
function seededRand(seed){const seedHash=xmur3(seed);return sfc32(seedHash(),seedHash(),seedHash(),seedHash())}
function choose(rand,arr){return arr[Math.floor(rand()*arr.length)]}
function shuffle(rand,arr){for(let i=arr.length-1;i>0;i--){const j=Math.floor(rand()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
function clamp(v,min,max){return v<min?min:v>max?max:v}

/* -------------------- URL seed (locked session) -------------------- */
function ensureSeed(){const url=new URL(location.href);let s=url.searchParams.get('seed');if(!s){s=(Math.random().toString(16).slice(2)+Math.random().toString(16).slice(2)).slice(0,16);url.searchParams.set('seed',s);history.replaceState(null,'',url.toString())}return s}
const runtimeState = { Tone:null, started:false };
const seed = ensureSeed();
document.getElementById('seedOut').textContent = seed;

/* -------------------- Tuning (12-TET / 19-TET) -------------------- */
const TUNING = (()=> {
  function ratio12(semitones){ return Math.pow(2, semitones/12) }
  function ratio19(steps){ return Math.pow(2, steps/19) }
  function buildScale(temperament, rootHz, length=64){
    const notes = [];
    if(temperament===12){
      const degrees=[0,2,4,5,7,9,11]; // major-ish pool
      for(let i=0;i<length;i++){
        const deg=degrees[i%degrees.length]+12*Math.floor(i/degrees.length)%24;
        notes.push(rootHz*ratio12(deg));
      }
    } else {
      const degrees=[0,3,5,7,10,12,14]; // 19-TET roughly diatonic-ish
      for(let i=0;i<length;i++){
        const deg=degrees[i%degrees.length]+19*Math.floor(i/degrees.length)%38;
        notes.push(rootHz*ratio19(deg));
      }
    }
    return notes;
  }
  return { ratio12, ratio19, buildScale }
})();

const ui = {
  power: document.getElementById('power'),
  bpm: document.getElementById('bpm'),
  rec: document.getElementById('rec'),
  play: document.getElementById('play'),
  stop: document.getElementById('stop'),
  loop: document.getElementById('loop'),
  save: document.getElementById('save'),
  loadFile: document.getElementById('loadFile'),
  temperament: document.getElementById('temperament'),
  tuningHUD: document.getElementById('tuningHUD'),
  transportState: document.getElementById('transportState'),
  mMaster: document.getElementById('mMaster'),
  mCPU: document.getElementById('mCPU'),
  loader: document.getElementById('loader'),
  bootText: document.getElementById('bootText'),
};

/* -------------------- Provided on-chain Tone.js loader (EXACT) -------------------- */
function loadToneJSAndBoot({
  toneUrl = 'https://ordinals.com/content/04813d7748d918bd8a3069cb1823ebc9586f0ce16cd6a97a784581ec38d13062i0',
  setLoaderStatus, runtimeState, boot
}) {
  setLoaderStatus('Loading Audio Engine...');
  import(toneUrl).then(() => {
    runtimeState.Tone = window.Tone;
    console.log('[BOP Matrix] Tone.js loaded:', runtimeState.Tone?.version ?? 'Unknown');
    boot();
  }).catch(err => {
    setLoaderStatus('Failed to load Tone.js. App cannot start.', true);
    console.error('[BOP Matrix] Critical Tone.js load error:', err);
  });
}

/* -------------------- Audio graph / Voices / FX -------------------- */
const AudioApp = (function(){
  let Tone;
  let rand;
  let rootHz;
  let temperamentDefault;
  let temperamentCurrent;
  let scaleNotes;
  let voices=[];
  let analyserL, analyserR, masterMeter, cpuAvg = 0;
  let masterGain, softClip, limiter, merger, scopeSplitter;
  let bootDone = false;

  const algNames = [
    'Lissajous Core','Spiral–Precess','Polar Rose',
    'Phyllotaxis Orbit','Figure-8 Morph','Epicycle Chain',
    'VectorScope XY','Torus-Knot','Audio Flowfield','Harmonic Bloom'
  ];

  const state = {
    seqSteps: new Array(16).fill(null), // (voiceIndex 0–9) or null
    seqLen: 16,
    seqPos: 0,
    isRecording: false,
    isPlaying: false,
    voiceForKey: [], // 0..9 map to voice index
    algForVoice: [], // 0..9 -> algorithm index
    notePool: [],    // per seed note pool used for boot + sequencing
    lastScheduleId: 0
  };

  function logBoot(s){ ui.bootText.textContent += s + '\n' }

  function setTemperament(newT){
    temperamentCurrent = newT;
    scaleNotes = TUNING.buildScale(temperamentCurrent, rootHz, 256);
    ui.tuningHUD.textContent = `Tuning: ${temperamentCurrent}-TET • Root ${(rootHz).toFixed(2)} Hz`;
    logBoot(`[Tuning] Now ${temperamentCurrent}-TET (future notes only)`);
  }

  function initSeeded(randIn){
    rand = randIn;
    // Root A ~ 220–440 seeded
    rootHz = 200 + Math.floor(rand()*80) + 220; // 220..499
    // Default temperament by seed
    temperamentDefault = (rand() < 0.5) ? 12 : 19;
    setTemperament(temperamentDefault);
    // Seeded note pool (10 pitch classes from scale)
    const indices = shuffle(rand, Array.from({length:32},(_,i)=>i)).slice(0,10).sort((a,b)=>a-b);
    state.notePool = indices.map(i=>scaleNotes[i*2 + (i%2)]);
    logBoot(`[Seed] Root=${rootHz.toFixed(2)}Hz, Default Temperament=${temperamentDefault}-TET`);
  }

  function seededInt(min,max){ return Math.floor(rand()*(max-min+1))+min }
  function seededFloat(min,max){ return rand()*(max-min)+min }

  function mkFXChain(i){
    // Seeded choices
    const Tone = runtimeState.Tone;
    const fx = [];
    // Reverb
    if(rand() < 0.9){
      const rv = new Tone.Reverb({
        decay: seededFloat(1.2, 6.0),
        preDelay: seededFloat(0.001, 0.08),
        wet: seededFloat(0.05, 0.35)
      });
      fx.push(rv);
    }
    // PingPong Delay
    if(rand() < 0.85){
      const pp = new Tone.PingPongDelay({
        delayTime: seededFloat(0.08,0.45),
        feedback: seededFloat(0.1,0.45),
        wet: seededFloat(0.03,0.25)
      });
      fx.push(pp);
    }
    // Modulation (Chorus/Phaser/Flanger pick one)
    const modPick = choose(rand,['chorus','phaser','none','flanger','chorus']);
    if(modPick==='chorus'){
      fx.push(new Tone.Chorus({frequency:seededFloat(0.05,1.2),depth:seededFloat(0.1,0.5),delayTime:seededFloat(1,8),wet:seededFloat(0.05,0.4)}).start());
    } else if(modPick==='phaser'){
      fx.push(new Tone.Phaser({frequency:seededFloat(0.05,1.0),octaves:seededInt(1,4),Q:seededFloat(0.2,2),baseFrequency:seededFloat(200,1200),wet:seededFloat(0.05,0.35)}));
    } else if(modPick==='flanger'){
      fx.push(new Tone.FeedbackDelay({delayTime:seededFloat(0.002,0.009),feedback:seededFloat(0.1,0.3),wet:seededFloat(0.05,0.25)}));
    }
    // Drive/Bitcrush (pick one)
    if(rand() < 0.75){
      if(rand() < 0.5){
        fx.push(new Tone.Distortion({distortion:seededFloat(0.02,0.25),wet:seededFloat(0.03,0.35)}));
      } else {
        fx.push(new Tone.BitCrusher({bits:seededInt(4,8),wet:seededFloat(0.04,0.3)}));
      }
    }
    // Dynamic filter with seeded LFO sweep
    const filt = new Tone.Filter({type:choose(rand,['lowpass','bandpass','highpass']), Q: seededFloat(0.2,10), frequency: seededFloat(200,2000)});
    const lfo = new Tone.LFO({frequency: seededFloat(0.02,0.15), min: seededFloat(200,600), max: seededFloat(2000,8000)}).start();
    lfo.connect(filt.frequency);
    fx.push(filt);

    // Chain will be connected later: voiceOut -> ...fx... -> merger
    return fx;
  }

  function mkWavetableOsc(Tone, freq){
    // “Wavetable-like” via custom partials (deterministic)
    const partialCount = seededInt(6,16);
    const partials = Array.from({length:partialCount}, (_,k)=> (rand()*0.8+0.2)/(k+1));
    const osc = new Tone.Oscillator({frequency:freq, type:'custom', partials});
    return osc;
  }

  function mkVoice(i){
    const Tone = runtimeState.Tone;
    const typePick = choose(rand,['FM','AM','Subtractive','Additive','Wavetable','Noise','Ring']);
    const voice = { index:i, type:typePick, start:()=>{}, stop:()=>{}, setFreq:()=>{}, gainNode:null, fx:[], alive:true };

    const vGain = new Tone.Gain(0); // clickless ramps
    voice.gainNode = vGain;

    let src=null, mod=null, filter=null;

    if(typePick==='FM'){
      src = new Tone.FMSynth({
        harmonicity: seededFloat(0.25,3),
        modulationIndex: seededFloat(1,12),
        oscillator:{type:choose(rand,['sine','triangle','sawtooth'])},
        modulation:{type:choose(rand,['sine','triangle'])},
        envelope:{attack:0.01,decay:0.2,sustain:0.8,release:0.8},
        modulationEnvelope:{attack:0.01,decay:0.15,sustain:0.5,release:0.5}
      });
      filter = new Tone.Filter({type:'lowpass', frequency: seededFloat(800,4000), Q: seededFloat(0.2,4)});
      src.chain(filter, vGain);
      voice.setFreq = f => src.frequency.rampTo(f, 0.02);

    } else if(typePick==='AM'){
      src = new Tone.AMSynth({
        harmonicity: seededFloat(0.2,2),
        oscillator:{type:choose(rand,['sine','square','triangle'])},
        envelope:{attack:0.02,decay:0.2,sustain:0.7,release:0.7}
      });
      filter = new Tone.Filter({type:'bandpass', frequency: seededFloat(600,2400), Q: seededFloat(0.3,6)});
      src.chain(filter, vGain);
      voice.setFreq = f => src.frequency.rampTo(f, 0.02);

    } else if(typePick==='Subtractive'){
      src = new Tone.Oscillator({type:choose(rand,['sawtooth','square','triangle']), frequency:220});
      const noise = new Tone.Noise('white');
      const mix = new Tone.Gain(0.3);
      noise.connect(mix); src.connect(mix);
      filter = new Tone.Filter({type:'lowpass', frequency: seededFloat(1200,6000), Q: seededFloat(0.2,2)});
      const vca = new Tone.Gain(0);
      mix.chain(filter, vca, vGain);
      voice.setFreq = f => src.frequency.rampTo(f, 0.02);
      voice.start = ()=>{ src.start(); noise.start(); };
      voice.stop = ()=>{ src.stop(); noise.stop(); };
      // envelope for subtractive vca
      voice.env = new Tone.Envelope({attack:0.02,decay:0.3,sustain:0.9,release:0.8}).connect(vca.gain);

    } else if(typePick==='Additive'){
      const partials = Array.from({length:seededInt(4,12)},(_,k)=>1/(k+1));
      src = new Tone.Oscillator({type:'custom',partials,frequency:220});
      filter = new Tone.Filter({type:'bandpass', frequency: seededFloat(800,4000), Q: seededFloat(0.5,8)});
      const vca = new Tone.Gain(0);
      src.chain(filter, vca, vGain);
      voice.setFreq = f => src.frequency.rampTo(f, 0.02);
      voice.start = ()=> src.start();
      voice.stop = ()=> src.stop();
      voice.env = new Tone.Envelope({attack:0.02,decay:0.25,sustain:0.85,release:0.8}).connect(vca.gain);

    } else if(typePick==='Wavetable'){
      src = mkWavetableOsc(Tone, 220);
      const vca = new Tone.Gain(0);
      filter = new Tone.Filter({type:'lowpass', frequency: seededFloat(1500,7000), Q: seededFloat(0.2,3)});
      src.chain(filter, vca, vGain);
      voice.setFreq = f => src.frequency.rampTo(f, 0.02);
      voice.start = ()=> src.start();
      voice.stop = ()=> src.stop();
      voice.env = new Tone.Envelope({attack:0.01,decay:0.2,sustain:0.9,release:0.8}).connect(vca.gain);

    } else if(typePick==='Noise'){
      src = new Tone.Noise(choose(rand,['white','pink']));
      const bp = new Tone.Filter({type:'bandpass', frequency: seededFloat(1000,6000), Q: seededFloat(0.7,10)});
      const vca = new Tone.Gain(0);
      src.chain(bp, vca, vGain);
      voice.setFreq = f => { /* noise pitchless; lightly move center */ bp.frequency.rampTo(clamp(f,400,7000), 0.05) };
      voice.start = ()=> src.start();
      voice.stop = ()=> src.stop();
      voice.env = new Tone.Envelope({attack:0.01,decay:0.15,sustain:0.7,release:0.5}).connect(vca.gain);

    } else if(typePick==='Ring'){
      // simple ring: mod * carrier into gain
      const carrier = new Tone.Oscillator({type:choose(rand,['sine','triangle']), frequency:220});
      const modOsc = new Tone.Oscillator({type:'sine', frequency: seededFloat(0.2,8)*220});
      const mult = new Tone.Multiply();
      const cGain = new Tone.Gain(0.5);
      carrier.connect(cGain).connect(mult);
      modOsc.connect(mult.factor);
      const vca = new Tone.Gain(0);
      mult.connect(vca).connect(vGain);
      voice.setFreq = f => { carrier.frequency.rampTo(f,0.02); modOsc.frequency.rampTo(f*seededFloat(0.2,3.0),0.02) };
      voice.start = ()=>{ carrier.start(); modOsc.start(); };
      voice.stop = ()=>{ carrier.stop(); modOsc.stop(); };
      voice.env = new Tone.Envelope({attack:0.01,decay:0.2,sustain:0.85,release:0.8}).connect(vca.gain);
      src = carrier; // for bookkeeping
    }

    // FX chain
    const chain = mkFXChain(i);
    voice.fx = chain;
    // Connect: vGain -> ...fx... -> merger (later)
    let head = vGain;
    for(const node of chain){ head.connect(node); head = node; }
    return voice;
  }

  function connectMaster(){
    const Tone = runtimeState.Tone;
    // Master chain: voices -> fx -> merger -> softClip -> limiter -> destination
    merger = new Tone.Gain(1.0);
    softClip = new Tone.WaveShaper(x=>{
      // soft clip curve
      const n=4096, curve=new Float32Array(n);
      for(let i=0;i<n;i++){ const x= (i/(n-1))*2-1; curve[i] = Math.tanh(2.5*x); }
      return curve;
    }());
    limiter = new Tone.Limiter(-1.0);
    masterGain = new Tone.Gain(0.9);

    // Analyser branches
    masterMeter = new Tone.Meter({ channels:1, smoothing:0.7 });
    analyserL = new Tone.Analyser('waveform', 1024);
    analyserR = new Tone.Analyser('waveform', 1024);

    // Split to two analysers (fake stereo visualization by phase offset)
    scopeSplitter = new Tone.Split();
    merger.connect(scopeSplitter);
    scopeSplitter.left.connect(analyserL);
    scopeSplitter.right.connect(analyserR);

    // Master out
    merger.chain(softClip, limiter, masterGain, masterMeter, Tone.getDestination());

    // small stereo trick: feed right with slight delay
    const sTap = new Tone.Delay(0.0015);
    merger.connect(sTap);
    sTap.connect(scopeSplitter.right);

    // meters updater
    Tone.Transport.scheduleRepeat(()=>{
      const level = clamp((masterMeter.getValue()+60)/60,0,1);
      ui.mMaster.firstElementChild.style.height = (level*100).toFixed(1)+'%';
    }, "16n");
  }

  function wireVoices(){
    for(const v of voices){
      // Connect each voice chain head to merger
      let out = v.gainNode;
      if(v.fx.length) out = v.fx[v.fx.length-1];
      out.connect(merger);
      // pre-warm sources
      if(v.start) v.start();
    }
  }

  function triggerVoice(vi, velocity=0.8, dur=0.25){
    const v = voices[vi];
    if(!v || !v.alive) return;
    const f = chooseNoteForVoice(vi);
    v.setFreq(f);
    // gain ramp
    v.gainNode.gain.cancelScheduledValues(runtimeState.Tone.now());
    v.gainNode.gain.linearRampToValueAtTime(velocity, runtimeState.Tone.now()+0.005);
    v.gainNode.gain.linearRampToValueAtTime(0.0001, runtimeState.Tone.now()+Math.max(0.06, dur));
    if(v.env){ v.env.triggerAttackRelease(dur); }
  }

  function chooseNoteForVoice(vi){
    // deterministic mapping into seeded scale pool, but temperament-current for future
    const idx = (vi*13 + state.seqPos*7) % scaleNotes.length;
    return scaleNotes[idx];
  }

  function scheduleStep(time){
    // transport tick handler for sequencer
    if(state.isRecording){
      // in recording mode, we simply advance position; key presses will write to this position
    }
    const stepVoice = state.seqSteps[state.seqPos];
    if(stepVoice!=null){
      const vel = 0.75;
      triggerVoice(stepVoice, vel, 0.23);
    }
    state.seqPos = (state.seqPos+1) % state.seqLen;
  }

  function setSeqLength(n){
    n = clamp(n,8,64);
    const prev = state.seqLen;
    state.seqLen = n;
    if(state.seqSteps.length<n){
      state.seqSteps = state.seqSteps.concat(new Array(n - state.seqSteps.length).fill(null));
    } else if(state.seqSteps.length>n){
      state.seqSteps.length = n;
    }
    logBoot(`[Seq] Length ${prev} → ${n}`);
  }

  function buildMapping(){
    // key 0..9 -> voice permutation and voice -> algorithm permutation
    const keyOrder = shuffle(rand, Array.from({length:10},(_,i)=>i));
    state.voiceForKey = keyOrder.slice(); // key digit => voice idx
    state.algForVoice = shuffle(rand, Array.from({length:10},(_,i)=>i));
    logBoot(`[Map] Keys→Voices: ${state.voiceForKey.join(',')}`);
    logBoot(`[Map] Voices→Alg: ${state.algForVoice.join(',')}`);
  }

  function bootSignature(){
    const Tone = runtimeState.Tone;
    const t0 = Tone.now() + 0.25;
    const dur = seededFloat(3.0,3.9);
    const step = dur/ (10 + seededInt(6,12));
    let t=t0;
    const order = shuffle(rand, Array.from({length:10},(_,i)=>i));
    // Ensure each voice sounds at least once; then a few flourishes
    for(const vi of order){
      const f = state.notePool[vi % state.notePool.length];
      // lock to default temperament by using notePool (was built at default)
      voices[vi].setFreq(f);
      runtimeState.Tone.Transport.scheduleOnce(time=>{
        triggerVoice(vi, 0.8, 0.22);
      }, t - Tone.now());
      t += step*0.85;
    }
    // extra figures
    for(let k=0;k<6;k++){
      const vi = seededInt(0,9);
      runtimeState.Tone.Transport.scheduleOnce(()=>{
        triggerVoice(vi, 0.6, 0.18+0.05*rand());
      }, (t + k*step*0.6) - Tone.now());
    }
    // idle pad after
    runtimeState.Tone.Transport.scheduleOnce(()=>{
      idlePad(true);
    }, (t0+dur+0.1) - Tone.now());
  }

  function idlePad(on){
    // low-level slow breathing across two voices
    const a = 2, b = 7;
    const now = runtimeState.Tone.now();
    const vA = voices[a], vB = voices[b];
    const fA = state.notePool[(a*3)%state.notePool.length]/2;
    const fB = state.notePool[(b*5)%state.notePool.length]/2;
    vA.setFreq(fA); vB.setFreq(fB);
    vA.gainNode.gain.cancelScheduledValues(now);
    vB.gainNode.gain.cancelScheduledValues(now);
    const target = on?0.18:0.0;
    vA.gainNode.gain.linearRampToValueAtTime(target, now+0.25);
    vB.gainNode.gain.linearRampToValueAtTime(target*0.8, now+0.25);
  }

  function startTransport(){
    const Tone = runtimeState.Tone;
    if(state.isPlaying) return;
    state.seqPos = 0;
    Tone.Transport.scheduleRepeat(scheduleStep, '16n', Tone.now()+0.05);
    Tone.Transport.start();
    state.isPlaying = true;
    ui.transportState.textContent = 'playing';
  }
  function stopTransport(){
    const Tone = runtimeState.Tone;
    Tone.Transport.stop();
    Tone.Transport.cancel(0);
    state.isPlaying = false;
    ui.transportState.textContent = 'stopped';
  }

  /* -------------------- Scope drawing (10 deterministic algorithms) -------------------- */
  const scope = (function(){
    const canvas = document.getElementById('scope');
    const ctx = canvas.getContext('2d');
    let W=0,H=0, t=0, last=performance.now();
    const rng = seededRand(seed); // visuals share seed but are independent of audio timing

    function resize(){ W=canvas.width = canvas.clientWidth; H=canvas.height = canvas.clientHeight; }
    window.addEventListener('resize', resize); resize();

    function draw(){
      const now = performance.now();
      const dt = (now-last)/1000; last=now; t+=dt;
      // cpu approx = draw time fraction (very rough)
      cpuAvg = cpuAvg*0.92 + (clamp(dt/0.016,0,2))*0.08;
      ui.mCPU.firstElementChild.style.height = (clamp(cpuAvg/2,0,1)*100).toFixed(1)+'%';

      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,W,H);

      // grid
      ctx.strokeStyle = 'rgba(20,80,60,0.4)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for(let x=0;x<W;x+=Math.max(40, W/16)){ctx.moveTo(x,0);ctx.lineTo(x,H)}
      for(let y=0;y<H;y+=Math.max(40, H/12)){ctx.moveTo(0,y);ctx.lineTo(W,y)}
      ctx.stroke();

      // active algorithm from the last key (or seqPos)
      const activeVoice = state.seqSteps[(state.seqPos+state.seqLen-1)%state.seqLen] ?? state.voiceForKey[0];
      const alg = state.algForVoice[activeVoice] ?? 0;

      // route
      if(alg===0) lissajous(); else
      if(alg===1) spiralPrecess(); else
      if(alg===2) polarRose(); else
      if(alg===3) phyllo(); else
      if(alg===4) fig8(); else
      if(alg===5) epicycle(); else
      if(alg===6) vectorscope(); else
      if(alg===7) torusKnot(); else
      if(alg===8) flowfield(); else
      harmonicBloom();

      requestAnimationFrame(draw);
    }

    function line(points){
      ctx.beginPath();
      for(let i=0;i<points.length;i++){
        const [x,y]=points[i];
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }
    function toXY(xn, yn){
      return [ (xn*0.5+0.5)*W, (yn*0.5+0.5)*H ];
    }

    function lissajous(){
      ctx.strokeStyle='#8fffd2'; ctx.lineWidth=1.6;
      const a=2+((seed.charCodeAt(0)%5)); const b=3+((seed.charCodeAt(1)%7));
      const d= (seed.charCodeAt(2)%Math.PI)/10;
      const pts=[];
      const N=1000;
      for(let i=0;i<N;i++){
        const u=i/N*Math.PI*2;
        pts.push(toXY(Math.sin(a*u+d), Math.sin(b*u)));
      }
      line(pts);
    }
    function spiralPrecess(){
      ctx.strokeStyle='#8fffd2'; ctx.lineWidth=1.2;
      const pts=[]; const N=1200;
      for(let i=0;i<N;i++){
        const u=i/N*8*Math.PI;
        const r= i/N;
        const x=r*Math.cos(u+0.3*Math.sin(t*0.4));
        const y=r*Math.sin(u+0.2*Math.cos(t*0.5));
        pts.push(toXY(x,y));
      }
      line(pts);
    }
    function polarRose(){
      ctx.strokeStyle='#8fffd2'; ctx.lineWidth=1.2;
      const k=(seed.charCodeAt(3)%7)+2;
      const pts=[]; const N=1500;
      for(let i=0;i<N;i++){
        const u=i/N*2*Math.PI;
        const r=Math.cos(k*u);
        pts.push(toXY(r*Math.cos(u), r*Math.sin(u)));
      }
      line(pts);
    }
    function phyllo(){
      ctx.strokeStyle='rgba(143,255,210,0.8)'; ctx.lineWidth=1;
      const n=900, c=0.015+((seed.charCodeAt(4)%10)/800);
      const golden = Math.PI*(3-Math.sqrt(5));
      for(let i=0;i<n;i++){
        const r=c*Math.sqrt(i);
        const a=i*golden;
        const x=r*Math.cos(a), y=r*Math.sin(a);
        const [X,Y]=toXY(x,y);
        ctx.fillStyle='rgba(143,255,210,0.55)';
        ctx.fillRect(X,Y,1,1);
      }
    }
    function fig8(){
      ctx.strokeStyle='#8fffd2'; ctx.lineWidth=1.6;
      const pts=[]; const N=1000;
      for(let i=0;i<N;i++){
        const u=i/N*2*Math.PI;
        const s=Math.sin(u);
        pts.push(toXY(s, s*Math.cos(u)));
      }
      line(pts);
    }
    function epicycle(){
      ctx.strokeStyle='#8fffd2'; ctx.lineWidth=1.4;
      const pts=[]; const N=1200;
      for(let i=0;i<N;i++){
        const u=i/N*2*Math.PI;
        const x=Math.cos(u)+0.5*Math.cos(3*u+t*0.4);
        const y=Math.sin(u)+0.5*Math.sin(2*u+t*0.5);
        pts.push(toXY(x/2,y/2));
      }
      line(pts);
    }
    function vectorscope(){
      ctx.strokeStyle='rgba(143,255,210,0.9)'; ctx.lineWidth=1.2;
      // Map analyser waveforms into XY
      const l = analyserL ? analyserL.getValue() : [];
      const r = analyserR ? analyserR.getValue() : l;
      ctx.beginPath();
      for(let i=0;i<l.length;i++){
        const x = (l[i]||0), y=(r[i]||0);
        const [X,Y]=toXY(x,y);
        if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
      }
      ctx.stroke();
    }
    function torusKnot(){
      ctx.strokeStyle='#8fffd2'; ctx.lineWidth=1.2;
      const p=2+(seed.charCodeAt(5)%3);
      const q=3+(seed.charCodeAt(6)%5);
      const pts=[]; const N=1200;
      for(let i=0;i<N;i++){
        const u=i/N*2*Math.PI;
        const x=(2+Math.cos(q*u))*Math.cos(p*u);
        const y=(2+Math.cos(q*u))*Math.sin(p*u);
        const z=Math.sin(q*u);
        pts.push(toXY(x/3, (y+0.5*z)/3));
      }
      line(pts);
    }
    function flowfield(){
      // hybrid particle w/ audio-reactive drift
      const l = analyserL ? analyserL.getValue() : [];
      const amp = l && l.length ? Math.abs(l[256]||0) : 0.05;
      ctx.strokeStyle='rgba(143,255,210,0.65)'; ctx.lineWidth=1;
      const pts=[]; const N=1400;
      for(let i=0;i<N;i++){
        const u=i/N*4*Math.PI;
        const n = Math.sin(u*2 + t*0.8)*0.5 + Math.cos(u*3 - t*0.6)*0.5;
        const x = Math.sin(u+t*0.2+n*0.5)*0.7 + amp*0.5*Math.sin(u*7);
        const y = Math.cos(u-t*0.23+n*0.4)*0.7 + amp*0.5*Math.cos(u*5);
        pts.push(toXY(x*0.7,y*0.7));
      }
      line(pts);
    }
    function harmonicBloom(){
      const l = analyserL ? analyserL.getValue() : [];
      ctx.fillStyle='rgba(143,255,210,0.55)';
      const N = 800;
      for(let i=0;i<N;i++){
        const u=i/N*2*Math.PI;
        const r = 0.35 + 0.2*Math.sin(5*u + t) + 0.1*((l[i% (l.length||1)]||0));
        const [X,Y]=toXY(r*Math.cos(u), r*Math.sin(u));
        ctx.fillRect(X,Y,1,1);
      }
    }

    requestAnimationFrame(draw);
    return { resize };
  })();

  /* -------------------- Public boot -------------------- */
  function boot(){
    Tone = runtimeState.Tone;
    rand = seededRand(seed);
    initSeeded(rand);
    connectMaster();

    // Voices
    voices = Array.from({length:10},(_,i)=>mkVoice(i));
    wireVoices();
    buildMapping();

    // Transport defaults
    Tone.Transport.bpm.value = parseFloat(ui.bpm.value)||110;
    Tone.Transport.loop = ui.loop.checked;

    // Boot signature at power-on (uses default temperament only)
    bootSignature();
    bootDone = true;

    ui.play.disabled = false; ui.stop.disabled = false;
  }

  /* -------------------- UI hookups -------------------- */
  function onKey(e,down){
    if(!runtimeState.started) return;
    const k = e.key;
    if(k>='0' && k<='9'){
      const vi = state.voiceForKey[parseInt(k,10)];
      triggerVoice(vi, 0.85, 0.22);
      if(state.isRecording){
        state.seqSteps[state.seqPos] = vi;
      }
    } else if (k==='['){ setSeqLength(clamp(state.seqLen-1,8,64)); }
      else if (k===']'){ setSeqLength(clamp(state.seqLen+1,8,64)); }
  }

  function bindUI(){
    document.addEventListener('keydown', e=>onKey(e,true));

    ui.rec.onclick = ()=>{
      state.isRecording = !state.isRecording;
      ui.rec.textContent = state.isRecording ? 'Rec●' : 'Rec';
      ui.rec.style.background = state.isRecording ? '#a00' : '';
    };
    ui.play.onclick = ()=> startTransport();
    ui.stop.onclick = ()=> { stopTransport(); idlePad(false); };
    ui.loop.onchange = ()=> runtimeState.Tone.Transport.loop = ui.loop.checked;
    ui.bpm.onchange = ()=> runtimeState.Tone.Transport.bpm.rampTo(parseFloat(ui.bpm.value)||110, 0.05);

    ui.save.onclick = ()=>{
      const data = {
        seed, seqLen: state.seqLen, steps: state.seqSteps,
        bpm: parseFloat(ui.bpm.value)||110, loop: ui.loop.checked,
        temperamentDefault, temperamentCurrent
      };
      const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `osc-synth-seq-${seed}.json`;
      a.click();
    };
    ui.loadFile.onchange = async (e)=>{
      const file = e.target.files[0]; if(!file) return;
      const text = await file.text();
      try{
        const data = JSON.parse(text);
        if(data.seed !== seed){ alert('Different seed file loaded — visual/audio identity may differ. Proceeding with steps only.'); }
        setSeqLength(clamp(data.seqLen||16,8,64));
        state.seqSteps = (data.steps||[]).slice(0,state.seqLen).concat(new Array(Math.max(0,state.seqLen-(data.steps||[]).length)).fill(null));
        ui.bpm.value = data.bpm||110; runtimeState.Tone.Transport.bpm.rampTo(parseFloat(ui.bpm.value), 0.05);
        ui.loop.checked = !!data.loop; runtimeState.Tone.Transport.loop = ui.loop.checked;
        if(data.temperamentCurrent) { ui.temperament.value = String(data.temperamentCurrent); setTemperament(parseInt(ui.temperament.value,10)); }
      }catch(err){ alert('Invalid JSON'); }
      e.target.value='';
    };

    ui.temperament.onchange = ()=>{
      // only future notes affected
      const t = parseInt(ui.temperament.value,10);
      setTemperament(t);
    };

    ui.power.onclick = async ()=>{
      if(runtimeState.started) return;
      ui.power.disabled = true;
      await runtimeState.Tone.start();
      runtimeState.started = true;
      ui.transportState.textContent = 'armed';
      // Start tiny transport (so boot events schedule)
      runtimeState.Tone.Transport.start();
      // after boot signature finishes, transport keeps running for sequencer
    };
  }

  function setLoaderStatus(msg, isErr=false){ ui.loader.textContent = msg; if(isErr){ ui.loader.style.color = 'var(--danger)'; } }

  return { boot, bindUI, setLoaderStatus, algNames, setTemperament };
})();

/* -------------------- Loader & App start -------------------- */
(function main(){
  AudioApp.bindUI();
  loadToneJSAndBoot({ setLoaderStatus: AudioApp.setLoaderStatus, runtimeState, boot: AudioApp.boot });
})();

/* -------------------- Basic responsiveness -------------------- */
(function fit(){
  const c = document.getElementById('scope');
  const wrap = document.getElementById('scopeWrap');
  const ro = new ResizeObserver(()=>{ c.width = wrap.clientWidth; c.height = wrap.clientHeight; });
  ro.observe(wrap);
})();
</script>
</body>
</html>
