<!-- This version has a lovely randomise function that smoothly transitions the sound and visual to the new settings 
each time the randomise button is pressed which creates a nice audio and visual experience when quick tapping the random button. -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Web3 Oscilloscope Music - Enhanced</title>
  <meta name="viewport" content="width=600,initial-scale=1">
  <style>
    html,body {margin:0;padding:0;height:100%;background:#000;color:#fff;font-family:sans-serif;}
    body {display:grid;place-items:center;gap:1.2rem;padding:1rem;}
    #scope {border-radius:8px;border:1px solid #444;background:#000;box-shadow:0 0 15px rgba(100,100,255,0.2);cursor:pointer;}
    #controls {display:flex;gap:0.8rem;align-items:center;flex-wrap:wrap;justify-content:center;}
    #controls button,#controls select{padding:0.5rem 1rem;border-radius:5px;border:1px solid #666;background:#2a2a2a;color:#eee;transition:background 0.2s,transform 0.1s;font-size:0.9rem;}
    #controls button:hover{background:#3a3a3a;transform:translateY(-1px);}
    #controls button:active{transform:translateY(1px);}
    #loader{font-size:0.95rem;color:#aaa;min-height:1.3rem;text-align:center;font-style:italic;}
    #info{font-size:0.8rem;color:#888;text-align:center;max-width:600px;}
    .visual-indicator{position:absolute;top:10px;right:10px;padding:4px 8px;border-radius:3px;font-size:0.75rem;font-weight:bold;z-index:10;}
    .indicator-silent{background:#555;color:#ccc;}
    .indicator-audio{background:#4a86e8;color:#fff;box-shadow:0 0 8px rgba(74,134,232,0.7);}
    #modeToggle.seed-mode{background:#2c5a2c;border-color:#5cb85c;color:#dff0d8;}
    #modeToggle.random-mode{background:#5a3c2c;border-color:#b85c5c;color:#f0d8d8;}
    .keyboard-note {position:absolute;bottom:10px;right:10px;padding:4px 8px;border-radius:3px;font-size:0.75rem;z-index:10;opacity:0.9;}
    .keyboard-note {background:#8b4513;color:#fff;box-shadow:0 0 8px rgba(139,69,19,0.7);}
  </style>
</head>
<body>
  <div id="visualIndicator" class="visual-indicator indicator-silent">Silent Mode</div>
  <div id="keyboardIndicator" class="keyboard-note" style="display:none;">Keyboard Ready</div>
  <canvas id="scope" width="600" height="600"></canvas>
  <section id="controls">
    <button id="startBtn">Start Audio</button>
    <button id="muteBtn">Mute</button>
    <select id="shapeSelect"></select>
    <button id="randomizeBtn">Randomize</button>
    <button id="modeToggle" class="random-mode">Mode: Random</button>
  </section>
  <div id="loader">Initializing...</div>
  <div id="info">Visuals start automatically. Click 'Start Audio' OR the image to hear sound. Use 'Mode' to switch generation method.</div>
  <script type="module">
    // --- Util ---
    const $ = id => document.getElementById(id);
    function mulberry32(seed) {
      let a = 0x6d2b79f5 ^ seed.length;
      for (let i = 0; i < seed.length; ++i) a = Math.imul(a ^ seed.charCodeAt(i), 2654435761);
      return () => ((a = Math.imul(a ^ a >>> 15, 1 | a)), (a >>> 16) / 0x10000);
    }
    function noteToFrequency(note) {
      const A4 = 440, noteNames = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
      const match = note.match(/([A-G]#?)(\d+)/);
      if (!match) return A4;
      const idx = noteNames.indexOf(match[1]), oct = +match[2];
      return A4 * Math.pow(2, (idx + (oct - 4) * 12 - 9) / 12);
    }

    // --- State ---
    const state = {
      isPlaying:false, isAudioStarted:false, Tone:null, nodes:{}, currentParams:{},
      isSeedMode:false, seedGenerator:null, predefinedSets:{}, keyboardOsc:{}, dummyData:null
    };
    // --- Shapes ---
    const baseShapes = {
      circle: {name:"Circle", draw:(d,t,p)=>{const S=p.size*300,c=300;ctx.beginPath();
        for(let i=0;i<d.length;++i){const a=i/d.length*2*Math.PI,amp=(d[i]+1)/2,r=S*amp,modA=a+t*(p.rotationSpeed??.05);
          const x=c+Math.cos(modA)*r,y=c+Math.sin(modA)*r;i?ctx.lineTo(x,y):ctx.moveTo(x,y);}ctx.closePath();ctx.stroke();}},
      square: {name:"Square", draw:(d,t,p)=>{const S=p.size*424.26,c=300,o=(600-S)/2;ctx.beginPath();
        for(let i=0;i<d.length;++i){const q=i/d.length,amp=(d[i]+1)/2;
          let x,y;if(q<.25)[x,y]=[o+S*(q/.25),o];else if(q<.5)[x,y]=[o+S,o+S*((q-.25)/.25)];
          else if(q<.75)[x,y]=[o+S-S*((q-.5)/.25),o+S];else[x,y]=[o,o+S-S*((q-.75)/.25)];
          const dx=x-c,dy=y-c,scale=.8+.2*amp+.1*Math.sin(t*(p.pulseSpeed??.2)),fx=c+dx*scale,fy=c+dy*scale;
          i?ctx.lineTo(fx,fy):ctx.moveTo(fx,fy);}ctx.closePath();ctx.stroke();}},
      butterfly: {name:"Butterfly", draw:(d,t,p)=>{const S=p.size*240,c=300;ctx.beginPath();
        for(let i=0;i<d.length;++i){const th=i/d.length*Math.PI*24,amp=(d[i]+1)/2,scale=Math.exp(Math.cos(th))-2*Math.cos(4*th)+Math.pow(Math.sin(th/12),5);
          let x=Math.sin(th)*scale*S*(.5+.5*amp),y=Math.cos(th)*scale*S*(.5+.5*amp);
          const a=t*(p.rotationSpeed??.05),nx=x*Math.cos(a)-y*Math.sin(a),ny=x*Math.cos(a)+y*Math.sin(a);
          i?ctx.lineTo(nx+c,ny+c):ctx.moveTo(nx+c,ny+c);}ctx.closePath();ctx.stroke();}},
      lissajous: {name:"Lissajous", draw:(d,t,p)=>{const S=p.size*270,c=300,a=p.lissaA||3,b=p.lissaB||2,dlt=p.lissaDelta||0;ctx.beginPath();
        for(let i=0;i<d.length;++i){const prog=i/d.length,amp=(d[i]+1)/2,modT=t*(p.rotationSpeed??.05);
          const x=S*Math.sin(a*modT+prog*2*Math.PI+dlt)*amp,y=S*Math.sin(b*modT+prog*2*Math.PI)*amp;
          i?ctx.lineTo(x+c,y+c):ctx.moveTo(x+c,y+c);}ctx.stroke();}},
      spiral: {name:"Spiral", draw:(d,t,p)=>{const S=p.size*270,c=300,turns=p.spiralTurns||5;ctx.beginPath();
        for(let i=0;i<d.length;++i){const prog=i/d.length,amp=(d[i]+1)/2,a=prog*2*Math.PI*turns+t*(p.rotationSpeed??.05),r=S*prog*amp;
          const x=c+Math.cos(a)*r,y=c+Math.sin(a)*r;i?ctx.lineTo(x,y):ctx.moveTo(x,y);}ctx.stroke();}},
      rose: {name:"Rose", draw:(d,t,p)=>{const S=p.size*270,c=300,k=p.roseK||3;ctx.beginPath();
        for(let i=0;i<d.length;++i){const prog=i/d.length,amp=(d[i]+1)/2,a=prog*2*Math.PI+t*(p.rotationSpeed??.05),r=S*Math.cos(k*a)*amp;
          const x=c+Math.cos(a)*r,y=c+Math.sin(a)*r;i?ctx.lineTo(x,y):ctx.moveTo(x,y);}ctx.closePath();ctx.stroke();}}
    };
    // Shape select options
    const shapeSel = $("shapeSelect");
    Object.entries(baseShapes).forEach(([k, {name}]) => {
      const o=document.createElement("option"); o.value=k; o.textContent=name; shapeSel.appendChild(o);
    });

    // --- Drawing ---
    const canvas = $("scope"), ctx = canvas.getContext("2d");

    // --- Dummy Data ---
    function generateDummyData(){
      const d = new Float32Array(2048);
      for(let i=0;i<2048;i++){
        const t=i/2048;d[i]=.4*Math.sin(t*6*Math.PI)+.3*Math.sin(t*14*Math.PI+Math.PI/3)+.2*Math.sin(t*22*Math.PI+Math.PI/6)+.1*Math.sin(t*34*Math.PI);}
      return d;
    }

    // --- Param Generators ---
    const noteNames = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'], octaves=[2,3,4,5], waveforms=['sine','square','sawtooth','triangle'], filterTypes=['lowpass','highpass','bandpass'];
    const rand = (arr, rng=Math.random) => arr[Math.floor(rng()*arr.length)];
    function getRandomNote(rng=Math.random){return rand(noteNames,rng)+rand(octaves,rng);}
    function generateRandomParams(shapeKey=null,rng=Math.random){
      const sKey=shapeKey||rand(Object.keys(baseShapes),rng),osc1Type=rand(waveforms,rng),osc1Note=getRandomNote(rng),useOsc2=rng()>.3,osc2Type=useOsc2?rand(waveforms,rng):null,osc2Note=useOsc2?getRandomNote(rng):null;
      let interaction='mix';if(useOsc2){const r=rng();if(r<.4)interaction='am';else if(r<.7)interaction='fm';}
      const filterFreq=500+rng()*4000,filterType=rand(filterTypes,rng),lfoFreq=.1+rng()*5,lfoMin=200+rng()*1e3,lfoMax=lfoMin+500+rng()*4e3,
        hueBase=Math.floor(rng()*360),hueRange=50+Math.floor(rng()*100),lineWidth=1.5+rng()*3,rotationSpeed=(rng()-.5)*.3,pulseSpeed=.05+rng()*.3,size=.65+rng()*.4,useGlow=rng()>.5;
      let lissaA,lissaB,lissaDelta,spiralTurns,roseK;
      switch(sKey){
        case 'lissajous':lissaA=1+Math.floor(rng()*5);lissaB=1+Math.floor(rng()*5);lissaDelta=rng()*Math.PI;break;
        case 'spiral':spiralTurns=2+Math.floor(rng()*6);break;
        case 'rose':roseK=.5+rng()*5;break;
        default:lissaA=1+Math.floor(rng()*5);lissaB=1+Math.floor(rng()*5);lissaDelta=rng()*Math.PI;spiralTurns=2+Math.floor(rng()*6);roseK=.5+rng()*5;
      }
      return {shapeKey:sKey,osc1:{type:osc1Type,note:osc1Note},osc2:useOsc2?{type:osc2Type,note:osc2Note}:null,interaction,
        filter:{frequency:filterFreq,type:filterType},lfo:{frequency:lfoFreq,min:lfoMin,max:lfoMax},
        visual:{hueBase,hueRange,lineWidth,rotationSpeed,pulseSpeed,size,useGlow,lissaA,lissaB,lissaDelta,spiralTurns,roseK}};
    }
    function generatePredefinedSets(seedString="defaultSeed123"){
      const rng=mulberry32(seedString),sets={};Object.keys(baseShapes).forEach(k=>sets[k]=generateRandomParams(k,rng));
      state.predefinedSets=sets;
    }

    // --- Keyboard (prevents stuck notes) ---
    const keyMap = {
      'a':21,'w':22,'s':23,'e':24,'d':25,'f':26,'t':27,'g':28,'y':29,'h':30,'u':31,'j':32,'k':33,'o':34,'l':35,'p':36,';':37,"'":38,
      'z':39,'x':40,'c':41,'v':42,'b':43,'n':44,',':45,'m':46,'.':47,'/':48,'q':49,'1':50,'2':51,'3':52,'4':53,'5':54,'6':55,'7':56,
      '8':57,'9':58,'0':59,'-':60,'=':61,'r':62,'i':63,'[':64,']':65,'\\':66
    };
    function midiToNoteName(midi){const names=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];return names[midi%12]+(Math.floor(midi/12)-1);}
    function midiToFreq(midi){return 440*Math.pow(2,(midi-69)/12);}
    function setupKeyboard() {
      window.addEventListener('keydown', e => {
        if(!state.Tone||!state.isAudioStarted||e.repeat) return;
        const key = e.key.toLowerCase(), midi = keyMap[key];
        if(!midi || state.keyboardOsc[key]) return;
        const {osc1={},filter={}}=state.currentParams, freq=midiToFreq(midi), osc = new state.Tone.Oscillator(freq,osc1.type||'sine').start();
        let out = osc;
        if(filter.frequency) { const f = new state.Tone.Filter(filter.frequency,filter.type); osc.connect(f); out=f;}
        out.connect(state.Tone.Destination);
        state.keyboardOsc[key]=osc;
        $("keyboardIndicator").style.display = 'block';
        $("keyboardIndicator").textContent = `Playing: ${midiToNoteName(midi)}`;
        $("loader").textContent = `Playing note: ${midiToNoteName(midi)}`;
      });
      window.addEventListener('keyup', e => {
        const k = e.key.toLowerCase(), osc = state.keyboardOsc[k];
        if(osc) { osc.stop('+0.05'); delete state.keyboardOsc[k]; }
      });
      window.addEventListener('blur', ()=>{ Object.values(state.keyboardOsc).forEach(o=>o.stop('+0.01')); state.keyboardOsc={}; });
      window.addEventListener('beforeunload', ()=>{ Object.values(state.keyboardOsc).forEach(o=>o.stop()); });
      $("keyboardIndicator").style.display='block';
      $("keyboardIndicator").textContent='Keyboard Ready - Play any mapped key';
    }

    // --- Audio Graph ---
    function disposeNodes(){
      Object.values(state.nodes).forEach(n=>{
        try{if(n && typeof n.stop==='function') n.stop();}catch{}
        try{if(n && typeof n.dispose==='function') n.dispose();}catch{}
      }); state.nodes={};
    }
    function needsRebuild(newP,oldP){
      if(!oldP) return true;
      return Boolean(newP.osc2)!==Boolean(oldP.osc2) || newP.interaction!==oldP.interaction;
    }
    function updateAudioNodes(params, nodes, Tone) {
      if (nodes.osc1) {
        nodes.osc1.type = params.osc1.type;
        nodes.osc1.frequency.rampTo(noteToFrequency(params.osc1.note), 0.05);
      }
      if (params.osc2 && nodes.osc2) {
        nodes.osc2.type = params.osc2.type;
        nodes.osc2.frequency.rampTo(noteToFrequency(params.osc2.note), 0.05);
      }
      if (nodes.filter) {
        nodes.filter.type = params.filter.type;
        nodes.filter.frequency.rampTo(params.filter.frequency, 0.05);
      }
      if (nodes.lfo) {
        nodes.lfo.frequency.value = params.lfo.frequency;
        nodes.lfo.min = params.lfo.min;
        nodes.lfo.max = params.lfo.max;
      }
    }
    async function setupAudioGraph(params, forceRebuild = false){
      if(!state.Tone) return $("loader").textContent='Tone.js not loaded.';
      if(!state.isAudioStarted){
        try{await state.Tone.start(); state.isAudioStarted=true;}
        catch(e){$("loader").textContent="Failed to start audio.";return false;}
      }
      const needs = forceRebuild || needsRebuild(params, state.currentParams);
      if (needs) {
        disposeNodes();
        const T=state.Tone, osc1 = state.nodes.osc1 = new T.Oscillator(noteToFrequency(params.osc1.note), params.osc1.type).start();
        let osc2 = null; if(params.osc2) osc2 = state.nodes.osc2 = new T.Oscillator(noteToFrequency(params.osc2.note), params.osc2.type).start();
        const filter = state.nodes.filter = new T.Filter(params.filter.frequency, params.filter.type);
        const lfo = state.nodes.lfo = new T.LFO(params.lfo.frequency, params.lfo.min, params.lfo.max).start();
        const modulatedGain = state.nodes.modulatedGain = new T.Gain(1);
        const volume = state.nodes.volume = new T.Volume(-10);
        lfo.connect(filter.frequency);
        if(params.interaction === 'am' && osc2){
          osc1.connect(modulatedGain); osc2.connect(modulatedGain.gain); modulatedGain.connect(volume);
        } else if(params.interaction === 'fm' && osc2){
          osc2.connect(osc1.frequency); osc1.connect(volume);
        } else {
          osc1.connect(volume); if(osc2) osc2.connect(volume);
        }
        volume.connect(filter); filter.toDestination();
        const ana = state.nodes.analyser = T.context.createAnalyser(); ana.fftSize = 2048;
        filter.connect(ana);
        state.Tone.Destination.mute = !state.isPlaying;
        $("muteBtn").textContent = state.Tone.Destination.mute ? "Unmute" : "Mute";
      } else {
        updateAudioNodes(params, state.nodes, state.Tone);
      }
      return true;
    }

    // --- Animation Loop ---
    (function animate(){
      const time=performance.now()/1e3, ana=state.nodes.analyser;
      let data=(state.isAudioStarted&&state.isPlaying&&ana)?(ana.getFloatTimeDomainData(state.liveDataBuffer=state.liveDataBuffer||new Float32Array(ana.fftSize)),state.liveDataBuffer):(state.dummyData=state.dummyData||generateDummyData());
      const visInd = $("visualIndicator");
      visInd.textContent=(state.isAudioStarted&&state.isPlaying&&ana)?"Audio Live":(state.isAudioStarted?"Muted":"Silent Mode");
      visInd.className="visual-indicator "+((state.isAudioStarted&&state.isPlaying&&ana)?"indicator-audio":"indicator-silent");
      const p=state.currentParams.visual||{hueBase:200,hueRange:100,lineWidth:2,rotationSpeed:.05,pulseSpeed:.2,size:.8,useGlow:true}, shapeKey=state.currentParams.shapeKey||"circle", shapeFunc=baseShapes[shapeKey]?.draw;
      ctx.clearRect(0,0,600,600);
      const hue=(p.hueBase+time*15)%360,sat=80+15*Math.sin(time*.4),light=50+25*Math.sin(time*.25);
      ctx.strokeStyle=`hsl(${hue},${sat}%,${light}%)`;ctx.lineWidth=p.lineWidth;ctx.lineJoin=ctx.lineCap='round';ctx.shadowBlur=p.useGlow?12:0;ctx.shadowColor=ctx.strokeStyle;
      shapeFunc(data,time,p); state.nodes.animId=requestAnimationFrame(animate);
    })();

    // --- Audio Toggle ---
    async function toggleAudio(){
      const startBtn = $("startBtn"), muteBtn = $("muteBtn"), loader = $("loader");
      if(!state.isAudioStarted){
        if(await setupAudioGraph(state.currentParams, true)){
          state.isPlaying=true; state.Tone.Destination.mute=false;
          startBtn.textContent="Stop Audio"; muteBtn.disabled=false; muteBtn.textContent = "Mute";
          loader.textContent="Audio is now playing.";
        }
      } else if(state.isPlaying){
        state.Tone.Destination.mute=true; state.isPlaying=false;
        startBtn.textContent="Start Audio"; muteBtn.textContent = "Unmute";
        loader.textContent="Audio muted.";
      } else {
        state.Tone.Destination.mute=false; state.isPlaying=true;
        startBtn.textContent="Stop Audio"; muteBtn.textContent = "Mute";
        loader.textContent="Audio unmuted.";
      }
    }

    // --- UI Events ---
    $("startBtn").onclick = $("scope").onclick = toggleAudio;
    $("muteBtn").onclick = ()=>{
      if(!state.Tone||!state.isAudioStarted)return;
      const m=state.Tone.Destination.mute=!state.Tone.Destination.mute;
      $("muteBtn").textContent=m?"Unmute":"Mute";
      $("loader").textContent=m?"Audio muted.":"Audio unmuted.";
      $("visualIndicator").textContent = m ? "Muted" : "Audio Live";
      $("visualIndicator").className = "visual-indicator " + (m ? "indicator-silent" : "indicator-audio");
    };
    $("shapeSelect").onchange=()=>{
      if(state.currentParams){
        let np=state.isSeedMode&&state.predefinedSets[$("shapeSelect").value]?state.predefinedSets[$("shapeSelect").value]:{...state.currentParams,shapeKey:$("shapeSelect").value};
        if(np.visual){delete np.visual.lissaA;delete np.visual.lissaB;delete np.visual.lissaDelta;delete np.visual.spiralTurns;delete np.visual.roseK;}
        state.currentParams=np;
      }
    };
    $("randomizeBtn").onclick=async()=>{
      let np=state.isSeedMode?generateRandomParams(null,state.seedGenerator):generateRandomParams();
      state.currentParams=np;$("shapeSelect").value=np.shapeKey;state.dummyData=null;
      if(state.isAudioStarted){
        await setupAudioGraph(np);
        $("loader").textContent= state.isPlaying ? "Audio pattern randomized." : "Visual pattern randomized. Click 'Start Audio' to hear.";
      } else {
        $("loader").textContent="New visual pattern generated. Click 'Start Audio' to hear.";
      }
    };
    $("modeToggle").onclick=()=>{
      state.isSeedMode=!state.isSeedMode;
      if(state.isSeedMode){
        $("modeToggle").textContent="Mode: Seed";$("modeToggle").className="seed-mode";
        const seed="MyUniqueSeed_v1";state.seedGenerator=mulberry32(seed);generatePredefinedSets(seed);
        const k=Object.keys(state.predefinedSets)[0];state.currentParams=state.predefinedSets[k];$("shapeSelect").value=k;
        $("loader").textContent=`Seed Mode (${seed}) loaded. Showing '${baseShapes[k].name}'.`;
      }else{
        $("modeToggle").textContent="Mode: Random";$("modeToggle").className="random-mode";state.seedGenerator=null;
        $("loader").textContent="Random Mode. New randomizations will use Math.random.";
      }
    };

    // --- Tone.js Loader ---
    function loadToneJSAndBoot({toneUrl,setLoaderStatus,state,boot}){
      setLoaderStatus('Loading Audio Engine...');
      import(toneUrl).then(mod=>{
        state.Tone=window.Tone??mod?.default??mod;
        if(state.Tone){setLoaderStatus(`Tone.js v${state.Tone.version??"?"} ready.`);boot();}
        else throw new Error('Tone.js not found.');
      }).catch(e=>{
        setLoaderStatus('Failed to load Tone.js. App cannot start.',1);console.error(e);
      });
    }
    // --- Boot ---
    loadToneJSAndBoot({
      toneUrl: 'https://ordinals.com/content/04813d7748d918bd8a3069cb1823ebc9586f0ce16cd6a97a784581ec38d13062i0',
      setLoaderStatus:(msg,err)=>{$("loader").textContent=msg;$("loader").style.color=err?"red":"#aaa";$("startBtn").disabled=!!err;$("muteBtn").disabled=true;$("randomizeBtn").disabled=!!err;$("modeToggle").disabled=!!err;},
      state,
      boot:()=>{
        $("loader").textContent="Audio engine ready. Generating initial pattern...";
        $("startBtn").disabled=false;$("muteBtn").disabled=true;$("randomizeBtn").disabled=false;$("modeToggle").disabled=false;
        generatePredefinedSets("InitialSeed_v1");
        const initial="circle";
        state.currentParams=state.predefinedSets[initial]||generateRandomParams(initial);
        state.dummyData=generateDummyData();
        $("shapeSelect").value=state.currentParams.shapeKey;
        $("loader").textContent="Pattern generated (Seed Mode ready). Click 'Start Audio' OR the image to hear sound.";
        setupKeyboard();
      }
    });
    $("startBtn").disabled=true;$("muteBtn").disabled=true;$("randomizeBtn").disabled=true;$("modeToggle").disabled=true;
  </script>
</body>
</html>
