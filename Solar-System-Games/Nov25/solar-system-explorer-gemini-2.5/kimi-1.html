<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System Explorer - Realistic Space Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #0ff;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .panel {
            position: absolute;
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid #0ff;
            padding: 15px;
            pointer-events: auto;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        #probeStatus {
            top: 20px;
            left: 20px;
            min-width: 300px;
        }

        #celestialInfo {
            top: 20px;
            right: 20px;
            max-width: 350px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #timeControls {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        button {
            background: rgba(0, 100, 150, 0.8);
            color: #0ff;
            border: 1px solid #0ff;
            padding: 8px 16px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            border-radius: 3px;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(0, 150, 200, 0.8);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        button:active {
            transform: scale(0.95);
        }

        .status-item {
            margin: 5px 0;
            font-size: 12px;
        }

        .planet-detail {
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 40, 80, 0.5);
            border-radius: 3px;
            border-left: 3px solid #0ff;
        }

        .planet-name {
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }

        .probe {
            fill: #ff0;
            stroke: #ff0;
            filter: drop-shadow(0 0 5px #ff0);
        }

        .orbit {
            stroke: rgba(0, 255, 255, 0.2);
            stroke-width: 1;
            fill: none;
        }

        .selected {
            stroke: #ff0;
            stroke-width: 2;
            stroke-dasharray: 5, 5;
            animation: dash 2s linear infinite;
        }

        @keyframes dash {
            to {
                stroke-dashoffset: -10;
            }
        }

        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 30px;
            background: rgba(0, 20, 40, 0.95);
            border: 2px solid #0ff;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        .menu-title {
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #0ff;
        }

        .menu-text {
            margin: 15px 0;
            line-height: 1.6;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #0ff;
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            font-size: 11px;
        }

        .stat-item {
            background: rgba(0, 60, 120, 0.5);
            padding: 5px 10px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="ui">
        <div id="probeStatus" class="panel">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <h3>PROBE STATUS</h3>
                <button class="close-btn" onclick="togglePanel('probeStatus')">×</button>
            </div>
            <div class="status-item">Velocity: <span id="velocity">0</span> km/s</div>
            <div class="status-item">Altitude: <span id="altitude">0</span> km</div>
            <div class="status-item">Fuel: <span id="fuel">100</span>%</div>
            <div class="status-item">Fuel Usage: <span id="fuelRate">0</span> kg/s</div>
            <div class="status-item">Near Body: <span id="nearBody">None</span></div>
            <div class="status-item">Mission Time: <span id="missionTime">0</span> days</div>
            <div class="status-item">Current Time-Warp: <span id="currentWarp">1x</span></div>
            <div class="stats">
                <div class="stat-item">Scientific Score: <span id="scienceScore">0</span></div>
                <div class="stat-item">Discoveries: <span id="discoveries">0</span></div>
            </div>
        </div>

        <div id="celestialInfo" class="panel">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <h3>CELESTIAL BODIES</h3>
                <button class="close-btn" onclick="togglePanel('celestialInfo')">×</button>
            </div>
            <div id="celestialList"></div>
        </div>

        <div id="timeControls" class="panel">
            <button onclick="setTimeWarp(0)">Pause</button>
            <button onclick="setTimeWarp(1)">1x</button>
            <button onclick="setTimeWarp(10)">10x</button>
            <button onclick="setTimeWarp(100)">100x</button>
            <button onclick="setTimeWarp(1000)">1000x</button>
            <button onclick="setTimeWarp(10000)">10000x</button>
            <button onclick="toggleMapMode()">Map Mode</button>
            <button onclick="toggleMenu()">Menu</button>
        </div>

        <div id="menu" class="panel" style="display: none; pointer-events: auto;">
            <h2 class="menu-title">SOLAR SYSTEM EXPLORER</h2>
            <div class="menu-text">
                <p>Welcome to the most realistic Solar System simulation!</p>
                <p>Controls:</p>
                <p>W/↑ - Thrust Forward<br>
                   S/↓ - Thrust Backward<br>
                   A/← - Rotate Left<br>
                   D/→ - Rotate Right<br>
                   Mouse - Pan View<br>
                   Scroll - Zoom In/Out<br>
                   Space - Center on Probe<br>
                   L - Toggle Labels<br>
                   M - Map Mode</p>
                <p>Explore, scan, and discover the wonders of our Solar System!</p>
            </div>
            <button onclick="toggleMenu()">Continue</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game State
        const gameState = {
            timeWarp: 1,
            missionTime: 0,
            paused: false,
            mapMode: false,
            showLabels: true,
            selectedBody: null,
            camera: {
                x: 0,
                y: 0,
                zoom: 0.01,
                targetZoom: 0.01
            }
        };

        // Physics Constants
        const G = 6.67430e-11; // Gravitational constant
        const AU = 1.496e11; // Astronomical Unit in meters
        const SCALE = 1e-8; // Scale factor for rendering
        const SIZE_SCALE = 1e-5; // Size scale for rendering

        // Probe Object
        const probe = {
            x: 0,
            y: 1.5 * AU,
            vx: 29780, // Earth's orbital velocity
            vy: 0,
            angle: 0,
            fuel: 1000, // kg
            maxFuel: 1000,
            thrust: 0,
            mass: 500, // kg
            scanning: false,
            discoveries: new Set(),
            trajectory: [],
            modules: {
                engines: 1,
                scanners: 1,
                fuelTanks: 1,
                comms: 1
            }
        };

        // Celestial Body Data (Realistic values)
        const celestialBodies = {
            sun: {
                name: "Sun",
                type: "star",
                mass: 1.989e30,
                radius: 696340000,
                color: "#ffff00",
                x: 0,
                y: 0,
                vx: 0,
                vy: 0,
                temperature: 5778,
                rotationPeriod: 25.4
            }
        };

        // Planet definitions
        const planetsData = [
            { name: "Mercury", mass: 3.301e23, radius: 2439700, orbitRadius: 0.39 * AU, eccentricity: 0.21, period: 88, color: "#8c7853", rotation: 59, tilt: 0.03 },
            { name: "Venus", mass: 4.867e24, radius: 6051800, orbitRadius: 0.72 * AU, eccentricity: 0.007, period: 225, color: "#ffc649", rotation: -243, tilt: 177.4 },
            { name: "Earth", mass: 5.972e24, radius: 6371000, orbitRadius: 1 * AU, eccentricity: 0.017, period: 365, color: "#4169e1", rotation: 1, tilt: 23.5, 
              moons: [{ name: "Moon", mass: 7.342e22, radius: 1737400, orbitRadius: 384400000, period: 27.3, color: "#c0c0c0" }] },
            { name: "Mars", mass: 6.417e23, radius: 3389500, orbitRadius: 1.52 * AU, eccentricity: 0.09, period: 687, color: "#cd5c5c", rotation: 1.03, tilt: 25.2,
              moons: [
                  { name: "Phobos", mass: 1.06e16, radius: 11267, orbitRadius: 9376000, period: 0.32, color: "#a0a0a0" },
                  { name: "Deimos", mass: 1.48e15, radius: 6200, orbitRadius: 23459000, period: 1.26, color: "#a0a0a0" }
              ] },
            { name: "Jupiter", mass: 1.898e27, radius: 69911000, orbitRadius: 5.2 * AU, eccentricity: 0.05, period: 4333, color: "#daa520", rotation: 0.41, tilt: 3.1,
              moons: [
                  { name: "Io", mass: 8.93e22, radius: 1821600, orbitRadius: 421700000, period: 1.77, color: "#ffff99" },
                  { name: "Europa", mass: 4.8e22, radius: 1560800, orbitRadius: 671034000, period: 3.55, color: "#ffffcc" },
                  { name: "Ganymede", mass: 1.48e23, radius: 2634100, orbitRadius: 1070412000, period: 7.15, color: "#cccc99" },
                  { name: "Callisto", mass: 1.08e23, radius: 2410300, orbitRadius: 1882709000, period: 16.69, color: "#333333" }
              ] },
            { name: "Saturn", mass: 5.683e26, radius: 58232000, orbitRadius: 9.5 * AU, eccentricity: 0.06, period: 10759, color: "#f4e4c1", rotation: 0.45, tilt: 26.7,
              moons: [
                  { name: "Titan", mass: 1.35e23, radius: 2575000, orbitRadius: 1221865000, period: 15.95, color: "#daa520" },
                  { name: "Enceladus", mass: 1.08e20, radius: 252100, orbitRadius: 238020000, period: 1.37, color: "#e6e6fa" }
              ] },
            { name: "Uranus", mass: 8.681e25, radius: 25362000, orbitRadius: 19.2 * AU, eccentricity: 0.05, period: 30687, color: "#4fd1c5", rotation: -0.72, tilt: 97.8,
              moons: [
                  { name: "Titania", mass: 3.49e21, radius: 788400, orbitRadius: 435910000, period: 8.71, color: "#cccccc" },
                  { name: "Oberon", mass: 3.01e21, radius: 761400, orbitRadius: 583520000, period: 13.46, color: "#999999" }
              ] },
            { name: "Neptune", mass: 1.024e26, radius: 24622000, orbitRadius: 30 * AU, eccentricity: 0.01, period: 60190, color: "#4169e1", rotation: 0.67, tilt: 28.3,
              moons: [
                  { name: "Triton", mass: 2.14e22, radius: 1353400, orbitRadius: 354759000, period: -5.88, color: "#e6e6fa" }
              ] }
        ];

        // Initialize planets and moons
        planetsData.forEach((planet, index) => {
            const angle = (index / planetsData.length) * Math.PI * 2;
            const meanAnomaly = angle;
            const eccentricAnomaly = meanAnomaly; // Simplified
            const trueAnomaly = 2 * Math.atan(Math.sqrt((1 + planet.eccentricity) / (1 - planet.eccentricity)) * Math.tan(eccentricAnomaly / 2));
            
            celestialBodies[planet.name.toLowerCase()] = {
                name: planet.name,
                type: "planet",
                mass: planet.mass,
                radius: planet.radius,
                orbitRadius: planet.orbitRadius,
                eccentricity: planet.eccentricity,
                period: planet.period * 24 * 3600,
                color: planet.color,
                rotationPeriod: planet.rotation,
                axialTilt: planet.tilt,
                x: planet.orbitRadius * Math.cos(trueAnomaly),
                y: planet.orbitRadius * Math.sin(trueAnomaly),
                vx: -Math.sqrt(G * celestialBodies.sun.mass / planet.orbitRadius) * Math.sin(trueAnomaly),
                vy: Math.sqrt(G * celestialBodies.sun.mass / planet.orbitRadius) * Math.cos(trueAnomaly),
                rotationAngle: 0,
                moons: []
            };

            if (planet.moons) {
                planet.moons.forEach(moon => {
                    const moonAngle = Math.random() * Math.PI * 2;
                    celestialBodies[`${planet.name.toLowerCase()}_${moon.name.toLowerCase()}`] = {
                        name: moon.name,
                        type: "moon",
                        parent: planet.name.toLowerCase(),
                        mass: moon.mass,
                        radius: moon.radius,
                        orbitRadius: moon.orbitRadius,
                        period: moon.period * 24 * 3600,
                        color: moon.color,
                        x: celestialBodies[planet.name.toLowerCase()].x + moon.orbitRadius * Math.cos(moonAngle),
                        y: celestialBodies[planet.name.toLowerCase()].y + moon.orbitRadius * Math.sin(moonAngle),
                        vx: celestialBodies[planet.name.toLowerCase()].vx - Math.sqrt(G * planet.mass / moon.orbitRadius) * Math.sin(moonAngle),
                        vy: celestialBodies[planet.name.toLowerCase()].vy + Math.sqrt(G * planet.mass / moon.orbitRadius) * Math.cos(moonAngle),
                        rotationAngle: 0
                    };
                });
            }
        });

        // Asteroids and dwarf planets
        const asteroidsData = [
            { name: "Ceres", mass: 9.39e20, radius: 473000, orbitRadius: 2.77 * AU, period: 1680, color: "#d2b48c" },
            { name: "Pluto", mass: 1.31e22, radius: 1187000, orbitRadius: 39.5 * AU, eccentricity: 0.25, period: 90560, color: "#cd853f" },
            { name: "Makemake", mass: 3e21, radius: 715000, orbitRadius: 45.8 * AU, period: 111845, color: "#8b7355" },
            { name: "Haumea", mass: 4e21, radius: 816000, orbitRadius: 43.3 * AU, period: 103774, color: "#b0c4de" },
            { name: "Eris", mass: 1.66e22, radius: 1163000, orbitRadius: 68 * AU, eccentricity: 0.44, period: 203830, color: "#708090" }
        ];

        asteroidsData.forEach((body, index) => {
            const angle = (index / asteroidsData.length) * Math.PI * 2;
            celestialBodies[body.name.toLowerCase()] = {
                name: body.name,
                type: body.name === "Ceres" ? "asteroid" : "dwarf",
                mass: body.mass,
                radius: body.radius,
                orbitRadius: body.orbitRadius,
                eccentricity: body.eccentricity || 0,
                period: body.period * 24 * 3600,
                color: body.color,
                x: body.orbitRadius * Math.cos(angle),
                y: body.orbitRadius * Math.sin(angle),
                vx: -Math.sqrt(G * celestialBodies.sun.mass / body.orbitRadius) * Math.sin(angle),
                vy: Math.sqrt(G * celestialBodies.sun.mass / body.orbitRadius) * Math.cos(angle),
                rotationAngle: 0
            };
        });

        // Input handling
        const keys = {};
        let mouseX = 0, mouseY = 0;
        let isDragging = false;
        let lastMouseX = 0, lastMouseY = 0;

        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            if (e.key === ' ') {
                e.preventDefault();
                centerOnProbe();
            }
            if (e.key.toLowerCase() === 'l') {
                gameState.showLabels = !gameState.showLabels;
            }
            if (e.key.toLowerCase() === 'm') {
                toggleMapMode();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                gameState.camera.x -= dx / gameState.camera.zoom;
                gameState.camera.y -= dy / gameState.camera.zoom;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            gameState.camera.targetZoom *= zoomFactor;
            gameState.camera.targetZoom = Math.max(1e-9, Math.min(0.1, gameState.camera.targetZoom));
        });

        canvas.addEventListener('click', (e) => {
            if (isDragging) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - canvas.width / 2) / gameState.camera.zoom + gameState.camera.x;
            const y = (e.clientY - rect.top - canvas.height / 2) / gameState.camera.zoom + gameState.camera.y;
            
            // Check for body clicks
            for (const [key, body] of Object.entries(celestialBodies)) {
                const dx = x - body.x;
                const dy = y - body.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < body.radius * SIZE_SCALE / gameState.camera.zoom) {
                    gameState.selectedBody = key;
                    updateCelestialInfo();
                    break;
                }
            }
        });

        // Game Functions
        function setTimeWarp(factor) {
            gameState.timeWarp = factor;
            document.getElementById('currentWarp').textContent = factor + 'x';
        }

        function toggleMapMode() {
            gameState.mapMode = !gameState.mapMode;
        }

        function togglePanel(panelId) {
            const panel = document.getElementById(panelId);
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }

        function toggleMenu() {
            const menu = document.getElementById('menu');
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
            gameState.paused = menu.style.display === 'block';
        }

        function centerOnProbe() {
            gameState.camera.targetZoom = 0.0001;
        }

        function updateCelestialInfo() {
            const list = document.getElementById('celestialList');
            list.innerHTML = '';
            
            for (const [key, body] of Object.entries(celestialBodies)) {
                const div = document.createElement('div');
                div.className = 'planet-detail';
                if (gameState.selectedBody === key) {
                    div.classList.add('selected');
                }
                
                let html = `<div class="planet-name">${body.name}</div>`;
                html += `<div>Type: ${body.type}</div>`;
                html += `<div>Mass: ${(body.mass / 1e24).toFixed(2)} × 10^24 kg</div>`;
                html += `<div>Radius: ${(body.radius / 1000).toFixed(0)} km</div>`;
                
                if (body.orbitRadius) {
                    html += `<div>Orbit: ${(body.orbitRadius / AU).toFixed(2)} AU</div>`;
                }
                
                if (body.discovered) {
                    html += `<div style="color: #0f0;">✓ Scanned</div>`;
                    html += `<div>Discovery Score: +${body.scienceScore}</div>`;
                }
                
                div.innerHTML = html;
                div.onclick = () => {
                    gameState.selectedBody = key;
                    updateCelestialInfo();
                };
                list.appendChild(div);
            }
        }

        // Physics and Game Loop
        function updateCelestialBodies(deltaTime) {
            const realTimeDelta = deltaTime * gameState.timeWarp * 0.1;
            gameState.missionTime += realTimeDelta / (24 * 3600);

            for (const [key, body] of Object.entries(celestialBodies)) {
                // Orbital motion
                if (body.orbitRadius && key !== 'sun') {
                    body.rotationAngle += (realTimeDelta / (body.rotationPeriod * 3600)) * Math.PI * 2;
                    
                    if (!body.parent) {
                        // Planet around sun
                        const meanMotion = 2 * Math.PI / body.period;
                        const meanAnomaly = meanMotion * gameState.missionTime * 24 * 3600;
                        const eccentricAnomaly = meanAnomaly; // Simplified
                        const trueAnomaly = 2 * Math.atan(Math.sqrt((1 + body.eccentricity) / (1 - body.eccentricity)) * Math.tan(eccentricAnomaly / 2));
                        
                        const r = body.orbitRadius * (1 - body.eccentricity * Math.cos(eccentricAnomaly));
                        body.x = r * Math.cos(trueAnomaly);
                        body.y = r * Math.sin(trueAnomaly);
                        
                        const orbitalSpeed = Math.sqrt(G * celestialBodies.sun.mass * (2/r - 1/body.orbitRadius));
                        body.vx = -orbitalSpeed * Math.sin(trueAnomaly);
                        body.vy = orbitalSpeed * Math.cos(trueAnomaly);
                    }
                }
                
                // Moon motion around planets
                if (body.parent && celestialBodies[body.parent]) {
                    const parent = celestialBodies[body.parent];
                    const moonMeanMotion = 2 * Math.PI / body.period;
                    const moonMeanAnomaly = moonMeanMotion * gameState.missionTime * 24 * 3600;
                    
                    body.x = parent.x + body.orbitRadius * Math.cos(moonMeanAnomaly);
                    body.y = parent.y + body.orbitRadius * Math.sin(moonMeanAnomaly);
                    
                    body.vx = parent.vx - Math.sqrt(G * parent.mass / body.orbitRadius) * Math.sin(moonMeanAnomaly);
                    body.vy = parent.vy + Math.sqrt(G * parent.mass / body.orbitRadius) * Math.cos(moonMeanAnomaly);
                }
            }

            // Update probe
            updateProbe(realTimeDelta);
            
            // Check discoveries
            checkDiscoveries();
            
            // Update UI
            updateUI();
        }

        function updateProbe(deltaTime) {
            // Apply thrust
            if (probe.fuel > 0) {
                probe.thrust = 0;
                
                if (keys['w'] || keys['arrowup']) {
                    probe.thrust = 5000; // Newtons
                    probe.vx += Math.cos(probe.angle) * probe.thrust / probe.mass * deltaTime;
                    probe.vy += Math.sin(probe.angle) * probe.thrust / probe.mass * deltaTime;
                    probe.fuel -= probe.thrust * deltaTime / 1000;
                }
                if (keys['s'] || keys['arrowdown']) {
                    probe.thrust = -2500;
                    probe.vx += Math.cos(probe.angle) * probe.thrust / probe.mass * deltaTime;
                    probe.vy += Math.sin(probe.angle) * probe.thrust / probe.mass * deltaTime;
                    probe.fuel -= Math.abs(probe.thrust) * deltaTime / 1000;
                }
                if (keys['a'] || keys['arrowleft']) {
                    probe.angle -= 2 * deltaTime;
                }
                if (keys['d'] || keys['arrowright']) {
                    probe.angle += 2 * deltaTime;
                }
            }

            // Apply gravitational forces
            let totalFx = 0, totalFy = 0;
            let nearBody = null;
            let minDist = Infinity;

            for (const body of Object.values(celestialBodies)) {
                if (body.type === 'star' && !gameState.mapMode) {
                    const dx = body.x - probe.x;
                    const dy = body.y - probe.y;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    
                    if (r < minDist) {
                        minDist = r;
                        nearBody = body;
                    }
                    
                    if (r > body.radius) {
                        const F = G * body.mass * probe.mass / (r * r);
                        const ax = F * dx / r / probe.mass;
                        const ay = F * dy / r / probe.mass;
                        
                        totalFx += ax;
                        totalFy += ay;
                    }
                }
            }

            // Update probe velocity and position
            probe.vx += totalFx * deltaTime;
            probe.vy += totalFy * deltaTime;
            probe.x += probe.vx * deltaTime;
            probe.y += probe.vy * deltaTime;

            // Store trajectory
            if (probe.trajectory.length === 0 || 
                Math.abs(probe.x - probe.trajectory[probe.trajectory.length - 1].x) > 1e8) {
                probe.trajectory.push({ x: probe.x, y: probe.y });
                if (probe.trajectory.length > 1000) {
                    probe.trajectory.shift();
                }
            }

            // Update camera
            if (!isDragging) {
                const targetX = probe.x;
                const targetY = probe.y;
                gameState.camera.x += (targetX - gameState.camera.x) * deltaTime * 0.1;
                gameState.camera.y += (targetY - gameState.camera.y) * deltaTime * 0.1;
            }
            
            gameState.camera.zoom += (gameState.camera.targetZoom - gameState.camera.zoom) * deltaTime * 2;
        }

        function checkDiscoveries() {
            for (const body of Object.values(celestialBodies)) {
                if (!body.discovered) {
                    const dx = probe.x - body.x;
                    const dy = probe.y - body.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < body.radius + 1e7) {
                        body.discovered = true;
                        body.scienceScore = Math.floor(body.mass / 1e20);
                        probe.discoveries.add(body.name);
                        
                        // Add to science score
                        let totalScore = 0;
                        Object.values(celestialBodies).forEach(b => {
                            if (b.discovered) totalScore += b.scienceScore || 0;
                        });
                        document.getElementById('scienceScore').textContent = totalScore;
                        document.getElementById('discoveries').textContent = probe.discoveries.size;
                        
                        updateCelestialInfo();
                    }
                }
            }
        }

        function updateUI() {
            const velocity = Math.sqrt(probe.vx * probe.vx + probe.vy * probe.vy);
            document.getElementById('velocity').textContent = (velocity / 1000).toFixed(2);
            
            let minDist = Infinity;
            let nearBodyName = "None";
            for (const body of Object.values(celestialBodies)) {
                const dx = probe.x - body.x;
                const dy = probe.y - body.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < minDist) {
                    minDist = dist;
                    nearBodyName = body.name;
                }
            }
            
            const altitude = (minDist - 696340000) / 1000;
            document.getElementById('altitude').textContent = Math.max(0, altitude).toFixed(0);
            document.getElementById('fuel').textContent = Math.max(0, Math.floor(probe.fuel / probe.maxFuel * 100));
            document.getElementById('fuelRate').textContent = probe.thrust > 0 ? (probe.thrust / 1000).toFixed(1) : '0';
            document.getElementById('nearBody').textContent = nearBodyName;
            document.getElementById('missionTime').textContent = Math.floor(gameState.missionTime);
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 1000; i++) {
                const x = (i * 137.5) % canvas.width;
                const y = (i * 89.7) % canvas.height;
                const brightness = (i * 17) % 100;
                ctx.globalAlpha = brightness / 100;
                ctx.fillRect(x, y, 1, 1);
            }
            ctx.globalAlpha = 1;

            // Set transform
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(gameState.camera.zoom, gameState.camera.zoom);
            ctx.translate(-gameState.camera.x, -gameState.camera.y);

            // Draw orbits
            if (gameState.mapMode || gameState.showLabels) {
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
                for (const body of Object.values(celestialBodies)) {
                    if (body.orbitRadius && body.parent === undefined) {
                        ctx.beginPath();
                        ctx.arc(0, 0, body.orbitRadius * SCALE, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
            }

            // Draw probe trajectory
            if (probe.trajectory.length > 1) {
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.lineWidth = 2 / gameState.camera.zoom;
                ctx.beginPath();
                ctx.moveTo(probe.trajectory[0].x * SCALE, probe.trajectory[0].y * SCALE);
                for (let i = 1; i < probe.trajectory.length; i++) {
                    ctx.lineTo(probe.trajectory[i].x * SCALE, probe.trajectory[i].y * SCALE);
                }
                ctx.stroke();
            }

            // Draw celestial bodies
            for (const [key, body] of Object.entries(celestialBodies)) {
                const x = body.x * SCALE;
                const y = body.y * SCALE;
                const radius = body.radius * SIZE_SCALE;
                
                // Skip if too small to see
                if (radius < 1 && !gameState.mapMode) continue;
                
                // Draw body
                ctx.save();
                ctx.translate(x, y);
                
                // Rotation
                if (body.rotationAngle) {
                    ctx.rotate(body.rotationAngle);
                }
                
                // Atmosphere for planets
                if (body.type === 'planet' && radius > 10) {
                    const gradient = ctx.createRadialGradient(0, 0, radius * 0.8, 0, 0, radius * 1.5);
                    gradient.addColorStop(0, body.color);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Main body
                ctx.fillStyle = body.color;
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Surface details for larger bodies
                if (radius > 5) {
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2;
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                    }
                    ctx.stroke();
                }
                
                // Labels
                if (gameState.showLabels || radius > 50) {
                    ctx.restore();
                    ctx.fillStyle = '#fff';
                    ctx.font = `${Math.min(14, radius / 2)}px Courier New`;
                    ctx.textAlign = 'center';
                    ctx.fillText(body.name, x, y - radius - 10);
                    
                    if (body.discovered) {
                        ctx.fillStyle = '#0f0';
                        ctx.fillText('✓', x + 30, y - radius - 10);
                    }
                } else {
                    ctx.restore();
                }
            }

            // Draw probe
            const probeX = probe.x * SCALE;
            const probeY = probe.y * SCALE;
            
            ctx.save();
            ctx.translate(probeX, probeY);
            ctx.rotate(probe.angle);
            
            // Probe body
            ctx.fillStyle = '#ffff00';
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 2 / gameState.camera.zoom;
            ctx.beginPath();
            ctx.moveTo(10, 0);
            ctx.lineTo(-5, -5);
            ctx.lineTo(-5, 5);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Thruster effects
            if (probe.thrust !== 0) {
                const thrustLength = Math.abs(probe.thrust) / 100;
                ctx.fillStyle = probe.thrust > 0 ? '#ff4500' : '#00ffff';
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.moveTo(-5, -3);
                ctx.lineTo(-5 - thrustLength, 0);
                ctx.lineTo(-5, 3);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            ctx.restore();

            ctx.restore();
        }

        let lastTime = 0;
        function gameLoop(timestamp) {
            if (!gameState.paused) {
                const deltaTime = Math.min((timestamp - lastTime) / 1000, 0.1);
                updateCelestialBodies(deltaTime);
                draw();
            }
            lastTime = timestamp;
            requestAnimationFrame(gameLoop);
        }

        // Initialize and start
        updateCelestialInfo();
        toggleMenu();
        requestAnimationFrame(gameLoop);

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>