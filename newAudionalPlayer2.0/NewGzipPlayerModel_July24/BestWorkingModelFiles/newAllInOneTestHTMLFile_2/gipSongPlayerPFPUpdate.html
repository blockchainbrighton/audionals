<!DOCTYPE html>
<html>
<head>
    <title>TRUTH</title>
</head>
<body>
    <!-- Your existing scripts and variables -->
    <script>
        window.seed = 558;
        window.songDataUrl = "/content/5527d0cc95ce5ce6eedf4e275234da8b1fe087512d0db618b6de1aaad437c96bi0";
    </script>
    <script src="/content/799b9bb3e731b50c366365f22b9504f7704f9a51d3d45572d0d980b7a192000di0"></script>

    <script>
function getAssignments() {
    const a = [];
    for (let i = TOTAL_CHANNELS; i >= 1; i--) {
        const { arrayIndex: ai, cci2: c } = renderingState[i] || {};
        if (ai !== undefined && c !== undefined) {
            a.push(`Channel ${TOTAL_CHANNELS - i + 1}: ArrayIndex=${ai}, CCI2=${c}`);
        }
    }
    console.log("Assignments gathered:", a);
    return a;
}

let playbackStarted = false;
const psTimeEvent = (status) => {
    playbackStarted = status;
    console.log(`Playback ${status ? 'started' : 'stopped'}.`);
    console.log("Playback state:", playbackStarted);
};
document.addEventListener('playbackStarted', () => {
    window.psTime = Date.now();
    psTimeEvent(true);
});
document.addEventListener('playbackStopped', () => psTimeEvent(false));

const getTimecode = () => window.psTime ? Date.now() - window.psTime : 0;

function captureCanvas(cb) {
    const c = document.querySelectorAll('canvas')[1];
    if (!c) return console.error("No canvas element found.");
    console.log("Canvas selected with dimensions:", c.width, c.height);

    const fc = document.createElement('canvas');
    Object.assign(fc, { width: c.width, height: c.height });
    fc.getContext('2d').drawImage(c, 0, 0, fc.width, fc.height);
    console.log("Image drawn on finalCanvas with dimensions:", fc.width, fc.height);
    cb(fc, getTimecode());
}

function processAndDownloadCanvas(fc, t) {
    const m = {
        accessLevel: AccessLevel,
        seed: window.seed,
        assignments: getAssignments(),
        timecode: t
    };
    console.log("Metadata collected:", m);

    const ms = `
Seed: ${m.seed}
Access Level: ${m.accessLevel}
Channel Effect Assignments: 
${m.assignments.join('\n')}
Timecode: ${m.timecode} ms
    `.trim();

    const ctx = fc.getContext('2d');
    Object.assign(ctx, {
        font: '14px Arial',
        fillStyle: '#1b1b1b',
        shadowColor: 'black',
        textAlign: 'right'
    });

    ms.split('\n').reverse().forEach((line, i) => {
        ctx.fillText(line, fc.width - 10, fc.height - 10 - (i * 16.8));
    });

    console.log("Text drawn on finalCanvas");

    fc.toBlob(blob => {
        const link = document.createElement('a');
        Object.assign(link, {
            href: URL.createObjectURL(blob),
            download: `visual_state_${new Date().toISOString()}.jpeg`
        });
        link.click();
        console.log("Download link clicked");
    }, 'image/jpeg');
}

let lastCapture = 0;

document.addEventListener('keydown', e => {
    console.log("Keydown event detected:", e.key);
    const now = Date.now();
    if (e.key.toLowerCase() === 'p') {
        console.log("The isTrippy value:", isTrippy);
        console.log("Playback state at keydown:", playbackStarted);
        if (isTrippy && playbackStarted && now - lastCapture >= 30000) {
            lastCapture = now;
            captureCanvas(processAndDownloadCanvas);
        } else {
            console.log("Capture attempt blocked: Either too soon since the last capture or invalid conditions.");
        }
    }
});


    </script>
    
    
</body>
</html>
