let intervalID=null,gVolMult=1,gJsonData=null,bpm=0,isRevPlay=!1,isToggle=!1,isReady=!1;const srcChanMap=new Map,gTrimTimes={},gVolLevels={},gPlaySpeeds={},actSources=[],gGainNodes=new Map,gAudioBufs=[],gRevAudioBufs={},gainNodes={},audioCtx=window.AudioContextManager.getAudioContext(),audPlayerMsgs=new BroadcastChannel("channel_playback");let audioWorker,preSeq={},curStep=0,beatCount=0,barCount=0,curSeq=0,isPlaying=!1,playTimeoutId=null,nextNoteTime=0,totSeq=0;async function loadJson(){if(gJsonData)try{console.log("[debug] Loaded JSON data:",gJsonData);const e={channelsWithUrls:0,sequencesCount:0,activeStepsPerSequence:{},activeChannelsPerSequence:{},types:{}};analyzeJson(gJsonData,e);const n=preparePlayback(gJsonData,e);console.log("[debug] Prepared data for playback:",n),await fetchAndProcessAudioData(n.channelURLs),preprocessSchedulePlayback(n),console.log("[debug] Preprocessed sequences:",preSeq)}catch(e){console.error("Could not load JSON data from memory:",e)}else console.error("No data found in memory")}function analyzeJson(e,n){if(e.projectSequences&&"object"==typeof e.projectSequences)for(const[t,s]of Object.entries(e.projectSequences)){n.activeStepsPerSequence[t]=0,n.activeChannelsPerSequence[t]=[];for(const[e,o]of Object.entries(s)){const s=`Channel ${parseInt(e.slice(2))+1}`;n.activeStepsPerSequence[t]+=o.steps.length,n.activeChannelsPerSequence[t].push(s)}}for(const[t,s]of Object.entries(e))if("projectSequences"!==t){const e=Array.isArray(s)?"array":typeof s;n.types[e]=(n.types[e]||0)+1,"object"!==e&&"array"!==e||analyzeJson(s,n)}}function setEndSeq(e){if(e&&e.sequences){let n=null,t=!1;for(const s of Object.values(e.sequences)){const o=Object.values(s.normalSteps).every((e=>0===e.length));if(o&&n){e.endSequence=n,t=!0,console.log("End sequence set to:",n);break}o||(n=s)}!t&&n&&(e.endSequence=n,console.log("End sequence set to the last non-empty sequence:",n))}}function preparePlayback(e,n){const{channelURLs:t,trimSettings:s,channelVolume:o,channelPlaybackSpeed:a,projectSequences:r,projectName:c,projectBPM:l,currentSequence:i}=e;bpm=l,totSeq=i,t.forEach(((e,n)=>{const t=n+1,r=s[n]||{};gTrimTimes[`Channel ${t}`]={startTrim:(r.startSliderValue||0)/100,endTrim:(r.endSliderValue||100)/100},gVolLevels[`Channel ${t}`]=(o[n]||1).toFixed(3),gPlaySpeeds[`Channel ${t}`]=Math.max(.1,Math.min(a[n],100)).toFixed(3)}));const p=Object.fromEntries(Object.entries(r).map((([e,n])=>{const t={},s={};return Object.entries(n).forEach((([e,n])=>{const o=`Channel ${parseInt(e.slice(2))+1}`;t[o]=[],s[o]=[],n.steps.forEach((e=>{const n="object"==typeof e?e.index:e;(e.reverse?s:t)[o].push(n)}))})),[e,{normalSteps:t,reverseSteps:s}]}))),u={projectName:c,bpm:l,channels:t.length,channelURLs:t,trimTimes:gTrimTimes,stats:n,sequences:p};return setEndSeq(u),u}function preprocessSchedulePlayback(e){if(!e||!e.sequences)return console.error("Playback data is not available or empty.");bpm=e.bpm,preSeq=Object.fromEntries(Object.entries(e.sequences).map((([e,n])=>[e,{normalSteps:processSteps(n.normalSteps),reverseSteps:processSteps(n.reverseSteps)}]))),isReady=Object.values(preSeq).some((e=>Object.keys(e.normalSteps).length>0||Object.keys(e.reverseSteps).length>0))}function processSteps(e){return Object.fromEntries(Object.entries(e).filter((([,e])=>e.length)).map((([e,n])=>[e,n.map((e=>({step:e,timing:(e*(60/bpm)).toFixed(3)})))])))}
