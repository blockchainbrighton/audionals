console.log("Visualiser.js loaded");let isChannel11Active=!1,activeChannelIndex=null,isPlaybackActive=!1,renderingState={},activeArrayIndex={},arrayLengths={1:0,2:0,3:0,4:0,5:0,6:0};const accessLevelMappings={1:[1],2:[1,2],3:[1,2,3],4:[1,2,3,4],5:[4,5],6:[1,2,3,4,5,6]};function initializeArrayLengths(){try{arrayLengths[1]=getColors1Length()||0}catch(e){console.error("Failed to get length for array 1",e)}try{arrayLengths[2]=getColors2Length()||0}catch(e){console.error("Failed to get length for array 2",e)}try{arrayLengths[3]=getColors3Length()||0}catch(e){console.error("Failed to get length for array 3",e)}try{arrayLengths[4]=getColors4Length()||0}catch(e){console.error("Failed to get length for array 4",e)}try{arrayLengths[5]=getColors5Length()||0}catch(e){console.error("Failed to get length for array 5",e)}try{arrayLengths[6]=getColors6Length()||0}catch(e){console.error("Failed to get length for array 6",e)}console.log("Initialized array lengths:",arrayLengths)}function randomWithSeed(e){const t=1e4*Math.sin(e);return t-Math.floor(t)}function calculateCCI2(e,t){if(!t||t<=0)return console.error("Invalid array length:",t),1;const r=100*randomWithSeed(seed+(e+1)),o=Math.floor(r/100*t);return Math.min(Math.max(o,0),t-1)}function generateAccessLevel(e){const t=randomWithSeed(e),r=Math.pow(t,.5),o=Math.floor(6*(1-r))+1;return Math.min(Math.max(o,1),6)}function logTestValuesForAccessLevels(){const e={1:[],2:[],3:[],4:[],5:[],6:[]},t={1:0,2:0,3:0,4:0,5:0,6:0};for(let r=0;r<1e6&&Object.values(t).some((e=>e<5));r++){const o=generateAccessLevel(r);t[o]<5&&(e[o].push(r),t[o]++)}console.log("Test Values for Each Access Level:");for(let t=1;t<=6;t++)console.log(`Access Level ${t}:`,e[t])}function selectArrayIndex(e,t,r){const o=randomWithSeed(e+100*r),n=accessLevelMappings[t];return n[Math.floor(o*n.length)]}initializeArrayLengths(),logTestValuesForAccessLevels();let AccessLevel=generateAccessLevel(seed);function testAccessLevelDistribution(){const e=1e7,t={1:0,2:0,3:0,4:0,5:0,6:0};for(let r=0;r<e;r++){t[generateAccessLevel(r)]++}console.log("Access Level Distribution:");for(let r in t){const o=(t[r]/e*100).toFixed(2);console.log(`Access Level ${r}: ${o}%`)}}function updateVisualizer(e,t,r){console.log(`Updating visual:\nAccessLevel=${AccessLevel}\nArrayIndex=${t}\nCCI2=${e}\nIndex=${t}`),immediateVisualUpdate()}function shouldUpdateVisualizer(e,t,r){const o=renderingState[e]||{};return(o.arrayIndex!==t||o.cci2!==r)&&(renderingState[e]={arrayIndex:t,cci2:r},!0)}testAccessLevelDistribution();let needImmediateUpdate=!1;function immediateVisualUpdate(){needImmediateUpdate&&(needImmediateUpdate=!1)}function logInitialAssignments(){setTimeout((()=>{const e=[],t=generateAccessLevel(seed);console.log(`Access Level: ${t}`);for(let r=1;r<=16;r++){const o=selectArrayIndex(seed,t,r),n=calculateCCI2(r,arrayLengths[o]);renderingState[r]={arrayIndex:o,cci2:n},activeArrayIndex[r]=o,e.push(`Channel ${r}: ArrayIndex=${o}, CCI2=${n}`)}console.log("Initial Assignments:",e.join("; "))}),100)}document.addEventListener("internalAudioPlayback",(e=>{const{action:t,channelIndex:r,step:o}=e.detail;if("stop"===t)cci2=initialCCI2,isChannel11Active=!1,isPlaybackActive=!1,activeChannelIndex=null,activeArrayIndex={},renderingState={},console.log(`Stop received. CCI2 reset to initial value ${initialCCI2}`),immediateVisualUpdate();else if("activeStep"===t&&(!isPlaybackActive||activeChannelIndex!==r)){isPlaybackActive=!0,activeChannelIndex=r,AccessLevel=generateAccessLevel(seed);const e=0===r?1:r,t=selectArrayIndex(seed,AccessLevel,e);if(console.log(`AccessLevel=${AccessLevel}\nArrayIndex=${t}\nCCI2=${cci2}\nIndex=${t}`),!arrayLengths[t])return void console.error("Invalid array length:",arrayLengths[t]);cci2=calculateCCI2(e,arrayLengths[t]),shouldUpdateVisualizer(r,t,cci2)&&(activeArrayIndex[r]=t,updateVisualizer(cci2,t,r))}})),AudionalPlayerMessages.onmessage=e=>{const{action:t,channelIndex:r}=e.data;if(isPlaybackActive||"stop"===t)if("stop"===t)cci2=initialCCI2,isChannel11Active=!1,isPlaybackActive=!1,activeChannelIndex=null,activeArrayIndex={},renderingState={},console.log(`Stop received. CCI2 reset to initial value ${initialCCI2}`);else if(activeChannelIndex!==r){activeChannelIndex=r,AccessLevel=generateAccessLevel(seed);const e=0===r?1:r,t=selectArrayIndex(seed,AccessLevel,e);if(console.log(`AccessLevel=${AccessLevel}\nArrayIndex=${t}\nCCI2=${cci2}\nIndex=${t}`),!arrayLengths[t])return void console.error("Invalid array length:",arrayLengths[t]);cci2=calculateCCI2(e,arrayLengths[t]),shouldUpdateVisualizer(r,t,cci2)&&(activeArrayIndex[r]=t,updateVisualizer(cci2,t,r))}},setTimeout(logInitialAssignments,500);let lastLogTime=0;const logFrequency=1e3;function log(e){const t=Date.now();t-lastLogTime>1e3&&(console.log(e),lastLogTime=t)}function errorLog(e,t){console.error(e,t)}let scaleFactor=3,S=window.innerWidth,R=100*scaleFactor,H=2*R,RS=2*Math.PI/2e3/1e3,SR=100*scaleFactor,OR=100*scaleFactor;const cv=document.getElementById("cv"),cx=cv.getContext("2d");cv.width=S,cv.height=S;const workerScript='\nself.onmessage = function(e) {\n    const { id, vertices, primaryAndSecondaryColors } = e.data;\n\n    // Pre-generate random colors array\n    const colorsArray = Array.from({ length: 5 }, () => {\n        return primaryAndSecondaryColors[Math.floor(Math.random() * primaryAndSecondaryColors.length)].hex;\n    });\n\n    // Compute colors for the vertices\n    const updatedColors = vertices.map((v, index) => {\n        // Use conditional color function\n        return {\n            index,\n            colors: [\n                getConditionalColor(v.x, v.y, 0.1, colorsArray[0], "black"),\n                getConditionalColor(v.x, v.y, 0.2, colorsArray[1], "black"),\n                getConditionalColor(v.x, v.y, 0.3, colorsArray[2], "black"),\n                getConditionalColor(v.x, v.y, 0.5, colorsArray[3], "black"),\n                getConditionalColor(v.x, v.y, 0.05, colorsArray[4], "black")\n            ]\n        };\n    });\n\n    postMessage({ id, updatedColors });\n};\n\nfunction getConditionalColor(x, y, divisor, trueColor, falseColor) {\n    return ((x / divisor | 0) + (y / divisor | 0)) % 111 === 0 ? trueColor : falseColor;\n}\n',blob=new Blob([workerScript],{type:"application/javascript"}),workerScriptURL=URL.createObjectURL(blob),rainbowWorker=new Worker(workerScriptURL);function sendRainbowRequest(e,t,r,o){rainbowWorker.postMessage({id:e,vertices:t,angle:r,primaryAndSecondaryColors:o})}URL.revokeObjectURL(workerScriptURL),rainbowWorker.onmessage=function(e){const{id:t,updatedColors:r}=e.data;updateScatterColors(t,r)};const visualizerWorkerScript='\nself.onmessage = function(e) {\n    const { type, id, data } = e.data;\n\n    switch (type) {\n        case \'COLOR_SETTINGS\':\n            const { vertices, primaryAndSecondaryColors, factors, randomValues } = data;\n            const colorsArray = Array.from({ length: 5 }, () => {\n                return primaryAndSecondaryColors[Math.floor(Math.random() * primaryAndSecondaryColors.length)].hex;\n            });\n\n            const updatedColors = vertices.map((v, index) => {\n                return {\n                    index,\n                    colors: [\n                        getConditionalColor(v.x, v.y, 0.1, colorsArray[0], "black"),\n                        getConditionalColor(v.x, v.y, 0.2, colorsArray[1], "black"),\n                        getConditionalColor(v.x, v.y, 0.3, colorsArray[2], "black"),\n                        getConditionalColor(v.x, v.y, 0.5, colorsArray[3], "black"),\n                        getConditionalColor(v.x, v.y, 0.05, colorsArray[4], "black")\n                    ]\n                };\n            });\n\n            postMessage({ type, id, updatedColors });\n            break;\n\n        case \'DYNAMIC_RGB\':\n            const { randomValue, baseZ, factor } = data;\n            const colorValue = Math.floor(randomValue * ((baseZ + 255) / (factor * 100) * 255));\n            const rgbColor = colorValue > 0.01 ? `rgb(${colorValue}, ${colorValue}, ${colorValue})` : "#FF0000";\n            postMessage({ type, id, rgbColor });\n            break;\n\n        default:\n            console.error(\'Unknown message type:\', type);\n            break;\n    }\n};\n\nfunction getConditionalColor(x, y, divisor, trueColor, falseColor) {\n    return ((x / divisor | 0) + (y / divisor | 0)) % 111 === 0 ? trueColor : falseColor;\n}\n',visualizerBlob=new Blob([visualizerWorkerScript],{type:"application/javascript"}),visualizerWorkerURL=URL.createObjectURL(visualizerBlob),visualizerWorker=new Worker(visualizerWorkerURL);URL.revokeObjectURL(visualizerWorkerURL);const rotationWorkerScript="\nself.onmessage = function(e) {\n    const { id, vertices, pivot, angle } = e.data;\n    const cosA = Math.cos(angle);\n    const sinA = Math.sin(angle);\n\n    const updatedVertices = vertices.map(v => {\n        let x = v.x - pivot.x,\n            y = v.y - pivot.y,\n            x1 = x * cosA - y * sinA,\n            y1 = x * sinA + y * cosA;\n        return { x: x1 + pivot.x, y: y1 + pivot.y, z: v.z };\n    });\n    postMessage({ id, updatedVertices });\n};\n",rotationBlob=new Blob([rotationWorkerScript],{type:"application/javascript"}),rotationWorkerScriptURL=URL.createObjectURL(rotationBlob),rotationWorker=new Worker(rotationWorkerScriptURL);function sendRotationRequest(e,t,r,o){rotationWorker.postMessage({id:e,vertices:t,pivot:r,angle:o})}URL.revokeObjectURL(rotationWorkerScriptURL),rotationWorker.onmessage=function(e){const{id:t,updatedVertices:r}=e.data;"cy"===t?cp.cy.updateVertices(r):t.startsWith("sp")&&cp[t].updateVertices(r)};class Cy{constructor(e,t,r,o){this.c=e,this.r=t,this.h=r,this.s=o,this.gV(),this.gF()}updateVertices(e){this.v=e}gV(){this.v=[];for(let e=0;e<=this.s;e++){let t=this.c.y-this.h/2+e/this.s*this.h;for(let e=0;e<=this.s;e++){let r=e/this.s*2*Math.PI,o=this.c.x+this.r*Math.cos(r),n=this.c.z+this.r*Math.sin(r);this.v.push({x:o,y:t,z:n})}}}gF(){this.f=[];for(let e=0;e<this.s;e++)for(let t=0;t<this.s;t++){let r=e*(this.s+1)+t,o=r+1,n=r+this.s+1,s=n+1;this.f.push([r,o,n]),this.f.push([o,s,n])}}rP(e,t){sendRotationRequest(this.id,this.v,e,t)}}class Sp{constructor(e,t,r){this.c=e,this.r=t,this.s=r,this.gV(),this.gF()}updateVertices(e){this.v=e}gV(){this.v=[];for(let e=0;e<=this.s;e++){let t=e/this.s*Math.PI;for(let e=0;e<=this.s;e++){let r=e/this.s*2*Math.PI,o=this.c.x+this.r*Math.sin(t)*Math.cos(r),n=this.c.y+this.r*Math.sin(t)*Math.sin(r),s=this.c.z+this.r*Math.cos(t);this.v.push({x:o,y:n,z:s})}}}gF(){this.f=[];for(let e=0;e<this.s;e++)for(let t=0;t<this.s;t++){let r=e*(this.s+1)+t,o=r+1,n=r+this.s+1,s=n+1;this.f.push([r,o,n]),this.f.push([o,s,n])}}rP(e,t){sendRotationRequest(this.id,this.v,e,t)}}class Cp{constructor(e,t,r,o){this.c=e,this.r=t,this.h=r,this.s=o,this.cy=new Cy(e,t,r,o),this.sp1=new Sp({x:e.x-t,y:e.y,z:e.z},t,o),this.sp2=new Sp({x:e.x+t,y:e.y,z:e.z},t,o)}updateVertices(e){this.v=e}rP(e,t){sendRotationRequest("cy",this.cy.v,e,t),sendRotationRequest("sp1",this.sp1.v,e,t),sendRotationRequest("sp2",this.sp2.v,e,t)}}let t,cp=new Cp({x:S/2,y:S/2,z:0},R,H,30),os1=new Sp({x:S/2-OR,y:S/2,z:0},SR,30),os2=new Sp({x:S/2+OR,y:S/2,z:0},SR,30);function d(e){let r;cx.clearRect(0,0,S,S),r=void 0===t?0:RS*(e-t)*100,t=e,cp.rP(cp.c,r),cp.drawObjectD2(cp.cy,e),cp.drawObjectD2(cp.sp1,e),cp.drawObjectD2(cp.sp2,e),requestAnimationFrame(d)}function getColorArray(e,t,r,o){const n=accessLevelMappings[o],s=activeArrayIndex[activeChannelIndex];if(!n.includes(s))return console.error(`Array index ${s} not allowed for AccessLevel ${o}`),[];switch(s){case 1:return getColors1(e,t,r);case 2:return getColors2(e,t,r);case 3:return getColors3(e,t,r);case 4:return getColors4(e,t,r);case 5:return getColors5(e,t,r);case 6:return getColors6(e,t,r);default:return console.error(`Invalid arrayIndex ${s}`),[]}}cp.drawObjectD2=function(e,t){let r=!isPlaybackActive||null===activeChannelIndex;for(let o of e.f){let n=o.map((t=>e.v[t])),s=n.map((e=>({x:e.x,y:e.y})));cx.beginPath(),cx.moveTo(s[0].x,s[0].y);for(let e=1;e<s.length;e++)cx.lineTo(s[e].x,s[e].y);cx.closePath();let a=180*Math.atan2(s[0].y-S/2,s[0].x-S/2)/Math.PI;if(r){let e=getColors1(a,t,n);if(!e||0===e.length)return void console.error("No colors returned for initial display.");cx.fillStyle=e[0]}else{activeArrayIndex[activeChannelIndex];let e=getColorArray(a,t,n,AccessLevel);if(!e||0===e.length)return void console.error(`No colors returned for AccessLevel: ${AccessLevel}`);cx.fillStyle=e[cci2%e.length]}cx.fill(),cx.strokeStyle="black",cx.stroke()}},requestAnimationFrame(d);