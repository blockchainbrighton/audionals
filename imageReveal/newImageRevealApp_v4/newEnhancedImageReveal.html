<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Image FX Playground</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:#121212;color:#f0f0f0;font-family:Arial,sans-serif;overflow:hidden;display:flex;flex-direction:column;justify-content:center;align-items:center;height:100vh;position:relative}
  #canvas-container{position:relative;width:80vh;height:80vh;max-width:80vw;max-height:80vh;cursor:pointer}
  canvas{position:absolute;top:0;left:0;width:100%;height:100%;border-radius:4px;box-shadow:0 0 20px #0008}
  .fx-btns{display:flex;gap:12px;justify-content:center;align-items:center;position:absolute;bottom:16px;left:50%;transform:translateX(-50%)}
  .fx-btn{padding:10px 16px;background:linear-gradient(135deg,#6e8efb,#a777e3);color:#fff;border:none;border-radius:4px;font-size:15px;cursor:pointer;opacity:.93;transition:.2s;box-shadow:0 4px 6px #0002}
  .fx-btn:hover{background:linear-gradient(135deg,#5d7df9,#9666d6);transform:translateY(-2px)}
  .fx-btn.active{background:linear-gradient(135deg,#3a4ca2,#7d3ed7)!important;box-shadow:0 4px 18px #4416;opacity:1}
  .fx-btn:disabled{opacity:.4;cursor:default}
  #error-message,#loading{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:18px;text-align:center}
  #error-message{color:#f55;display:none}
  #loading{color:#f0f0f0}
</style>
</head>
<body>
<div id="canvas-container">
  <canvas id="main-canvas"></canvas>
  <div id="loading">Loading image...</div>
  <div id="error-message">Failed to load image. Please check the URL.</div>
</div>
<div class="fx-btns" id="fx-btns"></div>
<script type="module">
window.images=["https://ordinals.com/content/01c48d3cceb02215bc3d44f9a2dc7fba63ea63719a2ef1c35d3f0c4db93ab8d5i0"];
const log=(...a)=>console.log('[FXDEMO]',...a);
const utils=(()=>{
  const p=[...Array(256)].map(()=>Math.floor(Math.random()*256)),pp=[...p,...p];
  const fade=t=>t**3*(t*(t*6-15)+10);
  const lerp=(a,b,t)=>a+t*(b-a);
  const grad=(h,x,y,z)=>{
    const u=h<8?x:y,v=h<4?y:(h===12||h===14?x:z);
    return ((h&1)===0?u:-u)+((h&2)===0?v:-v);
  };
  return {
    lerp,
    clamp:(v,min,max)=>Math.max(min,Math.min(max,v)),
    random:(min,max)=>Math.random()*(max-min)+min,
    randomInt:(min,max)=>Math.floor(Math.random()*(max-min+1))+min,
    easeInOut:t=>t<.5?2*t*t:1-((-2*t+2)**2/2),
    noise:(x,y,z)=>{
      const X=Math.floor(x)&255,Y=Math.floor(y)&255,Z=Math.floor(z)&255;
      x-=Math.floor(x);y-=Math.floor(y);z-=Math.floor(z);
      const u=fade(x),v=fade(y),w=fade(z);
      const A=pp[X]+Y,AA=pp[A]+Z,AB=pp[A+1]+Z,B=pp[X+1]+Y,BA=pp[B]+Z,BB=pp[B+1]+Z;
      return lerp(
        lerp(
          lerp(grad(pp[AA],x,y,z),grad(pp[BA],x-1,y,z),u),
          lerp(grad(pp[AB],x,y-1,z),grad(pp[BB],x-1,y-1,z),u),v),
        lerp(
          lerp(grad(pp[AA+1],x,y,z-1),grad(pp[BA+1],x-1,y,z-1),u),
          lerp(grad(pp[AB+1],x,y-1,z-1),grad(pp[BB+1],x-1,y-1,z-1),u),v),w);
    }
  };
})();

const effectDefaults={
  scanLines:{intensity:0.4,speed:1.5,lineWidth:3,spacing:6,verticalShift:0,active:false},
  filmGrain:{intensity:1,size:1.2,speed:80,density:1,dynamicRange:1,lastUpdate:0,noiseZ:0,active:false},
  blur:{radius:8,active:false},
  vignette:{intensity:1,size:0.45,active:false},
  glitch:{intensity:0.5,active:false},
  chromaShift:{intensity:0.3,active:false},
  colourSweep:{progress:0,direction:1,randomize:1,active:false},
  pixelate:{pixelSize:1,active:false}
};
const effectParamDefs={
  scanLines:[
    {name:'intensity',min:0,max:1},
    {name:'speed',min:0,max:6},
    {name:'lineWidth',min:1,max:0.5,relTo:'height'},
    {name:'spacing',min:1,max:64},
    {name:'verticalShift',min:0,max:32}],
  filmGrain:[
    {name:'intensity',min:0.1,max:1.2},
    {name:'size',min:1,max:2.5},
    {name:'speed',min:20,max:120},
    {name:'density',min:0.3,max:1},
    {name:'dynamicRange',min:0.2,max:1}],
  blur:[
    {name:'radius',min:0,max:32}],
  vignette:[
    {name:'intensity',min:0.01,max:1.5},
    {name:'size',min:0.05,max:1}],
  glitch:[
    {name:'intensity',min:0,max:1}],
  chromaShift:[
    {name:'intensity',min:0,max:0.35}],
  colourSweep:[
    {name:'progress',min:0,max:1},
    {name:'direction',min:0,max:1},
    {name:'randomize',min:0,max:1}],
  pixelate:[
    {name:'pixelSize',min:1,max:64}]
};

const cloneDefaults = k => JSON.parse(JSON.stringify(effectDefaults[k]));

const app=(()=>{
  let mainCanvas,mainCtx,effectCanvases={},effectCtxs={},width,height,image=null,imageLoaded=false,imageError=false,animationId=null,isPlaying=false,effects={};
  const effectKeys=['scanLines','filmGrain','blur','vignette','glitch','chromaShift','colourSweep','pixelate'];
  const testActive = new Set();       // which effects are in auto-test mode
  let    testAnimFrame = null, sweepSeed = 0, testStartTime = null;

  // Colour Sweep state and helpers
  const colourSweepState=new WeakMap();
  const colourSweepInit=(cv,img,randomize=1)=>{
    const {width:w,height:h}=cv;
    const off=document.createElement('canvas').getContext('2d');
    off.canvas.width=w;off.canvas.height=h;
    off.drawImage(img,0,0,w,h);
    let src;
    try{src=off.getImageData(0,0,w,h);}catch{return {src:null};}
    const N=w*h,bright=new Float32Array(N),d=src.data;
    for(let i=0;i<N;i++){
      const p=i<<2;
      bright[i]=Math.min((d[p]+d[p+1]+d[p+2])/3+(randomize?Math.random():0),255);
    }
    return {src,bright,out:new ImageData(new Uint8ClampedArray(d.length),w,h),lastP:-1};
  };
  const getColourSweepState=(cv,img,randomize)=> {
    let s=colourSweepState.get(cv);
    if(!s||s.img!==img||s.randomize!==randomize){
      s={img,randomize,...colourSweepInit(cv,img,randomize)};
      colourSweepState.set(cv,s);
    }
    return s;
  };
  const applyColourSweepEffect=()=>{
    const ctx=effectCtxs.colourSweep;if(!ctx||!imageLoaded)return;
    const g=effects.colourSweep,state=getColourSweepState(effectCanvases.colourSweep,image,g.randomize|0);
    if(!state.src){ctx.clearRect(0,0,width,height);return;}
    let p=utils.clamp(g.progress,0,1),fwd=(g.direction|0)!==0;
    if(!fwd)p=1-p;
    const thr=p*255,{src,bright,out}=state,S=src.data,O=out.data;
    for(let i=0;i<bright.length;i++){
      const q=i<<2;
      if(bright[i]<=thr){O[q]=S[q];O[q+1]=S[q+1];O[q+2]=S[q+2];O[q+3]=S[q+3];}
      else O[q+3]=0;
    }
    ctx.clearRect(0,0,width,height);
    ctx.putImageData(out,0,0);
    mainCtx.clearRect(0,0,width,height);
    mainCtx.drawImage(effectCanvases.colourSweep,0,0);
  };

  // Pixelate Effect
  const applyPixelateEffect=()=>{
    const ctx=effectCtxs.pixelate;if(!ctx||!imageLoaded)return;
    ctx.clearRect(0,0,width,height);
    let px=utils.clamp(Math.round(effects.pixelate.pixelSize)||1,1,128);
    if(!image?.width)return;
    const ar=image.width/image.height;
    let iw,ih;
    if(ar>1){iw=width;ih=width/ar;}else{ih=height;iw=height*ar;}
    if(px>1){
      ctx.imageSmoothingEnabled=false;
      ctx.drawImage(image,0,0,image.width,image.height,(width-iw)/2,(height-ih)/2,Math.ceil(iw/px),Math.ceil(ih/px));
      ctx.drawImage(ctx.canvas,(width-iw)/2,(height-ih)/2,Math.ceil(iw/px),Math.ceil(ih/px),(width-iw)/2,(height-ih)/2,iw,ih);
      ctx.imageSmoothingEnabled=true;
    } else ctx.drawImage(image,(width-iw)/2,(height-ih)/2,iw,ih);
    mainCtx.clearRect(0,0,width,height);
    mainCtx.drawImage(effectCanvases.pixelate,0,0);
  };

  // Init & Setup
  const init=()=>{
    effectKeys.forEach(k=>effects[k]=cloneDefaults(k));
    mainCanvas=document.getElementById('main-canvas');
    mainCtx=mainCanvas.getContext('2d',{alpha:false});
    window.addEventListener('resize',handleResize);
    mainCanvas.addEventListener('click',()=>!imageError&&(isPlaying?stopEffects():startEffects()));
    handleResize();loadImage();
    log('App initialized and DOM loaded.');
  };
  const handleResize=()=>{
    const container=document.getElementById('canvas-container');
    const size=Math.min(window.innerHeight*.8,window.innerWidth*.8);
    container.style.width=container.style.height=`${size}px`;
    width=height=size;
    mainCanvas.width=mainCanvas.height=size;
    for(const e in effectCanvases)if(effectCanvases[e])effectCanvases[e].width=effectCanvases[e].height=size;
    if(imageLoaded&&!isPlaying)drawImage();
  };
  const loadImage=()=>{
    if(!window.images?.length)return showError();
    image=new Image();
    image.crossOrigin='anonymous';
    image.onload=()=>{
      imageLoaded=true;
      document.getElementById('loading').style.display='none';
      drawImage();
      document.getElementById('fx-btns').style.opacity='1';
      createEffectButtons();
    };
    image.onerror=()=>{imageError=true;showError();};
    image.src=window.images[0];
  };
  const showError=()=>{
    document.getElementById('loading').style.display='none';
    document.getElementById('error-message').style.display='block';
  };
  const drawImage=()=>{
    if(!imageLoaded)return;
    mainCtx.fillStyle='#000';mainCtx.fillRect(0,0,width,height);
    const ar=image.width/image.height;
    let w,h;
    if(ar>1){w=width;h=width/ar;}else{h=height;w=height*ar;}
    mainCtx.drawImage(image,(width-w)/2,(height-h)/2,w,h);
  };

  // Animation loop
  const fxLoop = (ts = performance.now()) => {
    if (!isPlaying) return;
    drawImage();
    const ct = ts / 1000;

    // NEW: update parameters for every test that’s ON
    autoTestFrame(ct);

    effectKeys.forEach(fx => {
        if (effects[fx].active) {
        createEffectCanvas(fx);
        applyEffect(fx, ct);
        }
    });

    animationId = requestAnimationFrame(fxLoop);
    };
  const startEffects=()=>{
    isPlaying=true;
    fxLoop();
  };
  const stopEffects=()=>{
    isPlaying=false;
    if(animationId)cancelAnimationFrame(animationId),animationId=null;
    effectKeys.forEach(k=>effects[k]=cloneDefaults(k));
    clearAllEffectCanvases();
    drawImage();
    updateButtonStates();
    testStartTime=null;
  };
  // Buttons & UI
 const createEffectButtons = () => {
  const btns = document.getElementById('fx-btns');
  btns.innerHTML = '';

  effectKeys.forEach(fx => {
    const b       = document.createElement('button');
    b.className   = 'fx-btn';
    b.textContent = `${fx} (Test)`;
    b.dataset.fx  = fx;

    // ⇣ NEW: toggle the effect
    b.onclick = () => {
      if (testActive.has(fx)) {
        // turn it OFF
        testActive.delete(fx);
        effects[fx].active = false;
        removeEffectCanvas(fx);   // helper just like clearAllEffectCanvases but per-fx
      } else {
        // turn it ON
        testActive.add(fx);
        effects[fx] = cloneDefaults(fx);   // fresh params
        effects[fx].active = true;
      }
      // start/stop the main loop automatically
      if (testActive.size) startEffects(); else stopEffects();
      updateButtonStates();
    };

    btns.appendChild(b);
  });
  updateButtonStates();
};

const updateButtonStates = () =>
  document.querySelectorAll('.fx-btn').forEach(btn => {
    const fx = btn.dataset.fx;
    btn.classList.toggle('active', testActive.has(fx));
  });

  const clearAllEffectCanvases=()=>{
    for(const e in effectCanvases){
      if(effectCanvases[e]){
        effectCanvases[e].remove();
        effectCanvases[e]=effectCtxs[e]=null;
      }
    }
  };

  // Test logic
  const runEffectTest=fx=>{
    stopEffects();
    testActive=fx;
    sweepSeed=Math.random()*1e3;
    testStartTime=null;
    effectKeys.forEach(k=>{
      effects[k]=cloneDefaults(k);
      effects[k].active=k===fx;
    });
    updateButtonStates();
    autoTestFrame();
  };
  const stopEffectTest=()=>{
    if(testAnimFrame)cancelAnimationFrame(testAnimFrame);
    testAnimFrame=null;
    testActive=null;
    stopEffects();
    updateButtonStates();
  };
  const autoTestFrame = (ct) => {
  testActive.forEach(fx => {
    if (fx === 'colourSweep') {
      const prog = (ct % 10) / 10;
      Object.assign(effects.colourSweep, { progress: prog, direction: 1, randomize: 1 });
    } else if (fx === 'pixelate') {
      effects.pixelate.pixelSize = 1 + Math.abs(Math.sin(Math.PI * (ct % 5) / 5)) * 63;
    } else {
      const def = effectParamDefs[fx];
      if (!def) return;
      def.forEach(({ name, min, max, relTo }) => {
        if (relTo === 'height') { min *= height; max *= height; }
        effects[fx][name] =
          min + (max - min) *
          (0.5 + 0.5 * Math.sin(ct * 0.7 + 1.5 * Math.sin(ct * 0.33 + name.charCodeAt(0) % 4) +
                                Math.cos(ct * 0.21 + name.length)) *
           utils.easeInOut(0.5 + 0.5 * Math.sin(ct * 0.11 + name.length)));
      });
    }
  });
};

const removeEffectCanvas = fx => {
  if (effectCanvases[fx]) {
    effectCanvases[fx].remove();
    effectCanvases[fx] = effectCtxs[fx] = null;
  }
};

  // Create or reuse effect canvas
  const createEffectCanvas=e=>{
    if(effectCanvases[e])return;
    const c=document.createElement('canvas');
    c.width=c.height=width;
    Object.assign(c.style,{position:'absolute',top:0,left:0,width:'100%',height:'100%'});
    document.getElementById('canvas-container').appendChild(c);
    effectCanvases[e]=c;
    effectCtxs[e]=c.getContext('2d',{alpha:true});
  };
  // Effect switch
  const applyEffect=(effect,ct)=>{
    switch(effect){
      case 'scanLines':applyScanLinesEffect(ct);break;
      case 'filmGrain':applyFilmGrainEffect(ct);break;
      case 'blur':applyBlurEffect();break;
      case 'vignette':applyVignetteEffect();break;
      case 'glitch':applyGlitchEffect(ct);break;
      case 'chromaShift':applyChromaShiftEffect(ct);break;
      case 'colourSweep':applyColourSweepEffect();break;
      case 'pixelate':applyPixelateEffect();break;
    }
  };

  // Effects implementations
  const applyScanLinesEffect=ct=>{
    const ctx=effectCtxs.scanLines; if(!ctx)return;
    ctx.clearRect(0,0,width,height);
    const {intensity,lineWidth,spacing,speed,verticalShift=0}=effects.scanLines;
    const offset=((speed>0?(ct*speed*spacing)%spacing:0)+verticalShift);
    ctx.globalAlpha=intensity; ctx.fillStyle='#000';
    for(let y=offset;y<height;y+=spacing)ctx.fillRect(0,y,width,Math.max(1,lineWidth));
    ctx.globalAlpha=1;
    mainCtx.drawImage(effectCanvases.scanLines,0,0);
  };
  const makeRNG=seed=>{
    let s=seed>>>0;
    return ()=>((s=Math.imul(48271,s)&0x7fffffff)/0x7fffffff);
  };
  const applyFilmGrainEffect=ct=>{
    const g=effects.filmGrain, {intensity=1,size=1,speed=60,density=1}=g;
    const cw=width,ch=height,gw=Math.floor(cw/Math.max(1,size)),gh=Math.floor(ch/Math.max(1,size));
    if(!applyFilmGrainEffect.noiseCanvas||
      applyFilmGrainEffect.noiseCanvas.width!==gw||
      applyFilmGrainEffect.noiseCanvas.height!==gh)
      applyFilmGrainEffect.noiseCanvas=document.createElement('canvas');
    const nctx=applyFilmGrainEffect.noiseCanvas.getContext('2d');
    applyFilmGrainEffect.noiseCanvas.width=gw;
    applyFilmGrainEffect.noiseCanvas.height=gh;
    const imgData=nctx.createImageData(gw,gh),data=imgData.data;
    const rng=makeRNG(Math.floor(ct*speed*1e3));
    const activeRatio=Math.max(0.12,Math.min(1,density*intensity*0.8+0.18));
    let srcImg=null;
    try{srcImg=mainCtx.getImageData(0,0,cw,ch);}catch{}
    for(let y=0;y<gh;y++)for(let x=0;x<gw;x++){
      const p=(y*gw+x)*4;
      let isColoured=true;
      if(srcImg){
        const sp=((Math.floor(y*ch/gh)*cw)+Math.floor(x*cw/gw))*4;
        const r=srcImg.data[sp],g=srcImg.data[sp+1],b=srcImg.data[sp+2];
        isColoured=r+g+b>30;
      }
      if(isColoured){
        const active=rng()<activeRatio;
        const val=active?200+Math.floor(rng()*55):60+Math.floor(rng()*40);
        data[p]=data[p+1]=data[p+2]=val;
        data[p+3]=active?180+Math.floor(rng()*60):80+Math.floor(rng()*40);
      } else data.set([0,0,0,0],p);
    }
    nctx.putImageData(imgData,0,0);
    mainCtx.save();
    mainCtx.globalAlpha=0.28*Math.min(1,intensity)+0.14*Math.min(1,density);
    mainCtx.imageSmoothingEnabled=false;
    mainCtx.drawImage(applyFilmGrainEffect.noiseCanvas,0,0,gw,gh,0,0,cw,ch);
    mainCtx.imageSmoothingEnabled=true;
    mainCtx.globalAlpha=1;
    mainCtx.restore();
  };
  const applyBlurEffect=()=>{
    const ctx=effectCtxs.blur;if(!ctx)return;
    ctx.clearRect(0,0,width,height);
    ctx.filter=`blur(${effects.blur.radius}px)`;
    ctx.drawImage(mainCanvas,0,0);
    ctx.filter='none';
    mainCtx.globalAlpha=0.85;
    mainCtx.drawImage(effectCanvases.blur,0,0);
    mainCtx.globalAlpha=1;
  };
  const applyVignetteEffect=()=>{
    const ctx=effectCtxs.vignette;if(!ctx)return;
    ctx.clearRect(0,0,width,height);
    const {intensity,size}=effects.vignette;
    const grad=ctx.createRadialGradient(width/2,height/2,0,width/2,height/2,width*size);
    grad.addColorStop(0,'rgba(0,0,0,0)');
    grad.addColorStop(.5,'rgba(0,0,0,0)');
    grad.addColorStop(1,`rgba(0,0,0,${intensity})`);
    ctx.fillStyle=grad;
    ctx.fillRect(0,0,width,height);
    mainCtx.globalAlpha=1;
    mainCtx.drawImage(effectCanvases.vignette,0,0);
  };
  const applyGlitchEffect=ct=>{
    const ctx=effectCtxs.glitch,g=effects.glitch;
    if(!ctx||g.intensity===0)return;
    ctx.clearRect(0,0,width,height);
    const slices=utils.randomInt(3,7),sliceHeight=height/slices;
    for(let i=0;i<slices;i++){
      const y=i*sliceHeight,ox=utils.random(-width*g.intensity,width*g.intensity);
      ctx.drawImage(mainCanvas,0,y,width,sliceHeight,ox,y,width,sliceHeight);
      if(Math.random()>.5){
        ctx.globalCompositeOperation='lighten';
        ctx.fillStyle=`rgba(${utils.randomInt(0,255)},${utils.randomInt(0,255)},${utils.randomInt(0,255)},0.14)`;
        ctx.fillRect(ox,y,width,sliceHeight);
        ctx.globalCompositeOperation='source-over';
      }
    }
    mainCtx.drawImage(effectCanvases.glitch,0,0);
  };
  const applyChromaShiftEffect=ct=>{
    const ctx=effectCtxs.chromaShift,c=effects.chromaShift;
    if(!ctx||c.intensity===0)return;
    ctx.clearRect(0,0,width,height);
    const ox=Math.sin(ct*2)*width*c.intensity,oy=Math.cos(ct*1.5)*height*c.intensity*0.5;
    ctx.globalCompositeOperation='lighter';
    ctx.globalAlpha=0.8;
    ctx.drawImage(mainCanvas,ox,oy);
    ctx.globalAlpha=0.8;
    ctx.drawImage(mainCanvas,-ox,-oy);
    ctx.globalAlpha=1;
    ctx.globalCompositeOperation='source-over';
    mainCtx.drawImage(effectCanvases.chromaShift,0,0);
  };

  return {init};
})();
document.addEventListener('DOMContentLoaded',app.init);
</script>
</body>
</html>
