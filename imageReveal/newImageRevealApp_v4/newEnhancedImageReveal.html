<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Image FX Playground</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:#121212;color:#f0f0f0;font-family:Arial,sans-serif;overflow:hidden;display:flex;flex-direction:column;justify-content:center;align-items:center;height:100vh;position:relative}
  #canvas-container{position:relative;width:80vh;height:80vh;max-width:80vw;max-height:80vh;cursor:pointer}
  canvas{position:absolute;top:0;left:0;width:100%;height:100%;border-radius:4px;box-shadow:0 0 20px #0008}
  .fx-btns{display:flex;gap:12px;justify-content:center;align-items:center;position:absolute;bottom:16px;left:50%;transform:translateX(-50%)}
  .fx-btn{padding:10px 16px;background:linear-gradient(135deg,#6e8efb,#a777e3);color:#fff;border:none;border-radius:4px;font-size:15px;cursor:pointer;opacity:.93;transition:.2s;box-shadow:0 4px 6px #0002}
  .fx-btn:hover{background:linear-gradient(135deg,#5d7df9,#9666d6);transform:translateY(-2px)}
  .fx-btn.active{background:linear-gradient(135deg,#3a4ca2,#7d3ed7)!important;box-shadow:0 4px 18px #4416;opacity:1}
  .fx-btn:disabled{opacity:.4;cursor:default}
  #error-message,#loading{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:18px;text-align:center}
  #error-message{color:#f55;display:none}
  #loading{color:#f0f0f0}
</style>
</head>
<body>
<div id="canvas-container">
  <canvas id="main-canvas"></canvas>
  <div id="loading">Loading image...</div>
  <div id="error-message">Failed to load image. Please check the URL.</div>
</div>
<div class="fx-btns" id="fx-btns"></div>
<script type="module">
window.images=["https://ordinals.com/content/01c48d3cceb02215bc3d44f9a2dc7fba63ea63719a2ef1c35d3f0c4db93ab8d5i0"];
const log=(...a)=>console.log('[FXDEMO]',...a);
const utils=(()=>{
  const p=[...Array(256)].map(()=>Math.floor(Math.random()*256)),pp=[...p,...p];
  const fade=t=>t**3*(t*(t*6-15)+10);
  const lerp=(a,b,t)=>a+t*(b-a);
  const grad=(h,x,y,z)=>{
    const u=h<8?x:y,v=h<4?y:(h===12||h===14?x:z);
    return ((h&1)===0?u:-u)+((h&2)===0?v:-v);
  };
  return {
    lerp,
    clamp:(v,min,max)=>Math.max(min,Math.min(max,v)),
    random:(min,max)=>Math.random()*(max-min)+min,
    randomInt:(min,max)=>Math.floor(Math.random()*(max-min+1))+min,
    easeInOut:t=>t<.5?2*t*t:1-((-2*t+2)**2/2),
    noise:(x,y,z)=>{
      const X=Math.floor(x)&255,Y=Math.floor(y)&255,Z=Math.floor(z)&255;
      x-=Math.floor(x);y-=Math.floor(y);z-=Math.floor(z);
      const u=fade(x),v=fade(y),w=fade(z);
      const A=pp[X]+Y,AA=pp[A]+Z,AB=pp[A+1]+Z,B=pp[X+1]+Y,BA=pp[B]+Z,BB=pp[B+1]+Z;
      return lerp(
        lerp(
          lerp(grad(pp[AA],x,y,z),grad(pp[BA],x-1,y,z),u),
          lerp(grad(pp[AB],x,y-1,z),grad(pp[BB],x-1,y-1,z),u),v),
        lerp(
          lerp(grad(pp[AA+1],x,y,z-1),grad(pp[BA+1],x-1,y,z-1),u),
          lerp(grad(pp[AB+1],x,y-1,z-1),grad(pp[BB+1],x-1,y-1,z-1),u),v),w);
    }
  };
})();

const effectDefaults={
  scanLines:{intensity:0.4,speed:1.5,lineWidth:3,spacing:6,verticalShift:0,active:false},
  filmGrain:{intensity:1,size:1.2,speed:80,density:1,dynamicRange:1,lastUpdate:0,noiseZ:0,active:false},
  blur:{radius:8,active:false},
  vignette:{intensity:1,size:0.45,active:false},
  glitch:{intensity:0.5,active:false},
  chromaShift:{intensity:0.3,active:false},
  colourSweep:{progress:0,direction:1,randomize:1,active:false},
  pixelate:{pixelSize:1,active:false}
};
const effectParamDefs={
  scanLines:[
    {name:'intensity',min:0,max:1},
    {name:'speed',min:0,max:6},
    {name:'lineWidth',min:1,max:0.5,relTo:'height'},
    {name:'spacing',min:1,max:64},
    {name:'verticalShift',min:0,max:32}],
  filmGrain:[
    {name:'intensity',min:0.1,max:1.2},
    {name:'size',min:1,max:2.5},
    {name:'speed',min:20,max:120},
    {name:'density',min:0.3,max:1},
    {name:'dynamicRange',min:0.2,max:1}],
  blur:[
    {name:'radius',min:0,max:32}],
  vignette:[
    {name:'intensity',min:0.01,max:1.5},
    {name:'size',min:0.05,max:1}],
  glitch:[
    {name:'intensity',min:0,max:1}],
  chromaShift:[
    {name:'intensity',min:0,max:0.35}],
  colourSweep:[
    {name:'progress',min:0,max:1},
    {name:'direction',min:0,max:1},
    {name:'randomize',min:0,max:1}],
  pixelate:[
    {name:'pixelSize',min:1,max:64}]
};
const cloneDefaults = k => JSON.parse(JSON.stringify(effectDefaults[k]));

const app=(()=>{
  let mainCanvas,mainCtx,width,height,image=null,imageLoaded=false,imageError=false,animationId=null,isPlaying=false,effects={};
  // Keep the *order* the user enables effects
  let enabledOrder = [];
  const effectKeys=['scanLines','filmGrain','blur','vignette','glitch','chromaShift','colourSweep','pixelate'];
  const testActive = new Set(); // which effects are in auto-test mode
  let testAnimFrame = null, sweepSeed = 0, testStartTime = null;

  // Create buffer canvas
  let bufferA, bufferB, bufferCtxA, bufferCtxB;
  // Used for temporary swapping (double buffering)
  function ensureBuffers() {
    if(!bufferA) {
      bufferA = document.createElement('canvas');
      bufferB = document.createElement('canvas');
      bufferCtxA = bufferA.getContext('2d', {alpha:true});
      bufferCtxB = bufferB.getContext('2d', {alpha:true});
    }
    bufferA.width = bufferB.width = width;
    bufferA.height = bufferB.height = height;
  }

  // --- ColourSweep state, slightly revised ---
  const colourSweepCache = new WeakMap();
  function getColourSweepState(imgData, w, h, randomize) {
    // Cache key based on pixel hash + settings
    const cacheKey = imgData;
    let cached = colourSweepCache.get(cacheKey);
    if (cached && cached.randomize === randomize) return cached;
    // Calculate brightness array
    const N = w * h, bright = new Float32Array(N), d = imgData.data;
    for (let i = 0; i < N; i++) {
      const p = i << 2;
      bright[i] = Math.min((d[p] + d[p+1] + d[p+2]) / 3 + (randomize ? Math.random() : 0), 255);
    }
    const out = new ImageData(new Uint8ClampedArray(d.length), w, h);
    cached = {randomize, bright, out};
    colourSweepCache.set(cacheKey, cached);
    return cached;
  }

  // --- EFFECTS: All now accept (srcCtx, dstCtx, t) signature ---
  function applyScanLines(srcCtx, dstCtx, ct, params) {
    dstCtx.clearRect(0,0,width,height);
    dstCtx.drawImage(srcCtx.canvas, 0, 0);
    const {intensity,lineWidth,spacing,speed,verticalShift=0} = params;
    const offset=((speed>0?(ct*speed*spacing)%spacing:0)+verticalShift);
    dstCtx.globalAlpha = intensity;
    dstCtx.fillStyle='#000';
    for(let y=offset;y<height;y+=spacing) dstCtx.fillRect(0,y,width,Math.max(1,lineWidth));
    dstCtx.globalAlpha=1;
  }

  function makeRNG(seed) {
    let s = seed >>> 0;
    return () => ((s = Math.imul(48271, s) & 0x7fffffff) / 0x7fffffff);
  }

  function applyFilmGrain(srcCtx, dstCtx, ct, params) {
    dstCtx.clearRect(0,0,width,height);
    dstCtx.drawImage(srcCtx.canvas,0,0);
    const {intensity=1,size=1,speed=60,density=1} = params;
    const cw=width,ch=height,gw=Math.floor(cw/Math.max(1,size)),gh=Math.floor(ch/Math.max(1,size));
    let noiseCanvas = applyFilmGrain.noiseCanvas;
    if(!noiseCanvas||noiseCanvas.width!==gw||noiseCanvas.height!==gh) {
      noiseCanvas=document.createElement('canvas');
      noiseCanvas.width=gw;noiseCanvas.height=gh;
      applyFilmGrain.noiseCanvas=noiseCanvas;
    }
    const nctx = noiseCanvas.getContext('2d');
    const imgData = nctx.createImageData(gw,gh), data=imgData.data;
    const rng = makeRNG(Math.floor(ct*speed*1e3));
    const activeRatio = Math.max(0.12, Math.min(1, density*intensity*0.8+0.18));
    let srcImg;
    try { srcImg = srcCtx.getImageData(0,0,cw,ch); } catch {}
    for(let y=0; y<gh; y++) for(let x=0; x<gw; x++) {
      const p=(y*gw+x)*4;
      let isColoured=true;
      if(srcImg) {
        const sp=((Math.floor(y*ch/gh)*cw)+Math.floor(x*cw/gw))*4;
        const r=srcImg.data[sp],g=srcImg.data[sp+1],b=srcImg.data[sp+2];
        isColoured = r+g+b>30;
      }
      if(isColoured) {
        const active=rng()<activeRatio;
        const val=active?200+Math.floor(rng()*55):60+Math.floor(rng()*40);
        data[p]=data[p+1]=data[p+2]=val;
        data[p+3]=active?180+Math.floor(rng()*60):80+Math.floor(rng()*40);
      } else data.set([0,0,0,0],p);
    }
    nctx.putImageData(imgData,0,0);
    dstCtx.save();
    dstCtx.globalAlpha=0.28*Math.min(1,intensity)+0.14*Math.min(1,density);
    dstCtx.imageSmoothingEnabled=false;
    dstCtx.drawImage(noiseCanvas,0,0,gw,gh,0,0,cw,ch);
    dstCtx.imageSmoothingEnabled=true;
    dstCtx.globalAlpha=1;
    dstCtx.restore();
  }

  function applyBlur(srcCtx, dstCtx, _ct, params) {
    dstCtx.clearRect(0,0,width,height);
    dstCtx.filter = `blur(${params.radius}px)`;
    dstCtx.drawImage(srcCtx.canvas, 0, 0);
    dstCtx.filter = 'none';
  }

  function applyVignette(srcCtx, dstCtx, _ct, params) {
    dstCtx.clearRect(0,0,width,height);
    dstCtx.drawImage(srcCtx.canvas,0,0);
    const {intensity, size} = params;
    const grad = dstCtx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width*size);
    grad.addColorStop(0,'rgba(0,0,0,0)');
    grad.addColorStop(.5,'rgba(0,0,0,0)');
    grad.addColorStop(1,`rgba(0,0,0,${intensity})`);
    dstCtx.fillStyle = grad;
    dstCtx.fillRect(0,0,width,height);
  }

  function applyGlitch(srcCtx, dstCtx, ct, params) {
    dstCtx.clearRect(0,0,width,height);
    const g = params;
    const slices=utils.randomInt(3,7),sliceHeight=height/slices;
    for(let i=0;i<slices;i++) {
      const y=i*sliceHeight,ox=utils.random(-width*g.intensity,width*g.intensity);
      dstCtx.drawImage(srcCtx.canvas,0,y,width,sliceHeight,ox,y,width,sliceHeight);
      if(Math.random()>.5) {
        dstCtx.globalCompositeOperation='lighten';
        dstCtx.fillStyle=`rgba(${utils.randomInt(0,255)},${utils.randomInt(0,255)},${utils.randomInt(0,255)},0.14)`;
        dstCtx.fillRect(ox,y,width,sliceHeight);
        dstCtx.globalCompositeOperation='source-over';
      }
    }
  }

  function applyChromaShift(srcCtx, dstCtx, ct, params) {
    dstCtx.clearRect(0,0,width,height);
    const c = params;
    const ox = Math.sin(ct*2)*width*c.intensity, oy = Math.cos(ct*1.5)*height*c.intensity*0.5;
    dstCtx.globalCompositeOperation='lighter';
    dstCtx.globalAlpha=0.8;
    dstCtx.drawImage(srcCtx.canvas, ox, oy);
    dstCtx.globalAlpha=0.8;
    dstCtx.drawImage(srcCtx.canvas, -ox, -oy);
    dstCtx.globalAlpha=1;
    dstCtx.globalCompositeOperation='source-over';
  }

  function applyColourSweep(srcCtx, dstCtx, _ct, params) {
    const {progress, direction, randomize} = params;
    const srcImg = srcCtx.getImageData(0,0,width,height);
    const state = getColourSweepState(srcImg, width, height, randomize|0);
    let p = utils.clamp(progress, 0, 1), fwd = (direction|0)!==0;
    if (!fwd) p = 1-p;
    const thr = p * 255, {bright, out} = state, S = srcImg.data, O = out.data;
    for(let i=0;i<bright.length;i++) {
      const q=i<<2;
      if(bright[i]<=thr) {
        O[q]=S[q]; O[q+1]=S[q+1]; O[q+2]=S[q+2]; O[q+3]=S[q+3];
      } else O[q+3]=0;
    }
    dstCtx.clearRect(0,0,width,height);
    dstCtx.putImageData(out,0,0);
  }

  function applyPixelate(srcCtx, dstCtx, _ct, params) {
    let px=utils.clamp(Math.round(params.pixelSize)||1,1,128);
    dstCtx.clearRect(0,0,width,height);
    if(px>1) {
      dstCtx.imageSmoothingEnabled=false;
      dstCtx.drawImage(srcCtx.canvas,0,0,width,height,0,0,Math.ceil(width/px),Math.ceil(height/px));
      dstCtx.drawImage(dstCtx.canvas,0,0,Math.ceil(width/px),Math.ceil(height/px),0,0,width,height);
      dstCtx.imageSmoothingEnabled=true;
    } else {
      dstCtx.drawImage(srcCtx.canvas,0,0,width,height);
    }
  }

  // Map of effect functions
  const effectMap = {
    scanLines: applyScanLines,
    filmGrain: applyFilmGrain,
    blur: applyBlur,
    vignette: applyVignette,
    glitch: applyGlitch,
    chromaShift: applyChromaShift,
    colourSweep: applyColourSweep,
    pixelate: applyPixelate
  };

  // --- CORE PIPELINE LOGIC ---
  function fxLoop(ts = performance.now()) {
    if (!isPlaying) return;
    const ct = ts / 1000;
    ensureBuffers();
    // 1. Draw image to bufferA (start of chain)
    bufferCtxA.clearRect(0,0,width,height);
    drawImage(bufferCtxA);
    let readCtx = bufferCtxA, writeCtx = bufferCtxB;
    // 2. Build effect pipeline in enabledOrder
    autoTestFrame(ct);
    for(const fx of enabledOrder) {
      if (!effects[fx].active) continue;
      writeCtx.clearRect(0,0,width,height);
      effectMap[fx](readCtx, writeCtx, ct, effects[fx]);
      // Swap buffers for next effect
      [readCtx, writeCtx] = [writeCtx, readCtx];
    }
    // 3. Copy to mainCanvas
    mainCtx.clearRect(0,0,width,height);
    mainCtx.drawImage(readCtx.canvas, 0, 0);
    animationId = requestAnimationFrame(fxLoop);
  }

  // --- UI & State Management ---
  function init() {
    effectKeys.forEach(k=>effects[k]=cloneDefaults(k));
    mainCanvas=document.getElementById('main-canvas');
    mainCtx=mainCanvas.getContext('2d',{alpha:false});
    window.addEventListener('resize',handleResize);
    mainCanvas.addEventListener('click',()=>!imageError&&(isPlaying?stopEffects():startEffects()));
    handleResize();loadImage();
    log('App initialized and DOM loaded.');
  }
  function handleResize() {
    const container=document.getElementById('canvas-container');
    const size=Math.min(window.innerHeight*.8,window.innerWidth*.8);
    container.style.width=container.style.height=`${size}px`;
    width=height=size;
    mainCanvas.width=mainCanvas.height=size;
    ensureBuffers();
    if(imageLoaded&&!isPlaying) drawImage(mainCtx);
  }
  function loadImage() {
    if(!window.images?.length) return showError();
    image=new Image();
    image.crossOrigin='anonymous';
    image.onload=()=>{
      imageLoaded=true;
      document.getElementById('loading').style.display='none';
      drawImage(mainCtx);
      document.getElementById('fx-btns').style.opacity='1';
      createEffectButtons();
    };
    image.onerror=()=>{imageError=true;showError();};
    image.src=window.images[0];
  }
  function showError() {
    document.getElementById('loading').style.display='none';
    document.getElementById('error-message').style.display='block';
  }
  function drawImage(ctx) {
    if(!imageLoaded) return;
    ctx.fillStyle='#000';ctx.fillRect(0,0,width,height);
    const ar=image.width/image.height;
    let w,h;
    if(ar>1){w=width;h=width/ar;}else{h=height;w=height*ar;}
    ctx.drawImage(image,(width-w)/2,(height-h)/2,w,h);
  }
  function startEffects() {
    isPlaying=true;
    fxLoop();
  }
  function stopEffects() {
    isPlaying=false;
    if(animationId) cancelAnimationFrame(animationId),animationId=null;
    enabledOrder = [];
    effectKeys.forEach(k=>effects[k]=cloneDefaults(k));
    drawImage(mainCtx);
    updateButtonStates();
    testStartTime=null;
  }

  // --- Effect Buttons: now preserve *activation order* ---
  function createEffectButtons() {
    const btns = document.getElementById('fx-btns');
    btns.innerHTML = '';
    effectKeys.forEach(fx => {
      const b = document.createElement('button');
      b.className = 'fx-btn';
      b.textContent = `${fx} (Test)`;
      b.dataset.fx  = fx;
      b.onclick = () => {
        const idx = enabledOrder.indexOf(fx);
        if (idx !== -1) {
          enabledOrder.splice(idx, 1);
          effects[fx].active = false;
        } else {
          enabledOrder.push(fx);
          effects[fx] = cloneDefaults(fx);
          effects[fx].active = true;
        }
        if (enabledOrder.length) startEffects(); else stopEffects();
        updateButtonStates();
      };
      btns.appendChild(b);
    });
    updateButtonStates();
  }
  function updateButtonStates() {
    document.querySelectorAll('.fx-btn').forEach(btn => {
      const fx = btn.dataset.fx;
      btn.classList.toggle('active', enabledOrder.includes(fx));
    });
  }

  // --- Param auto-test logic (unchanged) ---
  const autoTestFrame = (ct) => {
    enabledOrder.forEach(fx => {
      if (fx === 'colourSweep') {
        const prog = (ct % 10) / 10;
        Object.assign(effects.colourSweep, { progress: prog, direction: 1, randomize: 1 });
      } else if (fx === 'pixelate') {
        effects.pixelate.pixelSize = 1 + Math.abs(Math.sin(Math.PI * (ct % 5) / 5)) * 63;
      } else {
        const def = effectParamDefs[fx];
        if (!def) return;
        def.forEach(({ name, min, max, relTo }) => {
          if (relTo === 'height') { min *= height; max *= height; }
          effects[fx][name] =
            min + (max - min) *
            (0.5 + 0.5 * Math.sin(ct * 0.7 + 1.5 * Math.sin(ct * 0.33 + name.charCodeAt(0) % 4) +
                                  Math.cos(ct * 0.21 + name.length)) *
             utils.easeInOut(0.5 + 0.5 * Math.sin(ct * 0.11 + name.length)));
        });
      }
    });
  };

  return {init};
})();
document.addEventListener('DOMContentLoaded',app.init);
</script>
</body>
</html>
