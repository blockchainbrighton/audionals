<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Image FX Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden;}
    body{display:flex;align-items:center;justify-content:center;height:100vh;}
    canvas{display:block;margin:auto;box-shadow:0 0 48px #000a;border-radius:2vw;}
    #test-btn{position:fixed;top:30px;left:50%;transform:translateX(-50%);background:#222;color:#fff;padding:0.7em 1.4em;font:1.2em monospace;border:none;border-radius:2em;z-index:10;box-shadow:0 4px 16px #000a;cursor:pointer;opacity:.92;transition:.2s;}
    #test-btn:active{background:#444;}
  </style>
  <script>
    window.images=["https://ordinals.com/content/01c48d3cceb02215bc3d44f9a2dc7fba63ea63719a2ef1c35d3f0c4db93ab8d5i0"];
  </script>
</head>
<body>
<button id="test-btn" style="display:none">Test All Effects</button>
<canvas id="fx-canvas"></canvas>
<script>
// ===== BAR-SYNCED FX LOGIC (WITH PATCHED COLOR) =====
const BPM = 104.15, BEAT_MS = 60000/BPM, BAR_MS = BEAT_MS*4, PEAK_BARS = [9,17,25,33,41,49];
const EFFECT_WEIGHTS = { grain:1, scanline:1, vignette:1 };
function hashSeed(str){let h=2166136261>>>0;for(let i=0;i<str.length;i++){h^=str.charCodeAt(i);h+=(h<<1)+(h<<4)+(h<<7)+(h<<8)+(h<<24);}return h>>>0;}
function makeRNG(seed){let s=seed>>>0;return ()=>((s=Math.imul(48271,s)&0x7fffffff)/0x7fffffff);}
function randInt(rng,a,b){return Math.floor(rng()*(b-a+1))+a;}
function randFloat(rng,a,b,d=2){return +(a+(b-a)*rng()).toFixed(d);}
function buildStepsWithPeaks(lowFactory,highFactory,rng){
  let steps=[],bar=1;
  for(let peak of PEAK_BARS){
    while(bar<peak){
      let chunk=Math.min(randInt(rng,2,4),peak-bar);
      steps.push({...lowFactory(),duration:chunk*BAR_MS});
      bar+=chunk;
    }
    steps.push({...highFactory(),duration:BAR_MS});
    bar++;
  }
  steps.push({enabled:false,duration:4*BAR_MS});
  return steps;
}
function createGrainConfig(rng,weight=1){
  if(weight<1&&rng()>weight)return{enabled:false};
  const steps=buildStepsWithPeaks(
    ()=>({enabled:true,opacity:randFloat(rng,0.05,0.4),frameIntervalMs:randInt(rng,30,60)}),
    ()=>({enabled:true,opacity:randFloat(rng,0.6,1.0),frameIntervalMs:randInt(rng,5,20)}),
    rng
  );
  return {enabled:true,steps,defaultOpacity:steps[0].opacity,defaultFrameIntervalMs:steps[0].frameIntervalMs};
}
function createScanlineConfig(rng,weight=1){
  if(weight<1&&rng()>weight)return{enabled:false};
  const steps=buildStepsWithPeaks(
    ()=>({enabled:true,opacity:randFloat(rng,0.05,0.3),lineHeightPx:randInt(rng,40,150),speed:randInt(rng,15,40)}),
    ()=>({enabled:true,opacity:randFloat(rng,0.6,0.9),lineHeightPx:randInt(rng,1,6),speed:randInt(rng,2,10)}),
    rng
  );
  return {enabled:true,steps,defaultOpacity:steps[0].opacity,defaultLineHeightPx:steps[0].lineHeightPx,defaultSpeed:steps[0].speed};
}
function createVignetteConfig(rng,weight=1){
  if(weight<1&&rng()>weight)return{enabled:false};
  const steps=buildStepsWithPeaks(
    ()=>{
      let c=randInt(rng,0,15).toString(16);
      return{enabled:true,strength:randFloat(rng,0.1,0.4),color:'#'+c.repeat(3)};
    },
    ()=>({enabled:true,strength:randFloat(rng,0.6,1.0),color:'#000'}),
    rng
  );
  return {enabled:true,steps,defaultStrength:steps[0].strength,defaultColor:steps[0].color};
}
function findStepAtTime(steps,t){let acc=0;for(let i=0;i<steps.length;++i){acc+=steps[i].duration;if(t<acc)return steps[i];}return steps[steps.length-1];}
// ===== END PATCH =====

// ===== ORIGINAL APP CODE (slightly patched for effect fusion) =====
const COLORS=["#0ff","#f0f","#ff0","#fff"], canvas=document.getElementById('fx-canvas');
let ctx=canvas.getContext('2d'), ctxRead, grainNoiseCanvas, grainNoiseCtx, image, showText=1, textAlpha=1, textScale=1, imageLoaded=0, stopNormalEffects, normalEffectsRunning=0, testMode=0, testRunning=0, testStop=0;
const FX_CONFIG={
  sequence:[
    ['fadeIn',{duration:2e3}],
    ['pixelateIn',{duration:1e3,from:32,to:1}],
    ['colorSweepIn', { duration: 1400, fwd: true }],
    ['scanlines',{active:1,opacity:.18,speed:2}],
    ['grain',{active:1,intensity:.15}],
    ['blur',{active:1,value:4}],
    ['vignette',{active:1,strength:.35}]
  ],
  startText:{text:"Click to start",font:"2.2vw 'Space Mono', monospace",color:"#fff",fadeDuration:1e3,shrinkDuration:1e3}
};
const lerp=(a,b,t)=>a+(b-a)*t, clamp=(x,a=0,b=1)=>Math.max(a,Math.min(x,b)), sleep=ms=>new Promise(r=>setTimeout(r,ms));
function createGrainNoise() {
  if (!grainNoiseCanvas) grainNoiseCanvas=document.createElement('canvas');
  grainNoiseCanvas.width=canvas.width, grainNoiseCanvas.height=canvas.height;
  grainNoiseCtx=grainNoiseCanvas.getContext('2d');
  let d=grainNoiseCtx.createImageData(canvas.width,canvas.height);
  for(let i=0;i<d.data.length;i+=4){let v=Math.random()*255;d.data[i]=d.data[i+1]=d.data[i+2]=v;d.data[i+3]=255;}
  grainNoiseCtx.putImageData(d,0,0);
}
function resizeCanvas(){
  let size=Math.floor(window.innerHeight*.8);
  canvas.width=canvas.height=size;ctx=canvas.getContext('2d');ctxRead=canvas.getContext('2d',{willReadFrequently:true});createGrainNoise();
}
window.addEventListener('resize',resizeCanvas);resizeCanvas();
function loadImage(url){return new Promise((res,rej)=>{let img=new Image();img.crossOrigin="Anonymous";img.onload=()=>res(img);img.onerror=rej;img.src=url;});}
// ---- Effects Library ---- //
const Effects={
  fadeIn({duration},draw,done){let t0=performance.now();function a(now){let p=clamp((now-t0)/duration);ctx.save();ctx.globalAlpha=p;draw();ctx.restore();p<1?requestAnimationFrame(a):done&&done();}requestAnimationFrame(a);},
  pixelateIn({duration,from,to},draw,done){let t0=performance.now();function a(now){let p=clamp((now-t0)/duration),px=Math.round(lerp(from,to,p));draw({pixelate:px});p<1?requestAnimationFrame(a):done&&done();}requestAnimationFrame(a);},
  colorSweepIn({duration, fwd=true}, draw, done) {
    let t0 = performance.now();
    function a(now) {
        let p = clamp((now - t0) / duration);
        colourSweepBrightnessEffects[fwd ? 'sweepBrightFwd' : 'sweepBrightRev'](ctx, canvas, image, p);
        if (p < 1) requestAnimationFrame(a);
        else done && done();
    }
    requestAnimationFrame(a);
  },
  scanlines({active=1,opacity=.2,speed=1},draw){draw();if(!active)return;ctx.save();ctx.globalAlpha=opacity;let t=performance.now()*.001*speed;for(let y=0;y<canvas.height;y+=4){ctx.fillStyle=y%8<4?"#000":"#fff1";ctx.fillRect(0,y+Math.sin(t+y/60)*2,canvas.width,2);}ctx.restore();},
  grain({active=1,intensity=.1},draw){draw();if(!active)return;ctx.save();ctx.globalAlpha=clamp(intensity,0,1);ctx.drawImage(grainNoiseCanvas,0,0,canvas.width,canvas.height);ctx.restore();},
  blur({active=1,value=3},draw){if(active){ctx.save();ctx.filter=`blur(${value}px)`;draw();ctx.filter="none";ctx.restore();}else draw();},
  vignette({active=1,strength=.3,color="#000"},draw){draw();if(!active)return;let g=ctx.createRadialGradient(canvas.width/2,canvas.height/2,canvas.width*.45,canvas.width/2,canvas.height/2,canvas.width/2);g.addColorStop(0,"rgba(0,0,0,0)");g.addColorStop(1,hexToRGBA(color,clamp(strength)));ctx.save();ctx.globalAlpha=strength;ctx.fillStyle=g;ctx.fillRect(0,0,canvas.width,canvas.height);ctx.restore();}
};
function hexToRGBA(hex,a=1){let r=0,g=0,b=0;if(hex.length===4){r=parseInt(hex[1]+hex[1],16);g=parseInt(hex[2]+hex[2],16);b=parseInt(hex[3]+hex[3],16);}else if(hex.length===7){r=parseInt(hex[1]+hex[2],16);g=parseInt(hex[3]+hex[4],16);b=parseInt(hex[5]+hex[6],16);}return `rgba(${r},${g},${b},${a})`;}
// --- Brightness Threshold Sweep Logic --- (omitted for brevity, same as your code)

const colourSweepBrightnessEffects = (() => { /* ... (unchanged) ... */ 
  const _state = new WeakMap();
  function _init(cv, img) {
    const { width: w, height: h } = cv;
    const off = document.createElement('canvas').getContext('2d');
    off.canvas.width = w; off.canvas.height = h;
    off.drawImage(img, 0, 0, w, h);
    let src;
    try { src = off.getImageData(0, 0, w, h); }
    catch { return { src: null }; }
    const N = w * h, bright = new Float32Array(N), d = src.data;
    for (let i = 0; i < N; i++) {
      const p = i << 2;
      bright[i] = Math.min((d[p] + d[p + 1] + d[p + 2]) / 3 + Math.random(), 255);
    }
    return { src, bright, out: new ImageData(new Uint8ClampedArray(d.length), w, h), lastP: -1 };
  }
  function _get(cv, img) {
    let s = _state.get(cv);
    if (!s || s.img !== img) { s = { img, ..._init(cv, img) }; _state.set(cv, s); }
    return s;
  }
  function _draw(ctx, cv, img, p, fwd) {
    const s = _get(cv, img); if (!s.src) { ctx.clearRect(0, 0, cv.width, cv.height); ctx.fillStyle = '#555'; ctx.fillRect(0, 0, cv.width, cv.height); return; }
    if (p === s.lastP) return; s.lastP = p;
    const thr = (fwd ? p : 1 - p) * 255, { src, bright, out } = s, S = src.data, O = out.data;
    for (let i = 0; i < bright.length; i++) {
      const q = i << 2;
      if (bright[i] <= thr) { O[q] = S[q]; O[q+1] = S[q+1]; O[q+2] = S[q+2]; O[q+3] = S[q+3]; }
      else O[q+3] = 0;
    }
    ctx.putImageData(out, 0, 0);
  }
  return {
    sweepBrightFwd: (ctx, cv, img, p) => _draw(ctx, cv, img, p, true),
    sweepBrightRev: (ctx, cv, img, p) => _draw(ctx, cv, img, p, false)
  };
})();

// --- Draw pipeline and overlay functions unchanged (drawBase, drawTextOverlay, etc.) ---

// --- (Effect Test, DrawScreen, UI, etc. unchanged) ---

// ========== Bar-synced "auto mode" ========== //
let barFXMode = false, fxStartTime = null;
const SEED = "example-seed", rng = makeRNG(hashSeed(SEED));
const grainConfig = createGrainConfig(rng, EFFECT_WEIGHTS.grain);
const scanlineConfig = createScanlineConfig(rng, EFFECT_WEIGHTS.scanline);
const vignetteConfig = createVignetteConfig(rng, EFFECT_WEIGHTS.vignette);

function runBarSyncedFX(){
  if(!imageLoaded)return;
  barFXMode=true; fxStartTime=performance.now();
  function loop(){
    if(!barFXMode)return;
    let t=performance.now()-fxStartTime, bars=t/BAR_MS, bar=Math.floor(bars)+1, seconds=t/1000;
    // Lookup steps
    const grainStep = grainConfig.enabled ? findStepAtTime(grainConfig.steps, t) : {enabled:false};
    const scanlineStep = scanlineConfig.enabled ? findStepAtTime(scanlineConfig.steps, t) : {enabled:false};
    const vignetteStep = vignetteConfig.enabled ? findStepAtTime(vignetteConfig.steps, t) : {enabled:false};
    // Compose pipeline (call each effect with dynamic params)
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBase();
    Effects.grain({active:grainStep.enabled?1:0,intensity:grainStep.opacity||.15},()=>{});
    Effects.scanlines({active:scanlineStep.enabled?1:0,opacity:scanlineStep.opacity||.18,speed:scanlineStep.speed||2},()=>{});
    Effects.vignette({active:vignetteStep.enabled?1:0,strength:vignetteStep.strength||.35,color:vignetteStep.color||"#000"},()=>{});
    // (blur/others as needed)
    requestAnimationFrame(loop);
  }
  loop();
}

function drawBase(params={}) {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(!image) return;
  let pixelate = params.pixelate || 1;
  let size = pixelate > 1 ? Math.ceil(canvas.width / pixelate) : canvas.width;
  ctx.imageSmoothingEnabled = pixelate === 1;
  if(pixelate > 1) {
    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, size, size);
    ctx.drawImage(canvas, 0, 0, size, size, 0, 0, canvas.width, canvas.height);
  } else {
    ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
  }
}

function drawTextOverlay(txt, font, color) {
  if (!showText || !txt) return;
  ctx.save();
  ctx.globalAlpha = textAlpha;
  ctx.font = font;
  ctx.fillStyle = color;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.setTransform(textScale, 0, 0, textScale, canvas.width / 2, canvas.height / 2);
  ctx.fillText(txt, 0, 0);
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.restore();
}

// --- Effect Auto-Test Config ---
const EFFECT_TESTS=[
  {name:'fadeIn',params:[{param:'opacity',min:0,max:1,apply:(v,draw)=>{ctx.save();ctx.globalAlpha=v;draw();ctx.restore();}}]},
  {name:'pixelate',params:[{param:'pixelate',min:1,max:512,apply:(v,draw)=>draw({pixelate:Math.round(v)})}]},
    {name:'colorSweep',params:[
    {param:'colorSweep',min:0,max:1,apply:(v,draw,ex)=>colourSweepBrightnessEffects.sweepBrightFwd(ctx, canvas, image, v)},
    {param:'colorSweepRev',min:0,max:1,apply:(v,draw,ex)=>colourSweepBrightnessEffects.sweepBrightRev(ctx, canvas, image, v)}
    ]},
  {name:'scanlines',params:[
    {param:'opacity',min:0,max:.5,apply:(v,draw)=>{draw();Effects.scanlines({active:1,opacity:v,speed:2},()=>{});}},
    {param:'speed',min:.5,max:100,apply:(v,draw)=>{draw();Effects.scanlines({active:1,opacity:.18,speed:v},()=>{});}}
  ]},
  {name:'grain',params:[{param:'intensity',min:0,max:5,apply:(v,draw)=>Effects.grain({active:1,intensity:v},draw)}]},
  {name:'blur',params:[{param:'value',min:0,max:12,apply:(v,draw)=>Effects.blur({active:1,value:v},draw)}]},
  {name:'vignette',params:[
    {param:'strength',min:0,max:5,apply:(v,draw,ex)=>Effects.vignette({active:1,strength:v,color:COLORS[ex.colorIndex%COLORS.length]},draw)},
    {param:'colorIndex',min:0,max:COLORS.length-1,apply:(v,draw)=>Effects.vignette({active:1,strength:.5,color:COLORS[Math.round(v)%COLORS.length]},draw)}
  ]}
];

// --- Auto-Test Logic ---
async function runEffectAutoTest() {
  if (!image) return; testRunning=1; testStop=0; let effectIdx=0;
  while(testMode&&!testStop){let eff=EFFECT_TESTS[effectIdx];
    for(let paramIdx=0;paramIdx<eff.params.length;paramIdx++){
      let {param,min,max,apply}=eff.params[paramIdx],hold=1500,anim=4000;
      console.log(`\n--- Testing ${eff.name} param: ${param} ---`);
      await new Promise(res=>{
        let start=performance.now(),dir=1;
        function step(now){
          if(!testMode||testStop)return res();
          let el=now-start,t=el/(anim/2);
          let ex = {};
          if (param === 'colorIndex') ex.colorIndex = Math.round(dir===1?lerp(min,max,t):lerp(max,min,t));
          if(t>1){if(dir===1){dir=-1;start=now;requestAnimationFrame(step);return;}
            let mid=lerp(min,max,.5);
            apply(mid, drawBase, ex);drawInfoOverlay(eff.name,param,mid);setTimeout(res,hold);return;}
          let value=dir===1?lerp(min,max,t):lerp(max,min,t);
          apply(value, drawBase, ex);drawInfoOverlay(eff.name,param,value);
          if(showText)drawTextOverlay(FX_CONFIG.startText.text,FX_CONFIG.startText.font,FX_CONFIG.startText.color);
          requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
      });
    }
    effectIdx=(effectIdx+1)%EFFECT_TESTS.length;
  }
  testRunning=testStop=0;if(!testMode)drawScreen();
}

// // --- Draw pipeline ---
// function drawScreen(params={}) {
//   ctx.clearRect(0,0,canvas.width,canvas.height); drawBase(params);
//   for(const [n,fxcfg] of FX_CONFIG.sequence.filter(e=>e[1]?.active||0))if(['scanlines','grain','blur','vignette'].includes(n))Effects[n](fxcfg,()=>{});
//   if(showText)drawTextOverlay(FX_CONFIG.startText.text,FX_CONFIG.startText.font,FX_CONFIG.startText.color);
// }

// --- UI & Startup ---
const testBtn=document.getElementById('test-btn');
(async function start(){
  drawScreen();
  canvas.addEventListener('click',async function(){
    if(!imageLoaded)return;
    if(normalEffectsRunning){stopNormalEffects&&stopNormalEffects();stopNormalEffects=0;normalEffectsRunning=0;testBtn.style.display='';drawScreen();console.log('Normal effects stopped.');}
    else{
      if(testMode)testMode=testStop=testRunning=0;
      if(!image){image=await loadImage(window.images[0]);imageLoaded=1;await sleep(200);showText=0;await hideTextOverlay(FX_CONFIG.startText);}
      stopNormalEffects=runEffects(FX_CONFIG.sequence);normalEffectsRunning=1;testBtn.style.display='';console.log('Normal effects started.');
    }
  });
  testBtn.style.display='none';
  image=await loadImage(window.images[0]);imageLoaded=1;await sleep(200);drawScreen();
})();
testBtn.onclick=()=>{
  if(!imageLoaded)return;
  if(testMode){testMode=testStop=testRunning=0;testBtn.style.display='';drawScreen();console.log('Effect auto-test stopped.');}
  else{stopNormalEffects&&stopNormalEffects();stopNormalEffects=0;normalEffectsRunning=0;testMode=1;testStop=0;testBtn.style.display='';runEffectAutoTest();console.log('Effect auto-test started.');}
};
window.addEventListener('keydown',e=>{if(e.key.toLowerCase()==='t'){if(!imageLoaded)return;testBtn.click();}});


function drawScreen(params={}) {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBase(params);
  for(const [n,fxcfg] of FX_CONFIG.sequence.filter(e=>e[1]?.active||0))
    if(['scanlines','grain','blur','vignette'].includes(n))
      Effects[n](fxcfg,()=>{});
  if(showText)
    drawTextOverlay(FX_CONFIG.startText.text,FX_CONFIG.startText.font,FX_CONFIG.startText.color);
}

// --- Draw overlays and info ---
function drawTextOverlay(txt,font,color){if(!showText||!txt)return;ctx.save();ctx.globalAlpha=textAlpha;ctx.font=font;ctx.fillStyle=color;ctx.textAlign="center";ctx.textBaseline="middle";ctx.setTransform(textScale,0,0,textScale,canvas.width/2,canvas.height/2);ctx.fillText(txt,0,0);ctx.setTransform(1,0,0,1,0,0);ctx.restore();}
async function hideTextOverlay(cfg){
  let {fadeDuration,shrinkDuration}=cfg,t0=performance.now(),t1=t0+fadeDuration;
  function stepFade(now){textAlpha=clamp(1-(now-t0)/fadeDuration);textScale=1;drawScreen();textAlpha>0?requestAnimationFrame(stepFade):stepShrink(performance.now());}
  function stepShrink(now){textAlpha=0;textScale=clamp(1-(now-t1)/shrinkDuration,0,1);drawScreen();textScale>0?requestAnimationFrame(stepShrink):(showText=0,drawScreen());}
  requestAnimationFrame(stepFade);
}
function drawInfoOverlay(effect,param,value){
  ctx.save();ctx.globalAlpha=.9;ctx.font=`bold ${Math.max(canvas.height/26,18)}px monospace`;
  ctx.fillStyle="#fff";ctx.textAlign="left";ctx.textBaseline="top";ctx.shadowColor="#000";ctx.shadowBlur=6;
  ctx.fillText(`${effect} (${param}): ${typeof value=="number"?value.toFixed(3):value}`,20,20);ctx.restore();
}



// --- UI & Startup, toggle between normal and bar-synced FX
// const testBtn=document.getElementById('test-btn');
(async function start(){
  drawScreen();
  canvas.addEventListener('click',async function(){
    if(!imageLoaded)return;
    if(barFXMode){barFXMode=0;testBtn.style.display='';drawScreen();console.log('Bar FX stopped.');}
    else if(normalEffectsRunning){stopNormalEffects&&stopNormalEffects();stopNormalEffects=0;normalEffectsRunning=0;testBtn.style.display='';drawScreen();console.log('Normal effects stopped.');}
    else{
      if(testMode)testMode=testStop=testRunning=0;
      if(!image){image=await loadImage(window.images[0]);imageLoaded=1;await sleep(200);showText=0;await hideTextOverlay(FX_CONFIG.startText);}
      runBarSyncedFX();
      testBtn.style.display='';console.log('Bar FX started.');
    }
  });
  testBtn.style.display='none';
  image=await loadImage(window.images[0]);imageLoaded=1;await sleep(200);drawScreen();
})();
testBtn.onclick=()=>{
  if(!imageLoaded)return;
  if(testMode){testMode=testStop=testRunning=0;testBtn.style.display='';drawScreen();console.log('Effect auto-test stopped.');}
  else{stopNormalEffects&&stopNormalEffects();stopNormalEffects=0;normalEffectsRunning=0;testMode=1;testStop=0;testBtn.style.display='';runEffectAutoTest();console.log('Effect auto-test started.');}
};
window.addEventListener('keydown',e=>{if(e.key.toLowerCase()==='t'){if(!imageLoaded)return;testBtn.click();}});
function runEffects(seq){let idx=0,stop=0;function next(){if(stop)return;if(idx>=seq.length)idx=0;let[n,params]=seq[idx++];if(typeof Effects[n]=="function")Effects[n](params,drawBase,next);else next();}next();return()=>{stop=1;};}

</script>
</body>
</html>
