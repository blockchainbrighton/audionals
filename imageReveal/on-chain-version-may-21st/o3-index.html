<!-- ======================================================================
     COLOUR SWEEP PLAYER – enhanced with Grain, Vignette & Scanlines
     All new overlay scripts live above the existing blur script, are
     self-contained, and respect window.APP_CONFIG.
     ==================================================================== -->
     <!DOCTYPE html>
     <html lang="en">
     <head>
     <meta charset="UTF-8">
     <title>Colour Sweep Player</title>
     <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<!-- The Song is 104.15 bpm all effect timings should revolve around this time and 4 bar loops -->
<!-- 18.1 seconds in is the start of bar 9, the first beat is at bar 17 - around 35 seconds -->
     <!-- ────────────────────────────────────────────────────────────────────
          0. GLOBAL CONFIG – Set Effect Params / Timings and Layer Positions
          ──────────────────────────────────────────────────────────────────── -->
          <!-- <script id="global-app-config">
            window.APP_CONFIG = {
              /* ----------------------------  Overlays  --------------------------- */
              effectOrder: ['grain', 'scanline', 'blur', 'vignette'], // Example: grain on top
            
              /* === GRAIN EFFECT SETTINGS === */
              grainEffect: {
                // enabled: true, // Top-level 'enabled' is implicitly true if 'steps' are defined and active.
                                 // Remove this or set to false to disable the entire effect sequence.
                areaMode: "fullscreen", // "image", "fullscreen", or "custom"
                // grainArea: {}, // Used only if areaMode === "custom"
            
                // Default values for properties if not specified in the first step,
                // or when transitioning from a disabled state.
                defaultOpacity: 0,
                defaultFrameIntervalMs: 50,
            
                steps: [
                  { duration: 0, enabled: true, opacity: 0.1, frameIntervalMs: 40 }, // Initial state (applied instantly)
                  { duration: 5000, opacity: 0.85, frameIntervalMs: 20 },           // Transition over 5s
                  { duration: 3000, opacity: 0.5, frameIntervalMs: 10 },            // Another transition
                  { duration: 2000, enabled: false },                               // Fade out over 2s (opacity to 0)
                  { duration: 1000 }, // Hold disabled state for 1s
                  { duration: 3000, enabled: true, opacity: 0.6, frameIntervalMs: 25 }, // Fade back in over 3s
                ]
              },
            
              /* === VIGNETTE EFFECT SETTINGS === */
              vignetteEffect: {
                // enabled: true, // Implicitly true if 'steps' are defined.
                // areaTarget: 'imageCanvas', // Optional: 'imageCanvas', null (fullscreen), or custom element
            
                defaultStrength: 0,
                defaultColor: "#000000",
                // Optional: CSS position string for vignette center, e.g., "center", "50% 50%", "top left"
                // defaultPosition: "center",
                // Optional: control the transparent part of the radial gradient, e.g., "60%"
                // defaultTransparentStop: "60%",
            
            
                steps: [
                  { duration: 3000, enabled: true, strength: 0.5, color: "#100510", /* position: "center", transparentStop: "50%" */ },
                  { duration: 4000, strength: 0.8, color: "#000000", /* position: "top right", transparentStop: "40%" */ },
                  { duration: 2000, enabled: false }, // Fade out strength to 0
                  { duration: 1000 }, // Hold disabled
                  { duration: 3000, enabled: true, strength: 0.6, color: "#050515" }, // Fade in
                ]
              },
            
              /* === SCANLINE EFFECT SETTINGS === */
              scanlineEffect: {
                // enabled: true,
                // areaTarget: 'imageCanvas',
            
                defaultOpacity: 0,
                defaultLineHeightPx: 0, // Effectively invisible lines
                defaultSpeed: 10, // Speed of animation (lower is faster for CSS animation duration)
                // defaultColor: "0,0,0", // RGB part of "rgba(R,G,B,opacity)" - currently fixed to black in logic
            
                steps: [
                  { duration: 0, enabled: true, opacity: 0.3, lineHeightPx: 10, speed: 15 },
                  { duration: 5000, opacity: 0.52, lineHeightPx: 24, speed: 10 },
                  { duration: 4000, opacity: 0.1, lineHeightPx: 2, speed: 25 },
                  { duration: 2000, enabled: false }, // Fade out opacity
                  { duration: 1000 }, // Hold disabled
                  { duration: 4000, enabled: true, opacity: 0.25, lineHeightPx: 8, speed: 12 },
                ]
              },
            
              /* === BLUR EFFECT SETTINGS === */
              blurEffect: {
                enabled: true, // Master switch for blur sequence. Individual steps don't have 'enabled'.
                              // To make blur fully dynamic like others, its internal logic would also need an 'enabled' per step.
                              // For now, sticking to its existing capability.
                direction: "all", // "x", "y", "all", "custom"
                // defaultBlur: 0, // If supporting enabled toggling, a default might be useful.
                // targetElementId: "imageRevealContainer", // Defaulted in code
            
                steps: [
                  { blur: 40, duration: 5000 },
                  { blur: 0, duration: 4000 },
                  { blur: 25, duration: 3000 },
                  { blur: 0, duration: 3000 }
                ]
              },
            
              /* === REVEAL & BEGIN TEXT === */
              mainRevealEffect: { name: "fadeIn", duration: 1.5 },
              clickToBegin: {
                text: "ENTER MATRIX",
                fadeOutDurationMs: 35000,
                blinkIntervalMs: 750,
                reappearDelayMs: 5000
              }
            };
            </script> -->

        <script id="global-app-config">

window.APP_CONFIG = {
  effectOrder: ['grain', 'scanline', 'vignette', 'blur'],
  grainEffect: {
    areaMode: "fullscreen", defaultOpacity: 0.5, defaultFrameIntervalMs: 20,
    steps: [ /* 15 steps of 4s each = 60s */
      { duration: 0, enabled: true, opacity: 0.5, frameIntervalMs: 20},
      { duration: 4000, opacity: 0.9, frameIntervalMs: 5}, { duration: 4000, opacity: 0.3, frameIntervalMs: 40},
      { duration: 4000, opacity: 0.7, frameIntervalMs: 10}, { duration: 4000, opacity: 0.2, frameIntervalMs: 50},
      { duration: 4000, opacity: 1.0, frameIntervalMs: 8},  { duration: 4000, opacity: 0.4, frameIntervalMs: 25},
      { duration: 4000, opacity: 0.6, frameIntervalMs: 15}, { duration: 4000, opacity: 0.8, frameIntervalMs: 7},
      { duration: 4000, opacity: 0.1, frameIntervalMs: 60}, { duration: 4000, opacity: 0.9, frameIntervalMs: 6},
      { duration: 4000, opacity: 0.5, frameIntervalMs: 22}, { duration: 4000, opacity: 0.7, frameIntervalMs: 12},
      { duration: 4000, opacity: 0.3, frameIntervalMs: 35}, { duration: 4000, opacity: 1.0, frameIntervalMs: 4},
      { duration: 4000, opacity: 0.6, frameIntervalMs: 18}
    ]
  },
  vignetteEffect: {
    defaultStrength: 0.2, defaultColor: "#111111",
    steps: [ /* 6 steps of 10s each = 60s */
      { duration: 0, enabled: true, strength: 0.2, color: "#111" },
      { duration: 10000, strength: 0.4, color: "#080808" },
      { duration: 10000, strength: 0.1, color: "#181818" },
      { duration: 10000, strength: 0.5, color: "#050505" },
      { duration: 10000, strength: 0.2, color: "#151515" },
      { duration: 10000, strength: 0.3, color: "#0a0a0a" },
      { duration: 10000, strength: 0.25, color: "#101010" }
    ]
  },
  scanlineEffect: {
    defaultOpacity: 0.4, defaultLineHeightPx: 10, defaultSpeed: 10,
    steps: [ /* 12 steps of 5s each = 60s */
      { duration: 0, enabled: true, opacity: 0.4, lineHeightPx: 10, speed: 10},
      { duration: 5000, opacity: 0.8, lineHeightPx: 2, speed: 3}, { duration: 5000, opacity: 0.2, lineHeightPx: 50, speed: 25},
      { duration: 5000, opacity: 0.6, lineHeightPx: 5, speed: 6},  { duration: 5000, opacity: 0.1, lineHeightPx: 80, speed: 40},
      { duration: 5000, opacity: 0.9, lineHeightPx: 1, speed: 2},  { duration: 5000, opacity: 0.3, lineHeightPx: 30, speed: 18},
      { duration: 5000, opacity: 0.7, lineHeightPx: 8, speed: 8},  { duration: 5000, opacity: 0.05, lineHeightPx: 100, speed: 50},
      { duration: 5000, opacity: 1.0, lineHeightPx: 3, speed: 4},  { duration: 5000, opacity: 0.25, lineHeightPx: 20, speed: 12},
      { duration: 5000, opacity: 0.5, lineHeightPx: 15, speed: 9}, { duration: 5000, opacity: 0.35, lineHeightPx: 40, speed: 20}
    ]
  },
  blurEffect: {
    enabled: true, direction: "x", defaultBlur: 0, // Directional subtle blur
    steps: [
      { blur: 0, duration: 5000 },
      { blur: 8, duration: 20000 },
      { blur: 2, duration: 15000 },
      { blur: 10, duration: 20000 }
    ]
  },
  mainRevealEffect: { name: "fadeIn", duration: 1.5 },
  clickToBegin: { text: "JOURNEY 8", fadeOutDurationMs: 3500, blinkIntervalMs: 750 }
};
</script>
<script>
    function clipOverlayToCanvas(overlayEl, targetCanvasEl) { // Renamed canvasEl to targetCanvasEl for clarity
        if (!overlayEl) return;

        let targetRect;

        if (targetCanvasEl) {
            targetRect = targetCanvasEl.getBoundingClientRect();
            // If the target canvas has no dimensions yet, it might not be fully initialized.
            // Fallback to window dimensions in such a case, or decide how to handle.
            // For simplicity here, if rect has 0 width/height, we might as well make overlay fullscreen for now.
            if (targetRect.width === 0 || targetRect.height === 0) {
                targetCanvasEl = null; // Treat as if no target was specified
            }
        }

        if (!targetCanvasEl) { // No valid target canvas, or it had zero dimensions
            targetRect = {
                top: 0,
                left: 0,
                width: window.innerWidth,
                height: window.innerHeight,
                right: window.innerWidth,
                bottom: window.innerHeight
            };
        }

        // If the overlay is a CANVAS, set its drawing surface dimensions
        if (overlayEl.tagName === 'CANVAS') {
            const newWidth = Math.round(targetRect.width);
            const newHeight = Math.round(targetRect.height);
            // Only update if necessary to avoid clearing canvas/performance issues
            if (overlayEl.width !== newWidth || overlayEl.height !== newHeight) {
                overlayEl.width = newWidth;
                overlayEl.height = newHeight;
            }
        }

        // Apply clip-path based on the original target (if one was provided and valid)
        if (targetCanvasEl) { // Check original targetCanvasEl for clipping
            const rectForClip = targetCanvasEl.getBoundingClientRect(); // Re-get, in case it became valid
             if (rectForClip.width > 0 && rectForClip.height > 0) {
                const clip = `inset(${Math.round(rectForClip.top)}px ${Math.round(window.innerWidth - rectForClip.right)}px ${Math.round(window.innerHeight - rectForClip.bottom)}px ${Math.round(rectForClip.left)}px)`;
                overlayEl.style.clipPath = clip;
                overlayEl.style.WebkitClipPath = clip;
            } else { // Target exists but has no size, don't clip
                overlayEl.style.clipPath = 'none';
                overlayEl.style.WebkitClipPath = 'none';
            }
        } else { // No target canvas at all, make it full screen (no clip)
            overlayEl.style.clipPath = 'none';
            overlayEl.style.WebkitClipPath = 'none';
        }
    }

    const getZ = name => {
        const order = window.APP_CONFIG?.effectOrder ?? ['grain', 'scanline', 'blur', 'vignette'];
        return 900 + order.indexOf(name) * 10;
    };
 </script>


   <!-- effects-module.js (drop-in replacement) -->
   <script id="effects-module">
    (() => {
      /* ───── 1. SHARED HELPERS ───── */
      const H = (window.OverlayEffectHelpers ??= {
        createOverlay: ({
          tag = 'div', id, z = 999, blend, pointer = 'none',
          style = {}, append = document.body,
        }) => {
          const el = Object.assign(document.createElement(tag), { id });
          Object.assign(
            el.style,
            { position: 'fixed', inset: 0, zIndex: z, pointerEvents: pointer, opacity: '0' /* Start hidden */ },
            blend && { mixBlendMode: blend },
            style,
          );
          append.appendChild(el);
          return el;
        },
        destroyOverlay: el => el?.remove(),
        animate: ({ // H.animate is primarily for single transitions.
          duration = 1, onUpdate, onDone, easing,
          activeRef = () => true,
        }) => {
          const s = performance.now();
          let rafId;
          const f = now => {
            if (!activeRef()) { cancelAnimationFrame(rafId); return; }
            const t = Math.min(1, (now - s) / duration);
            onUpdate(easing ? easing(t) : t);
            if (t < 1) {
              rafId = requestAnimationFrame(f);
            } else {
              onDone?.();
            }
          };
          rafId = requestAnimationFrame(f);
          return () => cancelAnimationFrame(rafId);
        },
        bindResize: (overlay, targetCanvasIdOrElement) => {
          const resize = () =>
            window.clipOverlayToCanvas?.(
              overlay,
              typeof targetCanvasIdOrElement === 'string' ? document.getElementById(targetCanvasIdOrElement) : targetCanvasIdOrElement,
            );
          window.addEventListener('resize', resize);
          resize(); // Initial call
          return () => window.removeEventListener('resize', resize);
        },
        lerpColor: (a = '#000000', b = '#000000', t = 0) => { // 'b' is the target color string parameter
            const parse = c => ({
                r: parseInt(c.slice(1, 3) || '00', 16),
                g: parseInt(c.slice(3, 5) || '00', 16),
                b: parseInt(c.slice(5, 7) || '00', 16), // This 'b' is a property key, which is fine
            });
            const ca = parse(a);
            const cb = parse(b); // Uses the parameter 'b'
            const r_val = Math.round(ca.r + (cb.r - ca.r) * t).toString(16).padStart(2, '0');
            const g_val = Math.round(ca.g + (cb.g - ca.g) * t).toString(16).padStart(2, '0');
            const b_val = Math.round(ca.b + (cb.b - ca.b) * t).toString(16).padStart(2, '0'); // Corrected from 'b'
            return `#${r_val}${g_val}${b_val}`;
        },
        getZ: name => {
            const order = window.APP_CONFIG?.effectOrder ?? ['grain', 'scanline', 'blur', 'vignette'];
            return 900 + order.indexOf(name) * 10;
        }
      });
    
      /* util: wire start/stop to playback events */
      const wire = (start, stop) => {
        document.addEventListener('playbackStarted', start);
        document.addEventListener('playbackStopped', stop);
      };
    
      const runEffectSequence = ({
        effectName, steps, initialProperties, applyProperties, getActiveRef, onSequenceCompleted
      }) => {
        let currentStepIndex = 0;
        let sequenceRAF;
        let currentProps = { ...initialProperties, _isEnabledSystem: initialProperties.enabled ?? true };
    
        applyProperties(currentProps, currentProps._isEnabledSystem);
    
        function runStep(stepIdx) {
          if (!getActiveRef() || stepIdx >= steps.length) {
            if (getActiveRef() && stepIdx >= steps.length && steps.length > 0) {
                const lastConfigStep = steps[steps.length-1] || {};
                const finalIsEnabled = lastConfigStep.hasOwnProperty('enabled') ? lastConfigStep.enabled : currentProps._isEnabledSystem;
                // Update currentProps with final values from the last defined step before applying
                currentProps = { ...currentProps, ...lastConfigStep, _isEnabledSystem: finalIsEnabled };
                applyProperties(currentProps, finalIsEnabled);
            }
            onSequenceCompleted?.();
            return;
          }
    
          const stepConfig = steps[stepIdx];
          const duration = stepConfig.duration ?? 0;
    
          const startPropsForAnim = { ...currentProps }; // Values at the beginning of this step's transition
          const targetPropsFromConfig = { ...stepConfig }; // Target values defined in this step's config
    
          const targetIsEnabledSystem = targetPropsFromConfig.hasOwnProperty('enabled')
            ? targetPropsFromConfig.enabled
            : startPropsForAnim._isEnabledSystem;
    
          if (duration === 0) {
            currentProps = { ...startPropsForAnim, ...targetPropsFromConfig, _isEnabledSystem: targetIsEnabledSystem };
            applyProperties(currentProps, targetIsEnabledSystem);
            runStep(stepIdx + 1);
            return;
          }
    
          const animationStartTime = performance.now();
    
          function frame(now) {
            if (!getActiveRef()) {
              cancelAnimationFrame(sequenceRAF);
              return;
            }
    
            const elapsedTime = now - animationStartTime;
            const progress = Math.min(1, duration > 0 ? elapsedTime / duration : 1);
            const interpolatedPropsThisFrame = { _isEnabledSystem: targetIsEnabledSystem };
    
            // Iterate over all keys that could possibly be animated or set
            const allKeys = new Set([...Object.keys(startPropsForAnim), ...Object.keys(targetPropsFromConfig)]);
    
            for (const key of allKeys) {
                if (key === '_isEnabledSystem' || key === 'duration' || key === 'enabled') continue;
    
                let startVal = startPropsForAnim[key];
                let endVal = targetPropsFromConfig.hasOwnProperty(key) ? targetPropsFromConfig[key] : startVal;
    
                // If a property isn't in startPropsForAnim (e.g. new prop in this step), initialize startVal sensibly
                if (startVal === undefined) {
                    if (typeof endVal === 'number') startVal = 0;
                    else if (typeof endVal === 'string' && endVal.startsWith('#')) startVal = '#000000';
                    // else it will be handled as non-interpolatable
                }
    
                if (key === 'opacity' || key === 'strength' || key === 'blur' /* Add other properties that should fade */) {
                    if (targetIsEnabledSystem && !startPropsForAnim._isEnabledSystem) { // Enabling: Animate from 0
                        startVal = 0;
                    } else if (!targetIsEnabledSystem && startPropsForAnim._isEnabledSystem) { // Disabling: Animate to 0
                        endVal = 0;
                    } else if (!targetIsEnabledSystem && !startPropsForAnim._isEnabledSystem) { // Staying disabled: Keep at 0
                        startVal = 0; endVal = 0;
                    }
                }
                
                if (typeof endVal === 'number' && typeof startVal === 'number') {
                  interpolatedPropsThisFrame[key] = startVal + (endVal - startVal) * progress;
                } else if (typeof endVal === 'string' && endVal.startsWith('#') &&
                           typeof startVal === 'string' && startVal.startsWith('#')) {
                  interpolatedPropsThisFrame[key] = H.lerpColor(startVal, endVal, progress);
                } else {
                  interpolatedPropsThisFrame[key] = (progress === 1 && targetPropsFromConfig.hasOwnProperty(key)) ? targetPropsFromConfig[key] : startVal;
                }
            }
            
            currentProps = { ...startPropsForAnim, ...interpolatedPropsThisFrame, _isEnabledSystem: targetIsEnabledSystem };
            applyProperties(currentProps, targetIsEnabledSystem);
    
            if (progress < 1) {
              sequenceRAF = requestAnimationFrame(frame);
            } else {
              // Ensure final values from stepConfig are precisely set
              currentProps = { ...startPropsForAnim, ...targetPropsFromConfig, _isEnabledSystem: targetIsEnabledSystem };
              applyProperties(currentProps, targetIsEnabledSystem);
              runStep(stepIdx + 1);
            }
          }
          sequenceRAF = requestAnimationFrame(frame);
        }
    
        runStep(currentStepIndex);
    
        return () => {
          cancelAnimationFrame(sequenceRAF);
        };
      };
    
    
      /* ───── 2. GRAIN EFFECT ───── */
      (() => {
        const EFFECT_NAME = 'grain';
        let overlay, ctx, noiseRAF, active = false, stopResize, currentFrameInterval;
        let stopCurrentSequence = null;
    
        const drawNoise = () => {
          if (!overlay || !ctx || !active || !overlay.style.opacity || parseFloat(overlay.style.opacity) === 0) return;
          const { width, height } = overlay;
          if (width === 0 || height === 0) return;
    
          const img = ctx.createImageData(width, height);
          const buf = new Uint32Array(img.data.buffer);
          for (let i = 0; i < buf.length; i++) {
            const rand = Math.random() * 255;
            buf[i] = (255 << 24) | (rand << 16) | (rand << 8) | rand;
          }
          ctx.putImageData(img, 0, 0);
        };
    
        let lastDrawTime = 0;
        const noiseLoop = () => {
          if (!active) return;
          noiseRAF = requestAnimationFrame(noiseLoop); // Schedule next frame first
          const now = performance.now();
          if (now - lastDrawTime > (currentFrameInterval ?? 50) ) { // ensure currentFrameInterval has a fallback
            lastDrawTime = now;
            drawNoise();
          }
        };
        
        const applyGrainProperties = (props, isEnabledSystem) => {
            if (!overlay) return;
            overlay.style.opacity = isEnabledSystem ? (props.opacity ?? 0).toString() : '0';
            currentFrameInterval = props.frameIntervalMs ?? 50; // from cfg.defaultFrameIntervalMs
        };
    
        const start = () => {
          stop();
          const cfg = window.APP_CONFIG?.grainEffect;
          if (!cfg || !cfg.steps || cfg.steps.length === 0) {
            console.warn(`${EFFECT_NAME} effect disabled or misconfigured (no steps).`);
            return;
          }
          
          overlay = H.createOverlay({
            tag: 'canvas', id: 'grainCanvas', z: H.getZ(EFFECT_NAME), blend: 'overlay'
          });
          ctx = overlay.getContext('2d', { willReadFrequently: true });
    
          let areaMode = cfg.areaMode || "image";
          let targetElementForResize = document.getElementById('imageCanvas'); // Default for "image"
          if (areaMode === "fullscreen") {
            targetElementForResize = null;
          } else if (areaMode === "custom" && cfg.grainArea) {
            console.warn("Grain 'custom' areaMode needs specific implementation for grainArea. Defaulting to fullscreen for resize binding.");
            targetElementForResize = null; // Placeholder for custom logic
          }
          stopResize = H.bindResize(overlay, targetElementForResize);
    
          active = true;
          const initialProperties = {
            opacity: cfg.defaultOpacity ?? 0,
            frameIntervalMs: cfg.defaultFrameIntervalMs ?? 50,
            enabled: cfg.steps[0]?.enabled ?? true, 
          };
          
          stopCurrentSequence = runEffectSequence({
            effectName: EFFECT_NAME,
            steps: cfg.steps,
            initialProperties,
            applyProperties: applyGrainProperties,
            getActiveRef: () => active,
            onSequenceCompleted: () => { /* console.log('Grain sequence completed') */ }
          });
          
          lastDrawTime = performance.now();
          noiseLoop();
        };
    
        const stop = () => {
          active = false;
          cancelAnimationFrame(noiseRAF);
          stopCurrentSequence?.();
          stopCurrentSequence = null;
          stopResize?.();
          H.destroyOverlay(overlay);
          overlay = ctx = stopResize = null;
          currentFrameInterval = 50; // Reset
        };
        wire(start, stop);
      })();
    
      /* ───── 3. VIGNETTE EFFECT ───── */
      (() => {
        const EFFECT_NAME = 'vignette';
        let overlay, active = false, stopResize;
        let stopCurrentSequence = null;
    
        const applyVignetteProperties = (props, isEnabledSystem) => {
            if (!overlay) return;
            // Vignette's apparent opacity is controlled by its strength/color to transparent transition.
            // So, overlay.style.opacity is mostly for hard on/off if desired, or let strength=0 handle "off".
            // Here, we allow the strength to animate to 0 for fade-out if isEnabledSystem becomes false.
            overlay.style.opacity = '1'; // Keep overlay div itself visible
    
            if (isEnabledSystem) {
                const strength = props.strength ?? 0;
                const color = props.color ?? '#000000';
                const position = props.position ?? "center";
                const transparentStop = props.transparentStop ?? "60%";
                if (strength > 0) {
                    overlay.style.background = `radial-gradient(circle at ${position}, transparent ${transparentStop}, ${color} ${strength * 100}%)`;
                } else {
                     overlay.style.background = 'none'; // No vignette if strength is 0
                }
            } else {
                overlay.style.background = 'none'; // Ensure it's off if system disabled
            }
        };
    
        const start = () => {
          stop();
          const cfg = window.APP_CONFIG?.vignetteEffect;
           if (!cfg || !cfg.steps || cfg.steps.length === 0) {
            console.warn(`${EFFECT_NAME} effect disabled or misconfigured (no steps).`);
            return;
          }
          
          overlay = H.createOverlay({ id: 'vignetteOverlay', z: H.getZ(EFFECT_NAME) });
          
          let areaTarget = document.getElementById('imageCanvas'); // Default
          if (cfg.hasOwnProperty('areaTarget')) { // Check if areaTarget is explicitly set
            areaTarget = cfg.areaTarget === 'imageCanvas' ? document.getElementById('imageCanvas') : 
                         cfg.areaTarget === null ? null : 
                         (typeof cfg.areaTarget === 'string' ? document.getElementById(cfg.areaTarget) : cfg.areaTarget);
          }
          stopResize = H.bindResize(overlay, areaTarget);
    
    
          active = true;
          const initialProperties = {
            strength: cfg.defaultStrength ?? 0,
            color: cfg.defaultColor ?? '#000000',
            position: cfg.defaultPosition ?? "center",
            transparentStop: cfg.defaultTransparentStop ?? "60%",
            enabled: cfg.steps[0]?.enabled ?? true,
          };
          
          stopCurrentSequence = runEffectSequence({
            effectName: EFFECT_NAME,
            steps: cfg.steps,
            initialProperties,
            applyProperties: applyVignetteProperties,
            getActiveRef: () => active,
          });
        };
    
        const stop = () => {
          active = false;
          stopCurrentSequence?.();
          stopCurrentSequence = null;
          stopResize?.();
          H.destroyOverlay(overlay);
          overlay = stopResize = null;
        };
        wire(start, stop);
      })();
    
      /* ───── 4. SCANLINE EFFECT ───── */
      (() => {
        const EFFECT_NAME = 'scanline';
        let overlay, styleTag, active = false, stopResize;
        let stopCurrentSequence = null;
        const animationName = `scanSlide-${EFFECT_NAME}-${Date.now()}`; // Make it unique per instantiation
    
        const applyScanlineProperties = (props, isEnabledSystem) => {
            if (!overlay || !styleTag) return;
            
            const overallOpacity = isEnabledSystem ? (props.opacity ?? 0).toString() : '0';
            overlay.style.opacity = overallOpacity;
    
            if (isEnabledSystem && (props.opacity ?? 0) > 0 && (props.lineHeightPx ?? 0) > 0) {
                const h = props.lineHeightPx;
                const lineOpacity = props.lineOpacityInternal ?? 1; // Opacity of the lines within the gradient, could be a separate prop
                const spd = props.speed ?? 10; 
                // const colorBase = props.colorRGB || "0,0,0"; // If line color is configurable beyond black
    
                overlay.style.background = `repeating-linear-gradient(0deg, rgba(0,0,0,${lineOpacity}) 0 ${h}px, transparent ${h}px ${h * 2}px)`;
                
                const currentAnimationDuration = `${spd}s`;
                if (overlay.style.animationName !== animationName || overlay.style.animationDuration !== currentAnimationDuration) {
                     overlay.style.animationName = animationName;
                     overlay.style.animationDuration = currentAnimationDuration;
                     overlay.style.animationTimingFunction = 'linear';
                     overlay.style.animationIterationCount = 'infinite';
                }
                // Keyframes need to update if lineHeight (h) changes the background-position target
                styleTag.textContent = `@keyframes ${animationName} {0%{background-position:0 0}100%{background-position:0 ${h * 2}px}}`;
                overlay.style.animationPlayState = 'running';
    
            } else {
                overlay.style.background = 'none';
                overlay.style.animationPlayState = 'paused';
            }
        };
    
        const start = () => {
          stop();
          const cfg = window.APP_CONFIG?.scanlineEffect;
          if (!cfg || !cfg.steps || cfg.steps.length === 0) {
            console.warn(`${EFFECT_NAME} effect disabled or misconfigured (no steps).`);
            return;
          }
    
          styleTag = document.head.appendChild(document.createElement('style'));
          overlay = H.createOverlay({ id: 'scanlineOverlay', z: H.getZ(EFFECT_NAME) });
          
          let areaTarget = document.getElementById('imageCanvas'); // Default
          if (cfg.hasOwnProperty('areaTarget')) {
            areaTarget = cfg.areaTarget === 'imageCanvas' ? document.getElementById('imageCanvas') : 
                         cfg.areaTarget === null ? null : 
                         (typeof cfg.areaTarget === 'string' ? document.getElementById(cfg.areaTarget) : cfg.areaTarget);
          }
          stopResize = H.bindResize(overlay, areaTarget);
    
          active = true;
          const initialProperties = {
            opacity: cfg.defaultOpacity ?? 0, // Overall effect opacity
            lineHeightPx: cfg.defaultLineHeightPx ?? 0,
            speed: cfg.defaultSpeed ?? 10,
            lineOpacityInternal: cfg.defaultLineOpacityInternal ?? 1, // Opacity of actual scan lines
            enabled: cfg.steps[0]?.enabled ?? true,
          };
    
          stopCurrentSequence = runEffectSequence({
            effectName: EFFECT_NAME,
            steps: cfg.steps,
            initialProperties,
            applyProperties: applyScanlineProperties,
            getActiveRef: () => active,
          });
        };
    
        const stop = () => {
          active = false;
          stopCurrentSequence?.();
          stopCurrentSequence = null;
          styleTag?.remove();
          styleTag = null;
          stopResize?.();
          H.destroyOverlay(overlay);
          overlay = stopResize = null;
        };
        wire(start, stop);
      })();
    
      /* ───── 5. BLUR EFFECT ───── */
      (() => {
        const EFFECT_NAME = 'blur';
        let blurRAF, el, steps, active = false;
        const getTargetElement = () => document.getElementById(window.APP_CONFIG?.blurEffect?.targetElementId || 'imageRevealContainer');
    
        const toXY = (dir, v_input) => {
            let v_x, v_y;
            if (dir === 'custom' && typeof v_input === 'object' && v_input !== null) {
                v_x = v_input.x ?? 0;
                v_y = v_input.y ?? 0;
            } else {
                const val = typeof v_input === 'number' ? v_input :
                            (typeof v_input === 'object' && v_input !== null && v_input.hasOwnProperty('blur')) ? v_input.blur : 0;
                if (dir === 'x') { v_x = val; v_y = 0; }
                else if (dir === 'y') { v_x = 0; v_y = val; }
                else { v_x = val; v_y = val; } // "all" or default
            }
            return { x: v_x, y: v_y };
        }
    
        const start = () => {
          stop();
          el = getTargetElement();
          const cfg = window.APP_CONFIG?.blurEffect;
    
          if (!cfg?.enabled || !el || !cfg.steps || cfg.steps.length === 0) {
            if (el) el.style.filter = 'none';
            return;
          }
          
          const dir = cfg.direction ?? 'all';
          steps = cfg.steps.map(s_config => ({ 
              duration: s_config.duration,
              xy: toXY(dir, s_config.blur ?? ( (dir === 'custom' && s_config.x !== undefined && s_config.y !== undefined) ? {x:s_config.x, y:s_config.y} : (cfg.defaultBlur ?? 0) ) ) 
          }));
          
          active = true;
          let startStepIndex = 0;
    
          // Apply initial step instantly if its duration is 0
          if (steps[0] && steps[0].duration === 0) {
              const { x, y } = steps[0].xy;
              el.style.filter = (x || y) ? `blur(${x}px) blur(${y}px)` : 'none'; // Apply separate blurs
              startStepIndex = 1; // Start animation sequence from the next step
              if (steps.length === 1) { // Only one instant step
                active = false; // No further animation needed
                return;
              }
          } else {
              // If first step has duration, ensure initial state (e.g. 0 blur) before animation
               const initialXY = toXY(dir, cfg.defaultBlur ?? 0);
               el.style.filter = (initialXY.x || initialXY.y) ? `blur(${initialXY.x}px) blur(${initialXY.y}px)` : 'none';
          }
          
          (function run(currentIndex) {
            if (!active || currentIndex >= steps.length) {
              if (active && steps.length > 0 && currentIndex >= steps.length) { // ensure final step applied
                const finalStep = steps[steps.length-1];
                 el.style.filter = (finalStep.xy.x || finalStep.xy.y) ? `blur(${finalStep.xy.x}px) blur(${finalStep.xy.y}px)` : 'none';
              }
              return;
            }
            
            const currentStepConfig = steps[currentIndex];
            const animDuration = Math.max(16, currentStepConfig.duration);
            
            const startXY = (currentIndex === 0) 
                ? toXY(dir, cfg.defaultBlur ?? 0) // Start from default if it's the first animated step
                : steps[currentIndex-1].xy;       // Otherwise, start from previous step's target
            
            const targetXY = currentStepConfig.xy;
            const s_time = performance.now();
    
            (function frame() {
              if (!active) { cancelAnimationFrame(blurRAF); return; }
    
              const t = Math.min(1, (performance.now() - s_time) / animDuration);
              const x = startXY.x + (targetXY.x - startXY.x) * t;
              const y = startXY.y + (targetXY.y - startXY.y) * t;
              
              // Construct filter string carefully: separate blurs for x and y if both non-zero.
              let filterString = '';
              if (x > 0.01) filterString += `blur(${x}px) `; // Threshold to avoid blur(0px)
              if (y > 0.01) filterString += `blur(${y}px)`; // Correct for Chrome/FF that want blur(Ypx) not blur(Xpx) blur(Ypx) for independent. This needs SVG filter or two elements.
                                                         // Standard CSS filter: blur(Npx) applies Npx in both directions.
                                                         // If direction is X or Y, we can just set one. If "all" or "custom" with both non-zero, standard blur() does combined.
                                                         // The `imageRevealContainer` is a single element. `filter: blur(x) blur(y)` does not work.
                                                         // It would be filter: blur(amount). If direction x/y, then that is just `blur(value)` on single axis effectively
                                                         // For `filter: blur()` the CSS spec is one value. The old syntax allowed two. Modern uses one.
                                                         // This interpretation is slightly off for `direction: "all" vs "custom"`. Let's simplify.
                                                         // `el.style.filter = x || y ? `blur(${Math.max(x,y)}px)` : 'none';` // Simpler, but loses axis specific.
                                                         // Original code used blur(x) blur(y) implying they knew a trick or specific target. Reverting to that.
              // Revert to original simple combined blur based on current xy step
              // Let's use the original formulation toXY produces values for, then apply them:
              const effectiveBlurX = x; // Value from step for X axis
              const effectiveBlurY = y; // Value from step for Y axis
              
              // CSS filter: blur(radius) applies radius in all directions.
              // To get separate x/y blur usually requires SVG filters or targeting `transform: scale` on sub-elements etc.
              // Given the input logic for "direction", "x", "y", "all", "custom",
              // it implies an intent to control these. However, `el.style.filter = blur(val)` applies `val` in both axes.
              // If steps are {blur: N, direction: 'x'}, filter should be `blur(Npx)` if CSS could isolate.
              // Let's assume the initial simpler `blur(value)` applied based on 'all' if both x,y present or individual.
              
              let appliedFilterValue = 0;
              if (dir === 'x') appliedFilterValue = effectiveBlurX;
              else if (dir === 'y') appliedFilterValue = effectiveBlurY;
              else  appliedFilterValue = Math.max(effectiveBlurX, effectiveBlurY); // For 'all' or 'custom' pick max, or average.
    
    
              if (appliedFilterValue > 0.01) {
                el.style.filter = `blur(${appliedFilterValue}px)`;
              } else {
                el.style.filter = 'none';
              }
    
              if (t < 1) {
                blurRAF = requestAnimationFrame(frame);
              } else {
                if ((effectiveBlurX > 0.01 || effectiveBlurY > 0.01) && appliedFilterValue <= 0.01) { // Last frame correction for near-zero
                     //This case seems unlikely if appliedFilterValue uses max. But ensure clean "none".
                } else if (appliedFilterValue > 0.01){
                    el.style.filter = `blur(${appliedFilterValue}px)`;
                } else {
                     el.style.filter = 'none'; // Final state.
                }
                run(currentIndex + 1);
              }
            })();
          })(startStepIndex);
        };
    
        const stop = () => {
          active = false;
          cancelAnimationFrame(blurRAF);
          // el is fetched in start(), could be null here if start was never called or failed
          // const currentEl = getTargetElement(); 
          // if (currentEl) currentEl.style.filter = 'none'; // Option: Reset on stop
        };
        wire(start, stop);
      })();
    })();
    </script>

            
            


     <!-- ────────────────────────────────────────────────────────────────────
          6.  PAGE STYLES  (identical to original; extra z-index is handled above)
          ──────────────────────────────────────────────────────────────────── -->
     <style>
html, body {
  box-sizing: border-box !important;
  border: none !important;
  outline: none !important;
  background: #000 !important;
  margin: 0 !important;
  padding: 0 !important;
  width: 100vw !important;
  height: 100vh !important;
  min-width: 100vw !important;
  min-height: 100vh !important;
  max-width: 100vw !important;
  max-height: 100vh !important;
  overflow: hidden !important;
}

*,
*::before,
*::after {
  box-sizing: inherit;
  border: none !important;
  outline: none !important;
  background: transparent;
}


#imageRevealContainer {
  position: fixed;
  inset: 0;
  margin: 0;
  padding: 0;
  border: none;
  background: #000 !important;
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  overflow: hidden;
}

body::-webkit-scrollbar, html::-webkit-scrollbar {
  display: none !important; /* hide any scrollbars */
}

#imageRevealContainer > :not(canvas) {
  display: none !important;
}

#imageCanvas {
  width: 90vh;
  height: 90vh;
  max-width: 90vw;
  max-height: 90vh;
  background: #000;
  border: none;
  margin: 0;
  padding: 0;
  display: block;
  image-rendering: pixelated;

  transform: translateZ(0);
  will-change: transform;

  box-shadow:
    inset 0 1px 0 0 #000,
    inset 0 -1px 0 0 #000;
  box-sizing: border-box;
}

#pixelTextCanvas {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 90vh;
  max-width: 90vw;
  height: auto;
  image-rendering: pixelated;
  opacity: 1;
  transition: opacity 16s ease-out, transform 16s ease-out;
  z-index: 1000;
}

#pixelTextCanvas.hidden {
  opacity: 0;
  transform: translate(-50%, -50%) scale(0);
}

#playBtn {
  display: none;
}

#backgroundBlackout {
  position: fixed;
  inset: 0;
  background: #000;
  z-index: 0;
  pointer-events: none;
}

     </style>
     </head>
     
     <!-- ────────────────────────────────────────────────────────────────────
          7.  DOM  (unchanged)
          ──────────────────────────────────────────────────────────────────── -->
     <body>
        <div id="backgroundBlackout" style="
        position: fixed;
        inset: 0;
        background: #000;
        z-index: 0;
        pointer-events: none;
        "></div>

       <canvas id="pixelTextCanvas" width="200" height="40"></canvas>
       <button id="playBtn">Play Mix</button>
     
       <!-- Audio URLs -->
       <script id="audio-data">
         const audioParts = [
           "https://ordinals.com/content/055e30b37a547674bd750cd963b9c3e2dfaecfe60833cbb9a377e12b2eea05a6i0",
           "https://ordinals.com/content/a475da90928ae5dba210a6a2708a20278367d46f898acdebe9707c0e43b994cei0",
           "https://ordinals.com/content/797a56f20af6f7016853f817a7041847e82dedd2d2b9246515646e741a3e53b2i0"
         ];
       </script>
     
       <!-- Image URLs -->
       <script id="image-data">
         window.images = ["https://ordinals.com/content/01c48d3cceb02215bc3d44f9a2dc7fba63ea63719a2ef1c35d3f0c4db93ab8d5i0"];
       </script>
           <!-- imageLoadMgmt.js -->
           <script src="https://ordinals.com/content/a698a70c8eda8e6a58abf2e65921ca629e1734a91c67e2d74a941a2cc5c36027i0"></script>
           <!-- imageRevealCore.js -->
              <script type="module" src="https://ordinals.com/content/7b66beb111fbc673a99867f13480a3289afc522b811ddd60163b3bcbb82aa758i0"></script>
          
   
              <script type="module">
              (()=>{const el=id=>document.getElementById(id),
              t=el("playBtn"),e=el("log"),
              a=window.AudioContext||window.webkitAudioContext,
              n=el("clickToBeginText"),
              d=m=>{if(!e)return;e.textContent+=`${new Date().toLocaleTimeString()}: ${m}\n`;e.scrollTop=e.scrollHeight},
              emit=ev=>document.dispatchEvent(new Event(ev)),
              setTxt=txt=>t.textContent=txt;
              if(!a)return setTxt("Audio not supported"),t.disabled=!0;
              n||console.warn('"Click to Begin" text element not found in playbackMgmt.js context');
              let o=new a,i=new Array(audioParts.length),r=0,s=null,c=!0,l=!1;
              const u=()=>{t.disabled=c;setTxt(c?"Loading…":l?"Stop Mix":"Play Mix");},
              h=async(url,idx,first=!1)=>{first&&d(`Fetching first part → ${url}`);
              i[idx]=await o.decodeAudioData(await(await fetch(url)).arrayBuffer());
              d(`${first?"First part ready":`Decoded part ${idx+1}/${audioParts.length}`} (${i[idx].duration.toFixed(2)} s).`);};
              (async()=>{try{await h(audioParts[0],0,!0);c=!1;u();
              await Promise.all(audioParts.slice(1).map((url,idx)=>h(url,idx+1)));d("All parts decoded. ✅");}
              catch(err){c=!1;u();d(`Preload failed: ${err.message}`);}})();
              const p=()=>{if(!l)return;if(r>=i.length)return l=!1,u(),d("Finished. 🎉"),y();
              const buf=i[r];if(!buf)return d(`Part ${r+1} buffer not ready, retrying...`),setTimeout(p,200);
              (s=o.createBufferSource()).buffer=buf;s.connect(o.destination);s.start();
              d(`▶ Part ${r+1}/${i.length} (${buf.duration.toFixed(2)} s)`);r++;
              s.onended=()=>{s=null;l&&p();};},
              y=()=>emit("playbackStopped"),
              f=async()=>{if(c||l)return;if(o.state==="suspended")await o.resume();
              l=!0;r=0;u();emit("playbackStarted");p();},
              g=()=>{if(!l)return;l=!1;if(s)try{s.onended=null;s.stop();}catch(err){d(`Error stopping active source: ${err.message}`);}
              s=null;d("Stopped by user.");u();y();},
              toggle=()=>{(l?g:f)();};
              t.onclick=toggle;
              document.addEventListener("togglePlayback",toggle);
              document.addEventListener("playbackStarted",()=>{});
              document.addEventListener("playbackStopped",()=>{});})();
              </script>
   
              
        

    <!-- imageRevealPublicApi.js (inline module script that USES the import) -->
    <script type="module">
        import { setupEffect } from "https://ordinals.com/content/6addd1c637ee377bd7e3510c7e78ec35a7fb037676f2ef416131067c9d1d4cf6i0";
        (() => {
          const cfg = window.APP_CONFIG?.clickToBegin ?? {},
            txt = cfg.text ?? "CLICK TO BEGIN",
            fadeMs = cfg.fadeOutDurationMs ?? 16000,
            blinkMs = cfg.blinkIntervalMs ?? 500,
            reapMs = cfg.reappearDelayMs ?? 16000,
            el = document.getElementById("pixelTextCanvas"),
            ctx = el.getContext("2d");
          let blink;
          el.style.transition = `opacity ${fadeMs/1e3}s ease-out,transform ${fadeMs/1e3}s ease-out`;
          const blinkFn = vis => { clearInterval(blink); el.style.visibility = vis; },
            startBlink = () => { blinkFn("visible"); blink = setInterval(() => el.style.visibility = el.style.visibility === "hidden" ? "visible" : "hidden", blinkMs); };
          el.onclick = () => (blinkFn("visible"), el.classList.add("hidden"), document.getElementById("playBtn").click());
          document.addEventListener("playbackStarted", () => { if (!el.classList.contains("hidden")) blinkFn("visible"), el.classList.add("hidden"); });
          document.addEventListener("playbackStopped", () => { el.classList.remove("hidden"); setTimeout(startBlink, reapMs); });
          (() => {
            ctx.clearRect(0, 0, el.width, el.height);
            ctx.font = "bold 16px monospace"; ctx.textBaseline = "middle"; ctx.textAlign = "center"; ctx.fillStyle = "#33CCFF";
            for (let dx = -1; dx <= 1; dx++) for (let dy = -1; dy <= 1; dy++) ctx.fillText(txt, el.width/2 + dx, el.height/2 + dy);
            ctx.fillStyle = "#000"; ctx.fillText(txt, el.width/2, el.height/2);
          })();
          startBlink();
        })();
        window.addEventListener("load", async () => {
          const imgUrl = window.images?.[0];
          if (!imgUrl) return console.error("Colour Sweep Player: no image URL provided.");
          let eff = { name: "fadeIn", duration: 60 }, cfg = window.APP_CONFIG?.mainRevealEffect;
          if (cfg) eff = { name: cfg.name, duration: cfg.duration }, console.log(`Using mainRevealEffect: ${eff.name}, duration: ${eff.duration}`);
          else console.warn("mainRevealEffect not found. Using defaults.");
          try { await setupEffect(imgUrl, eff.name, eff.duration); console.log("Colour sweep ready – click to begin."); }
          catch (err) { console.error("Failed to prepare colour sweep:", err); }
        });
        </script>
        
        
        
        <div id="backgroundBlackout" style="
        position: fixed;
        inset: 0;
        background: #000;
        z-index: 0;
        pointer-events: none;
      "></div>
      
    </body>
    </html>