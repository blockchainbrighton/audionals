<!-- ======================================================================
     COLOUR SWEEP PLAYER – enhanced with Grain, Vignette & Scanlines
     All new overlay scripts live above the existing blur script, are
     self-contained, and respect window.APP_CONFIG.
     ==================================================================== -->
     <!DOCTYPE html>
     <html lang="en">
     <head>
     <meta charset="UTF-8">
     <title>Colour Sweep Player</title>
     <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<!-- The Song is 104.15 bpm all effect timings should revolve around this time and 4 bar loops -->
<!-- 18.1 seconds in is the start of bar 9, the first beat is at bar 17 - around 35 seconds -->

<!-- Select and apply a configuration from the template-driven module -->
<!-- 1️⃣  Template-driven factory (optional to preload) -->
<script type="module" src="./effectConfigFactory.js"></script>

<!-- 2️⃣  Config loader – ES module that imports the factory -->
<script type="module">
  import { buildJourneyConfig } from './effectConfigFactory.js';  // ← add “./”

  /* ─────────── same logic as before, wrapped in an IIFE ─────────── */
  (() => {
    // --- CHOOSE YOUR JOURNEY (default) ---
    let chosenJourneyNumber = 100;

    // Optional URL ?journey=#
    const urlParams      = new URLSearchParams(window.location.search);
    const journeyFromUrl = parseInt(urlParams.get('journey'), 10);
    if (!isNaN(journeyFromUrl)) chosenJourneyNumber = journeyFromUrl;
    /* --------------------------------------------------------------- */

    try {
      /* Build the config on the fly */
      const rawConfig = buildJourneyConfig(String(chosenJourneyNumber));

      /* Deep-clone so the app can mutate APP_CONFIG safely */
      const selectedConfig = (typeof structuredClone === 'function')
        ? structuredClone(rawConfig)
        : JSON.parse(JSON.stringify(rawConfig));

      window.APP_CONFIG = selectedConfig;
      console.log(`Loaded Journey ${chosenJourneyNumber}: ${window.APP_CONFIG.clickToBegin.text}`);

      // <!-- ADDED: Script to modify APP_CONFIG for visual "gain" -->
      // Apply 200% "gain" to visual effects configurations
      if (window.APP_CONFIG) {
        const scaleFactor = 1.5; // 150%
        console.log(`Applying ${scaleFactor*100}% visual gain modification to APP_CONFIG.`);

        const эффектКонфиги = [
          window.APP_CONFIG.grainEffect,
          window.APP_CONFIG.vignetteEffect,
          window.APP_CONFIG.scanlineEffect,
          window.APP_CONFIG.blurEffect
        ];

        эффектКонфиги.forEach(cfg => {
          if (!cfg) return;

          // Properties that are typically 0-1 (opacity, strength)
          const opacityLikeProps = ['opacity', 'strength', 'lineOpacityInternal', 'defaultOpacity', 'defaultStrength', 'defaultLineOpacityInternal'];
          // Properties that are pixel/numeric values (blur)
          const numericProps = ['blur', 'defaultBlur', 'lineHeightPx', 'defaultLineHeightPx']; // Note: modifying lineHeightPx might change appearance drastically

          opacityLikeProps.forEach(prop => {
            if (cfg.hasOwnProperty(prop) && typeof cfg[prop] === 'number') {
              cfg[prop] = Math.min(1, cfg[prop] * scaleFactor);
            }
            if (cfg.steps && Array.isArray(cfg.steps)) {
              cfg.steps.forEach(step => {
                if (step.hasOwnProperty(prop) && typeof step[prop] === 'number') {
                  step[prop] = Math.min(1, step[prop] * scaleFactor);
                }
              });
            }
          });

          numericProps.forEach(prop => {
            if (cfg.hasOwnProperty(prop) && typeof cfg[prop] === 'number') {
              cfg[prop] *= scaleFactor;
            }
            if (cfg.steps && Array.isArray(cfg.steps)) {
              cfg.steps.forEach(step => {
                if (step.hasOwnProperty(prop) && typeof step[prop] === 'number') {
                  step[prop] *= scaleFactor;
                }
                // For blur effect, also check 'x' and 'y' if they exist in steps (custom direction)
                if (cfg === window.APP_CONFIG.blurEffect) {
                    if (step.hasOwnProperty('x') && typeof step.x === 'number') step.x *= scaleFactor;
                    if (step.hasOwnProperty('y') && typeof step.y === 'number') step.y *= scaleFactor;
                }
              });
            }
          });
        });
        // console.log("APP_CONFIG after visual gain modification:", JSON.parse(JSON.stringify(window.APP_CONFIG))); // For debugging
      }
      // <!-- END ADDED -->

    } catch (err) {
      console.error(`Error loading Journey ${chosenJourneyNumber}:`, err);

      /* Fallback to Journey 1 so the app keeps running */
      const fallback = buildJourneyConfig('1');
      window.APP_CONFIG = (typeof structuredClone === 'function')
        ? structuredClone(fallback)
        : JSON.parse(JSON.stringify(fallback));

      alert(
        'Error: Could not load the selected visual journey. ' +
        'Falling back to Journey 1. See console for details.'
      );
    }
  })();
</script>

<script>
    function clipOverlayToCanvas(overlayEl, targetCanvasEl) { // Renamed canvasEl to targetCanvasEl for clarity
        if (!overlayEl) return;

        let targetRect;

        if (targetCanvasEl) {
            targetRect = targetCanvasEl.getBoundingClientRect();
            // If the target canvas has no dimensions yet, it might not be fully initialized.
            // Fallback to window dimensions in such a case, or decide how to handle.
            // For simplicity here, if rect has 0 width/height, we might as well make overlay fullscreen for now.
            if (targetRect.width === 0 || targetRect.height === 0) {
                targetCanvasEl = null; // Treat as if no target was specified
            }
        }

        if (!targetCanvasEl) { // No valid target canvas, or it had zero dimensions
            targetRect = {
                top: 0,
                left: 0,
                width: window.innerWidth,
                height: window.innerHeight,
                right: window.innerWidth,
                bottom: window.innerHeight
            };
        }

        // If the overlay is a CANVAS, set its drawing surface dimensions
        if (overlayEl.tagName === 'CANVAS') {
            const newWidth = Math.round(targetRect.width);
            const newHeight = Math.round(targetRect.height);
            // Only update if necessary to avoid clearing canvas/performance issues
            if (overlayEl.width !== newWidth || overlayEl.height !== newHeight) {
                overlayEl.width = newWidth;
                overlayEl.height = newHeight;
            }
        }

        // Apply clip-path based on the original target (if one was provided and valid)
        if (targetCanvasEl) { // Check original targetCanvasEl for clipping
            const rectForClip = targetCanvasEl.getBoundingClientRect(); // Re-get, in case it became valid
             if (rectForClip.width > 0 && rectForClip.height > 0) {
                const clip = `inset(${Math.round(rectForClip.top)}px ${Math.round(window.innerWidth - rectForClip.right)}px ${Math.round(window.innerHeight - rectForClip.bottom)}px ${Math.round(rectForClip.left)}px)`;
                overlayEl.style.clipPath = clip;
                overlayEl.style.WebkitClipPath = clip;
            } else { // Target exists but has no size, don't clip
                overlayEl.style.clipPath = 'none';
                overlayEl.style.WebkitClipPath = 'none';
            }
        } else { // No target canvas at all, make it full screen (no clip)
            overlayEl.style.clipPath = 'none';
            overlayEl.style.WebkitClipPath = 'none';
        }
    }

    const getZ = name => {
        const order = window.APP_CONFIG?.effectOrder ?? ['grain', 'scanline', 'blur', 'vignette'];
        return 900 + order.indexOf(name) * 10;
    };
 </script>


   <!-- effects-module.js (drop-in replacement) -->
   <script id="effects-module">
    (() => {
      /* ───── 1. SHARED HELPERS ───── */
      const H = (window.OverlayEffectHelpers ??= {
        createOverlay: ({
          tag = 'div', id, z = 999, blend, pointer = 'none',
          style = {}, append = document.body,
        }) => {
          const el = Object.assign(document.createElement(tag), { id });
          Object.assign(
            el.style,
            { position: 'fixed', inset: 0, zIndex: z, pointerEvents: pointer, opacity: '0' /* Start hidden */ },
            blend && { mixBlendMode: blend },
            style,
          );
          append.appendChild(el);
          return el;
        },
        destroyOverlay: el => el?.remove(),
        animate: ({ // H.animate is primarily for single transitions.
          duration = 1, onUpdate, onDone, easing,
          activeRef = () => true,
        }) => {
          const s = performance.now();
          let rafId;
          const f = now => {
            if (!activeRef()) { cancelAnimationFrame(rafId); return; }
            const t = Math.min(1, (now - s) / duration);
            onUpdate(easing ? easing(t) : t);
            if (t < 1) {
              rafId = requestAnimationFrame(f);
            } else {
              onDone?.();
            }
          };
          rafId = requestAnimationFrame(f);
          return () => cancelAnimationFrame(rafId);
        },
        bindResize: (overlay, targetCanvasIdOrElement) => {
          const resize = () =>
            window.clipOverlayToCanvas?.(
              overlay,
              typeof targetCanvasIdOrElement === 'string' ? document.getElementById(targetCanvasIdOrElement) : targetCanvasIdOrElement,
            );
          window.addEventListener('resize', resize);
          resize(); // Initial call
          return () => window.removeEventListener('resize', resize);
        },
        lerpColor: (a = '#000000', b = '#000000', t = 0) => { // 'b' is the target color string parameter
            const parse = c => ({
                r: parseInt(c.slice(1, 3) || '00', 16),
                g: parseInt(c.slice(3, 5) || '00', 16),
                b: parseInt(c.slice(5, 7) || '00', 16), // This 'b' is a property key, which is fine
            });
            const ca = parse(a);
            const cb = parse(b); // Uses the parameter 'b'
            const r_val = Math.round(ca.r + (cb.r - ca.r) * t).toString(16).padStart(2, '0');
            const g_val = Math.round(ca.g + (cb.g - ca.g) * t).toString(16).padStart(2, '0');
            const b_val = Math.round(ca.b + (cb.b - ca.b) * t).toString(16).padStart(2, '0'); // Corrected from 'b'
            return `#${r_val}${g_val}${b_val}`;
        },
        getZ: name => {
            const order = window.APP_CONFIG?.effectOrder ?? ['grain', 'scanline', 'blur', 'vignette'];
            return 900 + order.indexOf(name) * 10;
        }
      });

      /* util: wire start/stop to playback events */
      const wire = (start, stop) => {
        document.addEventListener('playbackStarted', start);
        document.addEventListener('playbackStopped', stop);
      };

      const runEffectSequence = ({
        effectName, steps, initialProperties, applyProperties, getActiveRef, onSequenceCompleted
      }) => {
        let currentStepIndex = 0;
        let sequenceRAF;
        let currentProps = { ...initialProperties, _isEnabledSystem: initialProperties.enabled ?? true };

        applyProperties(currentProps, currentProps._isEnabledSystem);

        function runStep(stepIdx) {
          if (!getActiveRef() || stepIdx >= steps.length) {
            if (getActiveRef() && stepIdx >= steps.length && steps.length > 0) {
                const lastConfigStep = steps[steps.length-1] || {};
                const finalIsEnabled = lastConfigStep.hasOwnProperty('enabled') ? lastConfigStep.enabled : currentProps._isEnabledSystem;
                // Update currentProps with final values from the last defined step before applying
                currentProps = { ...currentProps, ...lastConfigStep, _isEnabledSystem: finalIsEnabled };
                applyProperties(currentProps, finalIsEnabled);
            }
            onSequenceCompleted?.();
            return;
          }

          const stepConfig = steps[stepIdx];
          const duration = stepConfig.duration ?? 0;

          const startPropsForAnim = { ...currentProps }; // Values at the beginning of this step's transition
          const targetPropsFromConfig = { ...stepConfig }; // Target values defined in this step's config

          const targetIsEnabledSystem = targetPropsFromConfig.hasOwnProperty('enabled')
            ? targetPropsFromConfig.enabled
            : startPropsForAnim._isEnabledSystem;

          if (duration === 0) {
            currentProps = { ...startPropsForAnim, ...targetPropsFromConfig, _isEnabledSystem: targetIsEnabledSystem };
            applyProperties(currentProps, targetIsEnabledSystem);
            runStep(stepIdx + 1);
            return;
          }

          const animationStartTime = performance.now();

          function frame(now) {
            if (!getActiveRef()) {
              cancelAnimationFrame(sequenceRAF);
              return;
            }

            const elapsedTime = now - animationStartTime;
            const progress = Math.min(1, duration > 0 ? elapsedTime / duration : 1);
            const interpolatedPropsThisFrame = { _isEnabledSystem: targetIsEnabledSystem };

            // Iterate over all keys that could possibly be animated or set
            const allKeys = new Set([...Object.keys(startPropsForAnim), ...Object.keys(targetPropsFromConfig)]);

            for (const key of allKeys) {
                if (key === '_isEnabledSystem' || key === 'duration' || key === 'enabled') continue;

                let startVal = startPropsForAnim[key];
                let endVal = targetPropsFromConfig.hasOwnProperty(key) ? targetPropsFromConfig[key] : startVal;

                // If a property isn't in startPropsForAnim (e.g. new prop in this step), initialize startVal sensibly
                if (startVal === undefined) {
                    if (typeof endVal === 'number') startVal = 0;
                    else if (typeof endVal === 'string' && endVal.startsWith('#')) startVal = '#000000';
                    // else it will be handled as non-interpolatable
                }

                if (key === 'opacity' || key === 'strength' || key === 'blur' /* Add other properties that should fade */) {
                    if (targetIsEnabledSystem && !startPropsForAnim._isEnabledSystem) { // Enabling: Animate from 0
                        startVal = 0;
                    } else if (!targetIsEnabledSystem && startPropsForAnim._isEnabledSystem) { // Disabling: Animate to 0
                        endVal = 0;
                    } else if (!targetIsEnabledSystem && !startPropsForAnim._isEnabledSystem) { // Staying disabled: Keep at 0
                        startVal = 0; endVal = 0;
                    }
                }

                if (typeof endVal === 'number' && typeof startVal === 'number') {
                  interpolatedPropsThisFrame[key] = startVal + (endVal - startVal) * progress;
                } else if (typeof endVal === 'string' && endVal.startsWith('#') &&
                           typeof startVal === 'string' && startVal.startsWith('#')) {
                  interpolatedPropsThisFrame[key] = H.lerpColor(startVal, endVal, progress);
                } else {
                  interpolatedPropsThisFrame[key] = (progress === 1 && targetPropsFromConfig.hasOwnProperty(key)) ? targetPropsFromConfig[key] : startVal;
                }
            }

            currentProps = { ...startPropsForAnim, ...interpolatedPropsThisFrame, _isEnabledSystem: targetIsEnabledSystem };
            applyProperties(currentProps, targetIsEnabledSystem);

            if (progress < 1) {
              sequenceRAF = requestAnimationFrame(frame);
            } else {
              // Ensure final values from stepConfig are precisely set
              currentProps = { ...startPropsForAnim, ...targetPropsFromConfig, _isEnabledSystem: targetIsEnabledSystem };
              applyProperties(currentProps, targetIsEnabledSystem);
              runStep(stepIdx + 1);
            }
          }
          sequenceRAF = requestAnimationFrame(frame);
        }

        runStep(currentStepIndex);

        return () => {
          cancelAnimationFrame(sequenceRAF);
        };
      };


      /* ───── 2. GRAIN EFFECT ───── */
      (() => {
        const EFFECT_NAME = 'grain';
        let overlay, ctx, noiseRAF, active = false, stopResize, currentFrameInterval;
        let stopCurrentSequence = null;

        const drawNoise = () => {
          if (!overlay || !ctx || !active || !overlay.style.opacity || parseFloat(overlay.style.opacity) === 0) return;
          const { width, height } = overlay;
          if (width === 0 || height === 0) return;

          const img = ctx.createImageData(width, height);
          const buf = new Uint32Array(img.data.buffer);
          for (let i = 0; i < buf.length; i++) {
            const rand = Math.random() * 255;
            buf[i] = (255 << 24) | (rand << 16) | (rand << 8) | rand;
          }
          ctx.putImageData(img, 0, 0);
        };

        let lastDrawTime = 0;
        const noiseLoop = () => {
          if (!active) return;
          noiseRAF = requestAnimationFrame(noiseLoop); // Schedule next frame first
          const now = performance.now();
          if (now - lastDrawTime > (currentFrameInterval ?? 50) ) { // ensure currentFrameInterval has a fallback
            lastDrawTime = now;
            drawNoise();
          }
        };

        const applyGrainProperties = (props, isEnabledSystem) => {
            if (!overlay) return;
            overlay.style.opacity = isEnabledSystem ? (props.opacity ?? 0).toString() : '0';
            currentFrameInterval = props.frameIntervalMs ?? 50; // from cfg.defaultFrameIntervalMs
        };

        const start = () => {
          stop();
          const cfg = window.APP_CONFIG?.grainEffect;
          if (!cfg || !cfg.steps || cfg.steps.length === 0) {
            console.warn(`${EFFECT_NAME} effect disabled or misconfigured (no steps).`);
            return;
          }

          overlay = H.createOverlay({
            tag: 'canvas', id: 'grainCanvas', z: H.getZ(EFFECT_NAME), blend: 'overlay'
          });
          ctx = overlay.getContext('2d', { willReadFrequently: true });

          let areaMode = cfg.areaMode || "image";
          let targetElementForResize = document.getElementById('imageCanvas'); // Default for "image"
          if (areaMode === "fullscreen") {
            targetElementForResize = null;
          } else if (areaMode === "custom" && cfg.grainArea) {
            console.warn("Grain 'custom' areaMode needs specific implementation for grainArea. Defaulting to fullscreen for resize binding.");
            targetElementForResize = null; // Placeholder for custom logic
          }
          stopResize = H.bindResize(overlay, targetElementForResize);

          active = true;
          const initialProperties = {
            opacity: cfg.defaultOpacity ?? 0,
            frameIntervalMs: cfg.defaultFrameIntervalMs ?? 50,
            enabled: cfg.steps[0]?.enabled ?? true,
          };

          stopCurrentSequence = runEffectSequence({
            effectName: EFFECT_NAME,
            steps: cfg.steps,
            initialProperties,
            applyProperties: applyGrainProperties,
            getActiveRef: () => active,
            onSequenceCompleted: () => { /* console.log('Grain sequence completed') */ }
          });

          lastDrawTime = performance.now();
          noiseLoop();
        };

        const stop = () => {
          active = false;
          cancelAnimationFrame(noiseRAF);
          stopCurrentSequence?.();
          stopCurrentSequence = null;
          stopResize?.();
          H.destroyOverlay(overlay);
          overlay = ctx = stopResize = null;
          currentFrameInterval = 50; // Reset
        };
        wire(start, stop);
      })();

      /* ───── 3. VIGNETTE EFFECT ───── */
      (() => {
        const EFFECT_NAME = 'vignette';
        let overlay, active = false, stopResize;
        let stopCurrentSequence = null;

        const applyVignetteProperties = (props, isEnabledSystem) => {
            if (!overlay) return;
            overlay.style.opacity = '1'; 

            if (isEnabledSystem) {
                const strength = props.strength ?? 0;
                const color = props.color ?? '#000000';
                const position = props.position ?? "center";
                const transparentStop = props.transparentStop ?? "60%";
                if (strength > 0) {
                    overlay.style.background = `radial-gradient(circle at ${position}, transparent ${transparentStop}, ${color} ${strength * 100}%)`;
                } else {
                     overlay.style.background = 'none';
                }
            } else {
                overlay.style.background = 'none';
            }
        };

        const start = () => {
          stop();
          const cfg = window.APP_CONFIG?.vignetteEffect;
           if (!cfg || !cfg.steps || cfg.steps.length === 0) {
            console.warn(`${EFFECT_NAME} effect disabled or misconfigured (no steps).`);
            return;
          }

          overlay = H.createOverlay({ id: 'vignetteOverlay', z: H.getZ(EFFECT_NAME) });

          let areaTarget = document.getElementById('imageCanvas'); 
          if (cfg.hasOwnProperty('areaTarget')) { 
            areaTarget = cfg.areaTarget === 'imageCanvas' ? document.getElementById('imageCanvas') :
                         cfg.areaTarget === null ? null :
                         (typeof cfg.areaTarget === 'string' ? document.getElementById(cfg.areaTarget) : cfg.areaTarget);
          }
          stopResize = H.bindResize(overlay, areaTarget);


          active = true;
          const initialProperties = {
            strength: cfg.defaultStrength ?? 0,
            color: cfg.defaultColor ?? '#000000',
            position: cfg.defaultPosition ?? "center",
            transparentStop: cfg.defaultTransparentStop ?? "60%",
            enabled: cfg.steps[0]?.enabled ?? true,
          };

          stopCurrentSequence = runEffectSequence({
            effectName: EFFECT_NAME,
            steps: cfg.steps,
            initialProperties,
            applyProperties: applyVignetteProperties,
            getActiveRef: () => active,
          });
        };

        const stop = () => {
          active = false;
          stopCurrentSequence?.();
          stopCurrentSequence = null;
          stopResize?.();
          H.destroyOverlay(overlay);
          overlay = stopResize = null;
        };
        wire(start, stop);
      })();

      /* ───── 4. SCANLINE EFFECT ───── */
      (() => {
        const EFFECT_NAME = 'scanline';
        let overlay, styleTag, active = false, stopResize;
        let stopCurrentSequence = null;
        const animationName = `scanSlide-${EFFECT_NAME}-${Date.now()}`;

        const applyScanlineProperties = (props, isEnabledSystem) => {
            if (!overlay || !styleTag) return;

            const overallOpacity = isEnabledSystem ? (props.opacity ?? 0).toString() : '0';
            overlay.style.opacity = overallOpacity;

            if (isEnabledSystem && (props.opacity ?? 0) > 0 && (props.lineHeightPx ?? 0) > 0) {
                const h = props.lineHeightPx;
                const lineOpacity = props.lineOpacityInternal ?? 1;
                const spd = props.speed ?? 10;

                overlay.style.background = `repeating-linear-gradient(0deg, rgba(0,0,0,${lineOpacity}) 0 ${h}px, transparent ${h}px ${h * 2}px)`;

                const currentAnimationDuration = `${spd}s`;
                if (overlay.style.animationName !== animationName || overlay.style.animationDuration !== currentAnimationDuration) {
                     overlay.style.animationName = animationName;
                     overlay.style.animationDuration = currentAnimationDuration;
                     overlay.style.animationTimingFunction = 'linear';
                     overlay.style.animationIterationCount = 'infinite';
                }
                styleTag.textContent = `@keyframes ${animationName} {0%{background-position:0 0}100%{background-position:0 ${h * 2}px}}`;
                overlay.style.animationPlayState = 'running';

            } else {
                overlay.style.background = 'none';
                overlay.style.animationPlayState = 'paused';
            }
        };

        const start = () => {
          stop();
          const cfg = window.APP_CONFIG?.scanlineEffect;
          if (!cfg || !cfg.steps || cfg.steps.length === 0) {
            console.warn(`${EFFECT_NAME} effect disabled or misconfigured (no steps).`);
            return;
          }

          styleTag = document.head.appendChild(document.createElement('style'));
          overlay = H.createOverlay({ id: 'scanlineOverlay', z: H.getZ(EFFECT_NAME) });

          let areaTarget = document.getElementById('imageCanvas');
          if (cfg.hasOwnProperty('areaTarget')) {
            areaTarget = cfg.areaTarget === 'imageCanvas' ? document.getElementById('imageCanvas') :
                         cfg.areaTarget === null ? null :
                         (typeof cfg.areaTarget === 'string' ? document.getElementById(cfg.areaTarget) : cfg.areaTarget);
          }
          stopResize = H.bindResize(overlay, areaTarget);

          active = true;
          const initialProperties = {
            opacity: cfg.defaultOpacity ?? 0, 
            lineHeightPx: cfg.defaultLineHeightPx ?? 0,
            speed: cfg.defaultSpeed ?? 10,
            lineOpacityInternal: cfg.defaultLineOpacityInternal ?? 1,
            enabled: cfg.steps[0]?.enabled ?? true,
          };

          stopCurrentSequence = runEffectSequence({
            effectName: EFFECT_NAME,
            steps: cfg.steps,
            initialProperties,
            applyProperties: applyScanlineProperties,
            getActiveRef: () => active,
          });
        };

        const stop = () => {
          active = false;
          stopCurrentSequence?.();
          stopCurrentSequence = null;
          styleTag?.remove();
          styleTag = null;
          stopResize?.();
          H.destroyOverlay(overlay);
          overlay = stopResize = null;
        };
        wire(start, stop);
      })();

      /* ───── 5. BLUR EFFECT ───── */
      (() => {
        const EFFECT_NAME = 'blur';
        let blurRAF, el, steps, active = false;
        const getTargetElement = () => document.getElementById(window.APP_CONFIG?.blurEffect?.targetElementId || 'imageRevealContainer');

        const toXY = (dir, v_input) => {
            let v_x, v_y;
            if (dir === 'custom' && typeof v_input === 'object' && v_input !== null) {
                v_x = v_input.x ?? 0;
                v_y = v_input.y ?? 0;
            } else {
                const val = typeof v_input === 'number' ? v_input :
                            (typeof v_input === 'object' && v_input !== null && v_input.hasOwnProperty('blur')) ? v_input.blur : 0;
                if (dir === 'x') { v_x = val; v_y = 0; }
                else if (dir === 'y') { v_x = 0; v_y = val; }
                else { v_x = val; v_y = val; } 
            }
            return { x: v_x, y: v_y };
        }

        const start = () => {
          stop();
          el = getTargetElement();
          const cfg = window.APP_CONFIG?.blurEffect;

          if (!cfg?.enabled || !el || !cfg.steps || cfg.steps.length === 0) {
            if (el) el.style.filter = 'none';
            return;
          }

          const dir = cfg.direction ?? 'all';
          steps = cfg.steps.map(s_config => ({
              duration: s_config.duration,
              xy: toXY(dir, s_config.blur ?? ( (dir === 'custom' && s_config.x !== undefined && s_config.y !== undefined) ? {x:s_config.x, y:s_config.y} : (cfg.defaultBlur ?? 0) ) )
          }));

          active = true;
          let startStepIndex = 0;

          if (steps[0] && steps[0].duration === 0) {
              const { x, y } = steps[0].xy;
              // el.style.filter = (x || y) ? `blur(${x}px) blur(${y}px)` : 'none'; // Original separate blurs
              let initialBlurVal = 0;
              if (dir === 'x') initialBlurVal = x; else if (dir === 'y') initialBlurVal = y; else initialBlurVal = Math.max(x,y);
              el.style.filter = initialBlurVal > 0.01 ? `blur(${initialBlurVal}px)` : 'none';

              startStepIndex = 1; 
              if (steps.length === 1) { 
                active = false; 
                return;
              }
          } else {
               const initialXY = toXY(dir, cfg.defaultBlur ?? 0);
               // el.style.filter = (initialXY.x || initialXY.y) ? `blur(${initialXY.x}px) blur(${initialXY.y}px)` : 'none';
               let initialBlurVal = 0;
               if (dir === 'x') initialBlurVal = initialXY.x; else if (dir === 'y') initialBlurVal = initialXY.y; else initialBlurVal = Math.max(initialXY.x, initialXY.y);
               el.style.filter = initialBlurVal > 0.01 ? `blur(${initialBlurVal}px)` : 'none';
          }

          (function run(currentIndex) {
            if (!active || currentIndex >= steps.length) {
              if (active && steps.length > 0 && currentIndex >= steps.length) { 
                const finalStep = steps[steps.length-1];
                // el.style.filter = (finalStep.xy.x || finalStep.xy.y) ? `blur(${finalStep.xy.x}px) blur(${finalStep.xy.y}px)` : 'none';
                let finalBlurVal = 0;
                if (dir === 'x') finalBlurVal = finalStep.xy.x; else if (dir === 'y') finalBlurVal = finalStep.xy.y; else finalBlurVal = Math.max(finalStep.xy.x, finalStep.xy.y);
                el.style.filter = finalBlurVal > 0.01 ? `blur(${finalBlurVal}px)` : 'none';

              }
              return;
            }

            const currentStepConfig = steps[currentIndex];
            const animDuration = Math.max(16, currentStepConfig.duration);

            const startXY = (currentIndex === 0)
                ? toXY(dir, cfg.defaultBlur ?? 0) 
                : steps[currentIndex-1].xy;

            const targetXY = currentStepConfig.xy;
            const s_time = performance.now();

            (function frame() {
              if (!active) { cancelAnimationFrame(blurRAF); return; }

              const t = Math.min(1, (performance.now() - s_time) / animDuration);
              const x = startXY.x + (targetXY.x - startXY.x) * t;
              const y = startXY.y + (targetXY.y - startXY.y) * t;

              let appliedFilterValue = 0;
              if (dir === 'x') appliedFilterValue = x;
              else if (dir === 'y') appliedFilterValue = y;
              else  appliedFilterValue = Math.max(x, y);


              if (appliedFilterValue > 0.01) {
                el.style.filter = `blur(${appliedFilterValue}px)`;
              } else {
                el.style.filter = 'none';
              }

              if (t < 1) {
                blurRAF = requestAnimationFrame(frame);
              } else {
                if (appliedFilterValue > 0.01){
                    el.style.filter = `blur(${appliedFilterValue}px)`;
                } else {
                     el.style.filter = 'none';
                }
                run(currentIndex + 1);
              }
            })();
          })(startStepIndex);
        };

        const stop = () => {
          active = false;
          cancelAnimationFrame(blurRAF);
        };
        wire(start, stop);
      })();
    })();
    </script>


     <!-- ────────────────────────────────────────────────────────────────────
          6.  PAGE STYLES  (identical to original; extra z-index is handled above)
          ──────────────────────────────────────────────────────────────────── -->
     <style>
html, body {
  box-sizing: border-box !important;
  border: none !important;
  outline: none !important;
  background: #000 !important;
  margin: 0 !important;
  padding: 0 !important;
  width: 100vw !important;
  height: 100vh !important;
  min-width: 100vw !important;
  min-height: 100vh !important;
  max-width: 100vw !important;
  max-height: 100vh !important;
  overflow: hidden !important;
}

*,
*::before,
*::after {
  box-sizing: inherit;
  border: none !important;
  outline: none !important;
  background: transparent;
}


#imageRevealContainer {
  position: fixed;
  inset: 0;
  margin: 0;
  padding: 0;
  border: none;
  background: #000 !important;
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  overflow: hidden;
}

body::-webkit-scrollbar, html::-webkit-scrollbar {
  display: none !important; /* hide any scrollbars */
}

#imageRevealContainer > :not(canvas) {
  display: none !important;
}

#imageCanvas {
  width: 90vh;
  height: 90vh;
  max-width: 90vw;
  max-height: 90vh;
  background: #000;
  border: none;
  margin: 0;
  padding: 0;
  display: block;
  image-rendering: pixelated;

  transform: translateZ(0);
  will-change: transform;

  box-shadow:
    inset 0 1px 0 0 #000,
    inset 0 -1px 0 0 #000;
  box-sizing: border-box;
}

#pixelTextCanvas {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 90vh;
  max-width: 90vw;
  height: auto;
  image-rendering: pixelated;
  opacity: 1;
  transition: opacity 16s ease-out, transform 16s ease-out;
  z-index: 1000;
}

#pixelTextCanvas.hidden {
  opacity: 0;
  transform: translate(-50%, -50%) scale(0);
}

#playBtn {
  display: none;
}

#backgroundBlackout {
  position: fixed;
  inset: 0;
  background: #000;
  z-index: 0;
  pointer-events: none;
}

     </style>
     </head>

     <!-- ────────────────────────────────────────────────────────────────────
          7.  DOM  (unchanged)
          ──────────────────────────────────────────────────────────────────── -->
     <body>
        <div id="backgroundBlackout" style="
        position: fixed;
        inset: 0;
        background: #000;
        z-index: 0;
        pointer-events: none;
        "></div>

       <canvas id="pixelTextCanvas" width="200" height="40"></canvas>
       <button id="playBtn">Play Mix</button>

       <!-- Audio URLs -->
       <script id="audio-data">
         const audioParts = [
           "https://ordinals.com/content/055e30b37a547674bd750cd963b9c3e2dfaecfe60833cbb9a377e12b2eea05a6i0",
           "https://ordinals.com/content/a475da90928ae5dba210a6a2708a20278367d46f898acdebe9707c0e43b994cei0",
           "https://ordinals.com/content/797a56f20af6f7016853f817a7041847e82dedd2d2b9246515646e741a3e53b2i0"
         ];
       </script>

       <!-- Image URLs -->
       <script id="image-data">
         window.images = ["https://ordinals.com/content/01c48d3cceb02215bc3d44f9a2dc7fba63ea63719a2ef1c35d3f0c4db93ab8d5i0"];
       </script>
           <!-- imageLoadMgmt.js -->
           <script src="https://ordinals.com/content/a698a70c8eda8e6a58abf2e65921ca629e1734a91c67e2d74a941a2cc5c36027i0"></script>
           <!-- imageRevealCore.js -->
              <script type="module" src="https://ordinals.com/content/7b66beb111fbc673a99867f13480a3289afc522b811ddd60163b3bcbb82aa758i0"></script>


              <script type="module">
              (()=>{const el=id=>document.getElementById(id),
              t=el("playBtn"),e=el("log"),
              a=window.AudioContext||window.webkitAudioContext,
              n=el("clickToBeginText"),
              d=m=>{if(!e)return;e.textContent+=`${new Date().toLocaleTimeString()}: ${m}\n`;e.scrollTop=e.scrollHeight},
              emit=ev=>document.dispatchEvent(new Event(ev)),
              setTxt=txt=>t.textContent=txt;
              if(!a)return setTxt("Audio not supported"),t.disabled=!0;
              n||console.warn('"Click to Begin" text element not found in playbackMgmt.js context');

              let o=new a,
              i=new Array(audioParts.length),
              r=0,
              s=null,
              c=!0,
              l=!1,
              masterGainNode = o.createGain(); // <!-- ADDED: Master Gain Node -->

              masterGainNode.gain.value = 2.0; // <!-- ADDED: Set gain to 200% (2.0) -->
              masterGainNode.connect(o.destination); // <!-- ADDED: Connect master gain to output -->
              console.log(`Audio gain set to ${masterGainNode.gain.value * 100}%`);


              const u=()=>{t.disabled=c;setTxt(c?"Loading…":l?"Stop Mix":"Play Mix");},
              h=async(url,idx,first=!1)=>{first&&d(`Fetching first part → ${url}`);
              i[idx]=await o.decodeAudioData(await(await fetch(url)).arrayBuffer());
              d(`${first?"First part ready":`Decoded part ${idx+1}/${audioParts.length}`} (${i[idx].duration.toFixed(2)} s).`);};
              (async()=>{try{await h(audioParts[0],0,!0);c=!1;u();
              await Promise.all(audioParts.slice(1).map((url,idx)=>h(url,idx+1)));d("All parts decoded. ✅");}
              catch(err){c=!1;u();d(`Preload failed: ${err.message}`);}})();
              const p=()=>{if(!l)return;if(r>=i.length)return l=!1,u(),d("Finished. 🎉"),y();
              const buf=i[r];if(!buf)return d(`Part ${r+1} buffer not ready, retrying...`),setTimeout(p,200);
              (s=o.createBufferSource()).buffer=buf;
              s.connect(masterGainNode); // <!-- MODIFIED: Connect source to masterGainNode instead of o.destination -->
              s.start();
              d(`▶ Part ${r+1}/${i.length} (${buf.duration.toFixed(2)} s)`);r++;
              s.onended=()=>{s=null;l&&p();};},
              y=()=>emit("playbackStopped"),
              f=async()=>{if(c||l)return;if(o.state==="suspended")await o.resume();
              l=!0;r=0;u();emit("playbackStarted");p();},
              g=()=>{if(!l)return;l=!1;if(s)try{s.onended=null;s.stop();}catch(err){d(`Error stopping active source: ${err.message}`);}
              s=null;d("Stopped by user.");u();y();},
              toggle=()=>{(l?g:f)();};
              t.onclick=toggle;
              document.addEventListener("togglePlayback",toggle);
              document.addEventListener("playbackStarted",()=>{});
              document.addEventListener("playbackStopped",()=>{});})();
              </script>


        <!-- imageRevealPublicApi.js (inline module script that USES the import) -->
        <script type="module">
            import { setupEffect } from "https://ordinals.com/content/6addd1c637ee377bd7e3510c7e78ec35a7fb037676f2ef416131067c9d1d4cf6i0";
            (() => {
              const cfg = window.APP_CONFIG?.clickToBegin ?? {},
                txt = cfg.text ?? "CLICK TO BEGIN",
                fadeMs = cfg.fadeOutDurationMs ?? 16000,
                blinkMs = cfg.blinkIntervalMs ?? 500,
                reapMs = cfg.reappearDelayMs ?? 16000,
                el = document.getElementById("pixelTextCanvas"),
                ctx = el.getContext("2d");
              let blink;
              el.style.transition = `opacity ${fadeMs/1e3}s ease-out,transform ${fadeMs/1e3}s ease-out`;
              const blinkFn = vis => { clearInterval(blink); el.style.visibility = vis; },
                startBlink = () => { blinkFn("visible"); blink = setInterval(() => el.style.visibility = el.style.visibility === "hidden" ? "visible" : "hidden", blinkMs); };
              el.onclick = () => (blinkFn("visible"), el.classList.add("hidden"), document.getElementById("playBtn").click());
              document.addEventListener("playbackStarted", () => { if (!el.classList.contains("hidden")) blinkFn("visible"), el.classList.add("hidden"); });
              document.addEventListener("playbackStopped", () => { el.classList.remove("hidden"); setTimeout(startBlink, reapMs); });
              (() => {
                ctx.clearRect(0, 0, el.width, el.height);
                ctx.font = "bold 16px monospace"; ctx.textBaseline = "middle"; ctx.textAlign = "center"; ctx.fillStyle = "#33CCFF";
                for (let dx = -1; dx <= 1; dx++) for (let dy = -1; dy <= 1; dy++) ctx.fillText(txt, el.width/2 + dx, el.height/2 + dy);
                ctx.fillStyle = "#000"; ctx.fillText(txt, el.width/2, el.height/2);
              })();
              startBlink();
            })();
            window.addEventListener("load", async () => {
              const imgUrl = window.images?.[0];
              if (!imgUrl) return console.error("Colour Sweep Player: no image URL provided.");
              let eff = { name: "fadeIn", duration: 60 }, cfg = window.APP_CONFIG?.mainRevealEffect;
              if (cfg) eff = { name: cfg.name, duration: cfg.duration }, console.log(`Using mainRevealEffect: ${eff.name}, duration: ${eff.duration}`);
              else console.warn("mainRevealEffect not found. Using defaults.");
              try { await setupEffect(imgUrl, eff.name, eff.duration); console.log("Colour sweep ready – click to begin."); }
              catch (err) { console.error("Failed to prepare colour sweep:", err); }
            });
            </script>



            <div id="backgroundBlackout" style="
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 0;
            pointer-events: none;
          "></div>

        </body>
        </html>