<!-- ======================================================================
     COLOUR SWEEP PLAYER – enhanced with Grain, Vignette & Scanlines
     All new overlay scripts live above the existing blur script, are
     self-contained, and respect window.APP_CONFIG.
     ==================================================================== -->
     <!DOCTYPE html>
     <html lang="en">
     <head>
     <meta charset="UTF-8">
     <title>Colour Sweep Player</title>
     <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

     <!-- ────────────────────────────────────────────────────────────────────
          0. GLOBAL CONFIG – add three new effect blocks
          ──────────────────────────────────────────────────────────────────── -->
     <script id="global-app-config">
     window.APP_CONFIG = {
       /* ----------------------------  Overlays  --------------------------- */
       effectOrder: ['grain', 'scanline', 'blur', 'vignette'],

       grainEffect: {
            enabled: true,
            frameIntervalMs: 20,     // Faster updates = more motion
            opacity: 0.85,           // Stronger initial grain
            endFrameIntervalMs: 8,   // Even more rapid toward the end
            endOpacity: 0.65,        // Keep grain prominent throughout
            duration: 30             // Match other durations or go longer
            },
            vignetteEffect: {
            enabled: false,
            strength: 0.6,          // start (0-1)
            color: "#000",          // stays fixed or morph between two colors if needed
            endStrength: 0.9,       // end
            endColor: "#08081a",    // (optional, to morph between colors)
            duration: 30            // seconds for morph
            },

       scanlineEffect: {
            enabled: false,
            lineHeightPx: 24,    // Initial value (start)
            opacity: 0.52,       // Initial value (start)
            speed: 10,           // Initial value (start)
            endLineHeightPx: 2,  // End value (thin)
            endOpacity: 0.12,    // End value (less visible)
            endSpeed: 0.5,       // End value (faster)
            duration: 30         // Animation duration in seconds
            },     
       /* -----------------------------  Blur  ------------------------------ */

       blurEffect: {
            enabled: false,
            direction: "all",
            steps: [
                { blur: 40, duration: 5000 },
                { blur: 0,  duration: 4000 },
                { blur: 25, duration: 3000 },
                { blur: 0,  duration: 3000 }
            ]
            },

       /* ------------------  Core (unchanged from original)  --------------- */
       // mainRevealEffectOptions: fadeIn:'fadeOut', fadeOut:'fadeIn', pixelateFwd:'pixelateRev', pixelateRev:'pixelateFwd',
       // glyphFwd:'glyphRev', glyphRev:'glyphFwd', sweepBrightFwd:'sweepBrightRev', sweepBrightRev:'sweepBrightFwd'

       mainRevealEffect: { name: "fadeIn", duration: 1.5 },
       clickToBegin: {
         text: "ENTER MATRIX",
         fadeOutDurationMs: 35000,
         blinkIntervalMs: 750,
         reappearDelayMs: 5000
       }
     };
     </script>

<script>
    function clipOverlayToCanvas(overlayEl, targetCanvasEl) { // Renamed canvasEl to targetCanvasEl for clarity
        if (!overlayEl) return;

        let targetRect;

        if (targetCanvasEl) {
            targetRect = targetCanvasEl.getBoundingClientRect();
            // If the target canvas has no dimensions yet, it might not be fully initialized.
            // Fallback to window dimensions in such a case, or decide how to handle.
            // For simplicity here, if rect has 0 width/height, we might as well make overlay fullscreen for now.
            if (targetRect.width === 0 || targetRect.height === 0) {
                targetCanvasEl = null; // Treat as if no target was specified
            }
        }

        if (!targetCanvasEl) { // No valid target canvas, or it had zero dimensions
            targetRect = {
                top: 0,
                left: 0,
                width: window.innerWidth,
                height: window.innerHeight,
                right: window.innerWidth,
                bottom: window.innerHeight
            };
        }

        // If the overlay is a CANVAS, set its drawing surface dimensions
        if (overlayEl.tagName === 'CANVAS') {
            const newWidth = Math.round(targetRect.width);
            const newHeight = Math.round(targetRect.height);
            // Only update if necessary to avoid clearing canvas/performance issues
            if (overlayEl.width !== newWidth || overlayEl.height !== newHeight) {
                overlayEl.width = newWidth;
                overlayEl.height = newHeight;
            }
        }

        // Apply clip-path based on the original target (if one was provided and valid)
        if (targetCanvasEl) { // Check original targetCanvasEl for clipping
            const rectForClip = targetCanvasEl.getBoundingClientRect(); // Re-get, in case it became valid
             if (rectForClip.width > 0 && rectForClip.height > 0) {
                const clip = `inset(${Math.round(rectForClip.top)}px ${Math.round(window.innerWidth - rectForClip.right)}px ${Math.round(window.innerHeight - rectForClip.bottom)}px ${Math.round(rectForClip.left)}px)`;
                overlayEl.style.clipPath = clip;
                overlayEl.style.WebkitClipPath = clip;
            } else { // Target exists but has no size, don't clip
                overlayEl.style.clipPath = 'none';
                overlayEl.style.WebkitClipPath = 'none';
            }
        } else { // No target canvas at all, make it full screen (no clip)
            overlayEl.style.clipPath = 'none';
            overlayEl.style.WebkitClipPath = 'none';
        }
    }

    const getZ = name => {
        const order = window.APP_CONFIG?.effectOrder ?? ['grain', 'scanline', 'blur', 'vignette'];
        return 900 + order.indexOf(name) * 10;
    };
 </script>


   <!-- effects-module.js (drop-in replacement) -->
<script id="effects-module">
(() => {
  /* ───── 1. SHARED HELPERS ───── */
  const H = (window.OverlayEffectHelpers ??= {
    createOverlay: ({
      tag = 'div', id, z = 999, blend, pointer = 'none',
      style = {}, append = document.body,
    }) => {
      const el = Object.assign(document.createElement(tag), { id });
      Object.assign(
        el.style,
        { position: 'fixed', inset: 0, zIndex: z, pointerEvents: pointer },
        blend && { mixBlendMode: blend },
        style,
      );
      append.appendChild(el);
      return el;
    },
    destroyOverlay: el => el?.remove(),
    animate: ({
      duration = 1, onUpdate, onDone, easing,
      activeRef = () => true,
    }) => {
      const s = performance.now();
      const f = now => {
        if (!activeRef()) return;
        const t = Math.min(1, (now - s) / duration);
        onUpdate(easing ? easing(t) : t);
        t < 1 ? requestAnimationFrame(f) : onDone?.();
      };
      requestAnimationFrame(f);
    },
    bindResize: (overlay, target) => {
      const resize = () =>
        window.clipOverlayToCanvas?.(
          overlay,
          typeof target === 'string' ? document.getElementById(target) : target,
        );
      window.addEventListener('resize', resize);
      resize();
      return () => window.removeEventListener('resize', resize);
    },
    lerpColor: (a = '#000', b = '#000', t = 0) =>
      '#' +
      [1, 3, 5]
        .map(i => {
          const av = parseInt(a.slice(i, i + 2) || '00', 16);
          const bv = parseInt(b.slice(i, i + 2) || '00', 16);
          return Math.round(av + (bv - av) * t)
            .toString(16)
            .padStart(2, '0');
        })
        .join(''),
  });

  /* util: wire start/stop to playback events */
  const wire = (start, stop) => {
    document.addEventListener('playbackStarted', start);
    document.addEventListener('playbackStopped', stop);
  };

  /* ───── 2. GRAIN EFFECT ───── */
  (() => {
    let overlay, ctx, noiseRAF, active = false, stopResize, curInterval, lastDraw;
    const drawNoise = () => {
      if (!overlay || !ctx) return; // Ensure overlay and context exist
      const { width, height } = overlay;
      if (width === 0 || height === 0) return; // Don't draw if canvas has no dimensions

      const img = ctx.createImageData(width, height);
      const buf = new Uint32Array(img.data.buffer);
      // Use a slightly more varied random for less uniform noise if desired
      // For classic white noise, Math.random() is fine.
      for (let i = 0; i < buf.length; i++) {
        const rand = Math.random() * 255;
        buf[i] = (255 << 24) | (rand << 16) | (rand << 8) | rand; // Grayscale noise
      }
      // Original white noise:
      // for (let i = 0; i < buf.length; i++) buf[i] = (255 << 24) | 0xffffff * Math.random();


      ctx.putImageData(img, 0, 0);
    };
    const loop = () => {
      const now = performance.now();
      if (now - lastDraw > curInterval) {
        lastDraw = now;
        drawNoise();
      }
      active && (noiseRAF = requestAnimationFrame(loop));
    };
    const start = () => {
      stop();
      const cfg = window.APP_CONFIG?.grainEffect;
      if (!cfg?.enabled) return;
      const startCfg = {
        interval: cfg.frameIntervalMs ?? 50,
        op: cfg.opacity ?? 0.15,
      };
      const endCfg = {
        interval: cfg.endFrameIntervalMs ?? 10,
        op: cfg.endOpacity ?? 0.35,
      };
      overlay = H.createOverlay({
        tag: 'canvas',
        id: 'grainCanvas',
        z: 9000,
        blend: 'overlay',
        style: { opacity: startCfg.op },
      });
      ctx = overlay.getContext('2d');
      stopResize = H.bindResize(overlay, 'imageCanvas');
      active = true;
      curInterval = startCfg.interval;
      lastDraw = 0;
      H.animate({
        duration: (cfg.duration ?? 20) * 1000,
        onUpdate: t => {
          curInterval =
            startCfg.interval + (endCfg.interval - startCfg.interval) * t;
          overlay.style.opacity =
            startCfg.op + (endCfg.op - startCfg.op) * t;
        },
        activeRef: () => active,
      });
      loop();
    };
    const stop = () => {
      active = false;
      cancelAnimationFrame(noiseRAF);
      stopResize?.();
      H.destroyOverlay(overlay);
      overlay = ctx = stopResize = null;
    };
    wire(start, stop);
  })();

  /* ───── 3. VIGNETTE EFFECT ───── */
  (() => {
    let overlay, active = false, stopResize;
    const start = () => {
      stop();
      const cfg = window.APP_CONFIG?.vignetteEffect;
      if (!cfg?.enabled) return;
      const s0 = cfg.strength ?? 0.6,
        c0 = cfg.color ?? '#000',
        s1 = cfg.endStrength ?? s0,
        c1 = cfg.endColor ?? c0;
      overlay = H.createOverlay({ id: 'vignetteOverlay', z: 910 });
      active = true;
      H.animate({
        duration: (cfg.duration ?? 30) * 1000,
        onUpdate: t => {
          const s = s0 + (s1 - s0) * t;
          const c = c0 === c1 ? c0 : H.lerpColor(c0, c1, t);
          overlay.style.background = `radial-gradient(circle at center,transparent 60%,${c} ${s * 100}%)`;
        },
        activeRef: () => active,
      });
      stopResize = H.bindResize(overlay, 'imageCanvas');
    };
    const stop = () => {
      active = false;
      stopResize?.();
      H.destroyOverlay(overlay);
      overlay = stopResize = null;
    };
    wire(start, stop);
  })();

  /* ───── 4. SCANLINE EFFECT ───── */
  (() => {
    let overlay, styleTag, active = false, stopResize;
    const start = () => {
      stop();
      const cfg = window.APP_CONFIG?.scanlineEffect;
      if (!cfg?.enabled) return;
      const h0 = cfg.lineHeightPx ?? 24,
        o0 = cfg.opacity ?? 0.52,
        s0 = cfg.speed ?? 10,
        h1 = cfg.endLineHeightPx ?? 2,
        o1 = cfg.endOpacity ?? 0.12,
        s1 = cfg.endSpeed ?? 0.5;
      styleTag = document.head.appendChild(document.createElement('style'));
      overlay = H.createOverlay({ id: 'scanlineOverlay', z: 905 });
      active = true;
      const update = (h, op, spd) => {
        overlay.style.background = `repeating-linear-gradient(0deg,rgba(0,0,0,${op}) 0 ${h}px,transparent ${h}px ${
          h * 2
        }px)`;
        styleTag.textContent = `@keyframes scanSlide{0%{background-position:0 0}100%{background-position:0 ${
          h * 2
        }px}}#scanlineOverlay{animation:scanSlide ${spd}s linear infinite}`;
      };
      H.animate({
        duration: (cfg.duration ?? 30) * 1000,
        onUpdate: t =>
          update(
            h0 + (h1 - h0) * t,
            o0 + (o1 - o0) * t,
            s0 + (s1 - s0) * t,
          ),
        activeRef: () => active,
      });
      stopResize = H.bindResize(overlay, 'imageCanvas');
    };
    const stop = () => {
      active = false;
      styleTag?.remove();
      stopResize?.();
      H.destroyOverlay(overlay);
      overlay = styleTag = stopResize = null;
    };
    wire(start, stop);
  })();

  /* ───── 5. BLUR EFFECT ───── */
  (() => {
    let blurRAF, el, steps, active = false;
    const toXY = (dir, v) =>
      dir === 'x'
        ? { x: v, y: 0 }
        : dir === 'y'
        ? { x: 0, y: v }
        : dir === 'custom'
        ? { x: v.x ?? 0, y: v.y ?? 0 }
        : { x: v, y: v };
    const start = () => {
      stop();
      el = document.getElementById('imageRevealContainer');
      const cfg = window.APP_CONFIG?.blurEffect;
      if (!cfg?.enabled || !el) return;
      const dir = cfg.direction ?? 'all';
      steps = (
        cfg.steps?.length > 1
          ? cfg.steps
          : [
              { blur: cfg.initialBlurPx ?? 50, duration: 0 },
              { blur: cfg.finalBlurPx ?? 0, duration: cfg.duration ?? 10000 },
            ]
      ).map(s => ({ ...s, xy: toXY(dir, s.blur) }));
      active = true;
      (function run(i = 0) {
        if (!active || i >= steps.length - 1) {
          const { x, y } = steps.at(-1).xy;
          el.style.filter = x || y ? `blur(${x}px) blur(${y}px)` : 'none';
          return;
        }
        const a = steps[i].xy,
          b = steps[i + 1].xy,
          d = Math.max(16, steps[i + 1].duration),
          s = performance.now();
        (function frame() {
          if (!active) return;
          const t = Math.min(1, (performance.now() - s) / d),
            x = a.x + (b.x - a.x) * t,
            y = a.y + (b.y - a.y) * t;
          el.style.filter = x || y ? `blur(${x}px) blur(${y}px)` : 'none';
          t < 1 ? (blurRAF = requestAnimationFrame(frame)) : run(i + 1);
        })();
      })();
    };
    const stop = () => {
      active = false;
      cancelAnimationFrame(blurRAF);
      el && (el.style.filter = 'none');
    };
    wire(start, stop);
  })();
})();
</script>

            
            


     <!-- ────────────────────────────────────────────────────────────────────
          6.  PAGE STYLES  (identical to original; extra z-index is handled above)
          ──────────────────────────────────────────────────────────────────── -->
     <style>
html, body {
  box-sizing: border-box !important;
  border: none !important;
  outline: none !important;
  background: #000 !important;
  margin: 0 !important;
  padding: 0 !important;
  width: 100vw !important;
  height: 100vh !important;
  min-width: 100vw !important;
  min-height: 100vh !important;
  max-width: 100vw !important;
  max-height: 100vh !important;
  overflow: hidden !important;
}

*,
*::before,
*::after {
  box-sizing: inherit;
  border: none !important;
  outline: none !important;
  background: transparent;
}


#imageRevealContainer {
  position: fixed;
  inset: 0;
  margin: 0;
  padding: 0;
  border: none;
  background: #000 !important;
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  overflow: hidden;
}

body::-webkit-scrollbar, html::-webkit-scrollbar {
  display: none !important; /* hide any scrollbars */
}

#imageRevealContainer > :not(canvas) {
  display: none !important;
}

#imageCanvas {
  width: 90vh;
  height: 90vh;
  max-width: 90vw;
  max-height: 90vh;
  background: #000;
  border: none;
  margin: 0;
  padding: 0;
  display: block;
  image-rendering: pixelated;

  transform: translateZ(0);
  will-change: transform;

  box-shadow:
    inset 0 1px 0 0 #000,
    inset 0 -1px 0 0 #000;
  box-sizing: border-box;
}

#pixelTextCanvas {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 90vh;
  max-width: 90vw;
  height: auto;
  image-rendering: pixelated;
  opacity: 1;
  transition: opacity 16s ease-out, transform 16s ease-out;
  z-index: 1000;
}

#pixelTextCanvas.hidden {
  opacity: 0;
  transform: translate(-50%, -50%) scale(0);
}

#playBtn {
  display: none;
}

#backgroundBlackout {
  position: fixed;
  inset: 0;
  background: #000;
  z-index: 0;
  pointer-events: none;
}

     </style>
     </head>
     
     <!-- ────────────────────────────────────────────────────────────────────
          7.  DOM  (unchanged)
          ──────────────────────────────────────────────────────────────────── -->
     <body>
        <div id="backgroundBlackout" style="
        position: fixed;
        inset: 0;
        background: #000;
        z-index: 0;
        pointer-events: none;
        "></div>

       <canvas id="pixelTextCanvas" width="200" height="40"></canvas>
       <button id="playBtn">Play Mix</button>
     
       <!-- Audio URLs -->
       <script id="audio-data">
         const audioParts = [
           "https://ordinals.com/content/055e30b37a547674bd750cd963b9c3e2dfaecfe60833cbb9a377e12b2eea05a6i0",
           "https://ordinals.com/content/a475da90928ae5dba210a6a2708a20278367d46f898acdebe9707c0e43b994cei0",
           "https://ordinals.com/content/797a56f20af6f7016853f817a7041847e82dedd2d2b9246515646e741a3e53b2i0"
         ];
       </script>
     
       <!-- Image URLs -->
       <script id="image-data">
         window.images = ["https://ordinals.com/content/01c48d3cceb02215bc3d44f9a2dc7fba63ea63719a2ef1c35d3f0c4db93ab8d5i0"];
       </script>
           <!-- imageLoadMgmt.js -->
           <script src="https://ordinals.com/content/a698a70c8eda8e6a58abf2e65921ca629e1734a91c67e2d74a941a2cc5c36027i0"></script>
           <!-- imageRevealCore.js -->
              <script type="module" src="https://ordinals.com/content/7b66beb111fbc673a99867f13480a3289afc522b811ddd60163b3bcbb82aa758i0"></script>
          
   
              <script type="module">
              (()=>{const el=id=>document.getElementById(id),
              t=el("playBtn"),e=el("log"),
              a=window.AudioContext||window.webkitAudioContext,
              n=el("clickToBeginText"),
              d=m=>{if(!e)return;e.textContent+=`${new Date().toLocaleTimeString()}: ${m}\n`;e.scrollTop=e.scrollHeight},
              emit=ev=>document.dispatchEvent(new Event(ev)),
              setTxt=txt=>t.textContent=txt;
              if(!a)return setTxt("Audio not supported"),t.disabled=!0;
              n||console.warn('"Click to Begin" text element not found in playbackMgmt.js context');
              let o=new a,i=new Array(audioParts.length),r=0,s=null,c=!0,l=!1;
              const u=()=>{t.disabled=c;setTxt(c?"Loading…":l?"Stop Mix":"Play Mix");},
              h=async(url,idx,first=!1)=>{first&&d(`Fetching first part → ${url}`);
              i[idx]=await o.decodeAudioData(await(await fetch(url)).arrayBuffer());
              d(`${first?"First part ready":`Decoded part ${idx+1}/${audioParts.length}`} (${i[idx].duration.toFixed(2)} s).`);};
              (async()=>{try{await h(audioParts[0],0,!0);c=!1;u();
              await Promise.all(audioParts.slice(1).map((url,idx)=>h(url,idx+1)));d("All parts decoded. ✅");}
              catch(err){c=!1;u();d(`Preload failed: ${err.message}`);}})();
              const p=()=>{if(!l)return;if(r>=i.length)return l=!1,u(),d("Finished. 🎉"),y();
              const buf=i[r];if(!buf)return d(`Part ${r+1} buffer not ready, retrying...`),setTimeout(p,200);
              (s=o.createBufferSource()).buffer=buf;s.connect(o.destination);s.start();
              d(`▶ Part ${r+1}/${i.length} (${buf.duration.toFixed(2)} s)`);r++;
              s.onended=()=>{s=null;l&&p();};},
              y=()=>emit("playbackStopped"),
              f=async()=>{if(c||l)return;if(o.state==="suspended")await o.resume();
              l=!0;r=0;u();emit("playbackStarted");p();},
              g=()=>{if(!l)return;l=!1;if(s)try{s.onended=null;s.stop();}catch(err){d(`Error stopping active source: ${err.message}`);}
              s=null;d("Stopped by user.");u();y();},
              toggle=()=>{(l?g:f)();};
              t.onclick=toggle;
              document.addEventListener("togglePlayback",toggle);
              document.addEventListener("playbackStarted",()=>{});
              document.addEventListener("playbackStopped",()=>{});})();
              </script>
   
              
        

    <!-- imageRevealPublicApi.js (inline module script that USES the import) -->
    <script type="module">
        import { setupEffect } from "https://ordinals.com/content/6addd1c637ee377bd7e3510c7e78ec35a7fb037676f2ef416131067c9d1d4cf6i0";
        (() => {
          const cfg = window.APP_CONFIG?.clickToBegin ?? {},
            txt = cfg.text ?? "CLICK TO BEGIN",
            fadeMs = cfg.fadeOutDurationMs ?? 16000,
            blinkMs = cfg.blinkIntervalMs ?? 500,
            reapMs = cfg.reappearDelayMs ?? 16000,
            el = document.getElementById("pixelTextCanvas"),
            ctx = el.getContext("2d");
          let blink;
          el.style.transition = `opacity ${fadeMs/1e3}s ease-out,transform ${fadeMs/1e3}s ease-out`;
          const blinkFn = vis => { clearInterval(blink); el.style.visibility = vis; },
            startBlink = () => { blinkFn("visible"); blink = setInterval(() => el.style.visibility = el.style.visibility === "hidden" ? "visible" : "hidden", blinkMs); };
          el.onclick = () => (blinkFn("visible"), el.classList.add("hidden"), document.getElementById("playBtn").click());
          document.addEventListener("playbackStarted", () => { if (!el.classList.contains("hidden")) blinkFn("visible"), el.classList.add("hidden"); });
          document.addEventListener("playbackStopped", () => { el.classList.remove("hidden"); setTimeout(startBlink, reapMs); });
          (() => {
            ctx.clearRect(0, 0, el.width, el.height);
            ctx.font = "bold 16px monospace"; ctx.textBaseline = "middle"; ctx.textAlign = "center"; ctx.fillStyle = "#33CCFF";
            for (let dx = -1; dx <= 1; dx++) for (let dy = -1; dy <= 1; dy++) ctx.fillText(txt, el.width/2 + dx, el.height/2 + dy);
            ctx.fillStyle = "#000"; ctx.fillText(txt, el.width/2, el.height/2);
          })();
          startBlink();
        })();
        window.addEventListener("load", async () => {
          const imgUrl = window.images?.[0];
          if (!imgUrl) return console.error("Colour Sweep Player: no image URL provided.");
          let eff = { name: "fadeIn", duration: 60 }, cfg = window.APP_CONFIG?.mainRevealEffect;
          if (cfg) eff = { name: cfg.name, duration: cfg.duration }, console.log(`Using mainRevealEffect: ${eff.name}, duration: ${eff.duration}`);
          else console.warn("mainRevealEffect not found. Using defaults.");
          try { await setupEffect(imgUrl, eff.name, eff.duration); console.log("Colour sweep ready – click to begin."); }
          catch (err) { console.error("Failed to prepare colour sweep:", err); }
        });
        </script>
        
        
        
        <div id="backgroundBlackout" style="
        position: fixed;
        inset: 0;
        background: #000;
        z-index: 0;
        pointer-events: none;
      "></div>
      
    </body>
    </html>