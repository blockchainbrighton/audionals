<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Reveal Art Program (Condensed)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        /* --- Base Styles --- */
        :root {
            --controls-bg: #f0f0f0; --canvas-bg: #000; --button-bg: #e0e0e0;
            --button-hover-bg: #d0d0d0; --text-color: #333; --border-color: #bbb;
            --slider-thumb-bg: #888; --slider-track-bg: #ddd; --error-color: #d33;
            --warning-color: #e9900a; --info-color: #666;
            --modal-bg: rgba(255, 255, 255, 0.98);
            --modal-overlay-bg: rgba(0, 0, 0, 0.6);
            --modal-border: #ccc;
            --code-bg: #eee;
            --code-text: #333;
        }
        body {
            font-family: sans-serif; display: flex; flex-direction: column; align-items: center;
            padding: 20px; background-color: #f9f9f9; color: var(--text-color); margin: 0; min-height: 100vh; box-sizing: border-box;
            transition: padding 0.3s ease;
        }
        h1 { margin-top: 0; color: #555; text-align: center; font-size: 1.5em; position: relative; display: inline-block; padding-right: 35px; transition: opacity 0.3s ease, transform 0.3s ease; }
        #controls { background-color: var(--controls-bg); padding: 15px 20px; border-radius: 8px; margin-bottom: 20px; display: grid; grid-template-columns: auto 1fr; gap: 10px 15px; align-items: center; box-shadow: 0 2px 5px rgba(0,0,0,0.1); border: 1px solid var(--border-color); max-width: 600px; width: 90%; transition: opacity 0.3s ease, transform 0.3s ease, margin 0.3s ease; }
        #controls label, #controls button, #controls input, #controls select { font-size: 0.9rem; padding: 8px 10px; border-radius: 4px; border: 1px solid var(--border-color); box-sizing: border-box; }
        #controls label { border: none; padding: 0; text-align: right; font-weight: bold; white-space: nowrap; }
        #controls input[type="file"] { padding: 3px; }
        #controls button { background-color: var(--button-bg); cursor: pointer; transition: background-color 0.2s ease; width: 100%; }
        #controls button:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        #controls button:disabled { cursor: not-allowed; opacity: 0.6; }
        #controls input[type="range"] { width: 100%; cursor: pointer; appearance: none; background: var(--slider-track-bg); height: 8px; padding: 0; margin: 0 5px 0 0; vertical-align: middle; }
        #controls input[type="range"]::-webkit-slider-thumb { appearance: none; width: 16px; height: 16px; background: var(--slider-thumb-bg); border-radius: 50%; cursor: pointer; }
        #controls input[type="range"]::-moz-range-thumb { width: 16px; height: 16px; background: var(--slider-thumb-bg); border-radius: 50%; cursor: pointer; border: none; }
        .duration-control span { display: inline-block; vertical-align: middle; }
        #duration-value { display: inline-block; min-width: 45px; text-align: left; font-weight: bold; }
        .button-group { grid-column: 1 / -1; display: flex; gap: 10px; justify-content: center; margin-top: 10px; }
        .button-group button { flex: 1 1 auto; max-width: 150px; }
        #reverse-container { grid-column: 1 / -1; display: flex; align-items: center; justify-content: center; gap: 5px; margin-top: 5px; }
        .reverse-label { text-align: left; font-weight: normal; order: 1; }
        #reverse-checkbox { order: 0; width: auto; padding: 0; margin: 0; }
        .mode-options { display: none; grid-column: 1 / -1; display: grid; grid-template-columns: auto 1fr; gap: inherit; align-items: center; margin-top: 8px; padding-left: 20px; border-left: 2px solid var(--border-color); padding-top: 5px; padding-bottom: 5px; }
        .mode-options.visible { display: grid; }
        .mode-options label { font-weight: normal; font-size: 0.85rem; white-space: nowrap; }
        .mode-options .slider-container { display: flex; align-items: center; gap: 8px; }
        .mode-options .slider-container input[type="range"] { flex-grow: 1; margin: 0; }
        .mode-options .slider-container span { min-width: 35px; text-align: left; font-size: 0.85rem; font-weight: bold; }
        #canvas-container {
            width: 90%; max-width: 800px; height: auto; max-height: 75vh;
            position: relative; background-color: var(--canvas-bg); box-shadow: 0 4px 8px rgba(0,0,0,0.15); border: 1px solid var(--border-color); margin-bottom: 20px; display: flex; justify-content: center; align-items: center; overflow: hidden; min-height: 200px;
            transition: width 0.3s ease, max-width 0.3s ease, height 0.3s ease, max-height 0.3s ease, margin 0.3s ease;
            cursor: default; /* Default cursor */
         }
        #canvas-container.clickable {
             cursor: pointer; /* Indicate clickability for toggle */
         }
        canvas { display: block; max-width: 100%; max-height: 100%; object-fit: contain; background-color: transparent; }
        #status { margin-top: 10px; color: var(--info-color); min-height: 1.2em; font-style: italic; text-align: center; width: 90%; max-width: 600px; font-size: 0.9em; transition: opacity 0.3s ease, transform 0.3s ease; }
        #info-button { position: absolute; top: 50%; right: 0; transform: translateY(-50%); width: 24px; height: 24px; padding: 0; border-radius: 50%; font-size: 1em; font-weight: bold; font-family: serif; line-height: 22px; text-align: center; cursor: pointer; border: 1px solid var(--border-color); background-color: var(--button-bg); color: var(--text-color); transition: background-color 0.2s ease, opacity 0.3s ease; }
        #info-button:hover { background-color: var(--button-hover-bg); }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: var(--modal-overlay-bg); padding-top: 60px; box-sizing: border-box; }
        .modal.visible { display: block; }
        .modal-content { background-color: var(--modal-bg); margin: auto; padding: 25px 30px; border: 1px solid var(--modal-border); width: 80%; max-width: 700px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); position: relative; }
        .modal-close-button { color: #aaa; position: absolute; top: 10px; right: 15px; font-size: 28px; font-weight: bold; line-height: 1; cursor: pointer; }
        .modal-close-button:hover, .modal-close-button:focus { color: black; text-decoration: none; }
        .modal h2 { margin-top: 0; color: #444; border-bottom: 1px solid #eee; padding-bottom: 10px; margin-bottom: 20px; } .modal h3 { margin-top: 25px; margin-bottom: 10px; color: #555; } .modal p, .modal ul { font-size: 0.95em; line-height: 1.6; margin-bottom: 15px; } .modal ul { padding-left: 25px; } .modal li { margin-bottom: 8px; } .modal code { background-color: var(--code-bg); color: var(--code-text); padding: 3px 6px; border-radius: 3px; font-family: monospace; font-size: 0.9em; white-space: pre-wrap; word-wrap: break-word; } .modal strong { font-weight: bold; } .modal .indent { margin-left: 20px; } .modal .code-block { display: block; background-color: var(--code-bg); color: var(--code-text); padding: 10px 15px; border-radius: 4px; font-family: monospace; font-size: 0.9em; white-space: pre-wrap; word-wrap: break-word; margin-top: 5px; margin-bottom: 15px; }

     /* --- Fullscreen Mode Styles --- */
body.api-fullscreen-active {
    padding: 0; /* Remove padding on body itself for true fullscreen */
    overflow: hidden;
    /* Use flex on body to center container */
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh; /* Ensure body takes full height */
    background-color: var(--canvas-bg); /* Optional: Match canvas bg */
}

/* Hide UI elements completely */
body.api-fullscreen-active h1,
body.api-fullscreen-active #controls,
body.api-fullscreen-active #status,
body.api-fullscreen-active #info-button {
    display: none; /* Remove from layout flow */
    /* Keep opacity/transform for potential exit transition, though not strictly needed */
    opacity: 0;
    transform: translateY(-20px);
    pointer-events: none;
    margin: 0; /* Remove all margins */
}

/* Canvas Container in Fullscreen */
body.api-fullscreen-active #canvas-container {
    /* Container centers the canvas element */
    display: flex;
    justify-content: center;
    align-items: center;

    /* Container takes available space (now centered in body) */
    /* It doesn't need explicit size if canvas has size */
    width: auto;
    height: auto;
    max-width: 100vw; /* Constrain to viewport */
    max-height: 100vh; /* Constrain to viewport */

    /* Remove styles from non-fullscreen */
    margin: 0;
    border: none;
    box-shadow: none;
    padding: 0;
    background-color: transparent; /* Let body handle bg or canvas */
    aspect-ratio: unset !important; /* Override JS */
}

/* Canvas Element in Fullscreen */
body.api-fullscreen-active #canvas-container canvas {
    /* Set target size: 80vh square */
    height: 80vh;
    width: 80vh;

    /* Ensure it doesn't exceed viewport bounds if 80vh is too big */
    max-width: 100vw;
    max-height: 100vh;

    /* Maintain aspect ratio if constrained by max-w/h */
    object-fit: contain;

    display: block; /* Ensure it behaves as a block */
    background-color: transparent; /* Or specific color if needed */
}

/* --- API Toggle Mode Hiding --- */
#canvas-container.api-toggle-hidden canvas {
    visibility: hidden; /* Hide the canvas visually but keep layout */
    /* Alternatively, use opacity: 0; if you prefer fading */
}

.click-overlay{
    position:absolute;
    inset:0;
    display:flex;
    justify-content:center;
    align-items:center;

    font-family:'Press Start 2P',monospace;
    font-size:1.25rem;
    letter-spacing:1px;
    color:#00ff96;
    text-shadow:0 0 4px #00ff96,0 0 8px #00ff96;

    pointer-events:none;
    opacity:0;
    transition:opacity .35s ease-out;
}
.click-overlay.visible{opacity:1}
.hidden{opacity:0}

</style>
    <script type="importmap">
     {
       "imports": {
         "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
         "@tweenjs/tween.js": "https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.esm.js"
       }
     }
   </script>
</head>
<body>
    <h1>Image Reveal Art Program <button id="info-button" title="Show Instructions">i</button></h1>

    <div id="controls">
        <!-- Controls -->
        <label for="file-input">Image:</label>
        <input type="file" id="file-input" accept="image/webp, image/jpeg, image/png">
        <label for="duration-slider">Duration:</label>
        <span class="duration-control"> <input type="range" id="duration-slider" min="0.5" max="300" step="0.1" value="5"> <span id="duration-value">5.0s</span> </span>
        <label for="mode-select">Mode:</label>
        <select id="mode-select"> <option value="simpleFade">Simple Fade</option> <option value="pixelRandom">Pixel-by-Pixel Random</option> <option value="lineByLineRow">Line-by-Line (Rows)</option> <option value="lineByLineCol">Line-by-Line (Columns)</option> <option value="geometricCircle">Geometric (Circle Expand)</option> <option value="geometricGrid">Geometric (Grid Cells Random)</option> <option value="colorSweepBright">Color Sweep (Brightness)</option> <option value="regionTracing">Region Tracing (Blocks)</option> <option value="outlineDrawing">Outline Drawing</option> <option value="radialWipe">Radial Wipe</option> <option value="blurToFocus">Blur-to-Focus</option> <option value="mosaic">Mosaic/Pixelation</option> <option value="waveScanH">Wave Scan (Horizontal)</option> <option value="waveScanV">Wave Scan (Vertical)</option> <option value="dissolveNoise">Dissolve (Noise)</option> <option value="texturedDissolve">Dissolve (Textured)</option> <option value="pixelSortBrightnessRow">Pixel Sorting (Bright Row)</option> <option value="tileFlip3D">3D Tile Flip</option> <option value="channelStripWipe">Channel Strip Wipe</option> <option value="gradientMaskWipeLR">Gradient Wipe (Left-Right)</option> <option value="gradientMaskWipeRadial">Gradient Wipe (Radial)</option> <option value="agentReveal">Agent Reveal</option> <option value="glyphReveal">Glyph Reveal</option> <option value="scanlineStretchV">Scanline Stretch (Vertical)</option> <option value="scanlineStretchH">Scanline Stretch (Horizontal)</option> </select>
        <div id="reverse-container"> <input type="checkbox" id="reverse-checkbox" disabled> <label for="reverse-checkbox" class="reverse-label">Reverse</label> </div>
        <div id="mode-options-agentReveal" class="mode-options"> <label for="agent-speed-slider">Agent Speed:</label> <span class="slider-container"> <input type="range" id="agent-speed-slider" min="0.1" max="10" step="0.1" value="2.5"> <span id="agent-speed-value">2.5</span> </span> <label for="agent-radius-slider">Agent Radius:</label> <span class="slider-container"> <input type="range" id="agent-radius-slider" min="1" max="100" step="1" value="15"> <span id="agent-radius-value">15</span> </span> </div>
        <div id="mode-options-glyphReveal" class="mode-options"> <label for="glyph-order-select">Glyph Order:</label> <select id="glyph-order-select"> <option value="random">Random</option> <option value="brightness">Brightness</option> </select> </div>
        <div class="button-group"> <button id="play-button" disabled>Play</button> <button id="pause-button" disabled>Pause</button> <button id="restart-button" disabled>Restart</button> </div>
    </div>

    <div id="canvas-container">
        <span>Load an image to begin</span>
        <!-- Retro “Click to Begin” overlay -->
        <div id="click-overlay" class="click-overlay hidden">Click&nbsp;to&nbsp;Begin</div>
    </div>

    <div id="status"></div>

    <!-- Info Modal -->
    <div id="info-modal" class="modal">
        <div class="modal-content">
            <span id="modal-close-button" class="modal-close-button" title="Close">×</span>
            <h2>Instructions & API Guide</h2>
             <!-- ... Basic Usage ... -->
             <h3>Keyboard Shortcuts</h3>
             <p>Use number keys (optionally with Shift/Ctrl) to trigger effects 0-29 quickly (plays immediately, disabled when typing).</p>
             <p><em>(See developer console (F12) for effect indices.)</em></p>

             <h3>API Usage (for Developers)</h3>
             <p>Use <code>window.ImageRevealAPI</code> in the developer console.</p>

             <h4><code>playEffectByIndex(index, options)</code></h4>
             <p>Loads resources (if specified) and immediately plays the effect.</p>
             <code class="code-block">ImageRevealAPI.playEffectByIndex(effectIndex, { /* ... options ... */ })</code>

             <h4><code>prepareEffectByIndex(index, options)</code></h4>
             <p>Loads resources (if specified), sets up the effect and initial canvas state. It then waits for clicks on the image/canvas area to toggle playback:</p>
             <ul>
                 <li><strong>First Click:</strong> Starts animation and audio.</li>
                 <li><strong>Second Click (while playing):</strong> Stops animation/audio and resets the visual to the start.</li>
                 <li><strong>Third Click:</strong> Starts again from the beginning.</li>
                 <li>... and so on.</li>
             </ul>
             <code class="code-block">ImageRevealAPI.prepareEffectByIndex(effectIndex, { /* ... options ... */ })</code>
             <p>Takes the same <code>options</code> as <code>playEffectByIndex</code>.</p>
             <p>Returns a Promise resolving to <code>true</code> if preparation was successful, <code>false</code> otherwise.</p>

             <h4>Examples:</h4>
             <code class="code-block">
// Play effect 0 immediately
ImageRevealAPI.playEffectByIndex(0);

// Load and prepare effect 11 (Mosaic) with audio/fullscreen, then toggle play/stop on click
ImageRevealAPI.prepareEffectByIndex(11, {
  imageUrl: 'IMAGE_URL',
  audioUrl: 'AUDIO_URL.webm',
  duration: 10,
  fullscreen: true
});
             </code>
             <!-- ... loadImageFromURL, Rest of modal ... -->
        </div>
     </div>


    <script type="module">
        import * as THREE from 'three';
        import TWEEN from '@tweenjs/tween.js';

        // --- Constants ---
        const DEBOUNCE_DELAY = 250;
        const REVERSIBLE_MODES = ['mosaic', 'pixelSortBrightnessRow', 'simpleFade', 'lineByLineRow', 'lineByLineCol', 'geometricCircle', 'radialWipe', 'blurToFocus', 'waveScanH', 'waveScanV', 'gradientMaskWipeLR', 'gradientMaskWipeRadial'];

        // --- DOM Elements ---
        const fileInput = document.getElementById('file-input');
        const durationSlider = document.getElementById('duration-slider');
        const durationValueSpan = document.getElementById('duration-value');
        const modeSelect = document.getElementById('mode-select');
        const playButton = document.getElementById('play-button');
        const pauseButton = document.getElementById('pause-button');
        const restartButton = document.getElementById('restart-button');
        const canvasContainer = document.getElementById('canvas-container');
        const statusDiv = document.getElementById('status');
        const reverseCheckbox = document.getElementById('reverse-checkbox');
        const agentOptionsContainer = document.getElementById('mode-options-agentReveal');
        const agentSpeedSlider = document.getElementById('agent-speed-slider');
        const agentSpeedValue = document.getElementById('agent-speed-value');
        const agentRadiusSlider = document.getElementById('agent-radius-slider');
        const agentRadiusValue = document.getElementById('agent-radius-value');
        const glyphOptionsContainer = document.getElementById('mode-options-glyphReveal');
        const glyphOrderSelect = document.getElementById('glyph-order-select');
        const infoButton = document.getElementById('info-button');
        const infoModal = document.getElementById('info-modal');
        const modalCloseButton = document.getElementById('modal-close-button');

        const clickOverlay = document.getElementById('click-overlay');
        const showOverlay   = () => clickOverlay?.classList.replace('hidden','visible');
        const hideOverlay   = () => clickOverlay?.classList.replace('visible','hidden');


        // --- State Variables ---
        let image = null;
        let canvasManager = null;
        let animationId = null;
        let startTime = 0;
        let pausedTime = 0;
        let isPlaying = false;
        let isPaused = false; // Note: toggle logic doesn't use pause, but keep for buttons
        let currentProgress = 0;
        let totalDuration = 5000;
        let currentMode = 'simpleFade';
        let isReversed = false;
        let modeState = {};
        let resizeTimeout = null;
        let isInAPIFullscreen = false;
        let audioContext = null; // NEW: The Web Audio API context
        let audioBuffers = []; // NEW: Array to hold decoded AudioBuffer objects
        let activeSourceNodes = []; // NEW: Array to hold currently scheduled/playing source nodes
        let audioContextStartTime = 0; // NEW: Tracks when playback started within the context clock
        let totalAudioSequenceDuration = 0; // NEW: Calculated total duration of the sequence
        let audioLoadState = 'idle'; // NEW: 'loading', 'loaded', 'error'


        
        let isToggleModeActive = false; // NEW: True if prepareEffectByIndex was called and we are waiting for/handling toggle clicks
        let clickToggleHandler = null;  // NEW: Store the persistent toggle handler reference


        // === Helper Functions ===
        function getPixelIndex(x, y, w) { return (y * w + x) * 4; }
        function getBrightness(r, g, b) { return (r + g + b) / 3; }
        function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
        function setStatus(n,s="info"){const t=n.includes("Click image to play/stop")||n.includes("Playing...")||n.includes("Finished");isInAPIFullscreen&&!t||(statusDiv.textContent=n,statusDiv.className=s),"error"===s?console.error("Status Error:",n):"warning"===s&&console.warn("Status Warning:",n)}
        function requiresImageData(mode) { const modesNeedingData = ['pixelRandom', 'pixelSortBrightnessRow', 'regionTracing', 'outlineDrawing', 'colorSweepBright', 'channelStripWipe', 'dissolveNoise', 'texturedDissolve', 'glyphReveal']; return modesNeedingData.includes(mode); }

        // === Canvas Manager Class ===
       class CanvasManager{constructor(t,e){this.container=t,this.setStatus=e,this.canvas=null,this.ctx=null,this.three=null,this.width=0,this.height=0,this.imageData=null,this.targetImageData=null,this.targetBuffer=null,this.currentModeType=null,this.actualMode="simpleFade"}_is3DMode(t){return"tileFlip3D"===t}async initialize(t,e){this.width=t.naturalWidth,this.height=t.naturalHeight,this.actualMode=e,this.currentModeType=this._is3DMode(e)?"3d":"2d",this.container.innerHTML="",this._setContainerSize();try{return"3d"===this.currentModeType?await this._setup3D(t):await this._setup2D(t,e)}catch(t){throw this.setStatus("Error initializing canvas: "+t.message,"error"),this.dispose(!0),t}}async switchMode(t,e){if(!e)return this._is3DMode(this.actualMode)&&!this._is3DMode(t)?(this.dispose(!1),this.currentModeType="2d"):!this._is3DMode(this.actualMode)&&this._is3DMode(t)&&(this.dispose(!1),this.currentModeType="3d"),this.actualMode=t,this.clear(),!0;const i=this._is3DMode(t)?"3d":"2d";if(this.actualMode=t,i===this.currentModeType){if("2d"===this.currentModeType&&this.canvas){if(this._cleanup2DContext(!1),this.ctx=this.canvas.getContext("2d",{willReadFrequently:requiresImageData(t)}),!this.ctx)throw new Error("Failed to get 2D context after mode switch");this.ctx.imageSmoothingEnabled=!0,this.imageData||this._cacheImageData(e)}return!0}this.dispose(!1),this.currentModeType=i,this.width=e.naturalWidth,this.height=e.naturalHeight,this._setContainerSize();try{return"3d"===this.currentModeType?await this._setup3D(e):await this._setup2D(e,t),!0}catch(t){console.error(`Error switching to ${i} mode:`,t),this.setStatus(`Error setting up ${i} mode. Reverting.`,"error"),this.dispose(!1),this.currentModeType="2d",this.actualMode="simpleFade";try{await this._setup2D(e,"simpleFade")}catch(t){return console.error("Fallback 2D setup failed:",t),this.setStatus("Critical error setting up canvas.","error"),this.dispose(!0),!1}return!1}}_setup2D(t,e){return new Promise(((i,a)=>{try{if(this.canvas=document.createElement("canvas"),this.canvas.width=this.width,this.canvas.height=this.height,this.container.appendChild(this.canvas),this.ctx=this.canvas.getContext("2d",{willReadFrequently:requiresImageData(e)}),!this.ctx)throw new Error("Could not get 2D canvas context.");this.ctx.imageSmoothingEnabled=!0,this._cacheImageData(t),!this.imageData&&requiresImageData(e)&&this.setStatus("Warning: Could not access pixel data. Some effects limited.","warning"),t&&this.ctx&&!this.imageData&&!requiresImageData(e)&&this.ctx.drawImage(t,0,0),i()}catch(t){a(t)}}))}_setup3D(t){return new Promise(((t,e)=>{try{this.container.clientWidth&&this.container.clientHeight||console.warn("Canvas container zero dimensions during 3D setup. Check timing.");const e=this.width/this.height,i=12,a=Math.max(1,Math.round(i/e)),s=[],r=10/e,h=THREE.MathUtils.degToRad(camera.fov);camera.position.z=r/2/Math.tan(h/2),camera.position.z*=1.1,camera.position.z=Math.max(1,camera.position.z);for(let t=0;t<a;t++)for(let t=0;t<i;t++){new THREE.PlaneGeometry(tileW,tileH);uvs.setXY(0,u0,v0),uvs.setXY(1,u1,v0),uvs.setXY(2,u0,v1),uvs.setXY(3,u1,v1),uvs.needsUpdate=!0;new THREE.MeshStandardMaterial({map:texture,side:THREE.DoubleSide,roughness:.8,metalness:.1,transparent:!0,alphaTest:.1})}this.three={scene:scene,camera:camera,renderer:renderer,objects:s,texture:texture},this.updateSize(),t()}catch(t){this._cleanup3D(),e(t)}}))}_cacheImageData(t){if(this.imageData=this.targetImageData=this.targetBuffer=null,this.ctx&&t&&this.width&&this.height)try{this.ctx.drawImage(t,0,0),this.imageData=this.ctx.getImageData(0,0,this.width,this.height),this.targetImageData=this.ctx.createImageData(this.width,this.height),this.targetBuffer=this.targetImageData.data}catch(t){console.error("CanvasManager: Error getting ImageData (tainted canvas?):",t),this.imageData=this.targetImageData=this.targetBuffer=null,this.setStatus("Error: Could not access image pixel data. Some effects requiring pixel access will not work.","error")}}updateSize(){if(this._setContainerSize(),"3d"===this.currentModeType&&this.three&&this.canvas){const t=this.canvas.clientWidth,e=this.canvas.clientHeight;if(t>0&&e>0&&this.three.renderer&&this.three.camera){const i=this.three.renderer.getSize(new THREE.Vector2);i.x===t&&i.y===e||(console.log(`Resizing 3D renderer to: ${t} x ${e}`),this.three.renderer.setSize(t,e),this.three.camera.aspect=t/e,this.three.camera.updateProjectionMatrix())}}}_setContainerSize(){if(this.width>0&&this.height>0&&!isInAPIFullscreen){this.container.style.aspectRatio=`${this.width} / ${this.height}`;const t=this.container.clientWidth;this.container.style.height=t>0?t*this.height/this.width+"px":"300px"}else isInAPIFullscreen?(this.container.style.aspectRatio="",this.container.style.height=""):(this.container.style.aspectRatio="auto",this.container.style.height="200px")}clear(){this.container.innerHTML="<span>Load an image to begin</span>",this.canvas=this.ctx=this.three=this.imageData=this.targetImageData=this.targetBuffer=null,this.width=this.height=0,this._setContainerSize()}_cleanup2DContext(t=!0){this.ctx=this.imageData=this.targetImageData=this.targetBuffer=null,t&&this.canvas?.parentNode&&(this.canvas.parentNode.removeChild(this.canvas),this.canvas=null)}_cleanup3D(){this.three&&(TWEEN.removeAll(),this.three.objects?.forEach((t=>{t.geometry?.dispose(),t.material&&(t.material.map?.dispose(),t.material.dispose()),this.three.scene?.remove(t)})),this.three.texture?.dispose(),this.three.renderer?.dispose(),this.three.renderer?.domElement.parentNode&&this.three.renderer.domElement.parentNode.removeChild(this.three.renderer.domElement),this.three=null,this.canvas=null)}dispose(t=!0){"3d"===this.currentModeType?this._cleanup3D():this._cleanup2DContext(!0),this.currentModeType=null,this.width=this.height=0,t&&this.clear()}getContext(){return this.ctx}getThreeContext(){return this.three}getCanvas(){return this.canvas}getImageData(){return this.imageData}canAccessImageData(){return!!this.imageData}getTargetImageData(){return this.targetImageData}getTargetBuffer(){return this.targetBuffer}getWidth(){return this.width}getHeight(){return this.height}getModeType(){return this.currentModeType}getCurrentMode(){return this.actualMode}}
        // === Pixel Processing & Renderer Wrapper ===
        function processImageData(srcImgData,targetBuf,w,h,p,fn){ const src=srcImgData.data;if(!src||!targetBuf)return;targetBuf.fill(0); for(let y=0;y<h;y++)for(let x=0;x<w;x++){const i=getPixelIndex(x,y,w);const r=fn(src[i],src[i+1],src[i+2],src[i+3],x,y,i,p);targetBuf[i]=r.r;targetBuf[i+1]=r.g;targetBuf[i+2]=r.b;targetBuf[i+3]=r.a;} }
        const create2DRenderer=(logic,opt={needsClear:false})=>{ const wrapped=(p,cm,img,state)=>{ const ctx=cm.getContext(),w=cm.getWidth(),h=cm.getHeight(); if(!ctx||!img||w<=0||h<=0)return; if(opt.needsClear==='always'||(opt.needsClear&&(state.lastRenderedProgress<0||p<state.lastRenderedProgress)))ctx.clearRect(0,0,w,h); ctx.save(); try{logic(p,ctx,img,w,h,state,cm);}catch(e){console.error(e);setStatus(`Runtime Error ${cm.getCurrentMode()}`,'error');stopAnimation(true);}finally{ctx.restore();state.lastRenderedProgress=p;} }; wrapped.__isWrapped=true;return wrapped; };


// --- Initialization ---
function init(){try{window.AudioContext=window.AudioContext||window.webkitAudioContext,window.AudioContext?(audioContext=new AudioContext,"suspended"===audioContext.state&&console.log("AudioContext created in suspended state. Will resume on interaction.")):(console.warn("Web Audio API not supported in this browser."),setStatus("Warning: Advanced audio playback not supported.","warning"))}catch(t){console.error("Error creating AudioContext:",t),setStatus("Error initializing audio system.","error")}canvasManager=new CanvasManager(canvasContainer,setStatus),setupEventListeners(),updateDurationDisplay(),updateModeOptionControls(),setupModal(),setupEscapeListener(),setStatus("Load an image to start.")}
/**
 * Fetches and decodes multiple audio URLs into AudioBuffers. Optimized for clarity.
 * @param {string[]} urls - Array of audio URLs.
 * @returns {Promise<AudioBuffer[]>} - Promise resolving to an array of successfully decoded AudioBuffers.
 */
 async function _loadAudioBuffers(o){if(!audioContext)return console.warn("Web Audio API context not available. Cannot load audio buffers."),audioLoadState="error",[];if(0===o.length)return audioLoadState="loaded",[];audioLoadState="loading",setStatus(`Loading ${o.length} audio file(s)...`,"info"),console.log(`Web Audio: Starting load for ${o.length} URLs.`);const e=o.map((async(e,t)=>{try{const o=await fetch(e);if(!o.ok)throw new Error(`HTTP error! status: ${o.status} for ${e}`);const t=await o.arrayBuffer();let a;return a=1===audioContext.decodeAudioData.length?await audioContext.decodeAudioData(t):await new Promise(((o,e)=>{audioContext.decodeAudioData(t,o,e)})),a}catch(a){return console.error(`Failed to load or decode audio (${t+1}/${o.length}): ${e}`,a),setStatus(`Error loading/decoding audio: ${e.substring(0,40)}...`,"error"),null}})),t=(await Promise.all(e)).filter((o=>o instanceof AudioBuffer));if(t.length===o.length)audioLoadState="loaded",setStatus(`Successfully loaded and decoded ${t.length} audio file(s).`,"info"),console.log(`Web Audio: All ${t.length} buffers loaded successfully.`);else{audioLoadState="error";const e=o.length-t.length;setStatus(`Warning: ${e} of ${o.length} audio file(s) failed to load/decode.`,"warning"),console.warn(`Web Audio: Loading finished with ${e} failure(s).`)}return totalAudioSequenceDuration=t.reduce(((o,e)=>o+(e&&e.duration>0?e.duration:0)),0),console.log(`Web Audio: Total calculated audio duration: ${totalAudioSequenceDuration.toFixed(3)}s`),t}

// --- Helper to ensure AudioContext is running ---
// (No changes needed, looks good)
async function ensureAudioContextRunning(){if(!audioContext)return!1;if("suspended"===audioContext.state){console.log("Attempting to resume suspended AudioContext...");try{return await audioContext.resume(),"running"===audioContext.state?(console.log("AudioContext resumed successfully."),!0):(console.warn("AudioContext state still not 'running' immediately after resume attempt."),!0)}catch(e){return console.error("Failed to resume AudioContext:",e),setStatus("Audio Error: Could not resume. Please click again or interact with the page.","error"),!1}}return!0}

function removeClickToggleListener(){clickToggleHandler&&(canvasContainer.removeEventListener("click",clickToggleHandler),clickToggleHandler=null),canvasContainer.classList.remove("clickable","api-toggle-hidden"),hideOverlay(),isToggleModeActive=!1}
        // --------------------- Event Listeners ---------------------
        function setupEventListeners(){fileInput.addEventListener("change",handleFileLoad),durationSlider.addEventListener("input",handleDurationChange),modeSelect.addEventListener("change",handleModeChange),reverseCheckbox.addEventListener("change",handleReverseChange),playButton.addEventListener("click",(()=>{removeClickToggleListener(),playAnimation()})),pauseButton.addEventListener("click",pauseAnimation),restartButton.addEventListener("click",(()=>{removeClickToggleListener(),restartAnimation()})),window.addEventListener("resize",(()=>{clearTimeout(resizeTimeout),resizeTimeout=setTimeout(handleResize,DEBOUNCE_DELAY)})),agentSpeedSlider.addEventListener("input",(()=>{const e=+agentSpeedSlider.value.toFixed(1);agentSpeedValue.textContent=e,modeState&&(modeState.agentBaseSpeed=e)})),agentRadiusSlider.addEventListener("input",(()=>{const e=+agentRadiusSlider.value;agentRadiusValue.textContent=e,modeState&&(modeState.revealRadius=e)})),glyphOrderSelect.addEventListener("change",(()=>{modeState&&(modeState.glyphOrder=glyphOrderSelect.value),isPlaying||isPaused?setStatus("Restart animation to apply Glyph Order change.","warning"):image&"glyphReveal"===tMode&&(initializeModeState(),drawInitialState())}))}

        // --- Modal & Escape ---
        function setupModal() { /* ... unchanged ... */ if (!infoButton || !infoModal || !modalCloseButton) { console.error("Modal elements not found!"); return; } infoButton.addEventListener('click', () => { infoModal.classList.add('visible'); }); modalCloseButton.addEventListener('click', () => { infoModal.classList.remove('visible'); }); infoModal.addEventListener('click', (event) => { if (event.target === infoModal) { infoModal.classList.remove('visible'); } }); }
        function setupEscapeListener(){window.addEventListener("keydown",(e=>{"Escape"===e.key&&(infoModal.classList.contains("visible")?infoModal.classList.remove("visible"):isInAPIFullscreen&&exitAPIFullscreen())}))}

        // === UI Updates ===
        function updateDurationDisplay(durationSeconds = null) { /* ... unchanged ... */ if (durationSeconds !== null && !isNaN(durationSeconds) && durationSeconds >= parseFloat(durationSlider.min) && durationSeconds <= parseFloat(durationSlider.max)) { durationSlider.value = durationSeconds.toFixed(1); } totalDuration = parseFloat(durationSlider.value) * 1000; durationValueSpan.textContent = `${parseFloat(durationSlider.value).toFixed(1)}s`; }
        function updateButtonStates(){const a=isToggleModeActive;playButton.disabled=a||isPlaying||!image,pauseButton.disabled=a||!isPlaying||isPaused,restartButton.disabled=a||!image,a||isPlaying||isPaused||!image||(playButton.disabled=!1,pauseButton.disabled=!0)}
        function updateModeOptionControls() { /* ... unchanged ... */ const mode = modeSelect.value; agentOptionsContainer.classList.remove('visible'); glyphOptionsContainer.classList.remove('visible'); if (mode === 'agentReveal') { agentOptionsContainer.classList.add('visible'); const currentSpeed = modeState?.agentBaseSpeed ?? parseFloat(agentSpeedSlider.getAttribute('value')); const currentRadius = modeState?.revealRadius ?? parseFloat(agentRadiusSlider.getAttribute('value')); agentSpeedSlider.value = currentSpeed; agentSpeedValue.textContent = currentSpeed.toFixed(1); agentRadiusSlider.value = currentRadius; agentRadiusValue.textContent = currentRadius; } else if (mode === 'glyphReveal') { glyphOptionsContainer.classList.add('visible'); glyphOrderSelect.value = modeState?.glyphOrder ?? glyphOrderSelect.options[0].value; } reverseCheckbox.disabled = !REVERSIBLE_MODES.includes(mode); if (reverseCheckbox.disabled && reverseCheckbox.checked) { reverseCheckbox.checked = false; isReversed = false; } else { isReversed = reverseCheckbox.checked && !reverseCheckbox.disabled; } }

        // === Image Handling ===
        function handleFileLoad(e){const t=e.target.files[0];if(!t||!t.type.startsWith("image/"))return void setStatus("Please select a valid image file (webp, jpg, png).","warning");setStatus("Loading image..."),removeClickToggleListener(),_stopAudioSequenceWebAudio(),stopAnimation(!1),updateButtonStates();const a=new FileReader;a.onload=e=>{const t=new Image;t.onload=async()=>{image=t,currentMode=modeSelect.value,updateModeOptionControls(),isReversed=!1,reverseCheckbox.checked=!1,reverseCheckbox.disabled=!REVERSIBLE_MODES.includes(currentMode);try{setStatus("Initializing canvas..."),await canvasManager.initialize(image,currentMode),initializeModeState(),drawInitialState(),setStatus("Image loaded. Ready."),updateButtonStates()}catch(e){console.error("Init Error:",e),setStatus(`Error initializing after image load: ${e.message}`,"error"),image=null,canvasManager.clear(),updateButtonStates()}},t.onerror=()=>{setStatus("Error loading image data (Image.onerror).","error"),updateButtonStates(),image=null},t.src=e.target.result},a.onerror=()=>{setStatus("Error reading file (FileReader.onerror).","error"),updateButtonStates(),image=null},a.readAsDataURL(t)}        // === Mode/State Initialization ===
        function drawInitialState(){if(currentProgress=0,pausedTime=0,isPaused=!1,!image||!canvasManager.getCanvas())return void canvasManager.clear();const e=canvasManager,r=currentMode,t=e.getContext();if(initializeModeState(),isReversed)if("2d"===e.getModeType()&&t)t.clearRect(0,0,e.getWidth(),e.getHeight()),t.globalAlpha=1,t.globalCompositeOperation="source-over",t.filter="none",t.drawImage(image,0,0,e.getWidth(),e.getHeight()),currentProgress=1;else if("3d"===e.getModeType()&&"tileFlip3D"===r){update3DTiles(1);const r=e.getThreeContext();r&&r.renderer&&r.scene&&r.camera&&r.renderer.render(r.scene,r.camera),currentProgress=1}else currentProgress=0;else{const a=["agentReveal","glyphReveal","mosaic","pixelSortBrightnessRow","tileFlip3D"];if("2d"===e.getModeType()&&t)t.clearRect(0,0,e.getWidth(),e.getHeight()),t.globalAlpha=1,t.globalCompositeOperation="source-over",t.filter="none",a.includes(r)&&revealModes[r]&&revealModes[r](0,e,image,modeState),currentProgress=0;else if("3d"===e.getModeType()&&"tileFlip3D"===r){update3DTiles(0);const r=e.getThreeContext();r&&r.renderer&&r.scene&&r.camera&&r.renderer.render(r.scene,r.camera),currentProgress=0}else t&&t.clearRect(0,0,e.getWidth(),e.getHeight()),currentProgress=0}}
        function drawFinalFrame(){if(!image||!canvasManager)return;const e=canvasManager,r=e.getContext();if("2d"===e.getModeType()&&r)r.globalAlpha=1,r.globalCompositeOperation="source-over",r.filter="none",r.clearRect(0,0,e.getWidth(),e.getHeight()),r.drawImage(image,0,0,e.getWidth(),e.getHeight());else if("3d"===e.getModeType()){update3DTiles(1);const r=e.getThreeContext();r&&r.renderer&&r.scene&&r.camera&&r.renderer.render(r.scene,r.camera)}currentProgress=1}
        function initializeModeState() { /* ... unchanged ... */ modeState = {}; TWEEN.removeAll(); if (currentMode === 'agentReveal') { modeState.agentBaseSpeed = parseFloat(agentSpeedSlider.value); modeState.revealRadius = parseFloat(agentRadiusSlider.value); } else if (currentMode === 'glyphReveal') { modeState.glyphOrder = glyphOrderSelect.value; } const initializer = modeInitializers[currentMode]; if (initializer) { try { if (requiresImageData(currentMode) && !canvasManager.canAccessImageData()) { if (currentMode === 'glyphReveal' && modeState.glyphOrder !== 'brightness') { setStatus(`Warning: Glyph brightness order unavailable without pixel access, using Random.`, 'warning'); modeState.glyphOrder = 'random'; glyphOrderSelect.value = 'random'; } else { throw new Error(`Mode '${currentMode}' requires pixel access which failed or is unavailable.`); } } initializer(canvasManager, modeState); } catch (error) { console.error(`Error initializing state for mode '${currentMode}':`, error); setStatus(`Error setting up mode ${currentMode}. Effect may fail. ${error.message}`, 'error'); playButton.disabled = true; } } const ctx = canvasManager.getContext(); if (ctx) { ctx.globalAlpha = 1.0; ctx.filter = 'none'; ctx.globalCompositeOperation = 'source-over'; } modeState.lastRenderedProgress = -1; modeState.lastDrawnIndex = 0; modeState.needsClear = false; modeState.lastFlippedTileIndex = 0; modeState.isTileFlipping = []; }

        // === Animation Control ===
               // --- Modified Animation Control ---

              /**
 * Starts playback for both Visuals and Web Audio sequence.
 */
 async function playAnimation(){if(isPlaying)return void console.log("playAnimation called while already playing. Ignoring.");if(!image||!canvasManager.getCanvas())return void console.log("playAnimation prerequisites (image/canvas) not met.");let a=!1;if(audioContext&&audioBuffers.length>0){if(a=await ensureAudioContextRunning(),!a)return setStatus("Audio context not ready. Click again or interact.","warning"),void console.warn("Aborting playback start: Audio context not ready.")}else a=!0;!requiresImageData(currentMode)||canvasManager.canAccessImageData()?(playAnimationVisualsOnly(),audioContext&&"loaded"===audioLoadState&&audioBuffers.length>0?_playAudioSequenceWebAudio():audioBuffers.length>0&&console.warn("playAnimation: Audio buffers loaded, but context missing or not ready. Audio won't play.")):setStatus("Cannot play visuals: pixel data unavailable.","error")}

/**
 * Pauses the visual animation and Stops the Web Audio sequence.
 * NOTE: True pause/resume for precisely scheduled Web Audio is complex.
 * This simplifies Pause to stop audio playback, requiring a full restart of the audio sequence on resume.
 */
 function pauseAnimation(){isPlaying&&!isPaused&&(console.log("Pausing: Stopping visuals & Web Audio sequence."),animationId&&(cancelAnimationFrame(animationId),animationId=null),_stopAudioSequenceWebAudio(),isPaused=!0,isPlaying=!1,pausedTime=performance.now()-startTime,updateButtonStates(),setStatus(`Paused at ${Math.round(100*currentProgress)}%`,"info"))}

/**
 * Stops the visual animation and the Web Audio sequence completely.
 * @param {boolean} resetVisual - Whether to reset the canvas to the initial state.
 * @param {boolean} calledByToggle - Internal flag for toggle mode logic.
 */
 function stopAnimation(e=!0,a=!1){const t=isPlaying;console.log(`Stopping Animation. Reset Visual: ${e}, Called by Toggle: ${a}`),animationId&&(cancelAnimationFrame(animationId),animationId=null),_stopAudioSequenceWebAudio(),isPlaying=!1,isPaused=!1,startTime=0,pausedTime=0,"3d"===canvasManager?.getModeType()&&TWEEN.removeAll(),a?e&&image&&(initializeModeState(),drawInitialState(),setStatus("Ready. Click image to play/stop.","info")):(removeClickToggleListener(),e&&image?(initializeModeState(),drawInitialState(),setStatus("Ready.","info")):t?setStatus(`Finished (${currentMode}${isReversed?" - Reversed":""}).`,"info"):image?setStatus("Ready.","info"):(canvasManager?.clear(),setStatus("Load an image to start.","info"))),currentProgress=0,updateButtonStates()}
/**
 * Restarts the animation and the full audio sequence from the beginning.
 */
 function restartAnimation(){console.log("Restarting animation..."),removeClickToggleListener(),image&&canvasManager.getCanvas()&&(stopAnimation(!1),playAnimation())}

/**
 * Starts ONLY the visual animation loop using requestAnimationFrame.
 * Sets the isPlaying flag.
 */
 function playAnimationVisualsOnly(){if(isPlaying||!image||!canvasManager.getCanvas())return;if(requiresImageData(currentMode)&&!canvasManager.canAccessImageData())return console.error("playAnimationVisualsOnly: Cannot start - pixel data unavailable."),void setStatus("Cannot play visuals: pixel data unavailable.","error");console.log("Starting visual animation loop."),hideOverlay(),isPlaying=!0,isPaused=!1;const a=performance.now();startTime=pausedTime?a-pausedTime:a,pausedTime=0,0===currentProgress&&initializeModeState(),setStatus("Playing…","info"),animationId=requestAnimationFrame(animationLoop),updateButtonStates()}


/**
 * Plays the loaded audio buffers sequentially using Web Audio API.
 * Assumes audioContext is running and buffers are loaded.
 */
 function _playAudioSequenceWebAudio(){if(!audioContext||"running"!==audioContext.state||"loaded"!==audioLoadState||0===audioBuffers.length)return void console.error("Web Audio: Preconditions not met in _playAudioSequenceWebAudio.",{contextState:audioContext?.state,loadState:audioLoadState,bufferCount:audioBuffers.length});_stopAudioSequenceWebAudio(),console.log("Web Audio: Starting playback sequence..."),audioContextStartTime=audioContext.currentTime;let e=0;activeSourceNodes=audioBuffers.map(((o,t)=>{if(!o||o.duration<=0)return console.warn(`Web Audio: Skipping invalid buffer at index ${t}.`),null;const u=audioContext.createBufferSource();u.buffer=o,u.connect(audioContext.destination);const n=audioContextStartTime+e;try{u.start(n)}catch(e){console.error(`Web Audio: Error starting source node ${t}:`,e);try{u.disconnect()}catch(e){}return null}return t===findLastValidBufferIndex(audioBuffers)&&(u.onended=()=>{const e=activeSourceNodes.length>0;activeSourceNodes=[],audioContextStartTime=0,e?console.log("Web Audio: Full sequence playback naturally finished."):console.log("Web Audio: Last node ended, but likely due to manual stop.")}),e+=o.duration,u})).filter((e=>null!==e)),0===activeSourceNodes.length&&audioBuffers.length>0?(console.error("Web Audio: Failed to schedule any valid audio buffers for playback."),setStatus("Audio Error: Playback failed to start.","error")):activeSourceNodes.length<audioBuffers.length&&console.warn(`Web Audio: Only scheduled ${activeSourceNodes.length} out of ${audioBuffers.length} buffers successfully.`)}
// Helper function to find the index of the last valid buffer
function findLastValidBufferIndex(n){for(let r=n.length-1;r>=0;r--)if(n[r]&&n[r].duration>0)return r;return-1}
/**
 * Stops all currently scheduled or playing Web Audio source nodes.
 */
 function _stopAudioSequenceWebAudio(){activeSourceNodes.length>0&&(console.log(`Web Audio: Stopping ${activeSourceNodes.length} active source node(s).`),activeSourceNodes.forEach((e=>{if(e)try{e.onended=null,e.stop(0),e.disconnect()}catch(e){}})),activeSourceNodes=[]),audioContextStartTime=0}

/**
 * The main visual animation loop.
 */
 function animationLoop(e){if(!isPlaying)return;if("3d"===canvasManager.getModeType()){TWEEN.update(e);const r=canvasManager.getThreeContext();r?.renderer&&r.scene&&r.camera&&r.renderer.render(r.scene,r.camera)}const r=e-startTime;currentProgress=totalDuration>0?Math.min(r/totalDuration,1):1;const n=isReversed?1-currentProgress:currentProgress;if(n===modeState.lastRenderedProgress&&"3d"!==canvasManager.getModeType())return void(animationId=requestAnimationFrame(animationLoop));const o=revealModes[currentMode];if(o&&"3d"!==canvasManager.getModeType())try{o(n,canvasManager,image,modeState)}catch(e){return console.error(`Runtime Error in mode '${currentMode}':`,e),setStatus(`Runtime Error: ${e.message}`,"error"),void stopAnimation(!0)}else{if(!o&&"3d"!==canvasManager.getModeType())return console.error(`Error: No render function found for mode '${currentMode}'.`),void stopAnimation(!0);if("tileFlip3D"===currentMode&&o)try{o(n,canvasManager,image,modeState)}catch(e){return console.error(`Runtime Error in mode '${currentMode}':`,e),setStatus(`Runtime Error: ${e.message}`,"error"),void stopAnimation(!0)}}currentProgress>=1?(console.log("Visual animation finished (progress >= 1)."),isReversed?drawInitialState():drawFinalFrame(),stopAnimation(!1)):animationId=requestAnimationFrame(animationLoop)}


        // === Event Handlers ===
        function handleDurationChange() { /* ... unchanged ... */ updateDurationDisplay(); if (isPlaying || isPaused) { const elapsedProportion = currentProgress; const newStartTime = performance.now() - (elapsedProportion * totalDuration); if (isPlaying) startTime = newStartTime; if (isPaused) { pausedTime = elapsedProportion * totalDuration; startTime = performance.now() - pausedTime; } } }
        function handleReverseChange(){removeClickToggleListener();const e=reverseCheckbox.checked;e!==isReversed&&(isReversed=e,isPlaying||isPaused||image&&drawInitialState())}
        async function handleModeChange(){removeClickToggleListener();const e=modeSelect.value;if(e===currentMode&&image)return void updateModeOptionControls();currentMode;currentMode=e,currentAudio&&(currentAudio.pause(),currentAudio=null),stopAnimation(!1),updateModeOptionControls(),image}
        function handleResizeDebounced() { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(handleResize, DEBOUNCE_DELAY); }
        function handleResize(){if(!canvasManager||!image||!canvasManager.getCanvas())return;const e=isToggleModeActive;if(canvasManager.updateSize(),isPlaying){const e=revealModes[currentMode];if(e){const a=isReversed?1-currentProgress:currentProgress;try{e(a,canvasManager,image,modeState)}catch(e){console.error("Resize redraw error:",e),stopAnimation(!0,!1)}}const a=canvasManager.getThreeContext();a?.renderer&&a.renderer.render(a.scene,a.camera)}else if(isPaused){const e=revealModes[currentMode];if(e){const a=isReversed?1-currentProgress:currentProgress;try{e(a,canvasManager,image,modeState)}catch(e){console.error("Resize redraw error (paused):",e)}}const a=canvasManager.getThreeContext();a?.renderer&&a.renderer.render(a.scene,a.camera),setStatus(`Paused at ${Math.round(100*currentProgress)}%`,"info")}else drawInitialState(),e?(canvasContainer.classList.add("api-toggle-hidden"),setStatus("Ready. Click image to play/stop.","info"),canvasContainer.classList.add("clickable")):image?setStatus("Ready.","info"):setStatus("Load an image to start.","info")}

        // === Reveal Algorithms & Initializers ===
        const revealModes = { 
             simpleFade: create2DRenderer((p, ctx, img) => { ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); ctx.globalAlpha = p; ctx.drawImage(img, 0, 0); }), lineByLineRow: create2DRenderer((p, ctx, img, w, h) => { const rows = Math.ceil(p * h); ctx.clearRect(0, 0, w, h); if (rows > 0) ctx.drawImage(img, 0, 0, w, rows, 0, 0, w, rows); }), lineByLineCol: create2DRenderer((p, ctx, img, w, h) => { const cols = Math.ceil(p * w); ctx.clearRect(0, 0, w, h); if (cols > 0) ctx.drawImage(img, 0, 0, cols, h, 0, 0, cols, h); }), geometricCircle: create2DRenderer((p, ctx, img, w, h) => { const cx = w/2, cy = h/2; const maxR = Math.sqrt(Math.max(cx, w - cx)**2 + Math.max(cy, h - cy)**2); ctx.clearRect(0,0,w,h); ctx.beginPath(); ctx.arc(cx, cy, Math.max(0, p * maxR), 0, Math.PI*2); ctx.clip(); ctx.drawImage(img,0,0,w,h); }), radialWipe: create2DRenderer((p, ctx, img, w, h) => { const cx = w/2, cy = h/2; const end = p * Math.PI * 2 - Math.PI / 2; const maxR = Math.sqrt(w*w + h*h)/1.9; ctx.clearRect(0,0,w,h); ctx.beginPath(); ctx.moveTo(cx, cy); ctx.arc(cx, cy, maxR, -Math.PI / 2, end); ctx.closePath(); ctx.clip(); ctx.drawImage(img,0,0,w,h); }), blurToFocus: create2DRenderer((p, ctx, img, w, h) => { const blur = 20 * (1 - p); ctx.clearRect(0,0,w,h); ctx.filter = `blur(${Math.max(0, blur).toFixed(2)}px)`; ctx.drawImage(img,0,0,w,h); }), waveScanH: create2DRenderer((p, ctx, img, w, h) => { const ww = w*0.3, frq=10, amp=20; const frontX = p * (w+ww) - ww; ctx.clearRect(0,0,w,h); ctx.beginPath(); ctx.moveTo(0,0); for(let y=0;y<=h;y++) ctx.lineTo(Math.max(0, frontX+amp*Math.sin(y/h*2*Math.PI*frq)),y); ctx.lineTo(0,h); ctx.closePath(); ctx.clip(); ctx.drawImage(img,0,0,w,h); }), waveScanV: create2DRenderer((p, ctx, img, w, h) => { const wh = h*0.3, frq=10, amp=20; const frontY = p * (h+wh) - wh; ctx.clearRect(0,0,w,h); ctx.beginPath(); ctx.moveTo(0,0); for(let x=0;x<=w;x++) ctx.lineTo(x, Math.max(0, frontY+amp*Math.sin(x/w*2*Math.PI*frq))); ctx.lineTo(w,0); ctx.closePath(); ctx.clip(); ctx.drawImage(img,0,0,w,h); }), scanlineStretchV: create2DRenderer((p, ctx, img, w, h) => { ctx.clearRect(0,0,w,h); const rows=Math.max(1, Math.floor(p*h)); const sh=h/rows; for(let y=0;y<rows;y++) ctx.drawImage(img,0,y,w,1,0,y*sh,w,sh+1); }), scanlineStretchH: create2DRenderer((p, ctx, img, w, h) => { ctx.clearRect(0,0,w,h); const cols=Math.max(1, Math.floor(p*w)); const sw=w/cols; for(let x=0;x<cols;x++) ctx.drawImage(img,x,0,1,h,x*sw,0,sw+1,h); }),
             mosaic: create2DRenderer((p, ctx, img, w, h, state, cm) => { ctx.imageSmoothingEnabled = false; ctx.clearRect(0, 0, w, h); if (p >= 1.0) { ctx.imageSmoothingEnabled = true; ctx.drawImage(img, 0, 0, w, h); return; } if (p <= 0.0) { p = 0.0001; } const minB = 4; const maxB = Math.max(64, Math.min(w, h) / 4); const easedP = p**2; let blocks = Math.max(1, minB + Math.floor(easedP * (maxB - minB))); const aspect = w / h; let blocksX = Math.max(1, Math.min(w, Math.round(Math.sqrt(blocks*blocks * aspect)))); let blocksY = Math.max(1, Math.min(h, Math.round(blocksX / aspect))); if (blocksX >= 1 && blocksY >= 1) { state.tempCanvas = state.tempCanvas || document.createElement('canvas'); const tempCtx = state.tempCanvas.getContext('2d', { alpha: false }); state.tempCanvas.width = blocksX; state.tempCanvas.height = blocksY; tempCtx.imageSmoothingEnabled = false; tempCtx.drawImage(img, 0, 0, blocksX, blocksY); ctx.imageSmoothingEnabled = false; ctx.drawImage(state.tempCanvas, 0, 0, w, h); } else { ctx.imageSmoothingEnabled = true; ctx.drawImage(img, 0, 0, w, h); } }, { needsClear: false }),
             gradientMaskWipeLR: create2DRenderer((p, ctx, img, w, h) => { ctx.clearRect(0, 0, w, h); ctx.drawImage(img, 0, 0, w, h); const grad = ctx.createLinearGradient(0, 0, w, 0); const clampedP = Math.max(0, Math.min(1, p)); grad.addColorStop(0, 'rgba(0,0,0,1)'); grad.addColorStop(Math.max(0, clampedP - 0.01), 'rgba(0,0,0,1)'); grad.addColorStop(Math.min(1, clampedP + 0.01), 'rgba(0,0,0,0)'); grad.addColorStop(1, 'rgba(0,0,0,0)'); ctx.globalCompositeOperation = 'destination-in'; ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h); }, { needsClear: 'always' }), gradientMaskWipeRadial: create2DRenderer((p, ctx, img, w, h) => { const cx = w / 2; const cy = h / 2; const maxR = Math.sqrt(w * w + h * h) / 2; const currentR = Math.max(0, p * maxR); ctx.clearRect(0, 0, w, h); ctx.drawImage(img, 0, 0, w, h); const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(1, currentR)); const edgeWidth = 0.02 * maxR; const innerStop = Math.max(0, Math.min(1, (currentR - edgeWidth / 2) / currentR)); const outerStop = Math.min(1, (currentR + edgeWidth / 2) / currentR); grad.addColorStop(0, 'rgba(0,0,0,1)'); grad.addColorStop(innerStop, 'rgba(0,0,0,1)'); grad.addColorStop(outerStop, 'rgba(0,0,0,0)'); grad.addColorStop(1, 'rgba(0,0,0,0)'); ctx.globalCompositeOperation = 'destination-in'; ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h); }, { needsClear: 'always' }),
             colorSweepBright: (p, cm, img, state) => { const srcImgData = cm.getImageData(); const targetBuf = cm.getTargetBuffer(); const ctx = cm.getContext(); if (!ctx || !srcImgData || !targetBuf) return; processImageData(srcImgData, targetBuf, cm.getWidth(), cm.getHeight(), p, (r,g,b,a,x,y,idx,prog) => { const bright = getBrightness(r,g,b); const thresh = prog * 255; return bright <= thresh ? {r,g,b,a} : {r:0,g:0,b:0,a:0}; }); ctx.putImageData(cm.getTargetImageData(), 0, 0); state.lastRenderedProgress = p; }, dissolveNoise: (p, cm, img, state) => { const srcImgData = cm.getImageData(); const targetBuf = cm.getTargetBuffer(); const ctx = cm.getContext(); if (!ctx || !srcImgData || !targetBuf) return; processImageData(srcImgData, targetBuf, cm.getWidth(), cm.getHeight(), p, (r,g,b,a,x,y,idx,prog) => { if (Math.random() < prog) return {r,g,b,a}; else { const n = Math.random()*50; return {r:n,g:n,b:n,a:255}; } }); ctx.putImageData(cm.getTargetImageData(), 0, 0); state.lastRenderedProgress = p; }, texturedDissolve: (p, cm, img, state) => { const srcImgData = cm.getImageData(); const targetBuf = cm.getTargetBuffer(); const ctx = cm.getContext(); const noiseData = state.noiseData; if (!ctx || !srcImgData || !targetBuf || !noiseData) return; processImageData(srcImgData, targetBuf, cm.getWidth(), cm.getHeight(), p, (r,g,b,a,x,y,idx,prog) => { const noiseVal = noiseData[idx]; const thresh = prog * 255; return noiseVal <= thresh ? {r,g,b,a} : {r:0,g:0,b:0,a:0}; }); ctx.putImageData(cm.getTargetImageData(), 0, 0); state.lastRenderedProgress = p; }, channelStripWipe: (p, cm, img, state) => { const srcImgData = cm.getImageData(); const targetBuf = cm.getTargetBuffer(); const ctx = cm.getContext(); const h = cm.getHeight(); if (!ctx || !srcImgData || !targetBuf) return; const phase = 1/3; const pR=Math.min(1, p/phase), pG=Math.max(0,Math.min(1,(p-phase)/phase)), pB=Math.max(0,Math.min(1,(p-phase*2)/phase)); const rowsR=Math.ceil(pR*h), rowsG=Math.ceil(pG*h), rowsB=Math.ceil(pB*h); processImageData(srcImgData, targetBuf, cm.getWidth(), h, p, (r,g,b,a,x,y,idx,prog) => { const showR=y<rowsR, showG=y<rowsG, showB=y<rowsB; return {r:showR?r:0, g:showG?g:0, b:showB?b:0, a:(showR||showG||showB)?a:0}; }); ctx.putImageData(cm.getTargetImageData(), 0, 0); state.lastRenderedProgress = p; },
             pixelSortBrightnessRow: (p, cm, img, state) => { const ctx = cm.getContext(); const targetBuf = cm.getTargetBuffer(); const targetImgData = cm.getTargetImageData(); const srcImgData = cm.getImageData(); if (!ctx || !targetBuf || !targetImgData || !srcImgData || !state.pixelDataCache) return; const cache = state.pixelDataCache; const srcData = srcImgData.data; const w = cm.getWidth(); const h = cm.getHeight(); const sortThreshIdx = Math.floor(p * w); for (let y = 0; y < h; y++) { const rowBaseIdx = y * w; for (let x = 0; x < w; x++) { const targetPixelDataIdx = getPixelIndex(x, y, w); let srcPix; if (x < sortThreshIdx) { srcPix = cache[rowBaseIdx + x]; } else { const originalPixelDataIdx = getPixelIndex(x, y, w); srcPix = { r:srcData[originalPixelDataIdx], g:srcData[originalPixelDataIdx+1], b:srcData[originalPixelDataIdx+2], a:srcData[originalPixelDataIdx+3] }; } targetBuf[targetPixelDataIdx]=srcPix.r; targetBuf[targetPixelDataIdx+1]=srcPix.g; targetBuf[targetPixelDataIdx+2]=srcPix.b; targetBuf[targetPixelDataIdx+3]=srcPix.a; } } ctx.putImageData(targetImgData, 0, 0); state.lastRenderedProgress = p; },
             pixelRandom: (p, cm, img, state) => { const ctx = cm.getContext(); const srcImgData = cm.getImageData(); const targetBuf = cm.getTargetBuffer(); const targetImgData = cm.getTargetImageData(); if (!ctx || !srcImgData || !targetBuf || !state.pixelOrder) return; const totalPixels = state.pixelOrder.length; const showCount = Math.floor(p * totalPixels); const prevCount = state.lastDrawnIndex || 0; const srcData = srcImgData.data; if (p <= 0 || showCount < prevCount) { targetBuf.fill(0); state.lastDrawnIndex = 0; } const startIdx = Math.max(0, state.lastDrawnIndex); for (let i = startIdx; i < showCount; i++) { const targetIdx = state.pixelOrder[i] * 4; targetBuf[targetIdx]=srcData[targetIdx]; targetBuf[targetIdx+1]=srcData[targetIdx+1]; targetBuf[targetIdx+2]=srcData[targetIdx+2]; targetBuf[targetIdx+3]=srcData[targetIdx+3]; } ctx.putImageData(targetImgData, 0, 0); state.lastDrawnIndex = showCount; state.lastRenderedProgress = p; }, geometricGrid: (p, cm, img, state) => { const ctx = cm.getContext(); const w = cm.getWidth(); const h = cm.getHeight(); if (!ctx || !img || !state.gridCells) return; const showCount = Math.floor(p * state.gridCells.length); const prevCount = state.lastDrawnIndex || 0; if (p <= 0 || showCount < prevCount) { ctx.clearRect(0, 0, w, h); state.lastDrawnIndex = 0; } if (showCount > (state.lastDrawnIndex || 0)) { ctx.save(); ctx.beginPath(); const cellW = w / state.gridCols, cellH = h / state.gridRows; const drawStartIndex = state.lastDrawnIndex || 0; for (let i = drawStartIndex; i < showCount; i++) { const cellIdx = state.gridCells[i]; const gx = cellIdx % state.gridCols; const gy = Math.floor(cellIdx / state.gridCols); ctx.rect(gx * cellW, gy * cellH, cellW, cellH); } ctx.clip(); ctx.drawImage(img, 0, 0, w, h); ctx.restore(); } state.lastDrawnIndex = showCount; state.lastRenderedProgress = p; }, regionTracing: (p, cm, img, state) => { const ctx = cm.getContext(); const w = cm.getWidth(); const h = cm.getHeight(); if (!ctx || !img || !state.regions) return; const regionCount = state.regions.length; const showCount = Math.min(regionCount, Math.max(0, Math.floor(p * regionCount))); const prevCount = state.lastDrawnIndex || 0; if (p <= 0 || showCount < prevCount) { ctx.clearRect(0, 0, w, h); state.lastDrawnIndex = 0; if (showCount <= 0) { state.lastRenderedProgress = p; return; } } if (showCount > (state.lastDrawnIndex || 0)) { const drawStartIndex = state.lastDrawnIndex || 0; ctx.save(); ctx.beginPath(); for (let i = drawStartIndex; i < showCount; i++) { const r = state.regions[i]; if (!r) { console.warn(`Region tracing: undefined region at index ${i}`); continue; } ctx.rect(r.x, r.y, r.w, r.h); } ctx.clip(); ctx.drawImage(img, 0, 0, w, h); ctx.restore(); } state.lastDrawnIndex = showCount; state.lastRenderedProgress = p; }, outlineDrawing: (p, cm, img, state) => { const ctx = cm.getContext(); const targetBuf = cm.getTargetBuffer(); const targetImgData = cm.getTargetImageData(); const srcImgData = cm.getImageData(); if (!ctx || !img || !targetBuf || !state.edgesData || !state.edgePixelIndices || !srcImgData) return; const edgeP = Math.min(1, p*2); const fillP = Math.max(0, (p-0.5)*2); const showEdges = Math.floor(edgeP * state.edgePixelIndices.length); const edgeData = state.edgesData.data; const srcData = srcImgData.data; targetBuf.fill(0); for (let i = 0; i < showEdges; i++) { const dataIdx = state.edgePixelIndices[i] * 4; targetBuf[dataIdx]=edgeData[dataIdx]; targetBuf[dataIdx+1]=edgeData[dataIdx+1]; targetBuf[dataIdx+2]=edgeData[dataIdx+2]; targetBuf[dataIdx+3]=255; } if (fillP > 0) { for (let i = 0; i < srcData.length; i += 4) { const curA = targetBuf[i+3]/255; const ovrR=srcData[i], ovrG=srcData[i+1], ovrB=srcData[i+2], ovrA=srcData[i+3]/255; const finalA = ovrA * fillP + curA * (1 - ovrA * fillP); if (finalA > 1e-6) { targetBuf[i] = Math.round((ovrR * ovrA * fillP + targetBuf[i] * curA * (1 - ovrA * fillP)) / finalA); targetBuf[i+1] = Math.round((ovrG * ovrA * fillP + targetBuf[i+1] * curA * (1 - ovrA * fillP)) / finalA); targetBuf[i+2] = Math.round((ovrB * ovrA * fillP + targetBuf[i+2] * curA * (1 - ovrA * fillP)) / finalA); targetBuf[i+3] = Math.round(finalA * 255); } else { targetBuf[i+3] = 0; } } } ctx.putImageData(targetImgData, 0, 0); state.lastRenderedProgress = p; },
             agentReveal: (p, cm, img, state) => { const ctx = cm.getContext(); const w = cm.getWidth(); const h = cm.getHeight(); if (!ctx || !img || !state.agents) return; if (state.needsClear) { ctx.clearRect(0,0,w,h); state.needsClear = false; } const radius = state.revealRadius ?? 15; const speedMultiplier = state.agentBaseSpeed ?? 2.5; ctx.save(); ctx.beginPath(); state.agents.forEach(a => { const moveScale = 0.5 * speedMultiplier; a.x += (Math.random() - 0.5) * a.speed * moveScale; a.y += (Math.random() - 0.5) * a.speed * moveScale; a.x = Math.max(0, Math.min(w, a.x)); a.y = Math.max(0, Math.min(h, a.y)); ctx.moveTo(a.x + radius, a.y); ctx.arc(a.x, a.y, radius, 0, Math.PI * 2); }); ctx.clip(); ctx.drawImage(img, 0, 0, w, h); ctx.restore(); },
             glyphReveal: (p, cm, img, state) => { const ctx = cm.getContext(); const srcImgData = cm.getImageData(); const w = cm.getWidth(); const h = cm.getHeight(); if (!ctx || !img || !state.glyphGrid || !state.shuffledIndices) return; if (!srcImgData && p > 0 && state.glyphOrder === 'brightness') { console.warn("Glyph reveal: Missing image data for brightness fill."); return; } const { grid, cols, rows, cellW, cellH } = state.glyphGrid; const totalCells = grid.length; const showCount = Math.floor(p * totalCells); const srcData = srcImgData?.data; const prevCount = state.lastDrawnIndex ?? 0; if (showCount === prevCount && p !== 0 && p !== 1 && state.lastRenderedProgress === p) { return; } ctx.clearRect(0,0,w,h); ctx.strokeStyle = state.glyphOutlineColor || '#aaa'; ctx.lineWidth = 1; ctx.fillStyle = '#000'; const revealedThisFrame = new Set(); for(let i=0; i<showCount; i++) revealedThisFrame.add(state.shuffledIndices[i]); for (let i = 0; i < totalCells; i++) { const cell = grid[i]; const { x, y } = cell; if (revealedThisFrame.has(i)) { if (srcData) { const imgX = Math.min(w - 1, Math.max(0, Math.floor(x + cellW / 2))); const imgY = Math.min(h - 1, Math.max(0, Math.floor(y + cellH / 2))); const dataIdx = getPixelIndex(imgX, imgY, w); const r=srcData[dataIdx], g=srcData[dataIdx+1], b=srcData[dataIdx+2], a=srcData[dataIdx+3]; ctx.fillStyle = `rgba(${r},${g},${b},${a / 255})`; ctx.fillRect(x, y, cellW, cellH); } else { ctx.fillStyle = '#555'; ctx.fillRect(x, y, cellW, cellH); } } else { ctx.strokeRect(x + 0.5, y + 0.5, cellW - 1, cellH - 1); } } state.lastDrawnIndex = showCount; state.lastRenderedProgress = p; },
             tileFlip3D: (p, cm, img, state) => { const threeCtx = cm.getThreeContext(); if (!threeCtx || !state.tileOrder || !threeCtx.objects) return; const totalTiles = state.tileOrder.length; const targetCount = Math.floor(p * totalTiles); const prevCount = state.lastFlippedTileIndex || 0; if (targetCount > prevCount) { for (let i = prevCount; i < targetCount; i++) { const tileIdx = state.tileOrder[i]; const tile = threeCtx.objects[tileIdx]; if (tile && !state.isTileFlipping[tileIdx]) { state.isTileFlipping[tileIdx] = true; const targetY = 0; new TWEEN.Tween(tile.rotation) .to({ y: targetY }, 600) .easing(TWEEN.Easing.Quadratic.Out) .delay(Math.random() * 50) .onComplete(() => { state.isTileFlipping[tileIdx] = false; }) .start(); } } } else if (targetCount < prevCount) { for (let i = targetCount; i < prevCount; i++) { const tileIdx = state.tileOrder[i]; const tile = threeCtx.objects[tileIdx]; if (tile && !state.isTileFlipping[tileIdx]) { state.isTileFlipping[tileIdx] = true; const targetY = Math.PI; TWEEN.remove(tile.rotation); new TWEEN.Tween(tile.rotation) .to({ y: targetY }, 300) .easing(TWEEN.Easing.Quadratic.In) .onComplete(() => { state.isTileFlipping[tileIdx] = false; }) .start(); } } } state.lastFlippedTileIndex = targetCount; state.lastRenderedProgress = p; },
        };
        const modeInitializers = { 
            pixelRandom: (cm, state) => { if (!cm.canAccessImageData()) throw new Error("ImageData required."); const n=cm.getWidth()*cm.getHeight(); state.pixelOrder = shuffleArray(Array.from({ length: n }, (_, i) => i)); state.lastDrawnIndex = 0; cm.getTargetBuffer()?.fill(0); }, geometricGrid: (cm, state) => { const w = cm.getWidth(), h = cm.getHeight(); const aspect = w/h; const target = 400; state.gridCols = Math.max(1,Math.round(Math.sqrt(target*aspect))); state.gridRows = Math.max(1,Math.round(Math.sqrt(target/aspect))); const total = state.gridCols*state.gridRows; state.gridCells = shuffleArray(Array.from({ length: total }, (_, i) => i)); state.lastDrawnIndex = 0; }, regionTracing: (cm, state) => { const imgData = cm.getImageData(); const w = cm.getWidth(), h = cm.getHeight(); if (!imgData) throw new Error("ImageData required."); const cols=16, rows=16; const regions = []; const cw=w/cols, ch=h/rows; const data=imgData.data; for(let r=0; r<rows; r++){ for(let c=0; c<cols; c++){ let bright=0, count=0; const sx=Math.floor(c*cw), sy=Math.floor(r*ch); const ex=Math.min(w,Math.floor(sx+cw)), ey=Math.min(h,Math.floor(sy+ch)); for(let y=sy;y<ey;y++){ for(let x=sx;x<ex;x++){ const i=getPixelIndex(x,y,w); bright+=getBrightness(data[i],data[i+1],data[i+2]); count++; }} regions.push({ x: sx, y: sy, w: Math.max(1,ex-sx), h: Math.max(1,ey-sy), brightness: count>0?bright/count:0 }); }} regions.sort((a,b)=>a.brightness-b.brightness); state.regions=regions; state.lastDrawnIndex=0; }, outlineDrawing: (cm, state) => { const imgData = cm.getImageData(); const ctx=cm.getContext(); const w=cm.getWidth(), h=cm.getHeight(); if (!ctx || !imgData) throw new Error("Context/ImageData required."); const gray=new Uint8ClampedArray(w*h); const data=imgData.data; for(let i=0; i<data.length; i+=4) gray[i/4] = Math.round(0.299*data[i]+0.587*data[i+1]+0.114*data[i+2]); const edgeBytes=new Uint8ClampedArray(data.length); const edgeIndices=[]; const thr=50; const kX=[[-1,0,1],[-2,0,2],[-1,0,1]], kY=[[-1,-2,-1],[0,0,0],[1,2,1]]; for(let y=1;y<h-1;y++){ for(let x=1;x<w-1;x++){ let gx=0, gy=0; for(let ky=-1;ky<=1;ky++) for(let kx=-1;kx<=1;kx++) { const v=gray[(y+ky)*w+(x+kx)]; gx+=v*kX[ky+1][kx+1]; gy+=v*kY[ky+1][kx+1]; } const mag=Math.sqrt(gx*gx+gy*gy); const pIdx=(y*w+x); const dIdx=pIdx*4; if(mag>thr){ edgeBytes[dIdx]=edgeBytes[dIdx+1]=edgeBytes[dIdx+2]=200; edgeBytes[dIdx+3]=255; edgeIndices.push(pIdx); } else edgeBytes[dIdx+3]=0; }} state.edgesData=new ImageData(edgeBytes,w,h); state.edgePixelIndices=shuffleArray(edgeIndices); state.lastDrawnIndex=0; cm.getTargetBuffer()?.fill(0); },
            pixelSortBrightnessRow: (cm, state) => { const imgData = cm.getImageData(); const w=cm.getWidth(), h=cm.getHeight(); if (!imgData) throw new Error("ImageData required."); state.pixelDataCache=[]; const data=imgData.data; for(let y=0; y<h; y++){ const rowPixels = []; for(let x=0; x<w; x++){ const i=getPixelIndex(x,y,w); const r=data[i],g=data[i+1],b=data[i+2],a=data[i+3]; rowPixels.push({r,g,b,a, brightness:getBrightness(r,g,b)}); } rowPixels.sort((p1,p2)=>p1.brightness - p2.brightness); state.pixelDataCache.push(...rowPixels); } cm.getTargetBuffer()?.fill(0); state.lastRenderedProgress = -1; },
            texturedDissolve: (cm, state) => { const w=cm.getWidth(), h=cm.getHeight(); const size=w*h*4; const buf=new Uint8ClampedArray(size); for(let i=0;i<size;i+=4){ const v=Math.random()*255; buf[i]=buf[i+1]=buf[i+2]=v; buf[i+3]=255; } state.noiseData=buf; cm.getTargetBuffer()?.fill(0); }, agentReveal: (cm, state) => { const w = cm.getWidth(), h = cm.getHeight(); const numAgents = 10; state.agents = []; const baseSpeed = state.agentBaseSpeed ?? 2.5; state.revealRadius = state.revealRadius ?? 15; for (let i = 0; i < numAgents; ++i) { state.agents.push({ x: Math.random() * w, y: Math.random() * h, speed: 1 + Math.random() * 1.5 }); } state.needsClear = true; state.lastRenderedProgress = -1; }, glyphReveal: (cm, state) => { const ctx = cm.getContext(); const w = cm.getWidth(); const h = cm.getHeight(); if (!ctx) throw new Error("Context needed for glyph init."); const cellW = 10, cellH = 14; const cols = Math.max(1, Math.floor(w / cellW)); const rows = Math.max(1, Math.floor(h / cellH)); const grid = []; for (let r=0;r<rows;r++) { for (let c=0;c<cols;c++) grid.push({x: c*cellW, y: r*cellH, index: r*cols + c}); } state.glyphGrid = { grid, cols, rows, cellW, cellH }; state.glyphOutlineColor = '#aaa'; state.needsClear = true; state.lastRenderedProgress = -1; state.lastDrawnIndex = 0; const orderBy = state.glyphOrder || 'random'; if (orderBy === 'brightness') { const imgData = cm.getImageData(); if (!imgData) { throw new Error("ImageData required for Glyph Brightness sort."); } const srcData = imgData.data; const cellsWithBrightness = grid.map(cell => { const imgX = Math.min(w - 1, Math.max(0, Math.floor(cell.x + cellW / 2))); const imgY = Math.min(h - 1, Math.max(0, Math.floor(cell.y + cellH / 2))); const dataIdx = getPixelIndex(imgX, imgY, w); const brightness = getBrightness(srcData[dataIdx], srcData[dataIdx+1], srcData[dataIdx+2]); return { index: cell.index, brightness: brightness }; }); cellsWithBrightness.sort((a, b) => a.brightness - b.brightness); state.shuffledIndices = cellsWithBrightness.map(cell => cell.index); } else { state.shuffledIndices = shuffleArray(Array.from(grid.keys())); } },
            tileFlip3D: (cm, state) => { const threeCtx = cm.getThreeContext(); if (!threeCtx || !threeCtx.objects) return; TWEEN.removeAll(); threeCtx.objects.forEach(obj => { obj.rotation.y = Math.PI; obj.visible = true; }); state.lastFlippedTileIndex = 0; state.isTileFlipping = Array(threeCtx.objects.length).fill(false); state.tileOrder = shuffleArray(threeCtx.objects.map((_, i) => i)); state.lastRenderedProgress = -1; }
        };

        // === Three.js Update ===
        function update3DTiles(progress) { /* ... unchanged ... */ const threeCtx = canvasManager?.getThreeContext(); if (!threeCtx || !threeCtx.objects) return; TWEEN.removeAll(); const targetRot = progress >= 0.99 ? 0 : Math.PI; threeCtx.objects.forEach(obj => { obj.rotation.y = targetRot; obj.visible = true; }); if (threeCtx.renderer && threeCtx.scene && threeCtx.camera) { threeCtx.renderer.render(threeCtx.scene, threeCtx.camera); } }

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        // +++                  PUBLIC API SECTION                    +++
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        // --- Fullscreen ---
        function enterAPIFullscreen() { if (isInAPIFullscreen) return; console.log("Entering API Fullscreen"); isInAPIFullscreen = true; document.body.classList.add('api-fullscreen-active'); setTimeout(handleResize, 50); }
        function exitAPIFullscreen() { if (!isInAPIFullscreen) return; console.log("Exiting API Fullscreen"); isInAPIFullscreen = false; removeClickToggleListener(); document.body.classList.remove('api-fullscreen-active'); setTimeout(handleResize, 50); if (!isPlaying && !isPaused) { if (image) setStatus("Ready.", 'info'); else setStatus("Load an image to start.", 'info'); } updateButtonStates(); }

        // --- Loaders ---
        function _loadImageFromURL(url) { return new Promise((resolve, reject) => { setStatus(`Loading image: ${url.substring(0, 60)}...`, 'info'); const i = new Image(); i.crossOrigin = "Anonymous"; i.onload = () => resolve(i); i.onerror = (e) => reject(new Error(`Image load failed: ${e.type}`)); i.src = url; }); }
        function _loadAudioFromURL(url) { return new Promise((resolve, reject) => { setStatus(`Loading audio: ${url.substring(0, 60)}...`, 'info'); const a = new Audio(); a.preload = "auto"; const clean = () => { a.removeEventListener('canplaythrough', ok); a.removeEventListener('error', err); a.removeEventListener('abort', err); }; const ok = () => { clean(); resolve(a); }; const err = (e) => { clean(); reject(new Error(`Audio load failed: ${e.type}, ${a.error?.message || 'Check network'}`)); }; a.addEventListener('canplaythrough', ok); a.addEventListener('error', err); a.addEventListener('abort', err); a.src = url; a.load(); }); }


        /**
         * Handler for the click event to toggle play/stop.
         */
         function handleTogglePlay(){isToggleModeActive&&(isPlaying?(stopAnimation(!0,!0),canvasContainer.classList.add("api-toggle-hidden"),showOverlay()):(canvasContainer.classList.remove("api-toggle-hidden"),hideOverlay(),playAnimation()))}

                 /**
         * Base function for setting up an effect using Web Audio API for gapless playback.
         * @param {number} index - The index of the effect in the modeSelect dropdown.
         * @param {object} apiOptions - Options object (imageUrl, audioUrl, audioUrls, duration, reverse, fullscreen, modeParams).
         * @param {string} [apiOptions.imageUrl] - URL of the image to load.
         * @param {string} [apiOptions.audioUrl] - URL of a single audio file (legacy support).
         * @param {string[]} [apiOptions.audioUrls] - Array of audio file URLs for sequential playback (preferred).
         * @param {number} [apiOptions.duration] - Duration of the VISUAL effect in seconds. Audio duration is separate.
         * @param {boolean} [apiOptions.reverse] - Whether to play the visual effect in reverse (if supported).
         * @param {boolean} [apiOptions.fullscreen] - Whether to enter fullscreen mode.
         * @param {object} [apiOptions.modeParams] - Specific parameters for the chosen effect mode.
         * @param {boolean} enableToggleOnClick - If true, prepares for toggle click. If false, plays immediately.
         * @returns {Promise<boolean>} - Promise resolving to true if setup succeeded, false otherwise.
         */
        async function _setupEffectByIndex(e,a={},r=!1){const t=r?"prepare":"play";if(console.log(`API: ${t}EffectByIndex(${e}, Options:`,a,`Toggle: ${r}`),"number"!=typeof e||e<0||e>=modeSelect.options.length)return setStatus(`API Error: Invalid effect index ${e}.`,"error"),!1;if(!canvasManager)return setStatus("API Error: Canvas manager not initialized.","error"),!1;audioContext||!a.audioUrls&&!a.audioUrl||(console.warn("Web Audio API context not available. Audio playback disabled."),setStatus("Warning: Audio playback unavailable (Web Audio API init failed).","warning")),removeClickToggleListener(),isPlaying||isPaused?stopAnimation(!1,!1):_stopAudioSequenceWebAudio(),audioBuffers=[],activeSourceNodes=[],audioContextStartTime=0,totalAudioSequenceDuration=0,audioLoadState="idle",isInAPIFullscreen&&!a.fullscreen&&exitAPIFullscreen();let o=image;const i=modeSelect.options[e].value;let n=Promise.resolve([]),l=[];Array.isArray(a.audioUrls)&&a.audioUrls.length>0?(l=a.audioUrls.filter((e=>"string"==typeof e&&""!==e.trim())),l.length!==a.audioUrls.length&&console.warn("API: Filtered out invalid entries from audioUrls array.")):"string"==typeof a.audioUrl&&""!==a.audioUrl.trim()&&(l=[a.audioUrl.trim()],a.audioUrls&&console.warn("API: 'audioUrls' was provided but empty/invalid, falling back to 'audioUrl'.")),audioContext&&l.length>0?n=_loadAudioBuffers(l):l.length>0&&setStatus("Warning: Audio URLs provided, but Web Audio unavailable.","warning");let d=Promise.resolve(o);a.imageUrl&&"string"==typeof a.imageUrl&&""!==a.imageUrl.trim()&&(stopAnimation(!0,!1),d=_loadImageFromURL(a.imageUrl.trim()).catch((e=>{throw setStatus(`API Error loading image: ${e.message}`,"error"),console.error("API Image Load Error:",e),image=null,canvasManager.clear(),updateButtonStates(),new Error(`Failed to load required image: ${a.imageUrl}`)})));try{const[e,t]=await Promise.all([d,n]);if(a.imageUrl&&(image=e,o=image),!o)return setStatus("API Error: No valid image available for the effect.","error"),canvasManager.clear(),updateButtonStates(),!1;audioBuffers=t,"loaded"===audioLoadState?console.log(`API: Successfully prepared ${audioBuffers.length} audio buffer(s). Total Duration: ${totalAudioSequenceDuration.toFixed(2)}s`):l.length>0&&console.log(`API: Audio buffer loading completed with state: ${audioLoadState}`);if(a.imageUrl||currentMode!==i?(setStatus("Initializing canvas/mode..."),currentMode=i,await canvasManager.initialize(o,currentMode),modeSelect.value=i,isReversed=!1,reverseCheckbox.checked=!1,updateModeOptionControls()):updateModeOptionControls(),canvasManager.getCurrentMode()!==i)throw new Error(`Canvas mode did not switch correctly to ${i}.`);const s=REVERSIBLE_MODES.includes(i);let u=isReversed;if(void 0!==a.reverse&&"boolean"==typeof a.reverse&&(u=!!s&&a.reverse,!s&&a.reverse&&console.warn(`API: Mode '${i}' is not reversible, 'reverse: true' option ignored.`)),isReversed=u,reverseCheckbox.checked=isReversed,reverseCheckbox.disabled=!s,a.duration&&"number"==typeof a.duration&&a.duration>=.5?updateDurationDisplay(a.duration):updateDurationDisplay(),console.log(`API: Visual effect duration set to ${totalDuration/1e3}s.`),initializeModeState(),a.modeParams&&"object"==typeof a.modeParams){console.log(`API: Applying mode params for '${currentMode}':`,a.modeParams);let e=!1;"agentReveal"===currentMode?("number"==typeof a.modeParams.agentSpeed&&(agentSpeedSlider.value=Math.min(10,Math.max(.1,a.modeParams.agentSpeed)),e=!0),"number"==typeof a.modeParams.agentRadius&&(agentRadiusSlider.value=Math.min(100,Math.max(1,a.modeParams.agentRadius)),e=!0),agentSpeedValue.textContent=agentSpeedSlider.value,agentRadiusValue.textContent=agentRadiusSlider.value):"glyphReveal"===currentMode&&"string"==typeof a.modeParams.glyphOrder&&["random","brightness"].includes(a.modeParams.glyphOrder)&&(glyphOrderSelect.value=a.modeParams.glyphOrder,e=!0),e?initializeModeState():console.warn(`API: No valid modeParams recognized or applied for mode '${currentMode}'.`)}return a.fullscreen&&!isInAPIFullscreen&&(enterAPIFullscreen(),await new Promise((e=>setTimeout(e,60)))),drawInitialState(),r?(isToggleModeActive=!0,clickToggleHandler=handleTogglePlay,canvasContainer.addEventListener("click",clickToggleHandler,{passive:!0}),canvasContainer.classList.add("clickable","api-toggle-hidden"),showOverlay(),setStatus("Ready. Click image to play/stop.","info")):(canvasContainer.classList.remove("api-toggle-hidden"),hideOverlay(),playAnimation()),updateButtonStates(),!0}catch(e){return setStatus(`API Error during setup: ${e.message}`,"error"),console.error("API Setup Error:",e),_stopAudioSequenceWebAudio(),audioBuffers=[],audioLoadState="error",updateButtonStates(),updateModeOptionControls(),image||canvasManager?.clear(),!1}}

                /** NEW: Attaches the ended listener to the current audio object */
        function _attachAudioEndListener(d){d&&(_removeAudioEndListener(),boundAudioEndedHandler=_handleAudioEnded.bind(this),currentlyPlayingAudio=d,currentlyPlayingAudio.addEventListener("ended",boundAudioEndedHandler))}

                /** NEW: Removes the ended listener */
        function _removeAudioEndListener(){currentlyPlayingAudio&&boundAudioEndedHandler&&currentlyPlayingAudio.removeEventListener("ended",boundAudioEndedHandler),currentlyPlayingAudio=null,boundAudioEndedHandler=null}

                /** NEW: Handler for when an audio file finishes playing */
                function _handleAudioEnded(){if(_removeAudioEndListener(),currentAudioIndex++,isPlaying&&currentAudioIndex<audioSequence.length){const e=audioSequence[currentAudioIndex];e?(e.currentTime=0,_attachAudioEndListener(e),e.play().catch((e=>{console.error(`Error playing audio index ${currentAudioIndex}:`,e)}))):(console.warn("Next audio object is null/invalid at index:",currentAudioIndex),_handleAudioEnded())}else currentlyPlayingAudio=null}

                /** NEW: Stops all audio in the sequence and resets state */
                function _stopAndClearAudioSequence(){_removeAudioEndListener(),audioSequence.forEach((e=>{e&&(e.pause(),e.currentTime=0)})),audioSequence=[],currentAudioIndex=0,currentlyPlayingAudio=null}

        /** API: Plays effect immediately */
        async function playEffectByIndex(index, apiOptions = {}) {
            return _setupEffectByIndex(index, apiOptions, false); // enableToggleOnClick = false
        }

        /** API: Prepares effect for click-to-toggle */
         async function prepareEffectByIndex(index, apiOptions = {}) {
             return _setupEffectByIndex(index, apiOptions, true); // enableToggleOnClick = true
         }

        /** API: Loads image only */
        async function loadImageFromURL(a){if(removeClickToggleListener(),!canvasManager)return setStatus("API Error: Canvas not init.","error"),!1;currentAudio&&(currentAudio.pause(),currentAudio=null),stopAnimation(!0,!1);try{const e=await _loadImageFromURL(a);return image=e,currentMode=modeSelect.value,await canvasManager.initialize(image,currentMode),initializeModeState(),drawInitialState(),setStatus("Image loaded via API. Ready.","info"),updateButtonStates(),!0}catch(a){return setStatus(`API Error: ${a.message}`,"error"),image=null,canvasManager.clear(),updateButtonStates(),!1}}
        // Expose API globally
        window.ImageRevealAPI = { playEffectByIndex, prepareEffectByIndex, loadImageFromURL };

        // --- Logging & Shortcuts ---
        console.log("--- Available Effects (for API use) ---"); Array.from(modeSelect.options).forEach((o, i) => console.log(`${i}: ${o.textContent} ('${o.value}') ${REVERSIBLE_MODES.includes(o.value)?'[R]':''}`));
        console.log("--- Keyboard Shortcuts (Play Immediately) ---"); console.log("0-9, Shift+0-9, Ctrl+0-9 (disabled in inputs)");
        console.log("--- API Examples ---"); console.log("ImageRevealAPI.playEffectByIndex(0);"); console.log("ImageRevealAPI.prepareEffectByIndex(11, { imageUrl:'URL', audioUrl:'URL.webm' }); // Click canvas to toggle play/stop");
        console.log("Click the 'i' button for full instructions.");

        function handleEffectShortcut(e){const t=e.target.tagName.toUpperCase();if(infoModal.classList.contains("visible")||["INPUT","SELECT","TEXTAREA"].includes(t)||e.isComposing||isToggleModeActive)return;const n=e.key;if(!/^[0-9]$/.test(n))return;const o=parseInt(n,10);let s=-1,c=0===o?9:o-1;e.ctrlKey?s=c+20:e.shiftKey?s=c+10:e.altKey||e.metaKey||(s=c),-1!==s&&s<modeSelect.options.length&&(console.log(`Shortcut: Play effect ${s}`),e.preventDefault(),removeClickToggleListener(),playEffectByIndex(s))}window.addEventListener("keydown",handleEffectShortcut);
            
        
       
        init();

    </script>

    <script>

     // // +++ TESTING SECTION +++
        //        document.addEventListener('DOMContentLoaded', () => {
        //     setTimeout(() => {
        //         console.log("--- Running API Test: Prepare Glyph Reveal with Sequential Audio (Toggle on Click) ---"); // Updated log message

        //         const testImageUrl = 'https://ordinals.com/content/01c48d3cceb02215bc3d44f9a2dc7fba63ea63719a2ef1c35d3f0c4db93ab8d5i0';

        //         // Array of audio URLs for sequential playback
        //         const testAudioUrls = [
        //             'https://ordinals.com/content/055e30b37a547674bd750cd963b9c3e2dfaecfe60833cbb9a377e12b2eea05a6i0', // Part 1
        //             'https://ordinals.com/content/a475da90928ae5dba210a6a2708a20278367d46f898acdebe9707c0e43b994cei0', // Part 2
        //             'https://ordinals.com/content/797a56f20af6f7016853f817a7041847e82dedd2d2b9246515646e741a3e53b2i0'  // Part 3
        //         ];

        //         const effectIndex = 3; // Index for Glyph Reveal

        //         ImageRevealAPI.prepareEffectByIndex(effectIndex, {
        //             imageUrl: testImageUrl,
        //             // audioUrl: testAudioUrl, // REMOVED or commented out the old single URL property
        //             audioUrls: testAudioUrls,  // USE the new array property
        //             duration: 158,             // Visual effect duration (audio duration is independent)
        //             fullscreen: true,          // Keep fullscreen setting as desired
        //             // Optional: Add glyph-specific params if needed
        //             // modeParams: { glyphOrder: 'brightness' }
        //         }).then(success => {
        //             if (success) {
        //                 console.log(`API Test: Prepared Effect ${effectIndex} (Glyph Reveal) with ${testAudioUrls.length} audio files in sequence. Click canvas to toggle play/stop.`);
        //             } else {
        //                 console.error("API Test: Failed to prepare effect.");
        //             }
        //         }).catch(error => console.error("API Test Error:", error));

        //     }, 1500); // Delay for page setup
        // });
        // // */ // Ensure the test block end comment is correct if you use it
        // // */ // End test block

        // === Start Application ===

    </script>
</body>
</html>