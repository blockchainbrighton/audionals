<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drum & Bass Synth Toys</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        :root {
            --primary: #8a2be2;
            --secondary: #00bfff;
            --dark: #121212;
            --light: #f0f0f0;
            --accent: #ff6b6b;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, var(--dark), #1a1a2e);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(to right, var(--secondary), var(--primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            max-width: 700px;
            margin: 0 auto;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .global-control {
            background: rgba(30, 30, 46, 0.7);
            border-radius: 12px;
            padding: 15px;
            min-width: 180px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        .control-title {
            text-align: center;
            margin-bottom: 12px;
            font-weight: 600;
            color: var(--secondary);
        }
        
        .knob-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 10px 0;
        }
        
        .knob-label {
            margin-bottom: 8px;
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        .knob {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(145deg, #2d2d44, #1e1e2e);
            border: 2px solid var(--primary);
            position: relative;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            transition: transform 0.2s;
        }
        
        .knob:hover {
            transform: scale(1.05);
        }
        
        .knob::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 25px;
            background: var(--light);
            transform: translate(-50%, -50%) rotate(0deg);
            border-radius: 2px;
        }
        
        .transport-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            min-width: 120px;
        }
        
        .btn-primary {
            background: var(--primary);
            color: white;
        }
        
        .btn-secondary {
            background: var(--secondary);
            color: var(--dark);
        }
        
        .btn-accent {
            background: var(--accent);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .toys-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-top: 20px;
        }
        
        .toy {
            background: rgba(30, 30, 46, 0.8);
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.4);
            transition: transform 0.3s;
            border: 1px solid rgba(138, 43, 226, 0.3);
        }
        
        .toy:hover {
            transform: translateY(-5px);
            border-color: var(--primary);
        }
        
        .toy-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .toy-title {
            font-size: 1.5rem;
            color: var(--secondary);
        }
        
        .toy-icon {
            font-size: 1.8rem;
        }
        
        .toy-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }
        
        .pad-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-top: 20px;
        }
        
        .pad {
            aspect-ratio: 1;
            border-radius: 8px;
            background: linear-gradient(145deg, #2d2d44, #1e1e2e);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            border: 2px solid transparent;
        }
        
        .pad:hover {
            transform: scale(1.05);
        }
        
        .pad.active {
            background: var(--primary);
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.7);
            border-color: white;
        }

        .pad.latched {
            background: var(--secondary);
            color: var(--dark);
            box-shadow: 0 0 25px rgba(0, 191, 255, 0.6);
            border-color: var(--light);
        }

        .btn-toggle-active {
            box-shadow: 0 0 25px rgba(138, 43, 226, 0.6);
            border: 1px solid rgba(255,255,255,0.6);
        }

        .knob.active-knob {
            box-shadow: 0 0 18px rgba(138, 43, 226, 0.45);
        }

        .dropdown {
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .dropdown select {
            background: rgba(30, 30, 46, 0.8);
            color: var(--light);
            border: 1px solid rgba(138, 43, 226, 0.4);
            border-radius: 6px;
            padding: 6px 10px;
            cursor: pointer;
        }
        
        .status-bar {
            margin-top: 30px;
            text-align: center;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            font-size: 1.1rem;
        }
        
        .recording-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: var(--accent);
            border-radius: 50%;
            margin-right: 10px;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            opacity: 0.7;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .toys-container {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .global-control {
                width: 100%;
                max-width: 300px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Drum & Bass Synth Toys</h1>
        <p class="subtitle">5 unique instruments for live performance with recording capabilities. All sounds generated with Tone.js and Web Audio API.</p>
    </header>
    
    <div class="controls">
        <div class="global-control">
            <div class="control-title">Tempo</div>
            <div class="knob-container">
                <div class="knob-label">BPM</div>
                <div class="knob" id="tempoKnob" data-value="174" data-min="60" data-max="220"></div>
                <div id="tempoValue">174</div>
            </div>
        </div>
        
        <div class="global-control">
            <div class="control-title">Master FX</div>
            <div class="knob-container">
                <div class="knob-label">Reverb</div>
                <div class="knob" id="reverbKnob" data-value="0.3" data-min="0" data-max="1"></div>
                <div id="reverbValue">30%</div>
            </div>
            <div class="knob-container">
                <div class="knob-label">Delay</div>
                <div class="knob" id="delayKnob" data-value="0.2" data-min="0" data-max="1"></div>
                <div id="delayValue">20%</div>
            </div>
        </div>

        <div class="global-control">
            <div class="control-title">Loop Settings</div>
            <div class="knob-container">
                <div class="knob-label">Length (bars)</div>
                <div class="knob" id="loopLengthKnob" data-value="2" data-min="1" data-max="16"></div>
                <div id="loopLengthValue">2 bars</div>
            </div>
        </div>

        <div class="global-control">
            <div class="control-title">Drone LFO</div>
            <div class="knob-container">
                <div class="knob-label">Rate</div>
                <div class="knob" id="droneRateKnob" data-value="2" data-min="0.1" data-max="12"></div>
                <div id="droneRateValue">2Hz</div>
            </div>
            <div class="knob-container">
                <div class="knob-label">Depth</div>
                <div class="knob" id="droneDepthKnob" data-value="0.6" data-min="0" data-max="1"></div>
                <div id="droneDepthValue">60%</div>
            </div>
            <div class="dropdown">
                <label for="droneWaveSelect">Wave</label>
                <select id="droneWaveSelect">
                    <option value="sine" selected>Sine</option>
                    <option value="triangle">Triangle</option>
                    <option value="square">Square</option>
                    <option value="sawtooth">Saw</option>
                </select>
            </div>
        </div>
    </div>
    
    <div class="transport-controls">
        <button class="btn btn-primary" id="playBtn">Play</button>
        <button class="btn btn-secondary" id="loopBtn">Loop Off</button>
        <button class="btn btn-secondary" id="latchBtn">Latch Off</button>
        <button class="btn btn-accent" id="recordBtn">Record</button>
        <button class="btn btn-secondary" id="stopBtn">Stop</button>
        <button class="btn btn-secondary" id="clearBtn">Clear Recording</button>
    </div>
    
    <div class="toys-container">
        <!-- Toy 1: Bass Machine -->
        <div class="toy" id="bassMachine">
            <div class="toy-header">
                <div class="toy-title">Bass Machine</div>
                <div class="toy-icon">üîä</div>
            </div>
            <div class="toy-controls">
                <div class="knob-container">
                    <div class="knob-label">Cutoff</div>
                    <div class="knob" data-param="bass.cutoff" data-value="800" data-min="20" data-max="20000"></div>
                    <div class="knob-value">800Hz</div>
                </div>
                <div class="knob-container">
                    <div class="knob-label">Resonance</div>
                    <div class="knob" data-param="bass.resonance" data-value="3" data-min="0.1" data-max="20"></div>
                    <div class="knob-value">3.0</div>
                </div>
                <div class="knob-container">
                    <div class="knob-label">Distortion</div>
                    <div class="knob" data-param="bass.distortion" data-value="0.3" data-min="0" data-max="1"></div>
                    <div class="knob-value">30%</div>
                </div>
                <div class="knob-container">
                    <div class="knob-label">LFO Rate</div>
                    <div class="knob" data-param="bass.lfoRate" data-value="4" data-min="0.1" data-max="20"></div>
                    <div class="knob-value">4Hz</div>
                </div>
            </div>
            <div class="pad-grid">
                <div class="pad" data-note="C2">C2</div>
                <div class="pad" data-note="D2">D2</div>
                <div class="pad" data-note="E2">E2</div>
                <div class="pad" data-note="F2">F2</div>
                <div class="pad" data-note="G2">G2</div>
                <div class="pad" data-note="A2">A2</div>
                <div class="pad" data-note="B2">B2</div>
                <div class="pad" data-note="C3">C3</div>
            </div>
        </div>
        
        <!-- Toy 2: Stutter FX -->
        <div class="toy" id="stutterFx">
            <div class="toy-header">
                <div class="toy-title">Stutter FX</div>
                <div class="toy-icon">üåÄ</div>
            </div>
            <div class="toy-controls">
                <div class="knob-container">
                    <div class="knob-label">Rate</div>
                    <div class="knob" data-param="stutter.rate" data-value="8" data-min="1" data-max="32"></div>
                    <div class="knob-value">1/8</div>
                </div>
                <div class="knob-container">
                    <div class="knob-label">Depth</div>
                    <div class="knob" data-param="stutter.depth" data-value="0.7" data-min="0" data-max="1"></div>
                    <div class="knob-value">70%</div>
                </div>
                <div class="knob-container">
                    <div class="knob-label">Feedback</div>
                    <div class="knob" data-param="stutter.feedback" data-value="0.4" data-min="0" data-max="1"></div>
                    <div class="knob-value">40%</div>
                </div>
                <div class="knob-container">
                    <div class="knob-label">Dry/Wet</div>
                    <div class="knob" data-param="stutter.dryWet" data-value="0.6" data-min="0" data-max="1"></div>
                    <div class="knob-value">60%</div>
                </div>
            </div>
            <div class="pad-grid">
                <div class="pad" data-effect="stutter">Stutter</div>
                <div class="pad" data-effect="reverse">Reverse</div>
                <div class="pad" data-effect="freeze">Freeze</div>
                <div class="pad" data-effect="glitch">Glitch</div>
                <div class="pad" data-effect="pitch-up">Pitch+</div>
                <div class="pad" data-effect="pitch-down">Pitch-</div>
                <div class="pad" data-effect="filter-sweep">Sweep</div>
                <div class="pad" data-effect="noise">Noise</div>
            </div>
        </div>
        
        <!-- Toy 3: Percussion Synth -->
        <div class="toy" id="percussionSynth">
            <div class="toy-header">
                <div class="toy-title">Percussion Synth</div>
                <div class="toy-icon">ü•Å</div>
            </div>
            <div class="toy-controls">
                <div class="knob-container">
                    <div class="knob-label">Tone</div>
                    <div class="knob" data-param="percussion.tone" data-value="0.5" data-min="0" data-max="1"></div>
                    <div class="knob-value">50%</div>
                </div>
                <div class="knob-container">
                    <div class="knob-label">Decay</div>
                    <div class="knob" data-param="percussion.decay" data-value="0.3" data-min="0.01" data-max="2"></div>
                    <div class="knob-value">0.3s</div>
                </div>
                <div class="knob-container">
                    <div class="knob-label">Pitch</div>
                    <div class="knob" data-param="percussion.pitch" data-value="0" data-min="-12" data-max="12"></div>
                    <div class="knob-value">0</div>
                </div>
                <div class="knob-container">
                    <div class="knob-label">Noise</div>
                    <div class="knob" data-param="percussion.noise" data-value="0.4" data-min="0" data-max="1"></div>
                    <div class="knob-value">40%</div>
                </div>
            </div>
            <div class="pad-grid">
                <div class="pad" data-perc="kick">Kick</div>
                <div class="pad" data-perc="snare">Snare</div>
                <div class="pad" data-perc="hihat">Hi-Hat</div>
                <div class="pad" data-perc="clap">Clap</div>
                <div class="pad" data-perc="tom">Tom</div>
                <div class="pad" data-perc="rim">Rim</div>
                <div class="pad" data-perc="cowbell">Cowbell</div>
                <div class="pad" data-perc="shaker">Shaker</div>
            </div>
        </div>
        
        <!-- Toy 4: Lead Synth -->
        <div class="toy" id="leadSynth">
            <div class="toy-header">
                <div class="toy-title">Lead Synth</div>
                <div class="toy-icon">üéπ</div>
            </div>
            <div class="toy-controls">
                <div class="knob-container">
                    <div class="knob-label">Waveform</div>
                    <div class="knob" data-param="lead.waveform" data-value="0" data-min="0" data-max="3"></div>
                    <div class="knob-value">Saw</div>
                </div>
                <div class="knob-container">
                    <div class="knob-label">Portamento</div>
                    <div class="knob" data-param="lead.portamento" data-value="0.02" data-min="0" data-max="0.5"></div>
                    <div class="knob-value">20ms</div>
                </div>
                <div class="knob-container">
                    <div class="knob-label">Vibrato</div>
                    <div class="knob" data-param="lead.vibrato" data-value="0.3" data-min="0" data-max="1"></div>
                    <div class="knob-value">30%</div>
                </div>
                <div class="knob-container">
                    <div class="knob-label">Octave</div>
                    <div class="knob" data-param="lead.octave" data-value="0" data-min="-2" data-max="2"></div>
                    <div class="knob-value">0</div>
                </div>
            </div>
            <div class="pad-grid">
                <div class="pad" data-note="C4">C4</div>
                <div class="pad" data-note="D4">D4</div>
                <div class="pad" data-note="E4">E4</div>
                <div class="pad" data-note="F4">F4</div>
                <div class="pad" data-note="G4">G4</div>
                <div class="pad" data-note="A4">A4</div>
                <div class="pad" data-note="B4">B4</div>
                <div class="pad" data-note="C5">C5</div>
            </div>
        </div>
        
        <!-- Toy 5: Texture Generator -->
        <div class="toy" id="textureGen">
            <div class="toy-header">
                <div class="toy-title">Texture Generator</div>
                <div class="toy-icon">üåå</div>
            </div>
            <div class="toy-controls">
                <div class="knob-container">
                    <div class="knob-label">Density</div>
                    <div class="knob" data-param="texture.density" data-value="0.5" data-min="0" data-max="1"></div>
                    <div class="knob-value">50%</div>
                </div>
                <div class="knob-container">
                    <div class="knob-label">Grain Size</div>
                    <div class="knob" data-param="texture.grain" data-value="0.1" data-min="0.01" data-max="0.5"></div>
                    <div class="knob-value">100ms</div>
                </div>
                <div class="knob-container">
                    <div class="knob-label">Spread</div>
                    <div class="knob" data-param="texture.spread" data-value="0.3" data-min="0" data-max="1"></div>
                    <div class="knob-value">30%</div>
                </div>
                <div class="knob-container">
                    <div class="knob-label">Motion</div>
                    <div class="knob" data-param="texture.motion" data-value="0.4" data-min="0" data-max="1"></div>
                    <div class="knob-value">40%</div>
                </div>
            </div>
            <div class="pad-grid">
                <div class="pad" data-texture="atmos">Atmos</div>
                <div class="pad" data-texture="pads">Pads</div>
                <div class="pad" data-texture="riser">Riser</div>
                <div class="pad" data-texture="impact">Impact</div>
                <div class="pad" data-texture="swell">Swell</div>
                <div class="pad" data-texture="drones">Drones</div>
                <div class="pad" data-texture="noise">Noise</div>
                <div class="pad" data-texture="silence">Silence</div>
            </div>
        </div>
    </div>
    
    <div class="status-bar">
        <span id="statusText">Ready to jam! Press Play to start.</span>
    </div>
    
    <footer>
        <p>Drum & Bass Synth Toys ‚Ä¢ Built with Tone.js and Web Audio API ‚Ä¢ All sounds generated in real-time</p>
    </footer>

    <script>
        Tone.context.latencyHint = 'interactive';

        let isRecording = false;
        let recordedEvents = [];
        let recordingStartTime = 0;

        let currentTempo = 174;

        let masterReverb;
        let masterDelay;
        let masterOutput;

        const instruments = {
            bass: null,
            percussion: {},
            lead: null,
            texture: {},
            stutter: {}
        };

        const activeDrones = new Map();
        let latchMode = false;
        const droneSettings = {
            rate: 2,
            depth: 0.6,
            wave: 'sine'
        };

        let loopEnabled = false;
        let loopPart = null;
        let loopLengthBars = 2;

        const pressedKeys = new Set();

        const knobRegistry = new Map();

        const knobParamHandlers = new Map();

        const padKeyMap = {
            bassMachine: {
                q: 'C2',
                w: 'D2',
                e: 'E2',
                r: 'F2',
                t: 'G2',
                y: 'A2',
                u: 'B2',
                i: 'C3'
            },
            leadSynth: {
                a: 'C4',
                s: 'D4',
                d: 'E4',
                f: 'F4',
                g: 'G4',
                h: 'A4',
                j: 'B4',
                k: 'C5'
            },
            percussionSynth: {
                z: 'kick',
                x: 'snare',
                c: 'hihat',
                v: 'clap',
                b: 'tom',
                n: 'rim',
                m: 'cowbell',
                ',': 'shaker'
            },
            textureGen: {
                o: 'atmos',
                p: 'pads',
                '[': 'riser',
                ']': 'impact',
                ';': 'swell',
                "'": 'drones',
                '.': 'noise',
                '/': 'silence'
            },
            stutterFx: {
                '1': 'stutter',
                '2': 'reverse',
                '3': 'freeze',
                '4': 'glitch',
                '5': 'pitch-up',
                '6': 'pitch-down',
                '7': 'filter-sweep',
                '8': 'noise'
            }
        };

        function escapeSelector(value) {
            if (window.CSS && typeof window.CSS.escape === 'function') {
                return window.CSS.escape(value);
            }
            return value.replace(/[-\[\]\/{}()*+?.\\^$|]/g, '\$&');
        }

        function initMasterEffects() {
            masterOutput = new Tone.Gain().toDestination();
            masterReverb = new Tone.Reverb(1.5).connect(masterOutput);
            masterDelay = new Tone.FeedbackDelay('8n', 0.5).connect(masterOutput);
        }

        function initInstruments() {
            instruments.bass = new Tone.Synth({
                oscillator: { type: 'sawtooth' },
                envelope: { attack: 0.01, decay: 0.2, sustain: 0.8, release: 0.6 }
            }).connect(masterReverb);

            instruments.percussion = {
                kick: new Tone.MembraneSynth().connect(masterDelay),
                snare: new Tone.NoiseSynth({ envelope: { attack: 0.01, decay: 0.2, sustain: 0 } }).connect(masterDelay),
                hihat: new Tone.MetalSynth({ envelope: { attack: 0.001, decay: 0.1, release: 0.01 } }).connect(masterDelay),
                clap: new Tone.Sampler({
                    urls: { C1: 'clap.mp3' },
                    baseUrl: 'https://tonejs.github.io/audio/drum-samples/'
                }).connect(masterDelay),
                tom: new Tone.MembraneSynth({ pitchDecay: 0.02 }).connect(masterDelay),
                rim: new Tone.Synth({ oscillator: { type: 'square' } }).connect(masterDelay),
                cowbell: new Tone.MetalSynth({ envelope: { attack: 0.001, decay: 0.2, release: 0.1 } }).connect(masterDelay),
                shaker: new Tone.NoiseSynth({ envelope: { attack: 0.001, decay: 0.15, sustain: 0 } }).connect(masterDelay)
            };

            instruments.lead = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'sawtooth' },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.4 },
                portamento: 0.02
            }).connect(masterReverb);

            instruments.texture = {
                atmos: new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.4, sustain: 0.7, release: 1.5 } }).connect(masterReverb),
                pads: new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.2, sustain: 0.9, release: 1.2 } }).connect(masterReverb),
                riser: new Tone.FMSynth({ envelope: { attack: 0.5, sustain: 0.7, release: 1.5 } }).connect(masterReverb),
                impact: new Tone.MembraneSynth({ envelope: { attack: 0.01, decay: 0.8, sustain: 0, release: 0.6 } }).connect(masterReverb),
                swell: new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.4, sustain: 0.8, release: 1.8 } }).connect(masterReverb),
                drones: new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.3, sustain: 1, release: 2 } }).connect(masterReverb),
                noise: new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.1, sustain: 0.8, release: 1 } }).connect(masterReverb)
            };

            instruments.stutter = {
                stutter: new Tone.AutoFilter({ frequency: 8, type: 'square', depth: 1 }).connect(masterDelay),
                reverse: new Tone.PingPongDelay('16n').connect(masterDelay),
                freeze: new Tone.Reverb(3).connect(masterDelay),
                glitch: new Tone.BitCrusher(4).connect(masterDelay),
                'pitch-up': new Tone.PitchShift(2).connect(masterDelay),
                'pitch-down': new Tone.PitchShift(-2).connect(masterDelay),
                'filter-sweep': new Tone.AutoFilter({ frequency: 1, type: 'sine', depth: 0.7 }).connect(masterDelay),
                noise: new Tone.NoiseSynth({ envelope: { attack: 0.01, decay: 0.4, sustain: 0.2, release: 0.3 } }).connect(masterDelay)
            };

            knobParamHandlers.set('stutter.rate', value => {
                if (instruments.stutter?.stutter?.frequency) {
                    instruments.stutter.stutter.frequency.value = value;
                }
            });
            knobParamHandlers.set('stutter.depth', value => {
                if (instruments.stutter?.stutter) {
                    instruments.stutter.stutter.depth = value;
                }
            });
            knobParamHandlers.set('stutter.feedback', value => {
                if (instruments.stutter?.reverse?.feedback) {
                    instruments.stutter.reverse.feedback.value = value;
                }
            });
            knobParamHandlers.set('stutter.dryWet', value => {
                Object.values(instruments.stutter).forEach(effect => {
                    if (effect && 'wet' in effect) {
                        effect.wet.value = value;
                    }
                });
            });
        }

        function getKnobParamKey(knob) {
            return knob.dataset.param || knob.id || '';
        }

        function applyKnobSideEffects(knob, value, { fromPlayback = false } = {}) {
            if (knob.id === 'loopLengthKnob') {
                const integerValue = Math.max(1, Math.round(value));
                loopLengthBars = integerValue;
                document.getElementById('loopLengthValue').textContent = `${integerValue} ${integerValue === 1 ? 'bar' : 'bars'}`;
                if (loopEnabled) {
                    setTimeout(() => {
                        if (loopEnabled) {
                            buildLoopPart();
                            ensureTransport();
                        }
                    }, 0);
                }
                return integerValue;
            }

            if (knob.id === 'droneRateKnob') {
                const bounded = Math.max(parseFloat(knob.dataset.min), Math.min(parseFloat(knob.dataset.max), value));
                droneSettings.rate = parseFloat(bounded.toFixed(2));
                document.getElementById('droneRateValue').textContent = `${droneSettings.rate.toFixed(2)}Hz`;
                updateActiveDroneSettings();
                return droneSettings.rate;
            }

            if (knob.id === 'droneDepthKnob') {
                const bounded = Math.max(0, Math.min(1, value));
                droneSettings.depth = bounded;
                document.getElementById('droneDepthValue').textContent = `${Math.round(bounded * 100)}%`;
                updateActiveDroneSettings();
                return bounded;
            }

            if (knob.id === 'tempoKnob') {
                currentTempo = value;
                Tone.Transport.bpm.value = currentTempo;
                document.getElementById('tempoValue').textContent = Math.round(currentTempo);
            } else if (knob.id === 'reverbKnob') {
                masterReverb.wet.value = value;
                document.getElementById('reverbValue').textContent = `${Math.round(value * 100)}%`;
            } else if (knob.id === 'delayKnob') {
                masterDelay.wet.value = value;
                document.getElementById('delayValue').textContent = `${Math.round(value * 100)}%`;
            }

            const paramKey = knob.dataset.param;
            if (paramKey) {
                applyInstrumentParameter(paramKey, value);
            }

            return value;
        }

        function setupKnobs() {
            document.querySelectorAll('.knob').forEach(knob => {
                let isDragging = false;
                let startY = 0;
                let startValue = parseFloat(knob.dataset.value);
                const min = parseFloat(knob.dataset.min);
                const max = parseFloat(knob.dataset.max);
                const paramKey = getKnobParamKey(knob);

                const setValue = (raw, { fromPlayback = false } = {}) => {
                    if (Number.isNaN(raw)) return;
                    let value = raw;
                    if (knob.id === 'loopLengthKnob') {
                        value = Math.round(value);
                    }
                    value = Math.min(max, Math.max(min, value));
                    value = applyKnobSideEffects(knob, value, { fromPlayback });
                    knob.dataset.value = value;
                    updateKnobDisplay(knob, value);
                    if (!fromPlayback) {
                        startValue = value;
                    }
                    return value;
                };

                if (paramKey) {
                    knobRegistry.set(paramKey, { knob, setValue });
                }

                const handleMove = (clientY) => {
                    if (!isDragging) return;
                    const deltaY = startY - clientY;
                    const range = max - min;
                    const newValue = startValue + (deltaY * range / 200);
                    setValue(newValue);
                };

                knob.addEventListener('mousedown', (event) => {
                    isDragging = true;
                    startY = event.clientY;
                    startValue = parseFloat(knob.dataset.value);
                    knob.classList.add('active-knob');
                });

                window.addEventListener('mousemove', (event) => {
                    if (isDragging) {
                        handleMove(event.clientY);
                    }
                });

                const finishInteraction = () => {
                    if (!isDragging) return;
                    isDragging = false;
                    knob.classList.remove('active-knob');
                    if (paramKey) {
                        recordEvent('knob', { param: paramKey, value: parseFloat(knob.dataset.value) });
                    }
                };

                window.addEventListener('mouseup', finishInteraction);

                knob.addEventListener('touchstart', (event) => {
                    isDragging = true;
                    startY = event.touches[0].clientY;
                    startValue = parseFloat(knob.dataset.value);
                    knob.classList.add('active-knob');
                    event.preventDefault();
                }, { passive: false });

                window.addEventListener('touchmove', (event) => {
                    if (isDragging) {
                        handleMove(event.touches[0].clientY);
                    }
                }, { passive: false });

                window.addEventListener('touchend', finishInteraction);
                window.addEventListener('touchcancel', finishInteraction);
            });
        }

        function setKnobValueByParam(param, value, { fromPlayback = false } = {}) {
            const entry = knobRegistry.get(param);
            if (!entry) return;
            entry.setValue(value, { fromPlayback });
        }

        function applyInstrumentParameter(param, value) {
            const handler = knobParamHandlers.get(param);
            if (handler) {
                handler(value);
            }
        }

        function applyRecordedKnobEvent(data) {
            if (!data) return;
            const param = data.param || data.id;
            if (!param) return;
            const value = typeof data.value === 'number' ? data.value : parseFloat(data.value);
            if (Number.isNaN(value)) return;
            setKnobValueByParam(param, value, { fromPlayback: true });
        }

        function updateKnobDisplay(knob, value) {
            const min = parseFloat(knob.dataset.min);
            const max = parseFloat(knob.dataset.max);
            const angle = ((value - min) / (max - min)) * 240 - 120;
            knob.style.transform = `rotate(${angle}deg)`;

            const valueDisplay = knob.nextElementSibling;
            if (!valueDisplay) return;

            if (knob.id === 'loopLengthKnob') {
                const bars = Math.round(value);
                valueDisplay.textContent = `${bars} ${bars === 1 ? 'bar' : 'bars'}`;
                return;
            }
            if (knob.id === 'droneRateKnob') {
                valueDisplay.textContent = `${parseFloat(value).toFixed(2)}Hz`;
                return;
            }
            if (knob.id === 'droneDepthKnob') {
                valueDisplay.textContent = `${Math.round(value * 100)}%`;
                return;
            }

            if (knob.closest('#bassMachine')) {
                const label = knob.previousElementSibling?.textContent || '';
                if (label.includes('Cutoff')) {
                    valueDisplay.textContent = `${Math.round(value)}Hz`;
                } else if (label.includes('LFO')) {
                    valueDisplay.textContent = `${value.toFixed(1)}Hz`;
                } else {
                    valueDisplay.textContent = value.toFixed(1);
                }
            } else if (knob.closest('#percussionSynth')) {
                const label = knob.previousElementSibling?.textContent || '';
                if (label.includes('Decay')) {
                    valueDisplay.textContent = `${value.toFixed(2)}s`;
                } else {
                    valueDisplay.textContent = `${Math.round(value * 100)}%`;
                }
            } else if (knob.closest('#leadSynth')) {
                const label = knob.previousElementSibling?.textContent || '';
                if (label.includes('Waveform')) {
                    const waveforms = ['Saw', 'Square', 'Triangle', 'Sine'];
                    valueDisplay.textContent = waveforms[Math.round(value)] || 'Saw';
                } else if (label.includes('Portamento')) {
                    valueDisplay.textContent = `${Math.round(value * 1000)}ms`;
                } else {
                    valueDisplay.textContent = Math.round(value);
                }
            } else if (knob.closest('#textureGen')) {
                const label = knob.previousElementSibling?.textContent || '';
                if (label.includes('Grain')) {
                    valueDisplay.textContent = `${Math.round(value * 1000)}ms`;
                } else {
                    valueDisplay.textContent = `${Math.round(value * 100)}%`;
                }
            } else if (knob.closest('#stutterFx')) {
                const label = knob.previousElementSibling?.textContent || '';
                if (label.includes('Rate')) {
                    valueDisplay.textContent = `1/${Math.round(value)}`;
                } else {
                    valueDisplay.textContent = `${Math.round(value * 100)}%`;
                }
            }
        }

        function setupPads() {
            const pads = document.querySelectorAll('.pad');
            pads.forEach(pad => {
                if (!pad.dataset.label) {
                    pad.dataset.label = pad.textContent.trim();
                }

                pad.addEventListener('mousedown', () => {
                    pad.classList.add('active');
                    triggerPad(pad);
                });

                pad.addEventListener('mouseup', () => {
                    if (!pad.classList.contains('latched')) {
                        pad.classList.remove('active');
                    }
                });

                pad.addEventListener('mouseleave', () => {
                    if (!pad.classList.contains('latched')) {
                        pad.classList.remove('active');
                    }
                });

                pad.addEventListener('touchstart', (event) => {
                    pad.classList.add('active');
                    triggerPad(pad);
                    event.preventDefault();
                }, { passive: false });

                pad.addEventListener('touchend', () => {
                    if (!pad.classList.contains('latched')) {
                        pad.classList.remove('active');
                    }
                });

                pad.addEventListener('touchcancel', () => {
                    if (!pad.classList.contains('latched')) {
                        pad.classList.remove('active');
                    }
                });
            });
        }

        function getDescriptorKey(descriptor) {
            return `${descriptor.toyId}:${descriptor.type}:${descriptor.value}`;
        }

        function serialiseDescriptor(descriptor) {
            return {
                toyId: descriptor.toyId,
                type: descriptor.type,
                value: descriptor.value,
                instrument: descriptor.instrument
            };
        }

        function deserializeDescriptor(data) {
            return {
                toyId: data.toyId,
                type: data.type,
                value: data.value,
                instrument: data.instrument
            };
        }

        function getPadDescriptor(pad) {
            const toy = pad.closest('.toy');
            if (!toy) return null;
            const toyId = toy.id;

            if (pad.dataset.note) {
                const instrument = toyId === 'bassMachine' ? 'bass' : 'lead';
                return { toyId, type: 'note', value: pad.dataset.note, instrument };
            }
            if (pad.dataset.perc) {
                return { toyId, type: 'percussion', value: pad.dataset.perc, instrument: 'percussion' };
            }
            if (pad.dataset.texture) {
                return { toyId, type: 'texture', value: pad.dataset.texture, instrument: 'texture' };
            }
            if (pad.dataset.effect) {
                return { toyId, type: 'effect', value: pad.dataset.effect, instrument: 'effect' };
            }
            return null;
        }

        function findPadElement(descriptor) {
            const toy = document.getElementById(descriptor.toyId);
            if (!toy) return null;
            let selector = '';
            if (descriptor.type === 'note') {
                selector = `.pad[data-note="${descriptor.value}"]`;
            } else if (descriptor.type === 'percussion') {
                selector = `.pad[data-perc="${descriptor.value}"]`;
            } else if (descriptor.type === 'texture') {
                selector = `.pad[data-texture="${descriptor.value}"]`;
            } else if (descriptor.type === 'effect') {
                selector = `.pad[data-effect="${descriptor.value}"]`;
            }
            if (!selector) return null;
            return toy.querySelector(selector);
        }

        function playPadDescriptor(descriptor, time = Tone.now()) {
            if (descriptor.type === 'note') {
                if (descriptor.instrument === 'bass') {
                    instruments.bass.triggerAttackRelease(descriptor.value, '8n', time);
                } else if (descriptor.instrument === 'lead') {
                    instruments.lead.triggerAttackRelease(descriptor.value, '8n', time);
                }
            } else if (descriptor.type === 'percussion') {
                triggerPercussion(descriptor.value, time);
            } else if (descriptor.type === 'texture') {
                triggerTexture(descriptor.value, time);
            } else if (descriptor.type === 'effect') {
                triggerEffect(descriptor.value, time);
            }
        }

        function triggerPercussion(type, time = Tone.now()) {
            const perc = instruments.percussion;
            switch (type) {
                case 'kick':
                    perc.kick.triggerAttackRelease('C2', '8n', time);
                    break;
                case 'snare':
                    perc.snare.triggerAttackRelease('16n', time);
                    break;
                case 'hihat':
                    perc.hihat.triggerAttackRelease('8n', time, 0.4);
                    break;
                case 'clap':
                    if (perc.clap.triggerAttackRelease) {
                        perc.clap.triggerAttackRelease('C1', '8n', time);
                    } else {
                        perc.clap.triggerAttack('C1', time);
                    }
                    break;
                case 'tom':
                    perc.tom.triggerAttackRelease('G2', '8n', time);
                    break;
                case 'rim':
                    perc.rim.triggerAttackRelease('C4', '16n', time);
                    break;
                case 'cowbell':
                    perc.cowbell.triggerAttackRelease('16n', time);
                    break;
                case 'shaker':
                    perc.shaker.triggerAttackRelease('16n', time);
                    break;
                default:
                    break;
            }
        }

        function triggerTexture(type, time = Tone.now()) {
            if (type === 'silence') {
                return;
            }
            const tex = instruments.texture[type];
            if (!tex) return;
            if (tex.triggerAttackRelease) {
                tex.triggerAttackRelease('2n', time);
            } else if (tex.triggerAttack) {
                tex.triggerAttack(time);
            }
        }

        function triggerEffect(effectName, time = Tone.now()) {
            const effect = instruments.stutter[effectName];
            if (!effect) return;
            if ('wet' in effect) {
                effect.wet.cancelScheduledValues(time);
                effect.wet.setValueAtTime(0, time);
                effect.wet.linearRampToValueAtTime(0.75, time + 0.05);
                effect.wet.linearRampToValueAtTime(0, time + 0.35);
            } else if (effect.triggerAttackRelease) {
                effect.triggerAttackRelease('4n', time);
            } else if (effect.triggerAttack) {
                effect.triggerAttack(time);
            }
        }

        function triggerPad(pad, options = {}) {
            if (!pad) return;
            const { record = true, allowLatch = true, time = Tone.now() } = options;
            const descriptor = getPadDescriptor(pad);
            if (!descriptor) return;

            const key = getDescriptorKey(descriptor);
            if (activeDrones.has(key) && allowLatch) {
                stopDrone(descriptor, { pad, record, time });
                return;
            }

            if (latchMode && allowLatch) {
                startDrone(descriptor, { pad, record, time });
                return;
            }

            playPadDescriptor(descriptor, time);

            if (record) {
                if (descriptor.type === 'note') {
                    recordEvent('note', { instrument: descriptor.instrument, note: descriptor.value });
                } else if (descriptor.type === 'percussion') {
                    recordEvent('percussion', { type: descriptor.value });
                } else if (descriptor.type === 'texture') {
                    recordEvent('texture', { type: descriptor.value });
                } else if (descriptor.type === 'effect') {
                    recordEvent('effect', { type: descriptor.value });
                }
            }

            if (!pad.classList.contains('latched')) {
                setTimeout(() => {
                    if (!pad.classList.contains('latched')) {
                        pad.classList.remove('active');
                    }
                }, 180);
            }
        }

        function startDrone(descriptor, { pad, record = true, time = Tone.now() } = {}) {
            const key = getDescriptorKey(descriptor);
            if (activeDrones.has(key)) return;

            const drone = createDroneVoice(descriptor, time);
            if (!drone) return;

            activeDrones.set(key, drone);

            const padElement = pad || findPadElement(descriptor);
            if (padElement) {
                padElement.classList.add('latched');
                padElement.classList.add('active');
            }

            if (record) {
                recordEvent('drone', { action: 'start', descriptor: serialiseDescriptor(descriptor) });
            }
        }

        function stopDrone(descriptor, { pad, record = true, time = Tone.now() } = {}) {
            const key = getDescriptorKey(descriptor);
            const drone = activeDrones.get(key);
            if (!drone) return;

            if (drone.loop) {
                drone.loop.stop(time);
                drone.loop.dispose();
            }

            if (drone.source) {
                if (typeof drone.source.triggerRelease === 'function') {
                    drone.source.triggerRelease(time);
                } else if (typeof drone.source.stop === 'function') {
                    drone.source.stop(time);
                }
                if (typeof drone.source.dispose === 'function') {
                    setTimeout(() => drone.source.dispose(), 500);
                }
            }

            if (drone.lfo) {
                drone.lfo.stop();
                drone.lfo.disconnect();
                drone.lfo.dispose();
            }

            if (drone.gain) {
                drone.gain.disconnect();
                drone.gain.dispose();
            }

            activeDrones.delete(key);

            const padElement = pad || findPadElement(descriptor);
            if (padElement) {
                padElement.classList.remove('latched');
                if (!pressedKeys.has(padElement.dataset.key || '')) {
                    padElement.classList.remove('active');
                }
            }

            if (record) {
                recordEvent('drone', { action: 'stop', descriptor: serialiseDescriptor(descriptor) });
            }
        }

        function stopAllDrones({ record = false } = {}) {
            const descriptors = Array.from(activeDrones.values()).map(drone => drone.descriptor);
            descriptors.forEach(descriptor => {
                stopDrone(descriptor, { record });
            });
        }

        function createDroneVoice(descriptor, time) {
            const drone = { descriptor };
            let needsTransport = false;

            if (descriptor.toyId === 'stutterFx') {
                const loop = new Tone.Loop(loopTime => {
                    triggerEffect(descriptor.value, loopTime);
                }, getDroneIntervalSeconds());
                loop.start(0);
                drone.loop = loop;
                ensureTransport();
                return drone;
            }

            if (descriptor.toyId === 'textureGen' && descriptor.value === 'silence') {
                return null;
            }

            let destination = masterReverb;
            if (descriptor.type === 'percussion' || descriptor.toyId === 'percussionSynth') {
                destination = masterDelay;
            }

            drone.gain = new Tone.Gain(1).connect(destination);
            const min = Math.max(0, 1 - droneSettings.depth);
            drone.lfo = new Tone.LFO({
                frequency: droneSettings.rate,
                min,
                max: 1,
                type: droneSettings.wave
            }).start();
            drone.lfo.connect(drone.gain.gain);

            if (descriptor.type === 'note') {
                const synth = new Tone.Synth({
                    oscillator: { type: descriptor.instrument === 'bass' ? 'sawtooth' : 'triangle' },
                    envelope: { attack: 0.03, decay: 0.1, sustain: 1, release: 3 }
                }).connect(drone.gain);
                synth.triggerAttack(descriptor.value, time);
                drone.source = synth;
            } else if (descriptor.type === 'texture') {
                if (descriptor.value === 'noise') {
                    const noise = new Tone.NoiseSynth({ envelope: { attack: 0.05, sustain: 1, release: 1.5 } }).connect(drone.gain);
                    noise.triggerAttack(time);
                    drone.source = noise;
                } else {
                    const synth = new Tone.Synth({
                        oscillator: { type: 'sine' },
                        envelope: { attack: 0.3, sustain: 1, release: 2.5 }
                    }).connect(drone.gain);
                    synth.triggerAttack(descriptor.value === 'pads' ? 'C4' : 'C3', time);
                    drone.source = synth;
                }
            } else if (descriptor.type === 'percussion') {
                const loopSynth = createPercussionDroneSource(descriptor.value, drone.gain);
                const loop = new Tone.Loop(loopTime => {
                    if (loopSynth.triggerAttackRelease) {
                        loopSynth.triggerAttackRelease('8n', loopTime);
                    } else if (loopSynth.triggerAttack) {
                        loopSynth.triggerAttack(loopTime);
                    }
                }, getDroneIntervalSeconds());
                loop.start(0);
                drone.source = loopSynth;
                drone.loop = loop;
                needsTransport = true;
            }

            if (needsTransport) {
                ensureTransport();
            }

            return drone;
        }

        function createPercussionDroneSource(type, destination) {
            switch (type) {
                case 'kick':
                    return new Tone.MembraneSynth({ envelope: { attack: 0.01, decay: 0.4, sustain: 0, release: 0.2 } }).connect(destination);
                case 'snare':
                    return new Tone.NoiseSynth({ envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.1 } }).connect(destination);
                case 'hihat':
                    return new Tone.MetalSynth({ envelope: { attack: 0.001, decay: 0.1, release: 0.05 } }).connect(destination);
                case 'clap':
                    return new Tone.NoiseSynth({ envelope: { attack: 0.005, decay: 0.2, sustain: 0, release: 0.1 } }).connect(destination);
                case 'tom':
                    return new Tone.MembraneSynth({ envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.2 } }).connect(destination);
                case 'rim':
                    return new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.05 } }).connect(destination);
                case 'cowbell':
                    return new Tone.MetalSynth({ envelope: { attack: 0.001, decay: 0.3, release: 0.1 } }).connect(destination);
                case 'shaker':
                    return new Tone.NoiseSynth({ envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.1 } }).connect(destination);
                default:
                    return new Tone.NoiseSynth().connect(destination);
            }
        }

        function getDroneIntervalSeconds() {
            const minRate = Math.max(0.1, droneSettings.rate);
            const seconds = 1 / minRate;
            return Math.max(0.0625, seconds);
        }

        function updateActiveDroneSettings() {
            activeDrones.forEach(drone => {
                if (drone.lfo) {
                    drone.lfo.frequency.value = droneSettings.rate;
                    drone.lfo.min = Math.max(0, 1 - droneSettings.depth);
                    drone.lfo.max = 1;
                    drone.lfo.type = droneSettings.wave;
                }
                if (drone.loop) {
                    drone.loop.interval = getDroneIntervalSeconds();
                }
            });
        }

        function recordEvent(type, data) {
            if (!isRecording) return;
            const elapsedTime = Tone.now() - recordingStartTime;
            const snapshot = JSON.parse(JSON.stringify(data));
            recordedEvents.push({ type, data: snapshot, time: elapsedTime });
        }

        function startRecording() {
            if (isRecording) return;
            stopAllDrones({ record: false });
            disableLoopPlayback();
            recordedEvents = [];
            recordingStartTime = Tone.now();
            isRecording = true;
            document.getElementById('statusText').innerHTML = '<span class="recording-indicator"></span> Recording...';
            document.getElementById('recordBtn').textContent = 'Stop Recording';
        }

        function stopRecording() {
            if (!isRecording) return;
            isRecording = false;
            document.getElementById('statusText').textContent = `Recording saved (${recordedEvents.length} events)`;
            document.getElementById('recordBtn').textContent = 'Record';
        }

        function clearRecording() {
            recordedEvents = [];
            disableLoopPlayback();
            document.getElementById('statusText').textContent = 'Recording cleared';
        }

        function playRecording() {
            if (recordedEvents.length === 0) {
                document.getElementById('statusText').textContent = 'No recording to play';
                return;
            }
            disableLoopPlayback();
            schedulePlayback(recordedEvents);
            document.getElementById('statusText').textContent = 'Playing recording...';
        }

        function schedulePlayback(events) {
            Tone.Transport.stop();
            Tone.Transport.cancel(0);
            if (loopPart) {
                loopPart.stop(0);
            }
            events.forEach(event => {
                Tone.Transport.scheduleOnce(time => {
                    playbackEvent(event, time);
                }, event.time);
            });
            Tone.Transport.position = 0;
            Tone.Transport.start();
        }

        function playbackEvent(event, time) {
            if (event.type === 'note') {
                const toyId = event.data.instrument === 'bass' ? 'bassMachine' : 'leadSynth';
                const descriptor = { toyId, type: 'note', instrument: event.data.instrument, value: event.data.note };
                playPadDescriptor(descriptor, time);
                const pad = findPadElement(descriptor);
                if (pad && !pad.classList.contains('latched')) {
                    pad.classList.add('active');
                    setTimeout(() => pad.classList.remove('active'), 160);
                }
            } else if (event.type === 'percussion') {
                const descriptor = { toyId: 'percussionSynth', type: 'percussion', value: event.data.type, instrument: 'percussion' };
                playPadDescriptor(descriptor, time);
            } else if (event.type === 'texture') {
                const descriptor = { toyId: 'textureGen', type: 'texture', value: event.data.type, instrument: 'texture' };
                playPadDescriptor(descriptor, time);
            } else if (event.type === 'effect') {
                const descriptor = { toyId: 'stutterFx', type: 'effect', value: event.data.type, instrument: 'effect' };
                playPadDescriptor(descriptor, time);
            } else if (event.type === 'knob') {
                applyRecordedKnobEvent(event.data);
            } else if (event.type === 'drone') {
                handleDroneEvent(event.data, time);
            }
        }

        function handleDroneEvent(data, time) {
            const descriptor = deserializeDescriptor(data.descriptor);
            if (data.action === 'start') {
                startDrone(descriptor, { record: false, time });
            } else if (data.action === 'stop') {
                stopDrone(descriptor, { record: false, time });
            }
        }

        function buildLoopPart() {
            if (loopPart) {
                loopPart.stop(0);
                loopPart.dispose();
                loopPart = null;
            }
            if (recordedEvents.length === 0) {
                loopEnabled = false;
                updateLoopButton();
                return;
            }

            Tone.Transport.cancel(0);

            const loopDuration = Math.max(0.0001, Tone.Time(`${loopLengthBars}m`).toSeconds());
            const events = recordedEvents.map(event => {
                const time = event.time % loopDuration;
                return [time, JSON.parse(JSON.stringify(event))];
            }).sort((a, b) => a[0] - b[0]);

            loopPart = new Tone.Part((time, event) => {
                playbackEvent(event, time);
            }, events);
            loopPart.loop = true;
            loopPart.loopEnd = Tone.Time(`${loopLengthBars}m`);
            loopPart.start(0);
            loopEnabled = true;
            updateLoopButton();
            Tone.Transport.position = 0;
        }

        function toggleLoopPlayback() {
            if (loopEnabled) {
                disableLoopPlayback();
                document.getElementById('statusText').textContent = 'Loop stopped';
            } else {
                if (recordedEvents.length === 0) {
                    document.getElementById('statusText').textContent = 'Record something before looping';
                    return;
                }
                buildLoopPart();
                ensureTransport();
                document.getElementById('statusText').textContent = 'Looping recording';
            }
        }

        function disableLoopPlayback() {
            if (loopPart) {
                loopPart.stop(0);
                loopPart.dispose();
                loopPart = null;
            }
            loopEnabled = false;
            updateLoopButton();
            Tone.Transport.cancel(0);
        }

        function ensureTransport() {
            if (Tone.Transport.state !== 'started') {
                Tone.Transport.start();
            }
        }

        function updateLoopButton() {
            const loopBtn = document.getElementById('loopBtn');
            if (!loopBtn) return;
            loopBtn.textContent = loopEnabled ? 'Loop On' : 'Loop Off';
            loopBtn.classList.toggle('btn-toggle-active', loopEnabled);
        }

        function updateLatchButton() {
            const latchBtn = document.getElementById('latchBtn');
            if (!latchBtn) return;
            latchBtn.textContent = latchMode ? 'Latch On' : 'Latch Off';
            latchBtn.classList.toggle('btn-toggle-active', latchMode);
        }

        function setupTransport() {
            const playBtn = document.getElementById('playBtn');
            const recordBtn = document.getElementById('recordBtn');
            const stopBtn = document.getElementById('stopBtn');
            const clearBtn = document.getElementById('clearBtn');
            const loopBtn = document.getElementById('loopBtn');
            const latchBtn = document.getElementById('latchBtn');

            playBtn.addEventListener('click', () => {
                if (loopEnabled) {
                    ensureTransport();
                    document.getElementById('statusText').textContent = 'Looping recording';
                } else {
                    playRecording();
                }
            });

            recordBtn.addEventListener('click', () => {
                if (isRecording) {
                    stopRecording();
                } else {
                    startRecording();
                }
            });

            stopBtn.addEventListener('click', () => {
                Tone.Transport.stop();
                document.getElementById('statusText').textContent = 'Stopped';
                stopAllDrones({ record: isRecording });
            });

            clearBtn.addEventListener('click', () => {
                clearRecording();
            });

            loopBtn.addEventListener('click', () => {
                toggleLoopPlayback();
            });

            latchBtn.addEventListener('click', () => {
                latchMode = !latchMode;
                updateLatchButton();
                document.getElementById('statusText').textContent = latchMode ? 'Latch enabled' : 'Latch disabled';
            });
        }

        function applyKeyLabels() {
            Object.entries(padKeyMap).forEach(([toyId, mapping]) => {
                const toy = document.getElementById(toyId);
                if (!toy) return;
                Object.entries(mapping).forEach(([key, value]) => {
                    const descriptor = { toyId, type: null, value };
                    if (toyId === 'bassMachine' || toyId === 'leadSynth') {
                        descriptor.type = 'note';
                    } else if (toyId === 'percussionSynth') {
                        descriptor.type = 'percussion';
                    } else if (toyId === 'textureGen') {
                        descriptor.type = 'texture';
                    } else if (toyId === 'stutterFx') {
                        descriptor.type = 'effect';
                    }
                    const pad = findPadElement(descriptor);
                    if (!pad) return;
                    pad.dataset.key = key;
                    const label = pad.dataset.label || pad.textContent.trim();
                    pad.textContent = `${label} (${key.toUpperCase()})`;
                });
            });
        }

        function setupKeyboard() {
            window.addEventListener('keydown', (event) => {
                const key = event.key.toLowerCase();
                if (pressedKeys.has(key)) return;
                const pad = document.querySelector(`.pad[data-key="${escapeSelector(key)}"]`);
                if (pad) {
                    pressedKeys.add(key);
                    pad.classList.add('active');
                    triggerPad(pad, { fromKeyboard: true });
                    event.preventDefault();
                }
            });

            window.addEventListener('keyup', (event) => {
                const key = event.key.toLowerCase();
                if (!pressedKeys.has(key)) return;
                pressedKeys.delete(key);
                const pad = document.querySelector(`.pad[data-key="${escapeSelector(key)}"]`);
                if (pad && !pad.classList.contains('latched')) {
                    pad.classList.remove('active');
                }
            });
        }

        window.addEventListener('load', async () => {
            await Tone.start();
            initMasterEffects();
            initInstruments();
            setupKnobs();
            setupPads();
            applyKeyLabels();
            setupKeyboard();
            setupTransport();

            document.getElementById('droneWaveSelect').addEventListener('change', (event) => {
                droneSettings.wave = event.target.value;
                updateActiveDroneSettings();
            });

            Tone.Transport.bpm.value = currentTempo;

            document.querySelectorAll('.knob').forEach(knob => {
                updateKnobDisplay(knob, parseFloat(knob.dataset.value));
            });

            updateLoopButton();
            updateLatchButton();

            document.getElementById('statusText').textContent = 'Ready to jam! Press Play to start.';
        });
    </script>
</body>
</html>
