// visualiserGeometry.js

console.log("geometry.js loaded");class Cy{constructor(s,t,h,i){this.c=s,this.r=t,this.h=h,this.s=i,this.gV(),this.gF()}updateVertices(s){this.v=s}gV(){const s=[],t=2*Math.PI/this.s;for(let h=0;h<=this.s;h++){const i=this.c.y-this.h/2+h/this.s*this.h;for(let h=0;h<=this.s;h++){const e=h*t,o=this.c.x+this.r*Math.cos(e),c=this.c.z+this.r*Math.sin(e);s.push({x:o,y:i,z:c})}}this.v=s}gF(){const s=[],t=this.s+1;for(let h=0;h<this.s;h++)for(let i=0;i<this.s;i++){const e=h*t+i;s.push([e,e+1,e+t],[e+1,e+t+1,e+t])}this.f=s}rP(s,t){sendRotationRequest(this.id,this.v,s,t)}}class Sp{constructor(s,t,h){this.c=s,this.r=t,this.s=h,this.gV(),this.gF()}updateVertices(s){this.v=s}gV(){const s=[],t=2*Math.PI/this.s;for(let h=0;h<=this.s;h++){const i=h/this.s*Math.PI,e=Math.sin(i),o=Math.cos(i);for(let h=0;h<=this.s;h++){const i=h*t,c=Math.sin(i),n=Math.cos(i),r=this.c.x+this.r*e*n,a=this.c.y+this.r*e*c,p=this.c.z+this.r*o;s.push({x:r,y:a,z:p})}}this.v=s}gF(){const s=[],t=this.s+1;for(let h=0;h<this.s;h++)for(let i=0;i<this.s;i++){const e=h*t+i;s.push([e,e+1,e+t],[e+1,e+t+1,e+t])}this.f=s}rP(s,t){sendRotationRequest(this.id,this.v,s,t)}}class Cp{constructor(s,t,h,i){this.c=s,this.r=t,this.h=h,this.s=i,this.cy=new Cy(s,t,h,i),this.sp1=new Sp({x:s.x-t,y:s.y,z:s.z},t,i),this.sp2=new Sp({x:s.x+t,y:s.y,z:s.z},t,i)}updateVertices(s){this.v=s}rP(s,t){sendRotationRequest("cy",this.cy.v,s,t),sendRotationRequest("sp1",this.sp1.v,s,t),sendRotationRequest("sp2",this.sp2.v,s,t)}}let t;const scaleFactor=3,S=window.innerWidth,R=300,H=600,RS=2*Math.PI/2e3/1e3,SR=300,OR=300,cp=new Cp({x:S/2,y:S/2,z:0},R,H,30),os1=new Sp({x:S/2-OR,y:S/2,z:0},SR,30),os2=new Sp({x:S/2+OR,y:S/2,z:0},SR,30);