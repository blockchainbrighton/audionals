function playSequenceStep(e){if(!isReadyToPlay||!Object.keys(preprocessedSequences).length)return console.error("Sequence data is not ready or empty.");const t=Object.keys(preprocessedSequences);currentSequence%=t.length;const n=preprocessedSequences[t[currentSequence]];Object.keys(n).length?(playSteps(n.normalSteps,e),playSteps(n.reverseSteps,e,!0),incrementStepAndSequence(t.length)):incrementStepAndSequence(t.length)}function playSteps(e,t,n=!1){for(const[r,o]of Object.entries(e))if(Array.isArray(o)){const e=o.find((e=>e.step===currentStep));e&&playChannelStep(r,e,t,n)}else console.error(`[playSteps] Expected steps to be an array for channel "${r}", but got:`,o)}function playChannelStep(e,t,n,r){const o=globalAudioBuffers.find((t=>t.channel===e)),c=globalTrimTimes[e];if(o?.buffer&&c){const s=r?globalReversedAudioBuffers[e]:o.buffer,u=r?calculateReversedTrimTimes(c):c;playBuffer(s,u,e,n),notifyVisualizer(parseInt(e.slice(8))-1,t.step)}else console.error(`No audio buffer or trim times found for ${e}`)}function scheduleNotes(){const e=audioCtx.currentTime;for(nextNoteTime=Math.max(nextNoteTime,e);nextNoteTime<e+.1;){const e=nextNoteTime;playSequenceStep(e),audioCtx.currentTime>e&&console.warn(`[scheduleNotes] Note scheduled for ${e.toFixed(3)} missed at ${audioCtx.currentTime.toFixed(3)}.`),nextNoteTime+=getStepDuration()}}function incrementStepAndSequence(e){currentStep=(currentStep+1)%64,0===currentStep&&(currentSequence=(currentSequence+1)%e)}