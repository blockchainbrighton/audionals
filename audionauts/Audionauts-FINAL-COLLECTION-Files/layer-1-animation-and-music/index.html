<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Analog Reveal â€“ Optimized</title>
<style>
  html,body{margin:0;height:100%;background:#000;color:#fff;font-family:sans-serif}
  #cvs{display:block;margin:auto;max-width:90vmin;max-height:90vmin;cursor:pointer}
</style>
</head>
<body>
<canvas id="cvs"></canvas>
<script type="module">
const TIMELINE_TO_LOAD = 3;
const IMAGE_URL = 'https://ordinals.com/content/01c48d3cceb02215bc3d44f9a2dc7fba63ea63719a2ef1c35d3f0c4db93ab8d5i0';
const AUDIO_URL = './opus.webm';
const RECIPES_URL = './timelines/recipes.json';
const TOP_29_TIMELINES = [
  "CrystalBloomTimed", "DeepDream_64bars", "FractalFocus_64bars", "GlitchBloom", "GlitchWaves_64bars",
  "GraffitiGlow_64bars", "HighlightFlash_64bars", "IridescentWave_64bars", "NeonShards", "NoirWindow",
  "PsychedelicRipple", "ReverseWipe", "SequentialHueBands", "ShadowLift_64bars", "SpectrumSpin_64bars",
  "StarlitReveal", "StrobeFocus_64bars", "SunriseReveal", "analog-film", "cyberpunkGlitch_64bars",
  "manualTimeline1", "manualTimeline2", "manualtimeline3", "multiband-bright", "pixel-dust",
  "rgbShatter_64bars", "spectral-solidity", "timeline_colourBandsGlitchReveal", "timeline_windowSweepReveal"
];

const cvs = document.getElementById('cvs'), ctx = cvs.getContext('2d');
const audio = new Audio(AUDIO_URL); audio.preload = 'auto';
const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
const ease = t => t < .5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
const barsToSec = (bars, bpm = 104.15, beatsPerBar = 4) => 60 / bpm * bars * beatsPerBar;

let img, w, h, timeline = [], frameId = null, running = false, startTime = null;
const buf1 = document.createElement('canvas'), buf2 = document.createElement('canvas');
let buf1ctx = buf1.getContext('2d'), buf2ctx = buf2.getContext('2d');

const EFFECT_MAP = {
  F: { effect: 'fade', param: 'progress' },
  Px: { effect: 'pixelate', param: 'pixelSize' },
  Bl: { effect: 'blur', param: 'radius' },
  CS: { effect: 'chromaShift', param: 'intensity' },
  Gl: { effect: 'glitch', param: 'intensity' },
  Sc: { effect: 'scanLines', param: 'intensity' },
  Vg: { effect: 'vignette', param: 'intensity' },
  Fg: { effect: 'filmGrain', param: 'intensity' },
  C: { effect: 'colourSweep', param: 'progress' },
};
function parseValue(val) {
  if (typeof val !== 'string') return val;
  if (val.includes(',')) return val.split(',').map(s => parseValue(s.trim()));
  if (val === 'true') return true;
  if (val === 'false') return false;
  const num = parseFloat(val); return (!isNaN(num) && isFinite(val)) ? num : val;
}
function parseTimeline(str) {
  if (!str) return [];
  const segments = str.split(/(?<!,)\s*,\s*(?![^"]*"(?:,|$))/);
  const regex = /^([A-Z][a-z]?)((?:-?\d*\.?\d+|-?\w+|[^@]+?))-((?:-?\d*\.?\d+|-?\w+|[^@]+?))@(-?\d*\.?\d+)-(-?\d*\.?\d+)(?::(.*))?$/;
  return segments.map(segment => {
    const match = segment.match(regex);
    if (!match) return null;
    const [, code, from, to, startBar, endBar, rest] = match;
    const base = EFFECT_MAP[code]; if (!base) return null;
    const event = { ...base, from: parseValue(from), to: parseValue(to), startBar: +startBar, endBar: +endBar };
    if (rest) try { Object.assign(event, JSON.parse(`{${rest}}`)); } catch {}
    return event;
  }).filter(Boolean);
}

const fx = {
  filmGrain(src, dst, ct, p, ww, hh) {
    dst.filter = `contrast(110%) brightness(110%)`; dst.drawImage(src.canvas,0,0); dst.filter='none';
    const id = dst.getImageData(0,0,ww,hh), d = id.data;
    for (let i=0;i<d.length;i+=4) { const g=(Math.random()-.5)*255*p.intensity; d[i]+=g; d[i+1]+=g; d[i+2]+=g; }
    dst.putImageData(id,0,0);
  },
  vignette(src,dst,ct,p,ww,hh) {
    dst.drawImage(src.canvas,0,0);
    const g = dst.createRadialGradient(ww/2,hh/2,0,ww/2,hh/2,Math.min(ww,hh)*0.5);
    g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(0.6,'rgba(0,0,0,0)');
    g.addColorStop(1,`rgba(0,0,0,${p.intensity})`); dst.fillStyle=g; dst.fillRect(0,0,ww,hh);
  },
  colourSweep(src,dst,ct,p,ww,hh) {
    const pr=clamp(p.progress,0,1), fwd=p.direction!==-1, thr=(fwd?pr:1-pr)*255;
    const id=src.getImageData(0,0,ww,hh), d=id.data, soft=p.edgeSoftness||0, band=32*soft, isHide=p.mode==='hide';
    for(let i=0;i<d.length;i+=4){
      const bright=(d[i]+d[i+1]+d[i+2])/3, show=isHide?bright>thr:bright<=thr, dist=isHide?(bright-thr):(thr-bright);
      let alpha=0; if(show) alpha=255; else if(band>0&&dist<band) alpha=255*(1+dist/band); d[i+3]=alpha;
    } dst.putImageData(id,0,0);
  },
  blur(src,dst,ct,p,ww,hh){ dst.filter=`blur(${p.radius}px)`; dst.drawImage(src.canvas,0,0); dst.filter='none'; },
  scanLines(src,dst,ct,p,ww,hh){ dst.drawImage(src.canvas,0,0); dst.fillStyle=`rgba(0,0,0,${p.intensity})`; const s=p.spacing||6; for(let y=0;y<hh;y+=s) dst.fillRect(0,y,ww,1); },
  glitch(src,dst,ct,p,ww,hh){
    if(!p.intensity){dst.drawImage(src.canvas,0,0);return;}
    dst.clearRect(0,0,ww,hh); const slices=3+Math.floor(p.intensity*8);
    for(let i=0;i<slices;i++){ const hh2=hh/slices, y=i*hh2, off=(Math.random()-.5)*p.intensity*ww*.05; dst.drawImage(src.canvas,0,y,ww,hh2,off,y,ww,hh2);}
  },
  pixelate(src,dst,ct,p,ww,hh){
    const size=Math.max(1,p.pixelSize|0); if(size<=1){dst.drawImage(src.canvas,0,0);return;}
    const t=document.createElement('canvas').getContext('2d'); t.canvas.width=ww; t.canvas.height=hh;
    t.imageSmoothingEnabled=false; t.drawImage(src.canvas,0,0,ww/size,hh/size);
    t.drawImage(t.canvas,0,0,ww/size,hh/size,0,0,ww,hh); dst.drawImage(t.canvas,0,0);
  },
  fade(src,dst,ct,p,ww,hh){ dst.globalAlpha=clamp(p.progress,0,1); dst.drawImage(src.canvas,0,0); dst.globalAlpha=1; },
  chromaShift(src,dst,ct,p,ww,hh){ dst.drawImage(src.canvas,0,0);}
};

function draw() {
  if (!img || !timeline.length || !running) { frameId = requestAnimationFrame(draw); return; }
  const now = (performance.now()/1000) - startTime;
  buf1ctx.clearRect(0,0,w,h); buf1ctx.drawImage(img,0,0,w,h);

  timeline.forEach(l => {
    if (!l || !l.effect) return;
    const tStart = barsToSec(l.startBar), tEnd = barsToSec(l.endBar);
    if (now < tStart || now > tEnd) return;
    let t = (tEnd-tStart>0)? (now-tStart)/(tEnd-tStart) : 1;
    if (l.easing==='easeInOut') t = ease(t);
    const val = (typeof l.from === 'number' && typeof l.to === 'number') ? l.from+(l.to-l.from)*t : (t<0.5?l.from:l.to);
    const p = { ...l, [l.param]: val };
    if (fx[l.effect]) { fx[l.effect](buf1ctx, buf2ctx, now, p, w, h); [buf1ctx, buf2ctx] = [buf2ctx, buf1ctx]; }
  });

  ctx.clearRect(0,0,cvs.width,cvs.height);
  ctx.drawImage(buf1ctx.canvas,0,0);
  frameId = requestAnimationFrame(draw);
}

function resize() {
  const s = Math.min(innerWidth, innerHeight)*.9|0;
  cvs.width = cvs.height = s; w = h = s;
  buf1.width = buf2.width = s; buf1.height = buf2.height = s;
  if (!img) {
    ctx.fillStyle = '#555'; ctx.fillRect(0,0,w,h);
    ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.font = '24px sans-serif';
    ctx.fillText('Loading...', w/2, h/2);
  }
}
window.addEventListener('resize', resize);

function reset() {
  running = false;
  if (frameId) cancelAnimationFrame(frameId);
  audio.pause(); audio.currentTime = 0;
  ctx.clearRect(0,0,w,h);
  ctx.drawImage(img, 0, 0, w, h);
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(0,0,w,h);
}

function toggleRun() {
  if (!img) return;
  if (!running) {
    running = true; startTime = performance.now()/1000;
    audio.currentTime = 0; audio.play().catch(()=>{});
    draw();
  } else {
    reset();
  }
}

async function init() {
  resize();
  try {
    const response = await fetch(RECIPES_URL);
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const recipes = await response.json();
    const idx = clamp(TIMELINE_TO_LOAD-1, 0, TOP_29_TIMELINES.length-1);
    const timelineName = TOP_29_TIMELINES[idx];
    timeline = parseTimeline(recipes[timelineName]);
    const imgObj = new Image(); imgObj.crossOrigin = 'anonymous';
    imgObj.onload = () => { img = imgObj; reset(); cvs.onclick = toggleRun; };
    imgObj.onerror = () => { ctx.fillStyle='red'; ctx.fillText('Error loading image.',w/2,h/2+30);}
    imgObj.src = IMAGE_URL;
  } catch (error) {
    ctx.fillStyle = 'red'; ctx.textAlign = 'center'; ctx.font = '18px sans-serif';
    ctx.fillText(`Error: ${error.message}`, w/2, h/2);
  }
}
init();
</script>
</body>
</html>
